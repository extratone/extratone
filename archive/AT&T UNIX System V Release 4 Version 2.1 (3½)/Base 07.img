öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö4.0.2 386unix Fnd Set 7 of 10
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  070701000019d8000088490000000500000005000000012719347c0000e74c000000230000000c00000000000000000000000c00000000usr/bin/uux   ELF              4   Tä      4    (      4   4                      Ô                            4   4    zÌ  zÌ           °Ì  °\    ì  ³W           ,ã  ,s    p              /usr/lib/libc.so.1  a   o           b   i              n   [              7      Q   	       W   X   K   e       `       &   )   Z   d   k   !   ,   #   G   =   R       I   V   ]           _                  f   h   U         B   D   H      8       O              \   P   6           "       9   5      l   M   N                      j               g   3           @       F   c   E           m   ^   1                                                                                                                                                            
                                                      %       2             0                       +          A       ;   >          J           *   ?                      L           C       4       -   :      Y   T       /   S   .   a   $       <   (              '                      ÔÀ                 ,          |`         ,       "   L(     )   |       0   ÔÀ  !  5   <      >          E   d´     ñÿJ   $     Q   Ü\      Y   	    a   ø      h   ì       m   ¬       t   ì       {   <          ìl         Ü          \          d        ü       ¥   ´     ª          °   Ô      µ   ¼      ½   Ô      Â   <h      Ç   \@      Î   @      Ô   	  !  Û   Ìl      ã          é   \       î   ü     ô   ®L     ñÿû   L@        ü`        Ì                 l                $  Ì0      ,  s     ñÿ3  <       :  È      A  ì`     G         O  |       U  Ü¨      ^         d  ¬@      l  l       q  ¬       y  (        <         \         ¼4        ¼        ¤      ¡  <ğ     §  d     ®  Ü<      ¶  ¬«     ¼  d     Ã  L$      Ê  ¬¤      Ğ  ,       ×  ü       Ş  (    
 ë  l       ñ         ù  |x        ,,       l         l         ü(       \       )  d     0  ì       7  ¬(      >  d     E  ¬q     ñÿ[  l       b         j       p  |       v  ¼       }  ÌL        L         ¼H        ,p        X     ¡  ü       ©  Ì@      ²  Ü      ¹  Ì      À  ¬       Æ  ,s     ñÿÏ  Ü|      Ö  |       Ü  8     ã  \       ë       ò  L¸     ù  ì       ÿ  ¼à        LD      __iob open strrchr getgrgid read malloc _xstat _iob _cleanup setuid _end pclose __minor __ctype setbuf time strcat access chown getpwnam getpid fork _environ creat atof srand atoi readdir atol free strdup fputc _ctype __major lseek link fputs _etext atexit getpwuid chdir fdopen strchr kill freopen _edata signal mktemp popen _lxstat _exit getlogin close tolower exit _xmknod fopen write strcmp rand __makedev fseek fread optind strpbrk errno optopt rename ftell strcpy getuid _lib_version umask _fxstat fprintf fgets strlen execle localtime __fpstart opterr nuname fscanf optarg _GLOBAL_OFFSET_TABLE_ getgid geteuid sleep mkdir unlink sscanf strncpy sprintf calloc mlock getegid closedir fclose printf times _DYNAMIC strtok chmod strtol strncmp getopt fwrite ioctl opendir lockf /usr/lib/libc.so.1 ¸q	  ¼q'  ÀqP  Äq7  Èq  Ìq2  ĞqJ  Ôq8  Øq=  Üq"  àq  äqR  èqG  ìqW  ğq
  ôqF  øq/  üq\   r;  rM  rK  r  rj  r  r]  r)   rb  $r  (r  ,r*  0r  4r  8r?  <rk  @ri  DrV  Hrg  Lr5  Pr9  TrE  XrZ  \rc  `rA  dr1  hr%  lr   pr  trL  xr  |r  r  r+  r  r  r  r6  rm  ra   r  ¤r  ¨rO  ¬r  °r0  ´r  ¸r:  ¼rD  Àr$  ÄrI  ÈrY  Ìr  ĞrX  ÔrS  Ør<  Ür-  àr4  är  èr(  ìrh  ğr,  ôr^  ør  ürn   s  sN  s3  s>  s#  sd  s  s[   sf  $sl  (s`  Â   ÿ5°qÿ%´q    ÿ%¸qh    éàÿÿÿÿ%¼qh   éĞÿÿÿÿ%Àqh   éÀÿÿÿÿ%Äqh   é°ÿÿÿÿ%Èqh    é ÿÿÿÿ%Ìqh(   éÿÿÿÿ%Ğqh0   éÿÿÿÿ%Ôqh8   épÿÿÿÿ%Øqh@   é`ÿÿÿÿ%ÜqhH   éPÿÿÿÿ%àqhP   é@ÿÿÿÿ%äqhX   é0ÿÿÿÿ%èqh`   é ÿÿÿÿ%ìqhh   éÿÿÿÿ%ğqhp   é ÿÿÿÿ%ôqhx   éğşÿÿÿ%øqh   éàşÿÿÿ%üqh   éĞşÿÿÿ% rh   éÀşÿÿÿ%rh   é°şÿÿÿ%rh    é şÿÿÿ%rh¨   éşÿÿÿ%rh°   éşÿÿÿ%rh¸   épşÿÿÿ%rhÀ   é`şÿÿÿ%rhÈ   éPşÿÿÿ% rhĞ   é@şÿÿÿ%$rhØ   é0şÿÿÿ%(rhà   é şÿÿÿ%,rhè   éşÿÿÿ%0rhğ   é şÿÿÿ%4rhø   éğıÿÿÿ%8rh   éàıÿÿÿ%<rh  éĞıÿÿÿ%@rh  éÀıÿÿÿ%Drh  é°ıÿÿÿ%Hrh   é ıÿÿÿ%Lrh(  éıÿÿÿ%Prh0  éıÿÿÿ%Trh8  épıÿÿÿ%Xrh@  é`ıÿÿÿ%\rhH  éPıÿÿÿ%`rhP  é@ıÿÿÿ%drhX  é0ıÿÿÿ%hrh`  é ıÿÿÿ%lrhh  éıÿÿÿ%prhp  é ıÿÿÿ%trhx  éğüÿÿÿ%xrh  éàüÿÿÿ%|rh  éĞüÿÿÿ%rh  éÀüÿÿÿ%rh  é°üÿÿÿ%rh   é üÿÿÿ%rh¨  éüÿÿÿ%rh°  éüÿÿÿ%rh¸  épüÿÿÿ%rhÀ  é`üÿÿÿ%rhÈ  éPüÿÿÿ% rhĞ  é@üÿÿÿ%¤rhØ  é0üÿÿÿ%¨rhà  é üÿÿÿ%¬rhè  éüÿÿÿ%°rhğ  é üÿÿÿ%´rhø  éğûÿÿÿ%¸rh   éàûÿÿÿ%¼rh  éĞûÿÿÿ%Àrh  éÀûÿÿÿ%Ärh  é°ûÿÿÿ%Èrh   é ûÿÿÿ%Ìrh(  éûÿÿÿ%Ğrh0  éûÿÿÿ%Ôrh8  épûÿÿÿ%Ørh@  é`ûÿÿÿ%ÜrhH  éPûÿÿÿ%àrhP  é@ûÿÿÿ%ärhX  é0ûÿÿÿ%èrh`  é ûÿÿÿ%ìrhh  éûÿÿÿ%ğrhp  é ûÿÿÿ%ôrhx  éğúÿÿÿ%ørh  éàúÿÿÿ%ürh  éĞúÿÿÿ% sh  éÀúÿÿÿ%sh  é°úÿÿÿ%sh   é úÿÿÿ%sh¨  éúÿÿÿ%sh°  éúÿÿÿ%sh¸  épúÿÿÿ%shÀ  é`úÿÿÿ%shÈ  éPúÿÿÿ% shĞ  é@úÿÿÿ%$shØ  é0úÿÿÿ%(shà  é úÿÿj j ìR¸<Àth<è&úÿÿÄ¸,sÀtèúÿÿh(èúÿÿETdRURPèÏùÿÿèşùÿÿèY  ÄPè úÿÿj ¸        ôÃÿt$ÿt$jèñùÿÿÄÃÿt$ÿt$jèíùÿÿÄÃÿt$ÿt$jèéùÿÿÄÃÿt$ÿt$ÿt$jèáùÿÿÄÃº   ÿt$ÿt$RèÙùÿÿÄÃº   ÿt$RèÕùÿÿÄÃº   ÿt$RèÑùÿÿÄÃÿt$èÓùÿÿYÃÿt$ÿt$jèQùÿÿÄÃÿt$ÿt$jèMùÿÿÄÃÿt$ÿt$jèIùÿÿÄÃÿt$ÿt$ÿt$jèAùÿÿÄÃº   ÿt$ÿt$Rè9ùÿÿÄÃº   ÿt$Rè5ùÿÿÄÃº   ÿt$Rè1ùÿÿÄÃÿt$è3ùÿÿYÃUìì  WVSÇEü    ÇEø    ÇEô    ÇEğ    ÇEì    ÇEè    ÇEä    ÇEà    ÇEÜ    ÇEØ   fÇEÖ  ÇEĞ    2ÛÆEËÇ8ëÿÿ    Ç4ëÿÿ    èÂøÿÿ£¸¢èÈøÿÿ£§=¸¢ ujèÃøÿÿYE£¨«hÈ+h¸«è»øÿÿÄhÜ+hÌ¯è©øÿÿÄÆÄ¯XhÜ·jè£øÿÿÄhÜ·jèøÿÿÄhÜ·jèøÿÿÄhÜ·jèvøÿÿÄhÜ·jègøÿÿÄhÜ·j
èXøÿÿÄhÜ·jèIøÿÿÄhÜ·jè:øÿÿÄjjè.øÿÿÄh§è;  YÇ´¢   ÇÌ¢    Æs h´ÿ5¸¢èíf  Äh´h¼¢èÓ÷ÿÿÄÆ  jhgè©  Ä=ÿÿÿÿt,Æğ\AÇÜ\   jhà+h è±÷ÿÿÄÆ® ÿuÿuè¤u  Ä¾   ë6E<° t*¸0gÀt!hè+Eÿ4°è~÷ÿÿÄÀu
EÇ°4gF;u1  E°8-t¸é!  ¡d4ëÿÿé  ÇEĞ   éş  ÇEè    éî  ÇEè   éŞ  =Ü\ ugÿ5dè÷ÿÿY=   s(¡d¾ ¶%   t¡d ¢ğ\é  h^hÄ]hì+hôèÏöÿÿÄjÿèÅ  Yém  jÿ5dh èzöÿÿÄÆ® h èjK  YÀ;  jÿè  Yé.  fÇEÖ é  ÿEäé  ÿEàé
  ÇEÜ   éú   ÇEØ    éê   ¡d8ëÿÿÿwéĞ   ÿ5dè%öÿÿY£à\=à\ °   Çà\   é¡   =C   ©şÿÿër=b   yşÿÿëb=j   Iÿÿÿ=g   şÿÿëE=n   9ÿÿÿë6=x   yÿÿÿ=s   Tÿÿÿ=r   7ÿÿÿë=z   ÿÿÿhÌ¯hL0hôè]õÿÿÄjèCôÿÿYhô+ÿuÿuèbõÿÿÄğşÿuX=à\|h8gh,hôèõÿÿÄE9d|hÌ¯hL0hôèùôÿÿÄjèßóÿÿYÆ÷ÿÿ é   Æ=p   {şÿÿ)ÿÿÿ=c   vıÿÿìşÿÿ=a   AıÿÿËşÿÿé¶şÿÿ=à\|Edÿ4h,hôèôÿÿÄh ,÷ÿÿPèôÿÿÄEdÿ4÷ÿÿPèôÿÿÄÿdE9d|=à\|÷ÿÿPh$,hôèôÿÿÄhÛ¯è  Y½8ëÿÿ tG8ëÿÿ8/t ÿµ8ëÿÿhÛ¯h0,hsè"ôÿÿÄë/ÿµ8ëÿÿh8,hsèôÿÿÄëh<,hsèaóÿÿÄhD,èôóÿÿYÀth@gh\,hôèóÿÿÄjè  Y÷ÿÿ|óÿÿÆ<ëÿÿ ë6½|ïÿÿ>t½|ïÿÿ<&  |ïÿÿPj ÿµ|óÿÿè¦1  Ä|óÿÿ|ïÿÿPj ÿµ|óÿÿè1  Ä|óÿÿÀu¬<ëÿÿÀuh§<ëÿÿPè©òÿÿÄj<ëÿÿPh£è³òÿÿÄÆ£ =à\|<ëÿÿPh,hôèºòÿÿÄ<ëÿÿPè/6  YÀt?<ëÿÿPh,hôèòÿÿÄ}ü t	ÿuüèßòÿÿY}ø t	ÿuøèĞòÿÿYjèh  Y=à\|h´h¤,hôèJòÿÿÄ½4ëÿÿ u
Ç4ëÿÿ´Æóÿÿ E¼P¾ğ\P<ëÿÿPjCè?[  Ä=à\	|E¼Ph°,hôèôñÿÿÄj E¼PèVòÿÿÄÀu*hW  hXgÿ5¬«E¼Pÿ5`]èM  Äjÿè¶  Yh¼,h¤  E¼Pè"òÿÿÄEÌPè&òÿÿÄEø}Ì |}ø u*hY  h`gÿ5¬«E¼Pÿ5 ]èµL  Äjÿè[  Yj ÿuøèğñÿÿÄjj.E¼PèğñÿÿÄ£¼¯Àt0¡¼¯@ë+\ëÿÿPj <ëÿÿP|ïÿÿPè¬1  ÄéôıÿÿE¼Ph]èÆğÿÿÄÆ] EPjX<ëÿÿPjDèZ  Ä=à\	|EPhÀ,hôè¹ğÿÿÄj EPèñÿÿÄÀu*hi  hhgÿ5¬«EPÿ5`]èÕK  Äjÿè{  YhĞ,h  EPèçğÿÿÄEÌPèëğÿÿÄEü}Ì |}ü u*hk  hpgÿ5¬«EPÿ5$]èzK  Äjÿè   Yj ÿuüèµğÿÿÄEü`Ïh§h´jUhÔ,ÿuüèòïÿÿÄ}à t$j#hà,ÿuüèÚïÿÿÄjnh -ÿuüèÈïÿÿÄ}ä tj#h-ÿuüè°ïÿÿÄjNh(-ëj#h,-ÿuüèïÿÿÄjZhL-ÿuüèïÿÿÄ}Ğ t$j#hP-ÿuüèkïÿÿÄjBht-ÿuüèYïÿÿÄ=w thsjMhx-ÿuüè9ïÿÿÄ½4ëÿÿ t*j#h-ÿuüèïÿÿÄÿµ4ëÿÿjRh°-ÿuüèïÿÿÄ}Ü u  E­PjBh§jDèX  Äj E­PèIïÿÿÄÀu*h  hxgÿ5¬«E­Pÿ5`]èJ  Äjÿè©  Yh¸-h  E­PèïÿÿÄEÌPèïÿÿÄEô}Ì |
}ô    h  hgÿ5¬«E­Pÿ5 ]è¤I  ÄjÿèJ  YëghÔh   jûÿÿPèìîÿÿÄEÌÿuôÿuÌjûÿÿPèâîÿÿÄ;EÌt*h£  hgÿ5¬«E­Pÿ5$]è;I  Äjÿèá  Y¶à%   tEô¶@%    t*h¥  hgÿ5¬«E­Pÿ5$]èõH  Äjÿè  YÿuôèòíÿÿY¸§Àt$<ëÿÿÀtj<ëÿÿPh§èKîÿÿÄÀtrhsh´E­P=w t	¸gë¸gPh´E­PE­Ph¼-ÿuøè$íÿÿÄ$À}+h­  h¤gÿ5¬«h gÿ5$]èMH  Äjÿèó  YE­PjFhÜ-ÿuüèßìÿÿÄE­PjIhä-ÿuüèÉìÿÿÄ¸§Àt9<ëÿÿÀt/<ëÿÿPh§èìÿÿÄÀu<ëÿÿPE­PE­PèÛ4  Ä÷ÿÿ|óÿÿé  =à\||ïÿÿPhì-hôèQìÿÿÄ½|ïÿÿ<u	³Iéæ  ½|ïÿÿ>u³OéÔ  |ïÿÿÀt*¸¬gÀt!hø-|ïÿÿPèäëÿÿÄÀu	³Eé  ½|ïÿÿ|t½|ïÿÿ^t½|ïÿÿ&t	½|ïÿÿ;u@óÿÿÀt*|ïÿÿPóÿÿPèãëÿÿÄhü-óÿÿPèÏëÿÿÄÆEËé;  \ëÿÿPj \ïÿÿP|ïÿÿPè,  ÄEÌ=à\|\ïÿÿPh .hôèOëÿÿÄ=à\|\ëÿÿPh.hôè-ëÿÿÄ=à\|ÿuÌh .hôèëÿÿÄ}Ë t:Ûu6\ëÿÿPóÿÿPèëÿÿÄh,.óÿÿPèëÿÿÄÆEË éw  \ïÿÿÀu:h§\ïÿÿPèaêÿÿÄ=à\|m\ïÿÿPh0.hôèêÿÿÄëR\ïÿÿPè .  YÀt?\ïÿÿPh@.hôèaêÿÿÄ}ü t	ÿuüè°êÿÿY}ø t	ÿuøè¡êÿÿYjè9  YûOt	ûEÂ   ½\ëÿÿ~t\ëÿÿPèyQ  YÀtjè	  Y\ïÿÿP\ëÿÿP¾ÃPhX.ÿuüèééÿÿÄÀ  h  h°gÿ5¬«EPÿ5$]èE  Äjÿèµ  YéU  \ëÿÿPèQ  YÀtjè  YûIf  \ëÿÿPjIhh.ÿuüètéÿÿÄér  }Ì u6Ûu2\ëÿÿPóÿÿPè{éÿÿÄhd.óÿÿPègéÿÿÄé×  <ëÿÿÀtW¸§ÀtNjh§<ëÿÿPèæéÿÿÄÀu4<ëÿÿÀt*\ïÿÿÀt j\ïÿÿP<ëÿÿPè¶éÿÿÄÀÿÿÿ\ïÿÿÀ  ¸§À  jh§\ïÿÿPè}éÿÿÄÀn  \ëÿÿPèêO  YÀtjèz  Y=à\|\ëÿÿPht.hôèZèÿÿÄ¬êÿÿP\ëÿÿPè|  ÄÀt!\ëÿÿPh.hôè'èÿÿÄjè  YÀêÿÿ%   uU¡¸¢9ÈêÿÿuÀêÿÿ%   u;èàèÿÿ9ÌêÿÿuÀêÿÿ%    u!\ëÿÿPh.hôèÅçÿÿÄjè»  YE­PjA<ëÿÿPjDèÒP  Ä}è uÀêÿÿ%   (  E­P\ëÿÿPèJ  ÄÀt!\ëÿÿPh´.hôè_çÿÿÄjèU  Yh  E­PèFèÿÿÄhsh´E­P=w tl¸Àgëj\ëÿÿPóÿÿPèAçÿÿÄhp.óÿÿPè-çÿÿÄ}ü 	  h0  h¸gÿ5¬«EPÿ5$]è!B  ÄjÿèÇ  Yég	  ¸ÄgPh´E­P\ëÿÿPhÄ.ÿuøèæÿÿÄ$À£   hY  hÌgÿ5¬«hÈgÿ5$]èÂA  Äjÿèh  Yëvhsh´E­P=w t	¸Ôgë¸ØgPh´E­P\ëÿÿPhä.ÿuøè!æÿÿÄ$À}+h[  hàgÿ5¬«hÜgÿ5$]èJA  Äjÿèğ
  YûIu2E­PjIh/ÿuüè×åÿÿÄE­PjFh/ÿuüèÁåÿÿÄé_  j/\ëÿÿPèZæÿÿÄ£¼¯Àt
¡¼¯@ë\ëÿÿPóÿÿPè±åÿÿÄh/óÿÿPèåÿÿÄj/\ëÿÿPèæÿÿÄ£¼¯Àt¡¼¯@ë\ëÿÿPE­PjFh/ÿuüè.åÿÿÄéÌ  ¸§À  <ëÿÿÀõ  <ëÿÿPh§èØäÿÿÄÀÙ  \ëÿÿPèEL  YÀtjèÕ	  Y\ïÿÿPEPèØ+  ÄÀ   EPjR\ïÿÿPjCèÑM  Äj EPèåÿÿÄÀu*h  hègÿ5¬«EPÿ5`]èÁ?  Äjÿèg	  Yh \ïÿÿPEPèÉ+  Äh¤  EPèÀäÿÿÄPèGåÿÿYh$/EPèHåÿÿÄøÿu*h  hğgÿ5¬«EPÿ5 ]èP?  Äjÿèö  Yj WèäÿÿÄE­PjR\ïÿÿPjDèM  ÄlêÿÿPjZ<ëÿÿPjDèèL  ÄlêÿÿPh´hsh´E­P\ëÿÿPh(/WèãÿÿÄ À}+h  hügÿ5¬«høgÿ5$]è¶>  Äjÿè\  Y¶G%    t*h  hhÿ5¬«E­Pÿ5$]è>  Äjÿè'  YWèãÿÿYÿEì½\ëÿÿ~t\ëÿÿPèkJ  YÀtjèû  YûIuAE­P\ïÿÿPÿ5 ]jFhD/ÿuüèÕâÿÿÄE­PjIhT/ÿuüè¿âÿÿÄé]  j/\ëÿÿPèVãÿÿÄ£¼¯Àt
¡¼¯@ë\ëÿÿPE­P\ïÿÿPÿ5 ]jFh\/ÿuüèiâÿÿÄj/\ëÿÿPèãÿÿÄ£¼¯Àt¡¼¯@ë\ëÿÿPóÿÿPèaâÿÿÄhl/óÿÿPèMâÿÿÄé»  \ïÿÿÀt(<ëÿÿÀt<ëÿÿP\ïÿÿPèÍáÿÿÄÀ  \ïÿÿPEPèæ(  ÄÀ   EPjR\ïÿÿPjCèßJ  Äj EPèâÿÿÄÀu*hŞ  hhÿ5¬«EPÿ5`]èÏ<  Äjÿèu  Yh \ïÿÿPEPè×(  Äh¤  EPèÎáÿÿÄPèUâÿÿYhp/EPèVâÿÿÄøÿu*hã  hhÿ5¬«EPÿ5 ]è^<  Äjÿè  Yj WèáÿÿÄE­PjR\ïÿÿPjDèJ  ÄlêÿÿPjZ<ëÿÿPjDèöI  ÄlêÿÿPh´hsh´E­P\ëÿÿPht/WèàÿÿÄ À}+hæ  h hÿ5¬«hhÿ5$]èÄ;  Äjÿèj  Y¶G%    t*hç  h(hÿ5¬«E­Pÿ5$]è;  Äjÿè5  YWèàÿÿYEP¾ğ\Ph§jXèAI  Äj EPèwàÿÿÄÀu*hì  h0hÿ5¬«EPÿ5`]è1;  Äjÿè×  Yh¤  EPèHàÿÿÄPèÏàÿÿYh/EPèĞàÿÿÄøÿu*hï  h8hÿ5¬«EPÿ5 ]èØ:  Äjÿè~  Yj WèàÿÿÄj/\ëÿÿPèàÿÿÄ£¼¯Àt¡¼¯@ë\ëÿÿPE­P\ïÿÿPÿ5 ]jFh/Wè+ßÿÿÄE­P<ëÿÿPj/\ëÿÿPè¿ßÿÿÄ£¼¯Àt¡¼¯@ë	\ëÿÿPjCh¤/WèäŞÿÿÄ¶G%    t*hõ  h@hÿ5¬«EPÿ5$]è:  Äjÿè­  YWèßÿÿYh§EPEPèç&  ÄûIu3E­PjFh¼/ÿuüèxŞÿÿÄE­PjIhÄ/ÿuüèbŞÿÿÄé   j/\ëÿÿPèúŞÿÿÄ£¼¯Àt
¡¼¯@ë\ëÿÿPE­PjFhÌ/ÿuüèŞÿÿÄj/\ëÿÿPè¹ŞÿÿÄ£¼¯Àt	¡¼¯@ë\ëÿÿPóÿÿPèŞÿÿÄhØ/óÿÿPèıİÿÿÄën½\ëÿÿ~t\ëÿÿPèE  YÀtjè§  YûIu\ëÿÿPjIhÜ/ÿuüèİÿÿÄë,\ëÿÿPóÿÿPè¡İÿÿÄhä/óÿÿPèİÿÿÄ2Û|ïÿÿPj ÿµ|óÿÿè¬  Ä|óÿÿÀÃğÿÿóÿÿPjChè/ÿuüèİÿÿÄEü¶@%    t*h  hHhÿ5¬«EPÿ5$]è=8  Äjÿèã  Yÿuüè:İÿÿYhPhóÿÿPèhX  Äh]hğ/EPèòÜÿÿÄ<ëÿÿÀtQ¸§ÀtHh§<ëÿÿPèkÜÿÿÄÀu0<ëÿÿPEPEPèÄ$  Ä}Ø    h§èyV  Yëthsh´EP=w t	¸Xhë¸\hPh´EPEPhø/ÿuøèÜÿÿÄ$À}+h.  hdhÿ5¬«h`hÿ5$]è=7  Äjÿèã   Yÿuøè
İÿÿYÀt	¸   ë3ÀEğEø¶@%    t*h2  hlhÿ5¬«E¼Pÿ5$]èê6  Äjÿè   YÿuøèçÛÿÿYè   }ğ t3h <ëÿÿPE¼PèŞ"  Äèr   }Ø t<ëÿÿPèT  YëE¼PèÜÿÿYf}Ö t'jè "  Ph]èõÚÿÿÄh]h0ècÜÿÿÄj è	   Y[^_ÉÃUìVuj èN  Yötè#  Vh0hôèØÚÿÿÄ=à\|Vh00hôè¼ÚÿÿÄö}	Æ÷ØPëVèÙÿÿY^ÉÃUìì jÿuèPÚÿÿÄÿuh@0EâPè¼ÚÿÿÄhthEâPèV  ÄE÷ØPè]ÿÿÿYÉÃhÌ¯hL0hôèDÚÿÿÄjè*ÙÿÿYÃÿt$ÿt$jè)ÙÿÿÄÃÿt$ÿt$jè%ÙÿÿÄÃÿt$ÿt$jè!ÙÿÿÄÃÿt$ÿt$ÿt$jèÙÿÿÄÃº   ÿt$ÿt$RèÙÿÿÄÃº   ÿt$RèÙÿÿÄÃº   ÿt$Rè	ÙÿÿÄÃÿt$èÙÿÿYÃUìì  WVS]h¸0ÿuèÜÚÿÿÄĞÀtÆ ÿuh|hhÈ0 üÿÿPèÙÿÿÄhØ0 üÿÿPè³ÚÿÿÄøÿÒ   ÿuhÜ0Wè(ÙÿÿÄE ÀtohĞ¢ÿuè×şÿÿÄÀu[= £ tRhä0ÿuèÚÿÿÄğöt<Whè0è^ÚÿÿÄWVè|;  ÄÀtWh1èBÚÿÿÄVèÙÿÿYWj
è@ÚÿÿÄ; (  Wh$1èÚÿÿÄhĞ¢SèSşÿÿÄÀu	= £ uWh81èğÙÿÿÄéá   [^_ÉÃj SèD  Ä=ÿÿÿÿuBWhH1è¿ÙÿÿÄSÿuhh1 üÿÿPègØÿÿÄhh üÿÿPè³S  Äé   h|1SèÙÿÿÄğöu<Wh1èiÙÿÿÄSÿuh1 üÿÿPèØÿÿÄhh üÿÿPè]S  Äë1Wh¨1è-ÙÿÿÄWVèK:  ÄÀtWh°1èÙÿÿÄVèè×ÿÿYWj
èÙÿÿÄWèÙÿÿY[^_ÉÃWVt$=¨«ë=hØ1èF×ÿÿYPÿ7hĞ1è(ØÿÿÄÀuVhà1h wèq×ÿÿÄÇ wÇ? uÀ^_Ãÿt$ÿt$jèÖÿÿÄÃÿt$ÿt$jè	ÖÿÿÄÃÿt$ÿt$jèÖÿÿÄÃÿt$ÿt$ÿt$jèıÕÿÿÄÃº   ÿt$ÿt$RèõÕÿÿÄÃº   ÿt$RèñÕÿÿÄÃº   ÿt$RèíÕÿÿÄÃÿt$èïÕÿÿYÃUìì   WVuÆ h hhì1 üÿÿPèÖÿÿÄÿ5¸¢èçÕÿÿYhø1 üÿÿPè¥×ÿÿÄøÿ5§èÅÕÿÿYÿu¸ÿÿÿÿ^_ÉÃWh   Vè¸×ÿÿÄÀuWè×ÿÿY¸ÿÿÿÿ^_ÉÃVèÚÕÿÿY|ÿ
uVèÌÕÿÿYÆDÿ Wèp×ÿÿY3À^_ÉÃVÿ5¸¢è\ÕÿÿYÿt$ÿt$èşÿÿÄğÿ5§è>ÕÿÿYÆ^Ãÿt$ÿt$jèÔÿÿÄÃÿt$ÿt$jèÔÿÿÄÃÿt$ÿt$jèÔÿÿÄÃÿt$ÿt$ÿt$jèyÔÿÿÄÃº   ÿt$ÿt$RèqÔÿÿÄÃº   ÿt$RèmÔÿÿÄÃº   ÿt$RèiÔÿÿÄÃÿt$èkÔÿÿYÃ¡ÀwÃUìW=à\|ÿuhü1hôèÑÔÿÿÄ=à\|ÿuh2hôè³ÔÿÿÄÿuè  YøÿuAjÿuÿuè  Äøÿt?=à\|h0ih(2hôènÔÿÿÄ¸ÿÿÿÿ_ÉÃj h4iÿuèY  Äø=à\|+¡ÄwÀt
¸8ië¸@iPhH2hôèÔÿÿÄ=à\|+¡ÈwÀt
¸Hië¸PiPhX2hôèçÓÿÿÄ=à\|+¡ÌwÀt
¸Xië¸`iPhh2hôè³ÓÿÿÄ=à\|hĞwh|2hôèÓÿÿÄ=à\|+¡ÀwÀt
¸hië¸piPh2hôè_ÓÿÿÄÇ_ÉÃUìPWVS5à\|>|ÿuh2hôÿÓÄjhxiÿuè#  ÄEü=ÿÿÿÿujhih|iè  ÄÇÈw   >|(¡ÄwÀt
¸ië¸iPh´2hôÿÓÄ>|'¡ÈwÀt	¸ië¸ iPhÄ2hôÿÓÄ>|'¡ÌwÀt	¸¨ië¸°iPhÔ2hôÿÓÄ>|hĞwhè2hôÿÓÄ>|&¡ÀwÀt¸¸ië¸ÀiPhø2hôÿÓÄ3ÿë>|ÿ4½àwh3hôÿÓÄG<½àw uÚEü[^_ÉÃUìPWVu}ÿu<¸ÿÿÿÿ^_ÉÃEüPWèÚ  Äø}ü tötVÿuüèÑÿÿÄÀu3À^_ÉÃ? uËë½Uì=hx t,¸ÈiÀt#h3ÿ5hxèWÑÿÿÄÀuÇÄw   ë
ÇÄw    =lx t-¸ÌiÀt$h3ÿ5lxèÑÿÿÄÀuÇÈw   ëÇÈw    =dx t-¸ĞiÀt$h 3ÿ5dxèØĞÿÿÄÀuÇÌw   ëÇÌw    =x t-¸ÔiÀt$h$3ÿ5xèĞÿÿÄÀuÇÀw   ëÇÀw    =x t!jÿ5xhĞwèOĞÿÿÄÆŞw ë
ÆĞw =x    =¨^ tÿ5¨^èÒÿÿYÿ5xè,ĞÿÿY@PèÒÿÿY£¨^=¨^ u(hò   hØij ÿ5xÿ50]èX+  ÄjÿèşôÿÿYÿ5xÿ5¨^èÏÿÿÄ¡¨^£x£èx£]ÉÃÇ]èiÉÃUìPWVSU]ÇEü    <\xútút
útúu	ÇEü   ëú
uÇEü   ÿt|? tw3öëF<³?:u	Æ Gë5G? t?:uõ?:uÆ G=à\|ÿ4³h(3hôè1ÏÿÿÄF? t;uü|³=à\|Vh43hôè
ÏÿÿÄÇ³    [^_ÉÃUìPWVSu]ÇÄw    ÇÌw    ÇÈw    ÇÀw    ÆĞw Çx j¡x£èxÇx    ¡x£ìxÇ<y    ¡<y£yh@3häyè!ÎÿÿÄ£xhàwj
èşÿÿÄöu
3À[^_ÉÃh`3hH3è]ÏÿÿÄ£¬^À
  =à\|Dhjhd3hôèÎÿÿÄë+ÿ5¬^è]ÎÿÿY=à\|Vht3hôèãÍÿÿÄ¸ÿÿÿÿ[^_ÉÃ<\xé   EüPWèÊ  ÄøÃÀtG=   t\=      }ü tg} taÿuÿuüèfÍÿÿÄÀuOÿ5\xVèûÿÿÄÀu<ëb}ü t2öt.Vÿuüè5ÍÿÿÄÀuëD}ü tötjVÿuüèÎÿÿÄÀt(ÿt	? _ÿÿÿh\xèI  YÀ<ÿÿÿéÿÿÿÿ5¬^è]ÍÿÿYè[ûÿÿhèxjè'ıÿÿÄhxjèıÿÿÄ¡ÄwÀu
Çxx0jhyjèöüÿÿÄh<yjèçüÿÿÄhàwj
èØüÿÿÄ3À[^_ÉÃUìWVS5¬^Ü}h°3h3èÍÿÿÄÀuK=à\|h4jh´3hôèFÌÿÿÄ¸ÿÿÿÿ[^_ÉÃÿ5xWè<úÿÿÄÀuÿ6ÿÓY3À[^_ÉÃh\xè>   YÀt-=à\|WhÄ3hôèğËÿÿÄÿ6ÿÓY¸ÿÿÿÿ[^_ÉÃ=x uë¹UììWVSu3ÿëÇ¾    Gÿ|óhä}ÿ5¬^èÿ   ÄÀu¸ÿÿÿÿ[^_ÉÃ»ä}ëtEøPSèz   ÄØ3ÿë2}ø t*<ı8^ t ÿ4ı8^ÿuøè5ËÿÿÄÀu
Eü¾ëGÿ|Êÿ|$hÛ  hljjÿuøhLjèp&  ÄjÿèğÿÿYÛt; u3À[^_ÉÃUìWU}ëG? t
?	tõ? tğ:ëG? t?=uõ? tÆ GzëG? t?	t
? t?
uë? tÆ GÇ_ÉÃUìì   WVS]uëw üÿÿPètÊÿÿY¼ÿûÿÿëÆ O üÿÿ;ør?
tí?	tè? tã½ üÿÿ#t9½ üÿÿ
t0 üÿÿÀt& üÿÿPVèâÉÿÿÄ üÿÿPèÊÿÿYğ~ÿ\uNSh    üÿÿPè·ËÿÿÄÀlÿÿÿÆ+E[^_ÉÃWV¾ä|$ë	GF?:t? tşórèÆ ?:uGD$Ç äÇ^_Ã¡ÄwÃD$=Ğw thĞwPè@ÉÿÿÄÃPè6  YÃ¡ÌwÃ¡ÈwÃ=à\|ÿt$hÜ3hôèXÉÿÿÄÿt$ÿt$è  ÄÃUìì¼  WVSu3ÿëÇ½Ìşÿÿ    G<¾ uîÿuèöÊÿÿYØÛË   SèõÈÿÿYÃEüé±   tÿÿÿPSèSóÿÿÄÀus3ÿëi¼½Ìşÿÿ u0DşÿÿPÿ4¾è/óÿÿÄÀuDşÿÿ½ ÿÿÿTşÿÿ½Ìşÿÿtÿÿÿ9½ ÿÿÿuE9½ÌşÿÿuSèEÊÿÿY¸   [^_ÉÃG<¾ uEüÆ  j/SèÉÿÿÄEüÀu	SèÊÿÿYëEüÆ@ ; Hÿÿÿ3À[^_ÉÃUìPWVS]ÇEü    3ÿéÍ   <½àw t.¸|jÀt%hì3ÿ4½àwèØÇÿÿÄÀuÇEü   é   ;/t3j/ÿ4½àwèÈÿÿÄ£¼¯Àt¡¼¯@ğë4½àwë
4½àw=à\|Vhğ3hôèÇÿÿÄöt1Ût-SVèZÇÿÿÄÀuÿ4½àwÿuèÇÿÿÄ¸   [^_ÉÃG<½àw )ÿÿÿ}üuSÿuèæÆÿÿÄ¸   [^_ÉÃhü3ÿuèËÆÿÿÄ3À[^_ÉÃUìWVuVè.  Y=ÿÿÿÿ®   } u$hèxVè¡ıÿÿÄÀthyVèıÿÿÄÀt|}u$hxVèwıÿÿÄÀth<yVèeıÿÿÄÀtRh¨§èÆÿÿYPVh¨§èkÇÿÿÄÀu<h¨§èjÆÿÿYÆx8/u'?Dt?XuG?.uj/WèGÈÿÿÄÀu3À^_ÉÃ¸ÿÿÿÿ^_ÉÃUìì  WVS}WèÆÿÿYDÿØ8/u;ëCÆ/j/ÿuèºÆÿÿÄ£¼¯Àt
¡¼¯@ëEPCPèÅÿÿÄë%hĞ¢Wè=ğÿÿÄÀu¡ä¢% ğ  = @  t¥hĞ¢WèğÿÿÄÀu¡ä¢%   ç   tÿÿÿPWèöïÿÿÄÀ×   WtûÿÿPè&ÅÿÿÄj/tûÿÿPèÆÿÿÄğö¬   tûÿÿ;ğuFÆ hĞ¢tûÿÿPè¡ïÿÿÄÀu¡ä¢% ğ  = @  t} toj tûÿÿPèA+  Ä=ÿÿÿÿtW¸¨§Àt"tûÿÿÀttûÿÿPh¨§è¿ÄÿÿÄÀt$hĞ¢tûÿÿPè/ïÿÿÄÀu¡ä¢%   t3À[^_ÉÃ¸ÿÿÿÿ[^_ÉÃÿt$ÿt$jèÃÿÿÄÃÿt$ÿt$jèÃÿÿÄÃÿt$ÿt$jèÃÿÿÄÃÿt$ÿt$ÿt$jèÃÿÿÄÃº   ÿt$ÿt$RèyÃÿÿÄÃº   ÿt$RèuÃÿÿÄÃº   ÿt$RèqÃÿÿÄÃÿt$èsÃÿÿYÃUìWVSU}]3öë<Æ G? t÷?	tò?
uÆ Àt#ÇG³ëGÀt? t
?	t?
uêF;ò|ÅÇ³    Æ[^_ÉÃUìPWVSé   E0Îéà   >\Ë   FÀÑ   F¾=7   tHS=3   t?"=1   t6=0   t-é   =2   t ë{=5   t=4   tëf=6   u]3Ûşé³   =s   t7=n   t=b   u7ÆAëHÆ AëAÆ
Aë9=r   uÆAë*=t   u	Æ	AëÆ\AÁAë
ÁAF> ÿÿÿÆ EE8 øşÿÿ[^_ÉÃ¸0   ¾;Â"?7İ    ¾-0   ØGÇ+Æ=   |ÒÛu
Æ\AÆNAëAwÿëÿt$ÿt$jè)ÁÿÿÄÃÿt$ÿt$jè%ÁÿÿÄÃÿt$ÿt$jè!ÁÿÿÄÃÿt$ÿt$ÿt$jèÁÿÿÄÃº   ÿt$ÿt$RèÁÿÿÄÃº   ÿt$RèÁÿÿÄÃº   ÿt$Rè	ÁÿÿÄÃÿt$èÁÿÿYÃUììWVSM}uŞëÉtÁAG? tï?	tê?
tåÉf  Æ é^  Æ ;ó^  Ç[^_ÉÃC;ğu;2uGFC;ğu
;1uG;óuGFÆ Ç[^_ÉÃC;ğuä;0ußëØ;óuá?(uÆEû)ëEû¾EûPWè8  ÄEü+Ç@PWVèÀÿÿÄEü+Ç@ğ}üEû8uGëÀPÿÿÿé¢   =
   =ÿÿÿé   =&   `ÿÿÿ="   xÿÿÿëq='   iÿÿÿëb=\   4ÿÿÿ+=<   <ÿÿÿ=;   ÿÿÿë8=>   éşÿÿë*=`   !ÿÿÿ=^   ïşÿÿë=|   àşÿÿGF? uÆ ;óuC3À[^_ÉÃ¾=(   Şşÿÿtÿÿÿ=    qşÿÿ7ÿÿÿ=	   `şÿÿÿÿÿéışÿÿÇ[^_ÉÃUìPWVS}]f¾ Gèë8ufNföuë8/ufFG? uäÇ[^_ÉÃUììWVS3ÛEUÆ } tEÆ  ¸Ì¯Àt_¸jÀtVh4hÌ¯èÿ¾ÿÿÄÀu@E8(u8j)ÿEPèeÿÿÿÄEø+EPÿuÿuèÀ¾ÿÿÄEUø+UÆ Ã[^_ÉÃ}j!Wè½ÀÿÿÄğöuWÿuèk¾ÿÿÄÃ[^_ÉÃ»   ;÷   ¸§Àt)ÿt%Æ+ÇPWh§èf¿ÿÿÄÀuÆ+Ç§ÀtYÆ+ÇPWÿuè3¾ÿÿÄEÖ+×Æ } tCj!Wè÷¾ÿÿÄEü;ğt4Eü+ÆHPFPÿuèú½ÿÿÄEUü+ÖÆDÿ ë~é;ÿÿÿuüEü@Pÿuè¬½ÿÿÄÃ[^_ÉÃÿt$ÿt$jèá¼ÿÿÄÃÿt$ÿt$jèİ¼ÿÿÄÃÿt$ÿt$jèÙ¼ÿÿÄÃÿt$ÿt$ÿt$jèÑ¼ÿÿÄÃº   ÿt$ÿt$RèÉ¼ÿÿÄÃº   ÿt$RèÅ¼ÿÿÄÃº   ÿt$RèÁ¼ÿÿÄÃÿt$èÃ¼ÿÿYÃUìì  ÷úÿÿPèßÿÿÿYøûÿÿjRÿuèù¼ÿÿÄEÆ@ ÉÃÿt$ÿt$jè¼ÿÿÄÃÿt$ÿt$jè	¼ÿÿÄÃÿt$ÿt$jè¼ÿÿÄÃÿt$ÿt$ÿt$jèı»ÿÿÄÃº   ÿt$ÿt$Rèõ»ÿÿÄÃº   ÿt$Rèñ»ÿÿÄÃº   ÿt$Rèí»ÿÿÄÃÿt$èï»ÿÿYÃUìì,  WVS\}ÿtÀu¸ÿÿÿÿ[^_ÉÃÿ   ¸§À   h§WÿÓÄÀut3À[^_ÉÃ½Ôşÿÿ#tc½Ôşÿÿ tZ½Ôşÿÿ	tQ½Ôşÿÿ
tHh4ÔşÿÿPèO½ÿÿÄğöt.Æ ÿt'ÔşÿÿÀtÔşÿÿPWÿÓÄÀuèßH  3À[^_ÉÃh,  ÔşÿÿPèSI  ÄÀxÿÿÿè·H  ¸ÿÿÿÿ[^_ÉÃÿt$ÿt$jè}ºÿÿÄÃÿt$ÿt$jèyºÿÿÄÃÿt$ÿt$jèuºÿÿÄÃÿt$ÿt$ÿt$jèmºÿÿÄÃº   ÿt$ÿt$RèeºÿÿÄÃº   ÿt$RèaºÿÿÄÃº   ÿt$Rè]ºÿÿÄÃÿt$è_ºÿÿYÃUìì(WVS°^3ÿé  =Ü\ tGkÇ8ôPèL  Y=ÿÿÿÿtkÇ8ôPèm  Y=ÿÿÿÿu.kÇ8ôPè  YéH  Ç   kÇ8ğ\&=Ü\ tJkÇ8Pèã'  YğVkÇ8¾&PkÇ8PjkÇ8¾ôPh4EØPècºÿÿÄëjkÇ8ôPEØPè×¹ÿÿÄÆEæ =à\	|kÇ8¾&Ph4hôèİ¹ÿÿÄkÇ8¾&Ph<4EìPèºÿÿÄEìPkÇ8PèÛ¹ÿÿÄ; t+kÇ8ôì8VğW|$¹   ó¥_^èÍ
  Ä8Ç    kÇ8PEØPkÇ8ôPè¯  ÄjEØPkÇ8ôPè¹ÿÿÄG;=_şÿÿÇ    jj.hôèË¹ÿÿÄ£¼¯Àt¡¼¯@ë¸ôPhèÄ¸ÿÿÄ[^_ÉÃUìWVS]u3ÿë9jkÇ8PVèª¹ÿÿÄÀujkÇ8ôPSè¸ÿÿÄ3À[^_ÉÃG;=|¿¸ÿÿÿÿ[^_ÉÃ¸ÃUì=|*h   h jÿ5hjhjè­  ÄjÿèSİÿÿYjj/ÿuèö¸ÿÿÄ£¼¯Àt
¡¼¯@ëEPk8ôPèé·ÿÿÄjÿuk8PèÎ·ÿÿÄjÿuk8Pè³·ÿÿÄÿÉÃWV53ÿëkÇ8ôPèÍ  YG;>|ëÇ    ^_ÃUìì  VjÿuñûÿÿPèa·ÿÿÄj/ñûÿÿPèp¹ÿÿÄğÀt3Æ F=à\|ñûÿÿPh@4hôèT·ÿÿÄñûÿÿPèÉ  Yöt>=à\|Vh`4hôè'·ÿÿÄë =à\|ÿuh4hôè·ÿÿÄÿuè~  Y=à\|ÿuh¸4hôèŞ¶ÿÿÄj/ÿuè·ÿÿÄ£¼¯Àt	¡¼¯@ëEPh¨§hÄ4 üÿÿPèâ¶ÿÿÄ=à\| üÿÿPhÌ4hôè¶ÿÿÄj  üÿÿPèß¶ÿÿÄÀu)hº   h¬jj  üÿÿPÿ5`]è  Äjÿè@ÛÿÿY üÿÿPÿuèÄ  ÄÀt-h»   h¸jÿ5¬« üÿÿPÿ5D]èW  ÄjÿèıÚÿÿY^ÉÃÿt$ÿt$jèé´ÿÿÄÃÿt$ÿt$jèå´ÿÿÄÃÿt$ÿt$jèá´ÿÿÄÃÿt$ÿt$ÿt$jèÙ´ÿÿÄÃº   ÿt$ÿt$RèÑ´ÿÿÄÃº   ÿt$RèÍ´ÿÿÄÃº   ÿt$RèÉ´ÿÿÄÃÿt$èË´ÿÿYÃUìPWVS]è9¶ÿÿPèC·ÿÿYğ¿   ë&<» t> tÿ6ÿ4»èµÿÿÄÀu3À[^_ÉÃG;}|Ö¸ÿÿÿÿ[^_ÉÃUìWVSu]=à\	|h´hÔ4hôèÛ´ÿÿÄ~ t¸TlÀthà4ÿvè´ÿÿÄÀtf=à\	|ÿ6hä4hôè´ÿÿÄ¿   ëJ=à\	|ÿ4¾h5hôèu´ÿÿÄ¸´Àt!<¾ tÿ4¾h´è6´ÿÿÄÀu3À[^_ÉÃG;û|³¸ÿÿÿÿ[^_ÉÃUìì  WVS\}h 5G#PÿÓÄÀuè  G23À[^_ÉÃh<5h(5èµÿÿÄğëzh    ôÿÿP üÿÿPèĞïÿÿÄG#ÀtV½ ôÿÿ tMÿµ ôÿÿG#PÿÓÄÀtë8üóÿÿPÿµôÿÿWè±  Ä=ÿÿÿÿtVèå³ÿÿYôÿÿ G23À[^_ÉÃh    üÿÿPVè¾  ÄÀkÿÿÿVè­³ÿÿYÿ5Ğ^G#Pÿ5Ì^ÿµüóÿÿÿ5È^ÿw4ÿ5Ä^h@5hôè³ÿÿÄ$è   G23À[^_ÉÃUìì   WV5Üh5hl5è´ÿÿÄøëEh    ôÿÿP üÿÿPèÄîÿÿÄh5ÿµ ôÿÿè²ÿÿÄÀuWÿÖYôÿÿ¾ ^_ÉÃh    üÿÿPWèæ  ÄÀu£WÿÖY¸Z   ^_ÉÃUìì  WVS]Çpóÿÿ    ÇC4    h5Sèe³ÿÿÄøÿ)  SèJ  Yh
  hXlÿ5¬«Sÿ5 ]è  Äéş   h   xóÿÿPxûÿÿPèôíÿÿÄ=   }(WèD²ÿÿYSèõ  Yh  h|lj Shdlè5  Äxóÿÿ8R¤   xÿÿÿPÿµóÿÿè©ûÿÿÄğöt,=¬«u-Çpóÿÿ   xÿÿÿPÿµ|óÿÿè{ûÿÿÄğë
Ç°^   öt?Wè¸±ÿÿYh5  hlÿ5¬«½póÿÿ t
|óÿÿëóÿÿPÿ58]è  ÄÇpóÿÿ    E¨C4Wh   xûÿÿPè­²ÿÿÄÀæşÿÿWèL±ÿÿY3À[^_ÉÃUìì  WVS]uöt¸lÀth5Vè°ÿÿÄÀã   h   EPVè8  ÄjkEPè²ÿÿÄøÿujmEPèn²ÿÿÄøÿu	şéó   ?kuKÆ EPèk²ÿÿYÜ (Ù½|ûÿÿf|ûÿÿf f~ûÿÿÙ­~ûÿÿÛxûÿÿÙ­|ûÿÿxûÿÿëIÆ EPè ²ÿÿYÜ¨(Ù½|ûÿÿf|ûÿÿf f~ûÿÿÙ­~ûÿÿÛxûÿÿÙ­|ûÿÿxûÿÿE9P43À[^_ÉÃ¸ÿÿÿÿ[^_ÉÃ¾¶%   u+Vh5ûÿÿPèÕ¯ÿÿÄûÿÿPèn   Y3À[^_ÉÃG? u¾Vè±ÿÿYëUìWVS]u3ÿë'¾¶%   t¾FPèm±ÿÿYëF;GEH;ø}> uÌÆ; [^_ÉÃUìì  Vh°lh¨lhlhì5 üÿÿPè.¯ÿÿÄhø5 üÿÿPèJ°ÿÿÄğÀtÿuhü5VèÃ®ÿÿÄVèZ°ÿÿY^ÉÃUìì  WVSôh6EPè´¯ÿÿÄğö»   EPÿÓYhÊ  h¸lÿ5¬«EPÿ5 ]èÑ	  Äé   h    ôÿÿP üÿÿPè@êÿÿÄ=   }+Vè®ÿÿYEPÿÓYhÔ  hÜlj EPhÄlè~	  Ä ôÿÿ8Rt4xóÿÿPÿµôÿÿèö÷ÿÿÄ=ÿÿÿÿtEPÿµôÿÿÿµôÿÿè#öÿÿÄVh    üÿÿPèj¯ÿÿÄÀWÿÿÿVè	®ÿÿY[^_ÉÃUìì  WVSué¼   ½ üÿÿ#«    üÿÿPè_­ÿÿY¼ÿûÿÿëÆ O üÿÿ;ør?
tí?	tè? tã½ üÿÿ
tn üÿÿÀuëbEHÖ+U+Âüûÿÿ üÿÿPè­ÿÿY9üûÿÿs
üûÿÿë üÿÿPèä¬ÿÿYØÛt<S üÿÿPVè¯¬ÿÿÄCÿğ~ÿ\u Nÿuh    üÿÿPèl®ÿÿÄÀ)ÿÿÿFÆ Æ+EH[^_ÉÃUìì   WV}uÿvEPè3¬ÿÿÄh    ÿÿÿPEPèıÿÿÄ ÿÿÿÀt2¸èlÀt)h6 ÿÿÿPè$¬ÿÿÄÀuWVè2÷ÿÿÄ^_ÉÃ ÿÿÿÀt>¸ğlÀt5h6 ÿÿÿPèè«ÿÿÄÀuWVèööÿÿÄÀ   ¸ÿÿÿÿ^_ÉÃ ÿÿÿÀt2¸ülÀt)h6 ÿÿÿPè «ÿÿÄÀuWVèZöÿÿÄ^_ÉÃ ÿÿÿÀtB¸mÀt9h$6 ÿÿÿPèd«ÿÿÄÀu!WVèöÿÿÄÀt3À^_ÉÃ¸ÿÿÿÿ^_ÉÃÿvh06 ûÿÿPè«ÿÿÄ ûÿÿPè!üÿÿY¸ÿÿÿÿ^_ÉÃUìì   WVS}ÿt%¸mÀth|6WèåªÿÿÄÀu
3À[^_ÉÃh6h6è¬ÿÿÄğë?h    ôÿÿP üÿÿPèÄæÿÿÄØÿt½ ôÿÿ tÿµ ôÿÿWèªÿÿÄÀtOh    üÿÿPVèíüÿÿÄÀuªVèàªÿÿYÿ5Ü^ÿ5Ø^Wÿ5Ô^h°6hôè]ªÿÿÄ¸ÿÿÿÿ[^_ÉÃS ôÿÿPè£ıÿÿÄ=ÿÿÿÿtVèªÿÿY3À[^_ÉÃVèªÿÿYÿ5À^ÿ5¼^Wÿ5¸^h6hôèÿ©ÿÿÄ¸ÿÿÿÿ[^_ÉÃUìì  WVS]hÀ6SèöªÿÿÄøÿ  SèÛ  Yh  hmÿ5¬«Sÿ5 ]è  Äéæ   h    ôÿÿP üÿÿPèåÿÿÄ=   }(WèÔ©ÿÿYSè  Yh  h<mj Sh$mèÅ  Ä ôÿÿ8R   =à\|ÿµôÿÿhÄ6hôè%©ÿÿÄxóÿÿPÿµôÿÿèóÿÿÄ=ÿÿÿÿtNÿµôÿÿè;ªÿÿYÀt>WèP©ÿÿYSè  Yÿµôÿÿèõ
  Yh®  hHmÿ5¬«ÿµôÿÿÿ5L]è+  ÄWh    üÿÿPèVªÿÿÄÀÿşÿÿWèõ¨ÿÿY=à\|Shà6hôè{¨ÿÿÄSè²©ÿÿYÀt&Sè
  Yh¸  hTmÿ5¬«Sÿ5L]èº  Ä[^_ÉÃUìì<  WVS]ÆEñ SègªÿÿYğö"  hĞ  h`mÿ5¬«Sÿ5 ]èP  ÄjÿèöÌÿÿYéö   EÓPh£jhlmhü6ÓûÿÿPè¨ÿÿÄÓûÿÿPè  Y=ÿÿÿÿ¶   EÓPèç©ÿÿYøÿ   hØ  hmÿ5¬«EÓPÿ5 ]èÍ  ÄjÿèsÌÿÿYëX½ÄûÿÿCuOEñÀuEÓPEñPè§ÿÿÄëMEÓPEâPèï¦ÿÿÄEñPEâPè§ÿÿÄÀ}EâPEñPèË¦ÿÿÄÄûÿÿPWè7'  Ä=   tWèK©ÿÿYSEÓPVèg'  Ä=   õşÿÿVè+©ÿÿYjEñPÿuè¦ÿÿÄEÆ@ [^_ÉÃÿt$ÿt$jè­¥ÿÿÄÃÿt$ÿt$jè©¥ÿÿÄÃÿt$ÿt$jè¥¥ÿÿÄÃÿt$ÿt$ÿt$jè¥ÿÿÄÃº   ÿt$ÿt$Rè¥ÿÿÄÃº   ÿt$Rè¥ÿÿÄÃº   ÿt$Rè¥ÿÿÄÃÿt$è¥ÿÿYÃUìPÿuÿuøhmh7h¨§è>¦ÿÿÄjh¨§è#  ÄY=à\|h¨§h7hôèÎ¥ÿÿÄh¨§è¦ÿÿYĞÒt(jhmÿ5¬«h¨§ÿ5H]èí   ÄjÿèÊÿÿYh¨§hÛ¯è3¥ÿÿÄÉÃÿt$hmh7h¨§è¤¥ÿÿÄjh¨§è  ÄÃÿt$ÿt$jèA¤ÿÿÄÃÿt$ÿt$jè=¤ÿÿÄÃÿt$ÿt$jè9¤ÿÿÄÃÿt$ÿt$ÿt$jè1¤ÿÿÄÃº   ÿt$ÿt$Rè)¤ÿÿÄÃº   ÿt$Rè%¤ÿÿÄÃº   ÿt$Rè!¤ÿÿÄÃÿt$è#¤ÿÿYÃÿt$ÿt$jÿt$ÿt$ÿt$è%   ÄÃÿt$ÿt$jÿt$ÿt$ÿt$è   ÄÃUìì  W=à\ t	¿ôë(h47h7èe¥ÿÿÄøh¶  h87è1¥ÿÿÄÿt:è¦ÿÿüûÿÿÿuÿuÿuÿuÿuè   PÿµüûÿÿhÌ¯}u¸¬më_ÉÃ¸´mPhP7WèÛ£ÿÿÄ,=à\ uWè)¤ÿÿYhÌ¯ÿuÿu}u¸¸më¸ÀmPh7 üÿÿPèÙ£ÿÿÄ}u ÿ5] üÿÿPj
h£è%  Ä_ÉÃUìPWEüPèÒ¥ÿÿYEüPèØ¥ÿÿYøÿ7ÿwÿwÿwG@Ph°7hèv£ÿÿÄ¸_ÉÃUììDWj@ÿuEÀPèã¢ÿÿÄÆEÿ j/EÀPè±£ÿÿÄøÿu8h   hÔmj ÿuhÄmÿu´ÿu°jÿu¬ÿu¨ÿu¤è^şÿÿÄÄjÿèÁÇÿÿYÆ GEÀPWè   Ä;E
¸   _ÉÃ3À_ÉÃUìì   WVS}]ÇEü    Sè¹¤ÿÿYğö   h²   hàmÿ5¬«Sÿ5 ]ÿµlÿÿÿÿµhÿÿÿjÿµdÿÿÿÿµ`ÿÿÿÿµ\ÿÿÿèÂıÿÿÄÄjÿè%ÇÿÿYëHWè
¢ÿÿYP|ÿÿÿPWèë¢ÿÿÄÀu*|ÿÿÿPShÈ7E¼Pè.¢ÿÿÄE¼Pèª  YÀtÿEü|ÿÿÿPVèù!  Ä=   t£Vè¤ÿÿYEü[^_ÉÃÿt$ÿt$jè¥ ÿÿÄÃÿt$ÿt$jè¡ ÿÿÄÃÿt$ÿt$jè ÿÿÄÃÿt$ÿt$ÿt$jè ÿÿÄÃº   ÿt$ÿt$Rè ÿÿÄÃº   ÿt$Rè ÿÿÄÃº   ÿt$Rè ÿÿÄÃÿt$è ÿÿYÃUìì  WVSj ÿuè£ÿÿÄğşÿ  hĞ¢ÿuè/ÿÿÿÄÀuO¡ä¢% ğ  = @  u>hĞ7ÿuèî ÿÿÄj/ÿuèa¡ÿÿÄ£¼¯Àt	¡¼¯@ëEPÿuèÀ ÿÿÄ=à\|ÿuhÔ7hôèr ÿÿÄÿuø÷ÿÿPè ÿÿÄj/ø÷ÿÿPèÿ ÿÿÄøûÿÿÀuø÷ÿÿøûÿÿëÿøûÿÿhè7ÿµøûÿÿèÎÿÿÄÿµøûÿÿè°¢ÿÿY ÀuEøûÿÿë/ø÷ÿÿøûÿÿ=à\|ÿµøûÿÿhô7hôèÒÿÿÄh¶  h  ÿµøûÿÿèJ¢ÿÿÄØûÿu|Eøûÿÿh¶  h  ÿµøûÿÿè"¢ÿÿÄØûÿu4=à\|ÿ5¬«h8hôèjÿÿÄVèq ÿÿY¸ÿÿÿÿ[^_ÉÃ=à\|hìmh(8hôè7ÿÿÄh¶  ÿµøûÿÿè$ ÿÿÄh   üûÿÿPVè¿¡ÿÿÄøÿ~WüûÿÿPSè¸¡ÿÿÄEü;ÇtÍVèøÿÿYSèñÿÿYÿu}üÿu
¸ÿÿÿÿ[^_ÉÃE9øûÿÿtMÿuÿµøûÿÿè¡ÿÿÄÀt8=à\|ÿ5¬«hH8hôèÿÿÄÿµøûÿÿèÀÿÿY¸ÿÿÿÿ[^_ÉÃ3À[^_ÉÃUìì   WS]tÿÿÿPSèüÿÿÄÀuE% ğ  =   u¸   ë3ÀĞëº   ÒtSè]ÿÿYSÿuèó ÿÿÄøÿ}SÿuèíüÿÿÄøÿu	ÿuè0ÿÿYÇ[_ÉÃUìì   Vuj/VèÿÿÄ£¼¯Àt¡¼¯@ëÆPhğmhd8 üÿÿPèãÿÿÄ üÿÿPVès ÿÿÄVèÊÿÿYÀt'h   hnÿ5¬«Vÿ5L]è¹øÿÿÄjÿè_ÂÿÿY^ÉÃUìì   WVSu]ëSWj üÿÿPèÿÿÄVh   j üÿÿPèİÿÿÄøÿĞ¶F%    u¶C%    t
¸ÿÿÿÿ[^_ÉÃ3À[^_ÉÃUìì  VÿuüûÿÿPèÿÿÄhĞ¢ÿuèûÿÿÄÀuW¡ä¢% ğ  = @  uFhl8üûÿÿPèÊÿÿÄj/ÿuè=ÿÿÄ£¼¯Àt	¡¼¯@ëEPüûÿÿPèÿÿÄh¶  üûÿÿPèÔÿÿÄPè[ÿÿYh¶  üûÿÿPè9ÿÿÄÿ5¸¢èËÿÿYüûÿÿPÿuèûÿÿÄğÿ5§è«ÿÿYÆ^ÉÃUìì  Vÿuÿ5]hp8üûÿÿPè ÿÿÄj üûÿÿPè  ÄÀt¸ÿÿÿÿ^ÉÃj/ÿuèfÿÿÄ£¼¯Àt
¡¼¯@ëEPüûÿÿPèÀÿÿÄüûÿÿPÿuèıÿÿÄğöu&üûÿÿPÿuèÿÿÄh¶  üûÿÿPèRÿÿÄÆ^ÉÃÿt$ÿt$jè9ÿÿÄÃÿt$ÿt$jè5ÿÿÄÃÿt$ÿt$jè1ÿÿÄÃÿt$ÿt$ÿt$jè)ÿÿÄÃº   ÿt$ÿt$Rè!ÿÿÄÃº   ÿt$RèÿÿÄÃº   ÿt$RèÿÿÄÃÿt$èÿÿYÃUìì  WVS]SíûÿÿPè<ÿÿÄ;/   ;~u½îûÿÿuíë6íûÿÿPhÛ¯hx8SèÿÿÄ Û¯ÀuV¸ÿÿÿÿ[^_ÉÃFGÀt?/uïÆ EíÀtSEüPEíPè/	  ÄÀtÿ5]Sè´ÿÿÄWSè*ÿÿÄSè  YÀth8SèÿÿÄ¸ÿÿÿÿ[^_ÉÃ3À[^_ÉÃUìì  WVS]ÿu üÿÿPè^ÿÿÄ üÿÿPèÿÿYüûÿÿ üÿÿüûÿÿ|ÿ/th8 üÿÿPè¤ÿÿÄ½üÿÿj/WèSÿÿÄøÿu
3À[^_ÉÃÆ hĞ¢ üÿÿPèôıÿÿÄÀu-¡ä¢% ğ  = @  u=ì¢ur¡ä¢÷Ğ%ÿ  Øëb=à\| üÿÿPh8hôèéÿÿÄSèĞÿÿYğhÿ   üÿÿPèÌÿÿÄ=ÿÿÿÿuVè¬ÿÿY¸ÿÿÿÿ[^_ÉÃVèÿÿYÆ/Gé5ÿÿÿÿt$èëıÿÿYÀu3ÀÃÿt$h¤8hôèuÿÿÄ¸ÿÿÿÿÃUìWVS]óş>/Ó   FGéÈ   Fé¿   jh¼8VèÿÿÄÀtäöt¸nÀthÀ8VèôÿÿÄÀtÅjhÄ8VèàÿÿÄÀtöt9¸nÀt0hÈ8VèÁÿÿÄÀuvGÿ;Ãu;/tH;ûw#¸ÿÿÿÿ[^_ÉÃÀu";ûuÆ.GÆ 3À[^_ÉÃO;ûvÿ/uõëGÀtÆF8/uï>/:ÿÿÿé-ÿÿÿÿt$ÿt$jèeÿÿÄÃÿt$ÿt$jèaÿÿÄÃÿt$ÿt$jè]ÿÿÄÃÿt$ÿt$ÿt$jèUÿÿÄÃº   ÿt$ÿt$RèMÿÿÄÃº   ÿt$RèIÿÿÄÃº   ÿt$RèEÿÿÄÃÿt$èGÿÿYÃUìPVSu}=à\	|¾ÇPhÌ8hôè¬ÿÿÄ=à\	|VhØ8hôèÿÿÄ=à\	|¾EPhà8hôèpÿÿÄÆ Àu!¾§=à\	|Vhè8hôèGÿÿÄVè  YĞÿCtÿXu)kÂÿ°¼¾EPVj¾ÇPhø8ÿuèOÿÿÄë;kÂÿÀÀ%ÿ  PkÂ¼%ÿÿ  PV¾ÇPh9ÿuèÿÿÄ=à\|ÿuh9hôè´ÿÿÄ[^ÉÃUìì  WVS]=à^r&jNh(nhĞ  h$nhnèÉğÿÿÄjÿèoºÿÿYEøPèÕÿÿYÿuøèlÿÿYSh4nh$9øûÿÿPèÿÿÄj/øûÿÿPèãÿÿÄ£¼¯Àt¡¼¯@ë	øûÿÿÆ@ ¿   ëøûÿÿPèğ  YÀtjèÿÿYGÿ|áÿ|&j[hPnj øûÿÿPÿ54]èğÿÿÄjÿè¿¹ÿÿYSh\nh,9ø÷ÿÿPèçÿÿÄh49ø÷ÿÿPè³ÿÿÄğö   EüPh89Vè§ÿÿÄ=   tè¨ÿÿEüfÏVh<9ø÷ÿÿPèÿÿÄğöu*jehpnÿ5¬«ø÷ÿÿPÿ5 ]èwïÿÿÄjÿè¹ÿÿYh¶  ø÷ÿÿPèÿÿÄëbh@9ø÷ÿÿPèÿÿÄğöu*jjh|nÿ5¬«ø÷ÿÿPÿ5,]èïÿÿÄjÿèÁ¸ÿÿYh¶  ø÷ÿÿPè¯ÿÿÄèçÿÿEüÿEüeüÿÿ  ÿuühD9VèÿÿÄ¶F%    t*jrhnÿ5¬«ø÷ÿÿPÿ5$]è¯îÿÿÄjÿèU¸ÿÿYVè®ÿÿY¶F%    t*jthnÿ5¬«ø÷ÿÿPÿ5X]èsîÿÿÄjÿè¸ÿÿYøûÿÿPè(  Y=à\|ShL9hôèòÿÿÄ=à\|ÿuühT9hôèÔÿÿÄSkà^¬PèmÿÿÄkà^Uü¼èåÿÿ%ÿ  kà^À¡à^ÿà^[^_ÉÃÇà^    ÃUìWVu3ÿë+kÇ¬ÀtötjVkÇ¬Pè%ÿÿÄÀt	G;=à^|ÍkÇ¼^_ÉÃWVt$3ÿë#jVkÇ¬PèêÿÿÄÀuÇ^_ÃG;=à^|×VèAüÿÿY^_Ãÿt$ÿt$jèÙÿÿÄÃÿt$ÿt$jèÕÿÿÄÃÿt$ÿt$jèÑÿÿÄÃÿt$ÿt$ÿt$jèÉÿÿÄÃº   ÿt$ÿt$RèÁÿÿÄÃº   ÿt$Rè½ÿÿÄÃº   ÿt$Rè¹ÿÿÄÃÿt$è»ÿÿYÃUìPWèÿÿĞÀtRè¢ÿÿYøÿtE9Gt'ÿuèÿÿYøÿujèÿÿYøÿu
¸ÿÿÿÿ_ÉÃÿ7ÿuè¢ÿÿÄ3À_ÉÃWÿt$èNÿÿYøÿuD$Æ  ¸ÿÿÿÿ_Ãÿwÿt$èlÿÿÄD$W3À_Ãÿt$ÿt$jèÿÿÄÃÿt$ÿt$jèÿÿÄÃÿt$ÿt$jèÿÿÄÃÿt$ÿt$ÿt$jèÿÿÄÃº   ÿt$ÿt$RèÿÿÄÃº   ÿt$RèÿÿÄÃº   ÿt$Rè}ÿÿÄÃÿt$èÿÿYÃUìVu ä^Àu7èWÿÿPj
h\9hä^è%ÿÿÄè=ÿÿPh nhd9h|èÿÿÄVh|hä^è  Ä=ÿÿÿÿufh|èáÿÿYVèb   YÀt9ë.h|èÆÿÿY=à\|h´nhp9hôèhÿÿÄ¸ÿÿÿÿ^ÉÃVh|hä^è°  ÄÀuµVè¯  Y3À^ÉÃUììWVSj ÿuèµÿÿÄğ=à\|ÿuh9hôèÿÿÄşÿu9=¬«X  =à\  ÿ5¬«h 9hôèÎÿÿÄéø   jEğPVèhÿÿÄøVè½ÿÿYÿt+=à\Ì   h¸nhĞ9hôèÿÿÄé°   j
j EğPèÿÿÿÄØj SèÿÿÄøÿt	=¬«u,=à\|h¼nhø9hôè3ÿÿÄ¸ÿÿÿÿ[^_ÉÃ=à\|Sh(:hôèÿÿÄ=à\|Wh<:hôèïÿÿÄ=à\|ÿuhH:hôèÑÿÿÄÿuèÿÿYÀt)=à\|hÀnhh:hôè¤ÿÿÄélÿÿÿ3À[^_ÉÃUìWVSğ^3ÿë<½¼ tG;;|ñÿ
|%h   hØnWhÔnhÄnè¢èÿÿÄjÿèH²ÿÿY;;|ÿøjÿuè#ÿÿY@PèÛÿÿÄğöu$h   hünj ÿuhänèYèÿÿÄjÿèÿ±ÿÿYÿuVè¥ÿÿÄ4½¼[^_ÉÃUìWVu3ÿëV<½¼ tKöt"ötC<½¼ t9ÿ4½¼VèÿÿÄÀu%ÿ4½¼èÜÿÿYÿ4½¼èOÿÿYÇ½¼    G;=ğ^|¢^_ÉÃUìì@ÿuÿuh:EÀPèÿÿÄj/EÀPèüÿÿÄ£¼¯Àt¡¼¯@ëEÀÆ@ EÀPèDÿÿÿYÉÃUìì@j/ÿuèÿÿÄÀt3ÀÉÃj/ÿuè®ÿÿÄ£¼¯Àt
¡¼¯@ëEPÿuh:EÀPèÿÿÄj/EÀPèuÿÿÄ£¼¯Àt	¡¼¯@ëEÀÆ@ EÀPèûÿÿYÉÃUììdWV}h$  WèÿÿÄğöñ   ÿ5¬«ÿuWh:EPè¡ÿÿÄEPhoèğ  Ä=¬«t=¬«¤   WèqÿÿYé   =à\|¡¬«ÿ4d)h¤:hôèÿÿÄ=à\|Wh¬:hôèèÿÿÄ=à\|ÿuh¸:hôèÊÿÿÄWèÿÿYÀ})ÿ5¬«WhÀ:EPèçÿÿÄEPhoè6  Ä¸ÿÿÿÿ^_ÉÃjÿuVè=ÿÿÄh$  WèoÿÿÄjjWè"ÿÿÄVèiÿÿYÿuWè/ÿÿÄÀÿÿÿWè~ÿÿYÀ})ÿ5¬«WhĞ:EPèdÿÿÄEPhoè³  Ä3À^_ÉÃUìWVS¬«u3ÿhäVèhùÿÿÄÀuPÿ5è®ùÿÿYPÿ5èùÿÿYPÿ5äèùÿÿYPh$ohØ:hlèêÿÿÄhlèùÿÿY=ÿÿÿÿue¸ÿÿÿÿ[^_ÉÃ=à\|ÿ3hğ:hôènÿÿÄGÿ};t(hlèrüÿÿYhDoh8oèæ  Ä¸ÿÿÿÿ[^_ÉÃjèQÿÿYj jVèöÿÿÄÀu=à\|hToh;hôèÿÿÄ3À[^_ÉÃUìUR:/u¸Xoë¸\oPh$;hlèÿÿÄhählèøÿÿÄÀt
¸ÿÿÿÿÉÃÿ5èuøÿÿYPÿ5èTøÿÿYPÿ5äèGøÿÿYPhdoh,;hlè±ÿÿÄhlè,ùÿÿYÉÃUìhäÿuèÌ÷ÿÿÄÀuPÿ5èøÿÿYPÿ5èñ÷ÿÿYPÿ5äèä÷ÿÿYPhxohD;hlèNÿÿÄhlèÉøÿÿY=ÿÿÿÿu	¸ÿÿÿÿÉÃj jÿuè´ÿÿÄÉÃUìhäÿuèH÷ÿÿÄÀuIÿ5è÷ÿÿYPÿ5èm÷ÿÿYPÿ5äè`÷ÿÿYPhoh\;hlèÊÿÿÄhlèúÿÿYj j ÿuè@ÿÿÄÉÃÿt$ÿt$jèYÿÿÄÃÿt$ÿt$jèUÿÿÄÃÿt$ÿt$jèQÿÿÄÃÿt$ÿt$ÿt$jèIÿÿÄÃº   ÿt$ÿt$RèAÿÿÄÃº   ÿt$Rè=ÿÿÄÃº   ÿt$Rè9ÿÿÄÃÿt$è;ÿÿYÃè£ÿÿÀuèJÿÿPèTÿÿYÿt$è   YÃUììdj è«ÿÿYjè£ÿÿYjèÿÿYj ht;èÿÿÄjh;èÿÿÿÄjh;èğÿÿÄjjèÿÿÄjjèÿÿÄjjèüÿÿÄè  E ÀtCÿuh;EPèZÿÿÄÿ5¨«j EPh oh¸;h ;èçÿÿÄjdèİÿÿYÉÃÆE ëËUììdUÒtÂ ÀtRhÀ;EPèüÿÿÄëÆE èÿÿÀ    j è¬ÿÿYjè¤ÿÿYjèÿÿYjhÈ;èÿÿÄjhÔ;è ÿÿÄjhà;èñÿÿÄjjèÿÿÄjjè	ÿÿÄjjèıÿÿÄè  èÀÿÿPèÊÿÿYÿ5¨«j EPh <hì;èşÿÿÄjdèÿÿYÉÃÿt$ÿt$jèñÿÿÄÃÿt$ÿt$jèíÿÿÄÃÿt$ÿt$jèéÿÿÄÃÿt$ÿt$ÿt$jèáÿÿÄÃº   ÿt$ÿt$RèÙÿÿÄÃº   ÿt$RèÕÿÿÄÃº   ÿt$RèÑÿÿÄÃÿt$èÓÿÿYÃUìV5ô^ £Àt==à³ u
èÿÿ£à³> tNjj/hlè×ÿÿÄ£¼¯Àt¡¼¯@ë^ÉÃ¸lPh£èÜÿÿÄÀtÿ6èNÿÿYÇ    > uSh£h¸«h<hlè	ÿÿÄh<hlè×ÿÿÄh¤  hlè£ÿÿÄ> tj ÿ6è2ÿÿÄjj ÿ6èÿÿÄh]h£h´h<ÿ6èfÿÿÄÿ5Ü³ÿ5à³èâßÿÿPh <ÿ6èEÿÿÄÿuÿuh0<ÿ6è0ÿÿÄ^ÉÃUìì  ÿuhX£ÿ5Ü³èlÿÿP¾Ä¯PèßÿÿP= _ u¸¤oë¸¨oPh´h£h<<üûÿÿPèÿÿÄ,üûÿÿPè¬ÿÿYEü=ü^ }YÇ¬«    jh`<è)ÿÿÄ£ü^=¬«u)h¤  h|<èùÿÿÄ£ü^h¤  h<èbÿÿÄ=ü^ |*jj ÿ5ü^ègÿÿÄÿuüüûÿÿPÿ5ü^èïÿÿÄÉÃUìì   WVSu]=ø^ }YÇ¬«    j	h´<èÿÿÄ£ø^=¬«u)h¤  hĞ<èWÿÿÄ£ø^h¤  hì<èÀÿÿÄ=ø^ |è?ŞÿÿPh´h= üÿÿë;[^_ÉÃ üÿÿPèxÿÿYøö~	¸    ë¸
   Pÿ3Ãh== üÿÿPèÿÿÄÆNÀ½ üÿÿPè5ÿÿYP üÿÿPÿ5ø^èñÿÿÄ[^_ÉÃ=ü^ |ÿ5ü^è$ÿÿYÇü^ÿÿÿÿ=ô^ tÿ5ô^èUÿÿYÇô^    =ø^ |ÿ5ø^èæÿÿYÇø^ÿÿÿÿÃUììWV=l uEğPèŞÿÿY£l3öë(EğPèËÿÿYø+liÀè  ¹d   ÷ùğ=lÆ^_ÉÃÿt$ÿt$jèeÿÿÄÃÿt$ÿt$jèaÿÿÄÃÿt$ÿt$jè]ÿÿÄÃÿt$ÿt$ÿt$jèUÿÿÄÃº   ÿt$ÿt$RèMÿÿÄÃº   ÿt$RèIÿÿÄÃº   ÿt$RèEÿÿÄÃÿt$èGÿÿYÃUììWVuVèÿÿYøÿu3À^_ÉÃ? tæ
.tàjG
PÿuèkÿÿÄEÆ@ ¸   ^_ÉÃUìì@WVSu}]WVèÿÿÿÄÀu3À[^_ÉÃWSh=EÀPèÿÿÄ=à\|EÀPh$=hôè1ÿÿÄhĞ¢EÀPè¬şÿÿÄÀu£¡ä¢% ğ  = @  u¸   [^_ÉÃÿt$ÿt$jèí}ÿÿÄÃÿt$ÿt$jèé}ÿÿÄÃÿt$ÿt$jèå}ÿÿÄÃÿt$ÿt$ÿt$jèİ}ÿÿÄÃº   ÿt$ÿt$RèÕ}ÿÿÄÃº   ÿt$RèÑ}ÿÿÄÃº   ÿt$RèÍ}ÿÿÄÃÿt$èÏ}ÿÿYÃUìì  WVS]Çûÿÿ    Æûÿÿ ûÿÿPè ÿÿY3öÿuh¬oh0= üÿÿPèT~ÿÿÄh8= üÿÿPè ÿÿÄøÿtbWjdûÿÿPèÿÿÄÀt?jûÿÿPûÿÿPèÌ¹ÿÿÄ=   u ÿµûÿÿèÇ}ÿÿYğÿµûÿÿèÉÿÿYûÿÿö3öWèö}ÿÿYE=   w'ÿ$°(ş~T[^_ÉÃ3Û3öëG»pC 3öë<FÛu'½ûÿÿ,  |#ûÿÿûÿÿûpC ~»pC ëû,  }»,  h<= üÿÿPè:~ÿÿÄøÿu*jchÀoÿ5¬« üÿÿPÿ5 ]èbØÿÿÄjÿèè¡ÿÿYh¶   üÿÿPèÖ}ÿÿÄÿuÿuSÿµûÿÿVÿuh@=Wè·|ÿÿÄ Wè}ÿÿY[^_ÉÃUìì|  WÿuhÌohX=ğûÿÿPèÅ|ÿÿÄh`=ğûÿÿPè}ÿÿÄøÿÈ   WjdûÿÿPè~ÿÿÄÀuWè¨|ÿÿYğûÿÿPè{}ÿÿY3À_ÉÃWè|ÿÿYûÿÿPè~ÿÿYEøPûÿÿPEôPEğPhd=ûÿÿPèLÿÿÄUğBû=   wPÿ$)ûÿÿ+ûÿÿ;Eø}7høohàoèd÷ÿÿÄ=à\|ÿuøhp=hôè¦{ÿÿÄEğ_ÉÃ3À_ÉÃÿt$ÿt$jèzÿÿÄÃÿt$ÿt$jèzÿÿÄÃÿt$ÿt$jè}zÿÿÄÃÿt$ÿt$ÿt$jèuzÿÿÄÃº   ÿt$ÿt$RèmzÿÿÄÃº   ÿt$RèizÿÿÄÃº   ÿt$RèezÿÿÄÃÿt$ègzÿÿYÃè«  ÿt$èö   YÃÿt$ÿt$èw  ÄÃUìUìBÿ=      ÿ$L)j¡pÿ4_ÿÑÄÉÃj¡tÿ4`ÿÑÄÉÃj¡xÿ4aÿÑÄÉÃj¡pÿ4_èí  ÄÉÃj¡tÿ4`èÕ  ÄÉÃj¡xÿ4aè½  ÄÉÃRh=h|èLzÿÿÄh ph|èõÿÿÄ¸ÿÿÿÿÉÃUìì   WVS]Ça    ¡a£`£_h¸=h¤=èÙzÿÿÄğötRë5h¼= üÿÿPèû}ÿÿÄøSWhpèv  ÄÀt
èò  è=   üÿÿPVèø  ÄÀ¹Vè¿yÿÿY=_ uIhpè»  Y£_=_ u&h   hLpj h8ph,pèqÔÿÿÄjÿèÿÿYÇ_    =` uIhXpèi  Y£`=` u&h   hpj hxphlpèÔÿÿÄjÿèÅÿÿYÇ`    =a uIhpè  Y£a=a u&h¢   hÌpj h¸ph¬pèÍÓÿÿÄjÿèsÿÿYÇa    [^_ÉÃUìì   WVS]Ç|    ¡|£Çc    ¡c£bÇ¸¯   ÇÈ¯-   Ç°<   hÔ=hÀ=èyÿÿÄğötwëZhØ= üÿÿPè?|ÿÿÄøSWhØpèº   ÄÀt0hÜ=j è|ÿÿÄøÿuWhäpè   ÄÀt
è  è[   üÿÿPVè   ÄÀVèİwÿÿY[^_ÉÃUìWVS]óë,VèNwÿÿYÆø;şt5ÿ
u/OÆ ;ût÷ÿ\uÆGÿ ÿuÃ+Æ   PVè×xÿÿÄÀu¼Æ+Ã[^_ÉÃUìWVS}]ÿuèğvÿÿYPWÿuèÕwÿÿÄÀuÿuèÖvÿÿYøÀu3À[^_ÉÃÆ SWèªvÿÿÄÀt"~j:Wè¨xÿÿÄğöuÛSWèvÿÿÄÀu¸   [^_ÉÃ3À[^_ÉÃWV5Çë8-¹   ÷ù=   }hà=j è³zÿÿÄøÿuÎÇ     ^_ÃUìPWVS¿é¼  j=ÿ7èxÿÿÄğö   Æ FÀ  hä=ÿ7èØuÿÿÄÀuVh_è  Äél  hì=ÿ7è°uÿÿÄÀuVh`èv  ÄéD  hô=ÿ7èuÿÿÄÀuVhaèN  Äé  hü=ÿ7è`uÿÿÄÀuVhbè
  Äéô   h >ÿ7è8uÿÿÄÀuVhcèâ  ÄéÌ   h>ÿ7èuÿÿÄÀu)Vè3uÿÿYØÀÇ¸¯   é   ¸¯é   h>ÿ7èÔtÿÿÄÀu!Vè÷tÿÿYØÀÇÈ¯-   ëbÈ¯ëZh >ÿ7è tÿÿÄÀu!VèÃtÿÿYØÀÇ°<   ë.°ë&ÿ7h(>h|èÇtÿÿÄhìph|èğÿÿÄÇÇ-¹   ÷ù=   }	? (şÿÿ[^_ÉÃUìì   WVSUÜÂ Àt}ë[^_ÉÃÇ? uøh@>Ré   Æ üÿÿ >/th qhD> üÿÿPè&tÿÿÄV üÿÿPètÿÿÄj üÿÿPèa	  ÄÀu= üÿÿPè"	  Y? u&hi  h(qj hqhqèßÎÿÿÄjÿèÿÿYÇhH>j ÿÓÄğöcÿÿÿ[^_ÉÃUìWVSUÜÂ Àt}ë[^_ÉÃÇ? uøhL>Rë>Vè  Y? u&h  hPqj h@qh4qèWÎÿÿÄjÿèıÿÿYÇhP>j ÿÓÄğöu·[^_ÉÃ=È tÿ5Èè,sÿÿYÇÈ    Çp    è   Ã=Ì tÿ5ÌèürÿÿYÇÌ    Çt    è   Ã=Ğ tÿ5ĞèÌrÿÿYÇĞ    Çx    ÃUìWVSÈ}u=_ uh\qèë  ÿuğè7øÿÿYY=Ì tÿ5ÌèqrÿÿYÇÌ    Çt    èwÿÿÿ; u2èA   Àu)3À[^_ÉÃ?#t? t?	t?
t¸   [^_ÉÃÿ3VWègsÿÿÄÀuĞë¼UìWV=È5p=Ì tÿ5ÌèçqÿÿYÇÌ    Çt    èíşÿÿ? tÿ7èÁqÿÿYÿë2Ç    ë*hT>ÿ4_èarÿÿÄÀt¸   ^_ÉÃÿ<_ uÊ3À^_ÉÃUìWVSÌ}u=` uhdqè¯  ÿuğèûöÿÿYY; uè'   Àu3À[^_ÉÃÿ3VWè{rÿÿÄÀtà¸   [^_ÉÃUìWV=Ì5t? tÿ7èûpÿÿYÿë4Ç    ë*hX>ÿ4`èqÿÿÄÀt¸   ^_ÉÃÿ<` uÊ3À^_ÉÃUìWVSĞ}u=a uhlqèç  ÿuğè3öÿÿYY; uè'   Àu3À[^_ÉÃÿ3VWè³qÿÿÄÀtà¸   [^_ÉÃUìWV=Ğ5x? tÿ7è3pÿÿYÿë4Ç    ë*h\>ÿ4aèÑpÿÿÄÀt¸   ^_ÉÃÿ<a uÊ3À^_ÉÃUìPWVu=b t¡<b u3À^_ÉÃ¡ÿ4bè?oÿÿYHø¡b8(uB¡b<8)u0EÇ    ;ş}ÇëÆğV¡ÿb@PëEÇ     V¡ÿÿ4bÿuè¤nÿÿÄEÆD0ÿ ¸   ^_ÉÃ|=c t<c u3ÀÃÿt$ÿÿ4cÿt$èXnÿÿÄ¸   ÃUììWVS5à\|}é  >|#EøP}ì t	¸tqë¸qPhôÿÓÄEğPhS  WèrÿÿÄ=ÿÿÿÿug>|Wh`>hôÿÓÄ>%  ÿ5¬«h>hôÿÓÄé  }ì    >õ   EøPh>hôÿÓÄéİ   EğPEøPèmÿÿÄÀuÀj hS  WèrÿÿÄ=ÿÿÿÿu5>|Wh°>hôÿÓÄ>   ÿ5¬«hÔ>hôÿÓÄë|EìPjEøPè½ıÿÿÄÀŞşÿÿëh>|EøPhà>hôÿÓÄEøPhS  WèqÿÿÄ=ÿÿÿÿu7>|Whø>hôÿÓÄ>|ÿ5¬«h?hôÿÓÄ3À[^_ÉÃjEøP|=c t<c u3Àë ÿuÜÿÿ4cÿuØèelÿÿÄ¸   ëŞÄÀHÿÿÿ¸   [^_ÉÃ¡p_Ã¡t`Ã¡xaÃUìì   WVSà\h<?h(?èCmÿÿÄğöŞ   éÁ   h@? üÿÿPè_pÿÿÄøÿ¢   ?#   hP?èÏkÿÿYPWhD?è²lÿÿÄÀuch\?è±kÿÿYøÀth ´\Àt4;|Whh?hôèkÿÿÄ;|h´\h|?hôè~kÿÿÄWh´\è kÿÿÄë;|Wh?hôèSkÿÿÄ üÿÿPVèÏóÿÿÄÀ(ÿÿÿ[^_ÉÃÿt$ÿt$jè!jÿÿÄÃÿt$ÿt$jèjÿÿÄÃÿt$ÿt$jèjÿÿÄÃÿt$ÿt$ÿt$jèjÿÿÄÃº   ÿt$ÿt$Rè	jÿÿÄÃº   ÿt$RèjÿÿÄÃº   ÿt$RèjÿÿÄÃÿt$èjÿÿYÃWÿt$èvjÿÿY@PèNlÿÿYøÿtÿt$WèjÿÿÄÇ_ÃUìì   xÿÿÿPÿuèÿÿÿÄ=ÿÿÿÿu
¸ÿÿÿÿÉÃe   è¼iÿÿĞÀt';Uu	Ámëènÿÿ;EuÁmE#E;Eu3ÀÉÃÇ¬«   ¸ÿÿÿÿÉÃÂ             @      0AøøøàààààĞè 0H°?¸?Ä?à?ğ?@@0@D@X@h@|@@¤@¸@Ä@Ü@è@ô@AA(A8ALA`AtAAA¨AÀAĞAèAøABB0BLB`B|BB¨B¸BÔBôBC CDC`ClCxCCC´CÈCàCôCDD4D@DLD`DtDDD¼DÔDèD EE E<ELEXEdExEEE¤E¸EàEüEF4F\FF¤FäFGG4GGG G´GÄGäGHH8H\HhHtHHHH¤H°H¼HÈHÔHàHìHøHIII(I4I@ILIdII°IĞI JJ8JHJ`JJ°JÌJèJK4KPK\KlK|KK K¸KÄKèKL$L8LHL\L|LL   /var/uucp/.Log/uux  uux default -   %s
%s
  a:bcCjg:nprs:x:z    

** %s **
 arg - %s:       arg - %s
   %s/%s   %s  dummy   /var/uucp/.Workspace    No spool directory - %s - get help
 xsys %s
    bad system name: %s
    User %s
    cfile = %s
 w   rxfile = %s
    w   %c %s %s
   %c return status on success
    %c
 %c don't return status on failure
  %c
 %c return status on failure
    %c
 %c return input on abnormal exit
   %c
 %c %s
  %c return address for status or input return
   %c %s
  w   S %s %s %s -%s %s 0666 %s %s
   %c %s
  %c %s
  prm - %s
   2>      syspart -> %s,  rest -> %s,     ret -> %d
      syspart -> %s
  bad system name: %s
    %c %s %s
       %c %s
      rest %s
    can't get file status %s
   permission denied %s
   can't copy %s
  S %s %s %s -%s %s 0666 %s %s
   S %s %s %s -%s %s 0666 %s %s
   %c %s
  %c %s
      %c %s %s
   a   R %s %s %s - %s 0666 %s %s
 %c %s/%s/%s
    %c %s
  %c %s/%s/%s %s
     a   R %s %s %s - %s 0666 %s %s
 w   %c %s/%s/%s %s
 %c uucp -C %s %s!%s
    %c %s
  %c %s
  %c %s %s
       %c %s
      %c %s
  X.%s    S %s %s %s -%s %s 0666 %s %s
   %s
 uux failed ( %d )
  exit code %d
   XSIGNAL %d  Usage:  %s [-aNAME] [-b] [-c] [-C] [-j] [-gGRADE] [-n] [-p] \
	[-r] [-sFILE] [-xNUM] [-z] command-string
   ;&|<>^`\('"{}
  %s mail '%s'    w   
%s
    r   
	===== stderr was =====
   
	===== well, i tried =====
    
	===== stdin was   empty =====
    denied read permission =====
   user %s, stdin %s   r   unreadable =====
   user %s, stdin %s   =====
  
	===== well, i tried =====
    LOGNAME LOGNAME LOGNAME=%s  %s pwd 2>&- r   logFind called (name: %s,   rmtname: %s)
   machine/login match failed%s    _Request (%s),  _Switch (%s),   _CallBack (%s),     _MyName (%s),   _NoSpool (%s),  mchFind called (%s)
    _Request (%s),  _Switch (%s),   _CallBack (%s),     _MyName (%s),   _NoSpool (%s),  _Commands %s
   yes yes yes yes list (%s)   num = %d
   rmail   /etc/uucp/Permissions   r   can't open %s
  name (%s) not found; return FAIL
   /etc/uucp/Permissions   r   can't open %s
  validateFind (%s) FAIL
 cmdOK(%s, )
    ALL bname=%s
   NuLL    uux  	  %c.%.*s%c%.4x   User job queued to %c queue
    /%c create remote spool area %s
    create service grade directory %s under remote spool
   create remote spool area %s
    commit %s   %s/%s   to %s
  User (%s)
  Any Members of administrator defined service grade (%s)
    %s
 default /etc/uucp/Grades    r   %s (%ld bytes) %s (%ld bytes) %s (%s).
%s
  /etc/uucp/Grades    r   default r   Any Error encountered in the restrictions field of the Grades file. Field contents (%s).    %s %s %s    w   
%s
    r   user    non-user    group   non-group   Error encountered in action field of the Grades file. Field contents (%s).  default /etc/uucp/Grades    r   %s (%s).
 %s
%s
    %s (%s) %s
%s
  r   Removing data file (%s)
    Removing work file (%s)
    %s.%.*s.%s  chdir(%s)
  %s/%s   /var/uucp/.Admin/errors a   /var/uucp/.Admin/errors %sERROR (%.9s)  pid: %ld (%s) %s %s (%d) [FILE: %s, LINE: %d]
   %sERROR %.100s %.100s (%.9s)   %d/%d-%d:%2.2d:%2.2d    %s/%s   /   file name is %s
    .TM.XXXXXX  temp name is %s
    open of file returned errno %d
 using file name directly.%s
    rename failed: errno %d
    %s/%s   /   %s/%s/  %s/%s   /var/uucp/.Corrupt  /   mkdir - %s
 Illegal filename (%s).
 ./  .   ../ ..  gename(%c,  %s,     %c)
    null sys -> %s
 %c.%.*s%c%.4x   %c.%.5s%.4x%.3x file - %s
  %s%s    %s/%s   r   %4x w   w   %.4x
   %s seq  now %x
 %*ld
   %s/LTMP.%ld ulockf failed in onelock()
%s   ulockf name %s
 Lock File--can't read (errno %d) --remove it!
  Lock File--bad format--remove it!
%s    Lock File--process still active--not removed
%s kill pid (%ld),     returned %d --ok to remove lock file (%s)
  ulockf failed in unlink()
%s    %s.%s   %s.%s   %s %s %d    %s:     link(%s,    %s)
    ULK err %s %d   %s %d   %s.%3.3lu.%3.3lu.%3.3lu fd_mklock: lockf returns %d
    fd_mklock: ok
%s    %s%s    %s.%3.3lu.%3.3lu.%3.3lu %s.%3.3lu.%3.3lu.%3.3lu %s.%3.3lu.%3.3lu.%3.3lu /dev/null   /dev/null   /dev/null   -s%s    /usr/lib/uucp/uucico    UUCICO  -s%s    /dev/null   /dev/null   /dev/null   /usr/lib/uucp/uuxqt UUXQT   %s/%s   a   %s %s %s    (%s,%ld,%d)     %s (%s)
    %s!%s %s (%s) (%c,%ld,%d) [%s] %s
  /var/uucp/.Admin/xferstats  /var/uucp/.Admin/xferstats  /var/uucp/.Admin/xferstats  /var/uucp/.Admin/command    /var/uucp/.Admin/command    /var/uucp/.Admin/command    %s (%s)     %s%c    %s/%s   stat %s
    %s/%s   r   w   %d %d %ld %ld %s %s
    %s/%s   r   %d%d%ld%ld  RETRY TIME (%ld) NOT REACHED
   bad access type %d  /etc/uucp/Sysfiles  r    	  /etc/uucp/Devconfig r    	   	   	  systems devices dialers pop push    connecttime expecttime  msgtime unrecognized label %s   :   %s/ :   :   :   r   r   r   pop_push: I_LOOK on fd %d failed    errno %d
   pop_push: I_POP: %s not there
  pop_push: I_POP on fd %d failed     errno %d
   pop_push: PUSHing %s
   pop_push: I_PUSH on fd %d failed    errno %d
   /etc/uucp/Config    r    	  Protocol=   Protocol=   Protocol=   Protocol string %s  overrides %s
   Unknown configuration parameter %s
 Error 0 Not owner   No such file or directory   No such process Interrupted system call I/O error   No such device or address   Arg list too long   Exec format error   Bad file number No child processes  No more processes   Not enough space    Permission denied   Bad address Block device required   Device busy File exists Cross-device link   No such device  Not a directory Is a directory  Invalid argument    File table overflow Too many open files Not a typewriter    Text file busy  File too large  No space left on device Illegal seek    Read-only file system   Too many links  Broken pipe Argument out of domain  Result too large    No message of desired type  Identifier removed  Channel number out of range Level 2 not synchronized    Level 3 halted  Level 3 reset   Link number out of range    Protocol driver not attached    No CSI structure available  Level 2 halted  Deadlock situation detected/avoided No record locks available   Error 47    Error 48    Error 49    Bad exchange descriptor Bad request descriptor  Message tables full Anode table overflow    Bad request code    Invalid slot    File locking deadlock   Bad font file format    Error 58    Error 59    Not a stream device No data available   Timer expired   Out of stream resources Machine is not on the network   Package not installed   Object is remote    Link has been severed   Advertise error Srmount error   Communication error on send Protocol error  Error 72    Error 73    Multihop attempted  Error 75    Error 76    Not a data message  File name too long  Value too large for defined data type   Name not unique on network  File descriptor in bad state    Remote address changed  Can not access a needed shared library  Accessing a corrupted shared library    .lib section in a.out corrupted Attempting to link in more shared libraries than system limit   Can not exec a shared library directly  Error 88    Operation not applicable    Number of symbolic links encountered during path name traversal exceeds MAXSYMLINKS Error 91    Error 92    Directory not empty Too many users  Socket operation on non-socket  Destination address required    Message too long    Protocol wrong type for socket  Option not supported by protocol    Error 100   Error 101   Error 102   Error 103   Error 104   Error 105   Error 106   Error 107   Error 108   Error 109   Error 110   Error 111   Error 112   Error 113   Error 114   Error 115   Error 116   Error 117   Error 118   Error 119   Protocol not supported  Socket type not supported   Operation not supported on transport endpoint   Protocol family not supported   Address family not supported by protocol family Address already in use  Cannot assign requested address Network is down Network is unreachable  Network dropped connection because of reset Software caused connection abort    Connection reset by peer    No buffer space available   Transport endpoint is already connected Transport endpoint is not connected Structure needs cleaning    Error 136   Not a name file Not available   Is a name file  Remote I/O error    Reserved for future use Error 142   Cannot send after socket shutdown   Too many references: cannot splice  Connection timed out    Connection refused  Host is down    No route to host    Operation already in progress   Operation now in progress   Stale NFS file handle                                                                   Z               d(d                        @dLdXdddtdddd¨d´dÀdÌdÜdèdeee(e8eDe\epexee e°e¼eÜeìeüef,f<fPfdfff¸fØfèf gNo administrator defined service grades available on this machine. UUCP service grades range from [A-Z][a-z] only.  °h    ¸h   Àh   Ìh   Ôh   àh   èh   ğh   øh    i	   i
   i    i   (i               ÄjÈj kk\khkk¨kÈkØkl                        ÿÿÿÿÿÿÿÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /var/spool/uucp /var/spool/uucppublic   CAN'T OPEN  CAN'T WRITE CAN'T READ  CAN'T CREATE    CAN'T ALLOCATE  CAN'T LOCK  CAN'T STAT  CAN'T CHOWN CAN'T CHMOD CAN'T LINK  CAN'T CHDIR CAN'T UNLINK    WRONG ROLE  CAN'T MOVE TO CORRUPTDIR    CAN'T CLOSE CAN'T FORK  FILE EXISTS BAD OWNER/PERMS SUCCESSFUL  NO DEVICES AVAILABLE    WRONG TIME TO CALL  TALKING CONVERSATION FAILED BAD SEQUENCE CHECK  LOGIN FAILED    DIAL FAILED BAD LOGIN/MACHINE COMBINATION   DEVICE LOCKED   ASSERT ERROR    SYSTEM NOT IN Systems FILE  CAN'T ACCESS DEVICE DEVICE FAILED   WRONG MACHINE NAME  CALLBACK REQUIRED   REMOTE HAS A LCK FILE FOR ME    REMOTE DOES NOT KNOW ME REMOTE REJECT AFTER LOGIN   REMOTE REJECT, UNKNOWN MESSAGE  STARTUP FAILED  CALLER SCRIPT FAILED    CALLBACK REQUIRED - LOOP    /etc/uucp/Grades    -   -p  START   /var/uucp/.Workspace    uux.c   uux.c   uux.c   uux.c   uux.c   uux.c   uux.c   uux.c   o           uux.c   2>  uux.c   uux.c   o           uux.c   o           uux.c   uux.c   uux.c       uux.c   uux.c   uux.c   uux.c       uux.c   uux.c   uux.c   uux.c   uux.c   uux.c   QUEUED  o           uux.c   uux.c   XCAUGHT PATH=/usr/bin   DENIED  UNREADABLE  PATH=/usr/bin   LOGNAME MACHINE CALLBACK    REQUEST SENDFILES   READ    WRITE   NOREAD  NOWRITE MYNAME  COMMANDS    VALIDATE    PUBDIR  DIRECT          TRUE    FALSE   TRUE    FALSE   TRUE    FALSE   TRUE    FALSE       OTHER       TRUE    FALSE   TRUE    FALSE   TRUE    FALSE   TRUE    FALSE   yes yes yes yes permission.c    /var/spool/uucppublic   /var/spool/uucppublic   /etc/uucp/Permissions   /   /etc/uucp/Permissions   PERMISSIONS file: BAD OPTION--  permission.c    ALL uux TOO MANY SAVED C FILES      gtcfile.c   gtcfile.c   gtcfile.c       User does not have permission to use this service grade Job has not been queued.    Use (uuglist) to find which service grades you can queue to.    Job size    exceeds maximum number of bytes allowed into this service grade Job queued to default grade.    service grade   does not exist on this machine. Job not queued. Use (uuglist) to find which service grades are available on this machine.   Any grades.c    BAD NUMBER OF ARGUMENTS grades.c    grades.c    Any PATH=/usr/bin   mail    uucp    grades.c    BAD NUMBER OF ARGUMENTS grades.c    user    non-user    group   non-group   default grades.c    BAD NUMBER OF ARGUMENTS grades.c    grades.c    grades.c    grades.c    /var/spool/locks/LCK.   grades.c    chremdir.c  /var/spool/uucp ASSERT      ASSERT      No file name in utility.c   utility.c       /var/uucp/.Corrupt  cpmv.c  .   ..  SYSLST OVERFLOW     gename.c    /var/spool/locks/LCK.SQ.    gename.c    /var/uucp/.Sequence gename.c    gename.c    gename.c    gename.c    /var/spool/locks                    TOO MANY LOCKS      ulockf.c    CAN NOT ALLOCATE FOR    ulockf.c    ULOCKC  ULOCKLNK    ULOCKF  /var/spool/locks/LK fd_mklock   lockf failed            /dev/   /var/spool/locks/LK /var/spool/locks/LK /var/spool/locks/LK -r1 S   M   /var/uucp/.Status   systat.c    /var/uucp/.Status   RETRY TIME NOT REACHED  NO CALL sysaccess   service=    /etc/uucp/Systems   Ct_ALLOCATE scansys: Systems    sysfiles.c  /etc/uucp/Devices   Ct_ALLOCATE scansys: Devices    sysfiles.c  /etc/uucp/Dialers   Ct_ALLOCATE scansys: Dialers    sysfiles.c  service=    device= Sysfiles|Devconfig  /etc/uucp   Ct_ALLOCATE setfile: tptr   sysfiles.c  Ct_ALLOCATE setioctl: tptr  sysfiles.c  uucico  uucico  uucico  pop_push: optionally POPing %s
 pop_push: POPing %s
    ,s        BRbr¢²ÂÒâò"2BRbr¢²ÂÒâò"2BRbr¢²ÂÒâò"2BRbr¢²ÂÒâò"2BRbr¢²ÂÒâò"2BRbr¢²ÂÒâò        (   (   è       0
                      ¬q   è           @         .interp .hash .dynsym .dynstr .rel.plt .init .plt .text .fini .rodata .rodata1 .data .data1 .got .dynamic .bss .shstrtab .comment  @(#)/usr/bin/uux.sl 1.1 4.0 10/01/90 43615 AT&T-SF                                                   ÔÔ                     	         èè   H                        00  ğ                                                	      @@  è              (         ((                    .         ,,  à                3                            9         (¨                    ?         (¨  ,                 G         È+È«  æ                  P         °\°Ì  h                 V         dÔ                   ]         ¬q¬á                  b         ,s,ã  p                k         sã  Ç@                 p              ã                    z              ä  4                  07070100001c6f0000816d0000000000000002000000012719347c00000840000000230000000c00000000000000000000000d00000000usr/bin/x286  ELF              4   p      4    (      4   4                      Ô                            4   4    |  |           °  °                 P  P    p              /usr/lib/libc.so.1                                                   	   
                         À      
   À     ñÿ   ´        °     ñÿ   Ğ@      &   À     ñÿ-   ğ       2   ¬    
 ?   à       I   0     ñÿ_          f   P     ñÿ _cleanup _end _environ _etext atexit _edata exit _lib_version __fpstart _GLOBAL_OFFSET_TABLE_ printf _DYNAMIC /usr/lib/libc.so.1   <  @  D	  H  L  Â   ÿ54ÿ%8    ÿ%<h    éàÿÿÿÿ%@h   éĞÿÿÿÿ%Dh   éÀÿÿÿÿ%Hh   é°ÿÿÿÿ%Lh    é ÿÿÿj j ìR¸ÀÀthÀè¦ÿÿÿÄ¸PÀtèÿÿÿh¨èÿÿÿET´RURPèOÿÿÿè~ÿÿÿè   ÄPèÿÿÿj ¸        ôÃD$ÿ0h¸èpÿÿÿÄhèècÿÿÿYjèKÿÿÿYÃÂ               The "%s" executable is a XENIX 286 executable.
 Please load the "XENIX Compatibility Package" to run this executable.
  P        ÆÖæö   o      ¬   ¨   è       0
                      0   (                     .interp .hash .dynsym .dynstr .rel.plt .init .plt .text .fini .rodata .data .data1 .got .dynamic .bss .shstrtab .comment  @(#)/usr/bin/x286.sl 1.1 4.0 10/01/90 20127 AT&T-SF                                                   ÔÔ                     	         èè   H                         00  Ğ                                                 	        (               (         ¬¬                    .         °°  `                 3                             9         ¨¨                    ?         ¬¬                    G         °°                    M         ¸¸  w                  T         00                    Y         PP  p                b         ÀÀ                     g              À  z                  q              :  5                  07070100001bdf0000816d0000000200000002000000012719347c00001a38000000230000000c00000000000000000000000e00000000usr/bin/xargs ELF              <4   @      4    (      4   4                      Ô                            4   4                 È  È£    ¼  _             ¦    p              /usr/lib/libc.so.1                                                         
                                                                      	                                      Ä        Ì          ü          L         (²     ñÿ           %   4¤     .   Ô      3   Å     ñÿ:   \@      A   ¦     ñÿH   |       M   ¬       S   ì       Z   Ü       a   P    
 n   ¼       u   ,       z   l          Ì¥     ñÿ   H      ¢   ¦     ñÿ execvp open read _cleanup _end fork _environ atoi _etext atexit _edata exit write strcmp strcpy _lib_version strlen wait __fpstart _GLOBAL_OFFSET_TABLE_ sprintf _DYNAMIC /usr/lib/libc.so.1   Ø¥  Ü¥
  à¥  ä¥  è¥  ì¥  ğ¥  ô¥  ø¥  ü¥   ¦  ¦  ¦  ¦  ¦  Â   ÿ5Ğ¥ÿ%Ô¥    ÿ%Ø¥h    éàÿÿÿÿ%Ü¥h   éĞÿÿÿÿ%à¥h   éÀÿÿÿÿ%ä¥h   é°ÿÿÿÿ%è¥h    é ÿÿÿÿ%ì¥h(   éÿÿÿÿ%ğ¥h0   éÿÿÿÿ%ô¥h8   épÿÿÿÿ%ø¥h@   é`ÿÿÿÿ%ü¥hH   éPÿÿÿÿ% ¦hP   é@ÿÿÿÿ%¦hX   é0ÿÿÿÿ%¦h`   é ÿÿÿÿ%¦hh   éÿÿÿÿ%¦hp   é ÿÿÿj j ìR¸LÀthLèÿÿÿÄ¸¦ÀtèõşÿÿhLèëşÿÿET4¤RURPè¯şÿÿèŞşÿÿè   ÄPèàşÿÿj ¸        ôÃUììWVS]ÿMÇEè    ¿§Ãéë  Ç¤   ¡¤£ô£éË  Ç¤   ¡¤£ü£Çè£    Ç¤    Eğ8   ÿuğèdşÿÿY£ü£À~  ÿ3hD¤h°©èUşÿÿÄh°©jh°jèOşÿÿÄÿuØèTşÿÿYPÿuØjè8şÿÿÄÇ¤    Yé-  Ç¤   ¡¤£ü££¤Çè£    Eğ8 ı  £Ü£éó  Ç¤   éá  Eğ£Ø£éÓ  ÿuğè ıÿÿY£ä£=ä£Ö  =ä£ ©  ÿ3hh¤h°©èıÿÿÄh°©jh°jèzıÿÿÄÿuØèıÿÿYPÿuØjècıÿÿÄÇ¤    YéX  ÿuğè$ıÿÿY£è£ÀRÿ3h¤h°©èıÿÿÄh°©jh°jèıÿÿÄÿuØèıÿÿYPÿuØjèüüÿÿÄÇ¤    Yéñ   =ô£ u	=è£u
¸   ë3À£¤Çü£    ¡ü££¤é´   j h¤è¼üÿÿÄ£à£=ÿÿÿÿu=h¬¤jh°jèzüÿÿÄÿuØèüÿÿYPÿuØjècüÿÿÄÇ¤    Yë[Ç¤   ëLÿ3hÈ¤h°©è#üÿÿÄh°©jh°jèüÿÿÄÿuØè"üÿÿYPÿuØjèüÿÿÄÇ¤    YÃÿM} ~8-tA=¤ u
Ç ¤   } uLÇEüÜ¤ÿuüèù  YÔ£Ô£é÷   @Eğ¾ ÿEğ-e   =   Dÿÿÿÿ$TEüéÅ   =¤    = ¤    ÿ5Ü£ÿ3è	  Ä=ÿÿÿÿtxÿEèEè=   ~Zÿ5Ü£hì¤h°©èûÿÿÄh°©jh°jèûÿÿÄÿuØèûÿÿYPÿuØjèôúÿÿÄÇ¤    YÇ ¤   ¡Ô£ÇPÇÿ3Ãèı  YÔ£Ô£=¤ tEÿMÀ&ÿÿÿ¡Ì£Eø¡Ô£Eô¡¤Eìé  Eø£Ì£Eô£Ô£Eì£¤¡Ğ£8 tÿ5Ğ£è  YÔ£Ô£èª  Ô£Ô£Àt	=¤ uß= ¤ uJ=¤ tAÇ§°§-Ô£Ç¤    5¤¿§ëWè  Y= ¤ u	F;uè~ç¡Ô£Ç     = ¤ À   =ø£ u,=ü£ t	=ğ£ t=è£ t=ì£ uj èOùÿÿYÇ¤   =¤ tèR  ğë¾   ötdhì«ÿuüèş  Ä=ÿÿÿÿuMÿuüh¥h°©èùÿÿÄh°©jh°jèùÿÿÄÿuØèùÿÿYPÿuØjèùÿÿÄÇ¤    Y=¤ t=ø£ aşÿÿ=¤ tj ëjèøÿÿY[^_ÉÃUìPWV}¾   Wè¼øÿÿY@¤¡ä£9¤½   =Ğ£Ç¤    5¤=¤ tDÇ ¤   h$¥jh°jèWøÿÿÄÿuğè\øÿÿYPÿuğjè@øÿÿÄÇ¤    YëZ=ì£~Çì£   ëEh8¥jh°jèøÿÿÄÿuğè
øÿÿYPÿuğjèî÷ÿÿÄÇ¤    YÇ ¤   ötÇ^_ÉÃ3À^_ÉÃVt$Vÿ5Ì£èã÷ÿÿÄ5Ì£Vè´÷ÿÿY@Ì£VèÖşÿÿY^ÃUìPWVSè  Eÿ< tô}ÿ
tî}ÿ	tèEÿÀuÇø£    3À[^_ÉÃ=Ì£é  =¤ t¡Ì£ÿÌ£Uÿéo  ¡Ì£ÿÌ£Æ  ÿ5Ø£WèR÷ÿÿÄÀtEÿÀuÇø£    }ÿ
  é  ÿì£WèşÿÿYğöt`=ü£ t}ÿ
uÿğ£¡ğ£;ü£}=è£ t5¡è£9ì£|(Çì£    ¡ì££ğ£ÇĞ£l¥Ç¤    Æ[^_ÉÃèó  Ì£ÿÌ£é   Ûtû
uk¡Ì£ÿÌ£Æ  Whp¥h°©èöÿÿÄh°©jh°jèöÿÿÄÿuìèöÿÿYPÿuìjèüõÿÿÄÇ¤    YÇ ¤   3À[^_ÉÃ¡Ì£ÿÌ£èV  Ø:]ÿoÿÿÿèF  Eÿ¾EÿÀşÿÿ=	   Tşÿÿ=
   işÿÿ=    >şÿÿ="   t´='   t­=\   ÿÿÿé)şÿÿ}ÿ
tèé  EÿÀuî3À[^_ÉÃjh°jè>õÿÿÄÿt$èBõÿÿYPÿt$jè%õÿÿÄÇ¤    ÃUìPWVS¬¿è«ë ÿ7è	õÿÿYPÿ7jÿÓÄjh¸jÿÓÄ? uØ=à£ÿujh¼jÿÓÄ¸   [^_ÉÃjhÀjÿÓÄjEÿPÿ5à£èåôÿÿÄÀuj èWôÿÿY}ÿ
u3À[^_ÉÃjEşPÿ5à£è·ôÿÿÄğşu}ş
ußöuj èôÿÿY}ÿyu¸   [^_ÉÃ3À[^_ÉÃUììWVSÿuè/ôÿÿYEüÿ5Ü£è ôÿÿYHEøEHø¾¦»§ë:ÿ5Ü£Wè0  ÄÀuÆEü;Ãs#ÿuVèôÿÿÄ}øuüë	F;ósG? uÁ? uÆ ¸¦[^_ÉÃÿ5Ü£h¥h°©èóÿÿÄh°©jh°jèyóÿÿÄÿuèè~óÿÿYPÿuèjèbóÿÿÄÇ¤    YÇ ¤   3À[^_ÉÃUììWVSEp¡Ô£ EüVè1óÿÿY@)¤ÿuüVèàşÿÿÄøWèEúÿÿYÀ   WèóÿÿY@Ø¤¡¤=   ~Bh´¥jh°jèÍòÿÿÄÿuèèÒòÿÿYPÿuèjè¶òÿÿÄÇ¤    YÇ ¤   Wÿ5§èÂòÿÿÄE §§[^_ÉÃUìPjEÿPj è³òÿÿÄ=   u	¾EÿÉÃ3ÀÉÃUìPWVè¡òÿÿğ=ÿÿÿÿt`ÀuÿuÿuèòÿÿÄjÿèïñÿÿYëDEüPèòÿÿYø;ştÿÿuëÿÿt*Eü%ÿ   u¸   ë3ÀÀtEüÁø%ÿ   =ÿ   u¸ÿÿÿÿ^_ÉÃEüÁø%ÿ   ^_ÉÃUìPWVS}uë;ÇG8u1Ç+EHÈFFÇG:uÛuòÛu
Á[^_ÉÃE|u? uÃ¸ÿÿÿÿ[^_ÉÃÂ       Ôhhhhhìh`hhhäÄhhhĞ/dev/tty    xargs:      
   ?...        ì¯8¤ì«<¤@¤ÿÿÿÿÖ                                                    @(#)xargs:xargs.c	2.9           _   {}  #lines must be positive int: %s
    0 < max-cmd-line-size <= 470: %s
   #args must be positive int: %s
 can't read from tty for -p
 unknown option: %s
 /usr/bin/echo   too many args with %s
  %s not executed or returned -1
 arg list too long
  a single arg was greater than the max arglist size
     missing quote?: %s
 max arg size with insertion via %s's exceeded
  insert-buffer overflow
 ¦        Rbr¢²ÂÒâò"2   «      8   L   è       
   ¾                   Ì¥   x            À         .interp .hash .dynsym .dynstr .rel.plt .init .plt .text .fini .rodata .rodata1 .data .data1 .got .dynamic .bss .shstrtab .comment  @(#)/usr/bin/xargs.sl 1.1 4.0 10/01/90 13783 AT&T-SF                                                     ÔÔ                     	         èè   ¨                           p                           ¾                     	      ÀÀ  x               (         88                    .         <<                   3         <<                   9         LL                    ?         PP  T                  G         ¤¤  !                  P         È£È  p                  V         8¤8                   ]         Ì¥Ì  H                 b         ¦  p                k         ¦  £                 p                                  z                6                  07070100001c73000081ed0000000200000002000000012719347c00000fe8000000230000000c00000000000000000000000f00000000usr/bin/xtract    ELF              ¬4   ğ      4    (      4   4                      Ô                            4   4    :  :           p  p    Ä              Ä  Ä    p              /usr/lib/libc.so.1                                                                                                           	                             
                                         4À       4À  !     ¼          ¢     ñÿ   $     !   ô	    )   t     2          :   ô	  !  A   n     ñÿH   Ì@      O   |       T   4     ñÿ[   l       b   <`     h        o   ì       t   ¸    
    L,        \          Ü          |     ñÿ®   ,H      ¶   ü      ½         Ä   Ä     ñÿ __iob _iob _cleanup _end pclose __ctype _environ setpgrp _ctype _etext atexit kill _edata signal popen mbtowc exit _lib_version fgets strlen __fpstart _GLOBAL_OFFSET_TABLE_ sprintf fclose printf _DYNAMIC /usr/lib/libc.so.1                ¤  ¨  ¬  °  ´  ¸  ¼  À  Â   ÿ5ÿ%    ÿ%h    éàÿÿÿÿ%h   éĞÿÿÿÿ%h   éÀÿÿÿÿ%h   é°ÿÿÿÿ%h    é ÿÿÿÿ%h(   éÿÿÿÿ% h0   éÿÿÿÿ%¤h8   épÿÿÿÿ%¨h@   é`ÿÿÿÿ%¬hH   éPÿÿÿÿ%°hP   é@ÿÿÿÿ%´hX   é0ÿÿÿÿ%¸h`   é ÿÿÿÿ%¼hh   éÿÿÿÿ%Àhp   é ÿÿÿj j ìR¸¼Àth¼èÿÿÿÄ¸ÄÀtèõşÿÿh´èëşÿÿETtRURPè¯şÿÿèŞşÿÿè   ÄPèàşÿÿj ¸        ôÃUìì  WVSu3ÿhTèÅşÿÿYèÏşÿÿ}th¼èÏşÿÿYjèşÿÿYÿvÿvÿvhèüûÿÿPè¼şÿÿÄhxüûÿÿPè¸şÿÿÄØÀuh èşÿÿYjèMşÿÿYSh   ü÷ÿÿPèşÿÿÄÀ   ü÷ÿÿPèşÿÿYÀtü÷ÿÿPèşÿÿYÆû÷ÿÿ ÿvü÷ÿÿPèò   ÄÀuCÿvh èşÿÿÄ¿   jjèUşÿÿÄjj èYşÿÿÄSè`şÿÿYWè¹ıÿÿY[^_ÉÃh@èÖıÿÿYëÅÿvhPèÃıÿÿÄ¿   ë«UìPVM¶ü¡=   ¶ö¡=   v¾   0ë¾  Æ#EÖ#Ñ;Âu:}ÿ   E¶õ%    u ùÿ   ¶õ%    u
¸   ^ÉÃ3À^ÉÃUììWVSuEEüjÿuEôPèıÿÿÄøÿÿE}øëEôEø}jVEôPèoıÿÿÄøÿq  ÿu}ø 0  3À[^_ÉÃ÷]ôÃ=*   ó  =?   t5=[   t@=\   ujVEôPèıÿÿÄø]ôÿ  ÷;]ø  }ø   3À[^_ÉÃ}ø ñ  ÇEì    ÇEè    ÇEğ    >!uÇEè   FjVEôPè´üÿÿÄø]ôÿ³  ÷û-Á   }ì ·   >]®   jVEôPèzüÿÿÄø]ôÿy  ÷û\ujVEôPèWüÿÿÄø]ôÿV  ÷}è t7¶ü¡=   vSÿuìèğıÿÿÄÀtlEì9Eø|	9]ø  ÿEğëV¶ü¡=   vSÿuìè¹ıÿÿÄÀt5Eø9Eì-9]ø(ÿEğë#û\ujVEôPèÇûÿÿÄø]ôÿÆ   ÷]ì}è tEì9Eø¯   ÿEğëEì9EøtğjVEôPèûÿÿÄø]ôÿ   ÷û]Çşÿÿ}ğ tVÿuè¢ıÿÿÄ[^_ÉÃ3À[^_ÉÃF>*túÀtEüEë;VÿuèsıÿÿÄÀt¸   [^_ÉÃjÿuEôPè
ûÿÿÄøÿ}ÿEë}E8 u½3À[^_ÉÃÂ       USAGE: xtract cpio_options pattern archive
 cpio -iv%s "%s" < %s    xtract: could not popen() cpio
 xtract: error - %s not found
   xtract: done
   xtract: error - %s not found
           r   Ä        ÂÒâò"2BRbr¢   Í      ¨   ´   è   P    
   à                   |   x            0         .interp .hash .dynsym .dynstr .rel.plt .init .plt .text .fini .rodata .rodata1 .data .data1 .got .dynamic .bss .shstrtab .comment  @(#)/usr/bin/xtract.sl 1.1 4.0 10/01/90 55392 AT&T-SF                                                    ÔÔ                     	         èè   ¸                             °                       PP  à                     	      00  x               (         ¨¨                    .         ¬¬                   3         ¬¬                   9         ´´
                    ?         ¸¸
                    G         ¼¼
  ²                  P         pp                    V         xx                    ]         ||  H                 b         ÄÄ  p                k         44  É                 p              4                    z              ·  7                  07070100002a52000041ed0000000200000002000000032719347c00000000000000230000000c00000000000000000000000800000000usr/ccs   07070100002a53000041ed0000000200000002000000022719347c00000000000000230000000c00000000000000000000000c00000000usr/ccs/bin   07070100004a37000041ed0000000000000003000000022719347c00000000000000230000000c00000000000000000000000800000000usr/etc   070701000050e1000041fd00000002000000020000000e2719347c00000000000000230000000c00000000000000000000000c00000000usr/include   0707010000561f000081240000000200000002000000012719347c00000fb9000000230000000c00000000000000000000001700000000usr/include/archives.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*	Portions Copyright (c) 1988, Sun Microsystems, Inc.	*/
/*	All Rights Reserved.					*/

#ident	"@(#)/usr/include/archives.h.sl 1.1 4.0 10/15/90 57470 AT&T-SF"

#include <tar.h>

/* Magic numbers */

#define CMN_ASC	0x070701	/* Cpio Magic Number for ASCii header */
#define CMN_BIN	070707		/* Cpio Magic Number for Binary header */
#define CMN_BBS	0143561		/* Cpio Magic Number for Byte-Swap header */
#define CMN_CRC	0x070702	/* Cpio Magic Number for CRC header */
#define CMS_ASC	"070701"	/* Cpio Magic String for ASCii header */
#define CMS_CHR	"070707"	/* Cpio Magic String for CHR (-c) header */
#define CMS_CRC	"070702"	/* Cpio Magic String for CRC header */
#define CMS_LEN	6		/* Cpio Magic String LENgth */

/* Various header and field lengths */

#define CHRSZ	76		/* -c hdr size minus filename field */
#define ASCSZ	110		/* ASC and CRC hdr size minus filename field */
#define TARSZ	512		/* TAR hdr size */

#define HNAMLEN	256	/* maximum filename length for binary and -c headers */
#define EXPNLEN	1024	/* maximum filename length for ASC and CRC headers */
#define HTIMLEN	2	/* length of modification time field */
#define HSIZLEN	2	/* length of file size field */

/* cpio binary header definition */

struct hdr_cpio {
	short	h_magic,		/* magic number field */
		h_dev;			/* file system of file */
	ushort	h_ino,			/* inode of file */
		h_mode,			/* modes of file */
		h_uid,			/* uid of file */
		h_gid;			/* gid of file */
	short	h_nlink,		/* number of links to file */
		h_rdev,			/* maj/min numbers for special files */
		h_mtime[HTIMLEN],	/* modification time of file */
		h_namesize,		/* length of filename */
		h_filesize[HSIZLEN];	/* size of file */
	char	h_name[HNAMLEN];	/* filename */
} ;

/* cpio ODC header format */

struct c_hdr {
	char	c_magic[CMS_LEN],
		c_dev[6],
		c_ino[6],
		c_mode[6],
		c_uid[6],
		c_gid[6],
		c_nlink[6],
		c_rdev[6],
		c_mtime[11],
		c_namesz[6],
		c_filesz[11],
		c_name[HNAMLEN];
} ;

/* -c and CRC header format */

struct Exp_cpio_hdr {
	char	E_magic[CMS_LEN],
		E_ino[8],
		E_mode[8],
		E_uid[8],
		E_gid[8],
		E_nlink[8],
		E_mtime[8],
		E_filesize[8],
		E_maj[8],
		E_min[8],
		E_rmaj[8],
		E_rmin[8],
		E_namesize[8],
		E_chksum[8],
		E_name[EXPNLEN];
} ;

/* Tar header structure and format */

#define TBLOCK	512	/* length of tar header and data blocks */
#define	TNAMLEN	100	/* maximum length for tar file names */
#define TMODLEN	8	/* length of mode field */
#define TUIDLEN	8	/* length of uid field */
#define TGIDLEN	8	/* length of gid field */
#define TSIZLEN	12	/* length of size field */
#define TTIMLEN	12	/* length of modification time field */
#define TCRCLEN	8	/* length of header checksum field */

/* tar header definition */

union tblock {
	char dummy[TBLOCK];
	struct tar_hdr {
		char	t_name[TNAMLEN],	/* name of file */
			t_mode[TMODLEN],	/* mode of file */
			t_uid[TUIDLEN],		/* uid of file */
			t_gid[TGIDLEN],		/* gid of file */
			t_size[TSIZLEN],	/* size of file in bytes */
			t_mtime[TTIMLEN],	/* modification time of file */
			t_cksum[TCRCLEN],	/* checksum of header */
			t_typeflag,
			t_linkname[TNAMLEN],	/* file this file linked with */
			t_magic[TMAGLEN],
			t_version[TVERSLEN],
			t_uname[32],
			t_gname[32],
			t_devmajor[8],
			t_devminor[8],
			t_prefix[155];
	} tbuf;
} ;

/* volcopy tape label format and structure */

#define VMAGLEN 8
#define VVOLLEN 6
#define VFILLEN 464

struct volcopy_label {
	char	v_magic[VMAGLEN],
		v_volume[VVOLLEN],
		v_reels,
		v_reel;
	long	v_time,
                v_length,
		v_dens,
		v_reelblks,	/* u370 added field */
		v_blksize,	/* u370 added field */
		v_nblocks;	/* u370 added field */
	char	v_fill[VFILLEN];
	long	v_offset;	/* used with -e and -reel options */
	int	v_type;		/* does tape have nblocks field? */
} ;
   0707010000505b000081240000000200000002000000012719347c0000056c000000230000000c00000000000000000000001400000000usr/include/deflt.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/deflt.h.sl 1.1 4.0 10/15/90 7767 AT&T-SF"
/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */

/*
 *	@(#) deflt.h 1.1 86/10/07 
 */
/***	deflt.h -- include file for deflt(3).
 *
 */

#define	DEFLT	"/etc/default"

/*
 * Following for defcntl(3).
 * If you add new args, make sure that the default is:
 *	OFF	new-improved-feature-off, i.e. current state of affairs
 *	ON	new-improved-feature-on
 * or that you change the code for deflt(3) to have the old value as the
 * default.  (for compatibility).
 */

/* ... cmds */
#define	DC_GETFLAGS	0	/* get current flags */
#define	DC_SETFLAGS	1	/* set flags */

/* ... args */
#define	DC_CASE		0001	/* ON: respect case; OFF: ignore case */

#define	DC_STD		((0) | (DC_CASE))

extern char *defread();

#define	TURNON(flags, mask)	flags |= mask
#define	TURNOFF(flags, mask)	flags &= ~(mask)
#define	ISON(flags, mask)	(((flags) & (mask)) == (mask))
#define	ISOFF(flags, mask)	(((flags) & (mask)) != (mask))
0707010000505d000081240000000200000002000000012719347c00000d05000000230000000c00000000000000000000001600000000usr/include/devmgmt.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/devmgmt.h.sl 1.1 4.0 10/15/90 20983 AT&T-SF"
/*
 * Contents:
 *    -	Device Management definitions,
 *    -	getvol() definitions
 */

/*
 * Device management definitions
 *	- Default pathnames (relative to installation point)
 * 	- Environment variable namess
 * 	- Standard field names in the device table
 *	- Flags
 *	- Miscellaneous definitions
 */


/*
 * Default pathnames (relative to the package installation
 * point) to the files used by Device Management:
 *
 *	DTAB_PATH	Device table
 *	DGRP_PATH	Device group table
 *	DVLK_PATH	Device reservation table
 */

#define	DTAB_PATH			"/etc/device.tab"
#define	DGRP_PATH			"/etc/dgroup.tab"
#define	DVLK_PATH			"/etc/devlkfile"


/*
 * Names of environment variables
 *
 *	OAM_DEVTAB	Name of variable that defines the pathname to
 *			the device-table file
 *	OAM_DGROUP	Name of variable that defines the pathname to
 *			the device-group table file
 *	OAM_DEVLKTAB	Name of variable that defines the pathname to
 *			the device-reservation table file
 */

#define	OAM_DEVTAB			"OAM_DEVTAB"
#define	OAM_DGROUP			"OAM_DGROUP"
#define	OAM_DEVLKTAB			"OAM_DEVLKTAB"


/*
 * Standard field names in the device table
 */
 
#define	DTAB_ALIAS			"alias"
#define	DTAB_CDEVICE			"cdevice"
#define	DTAB_BDEVICE			"bdevice"
#define	DTAB_PATHNAME			"pathname"


/* 
 * Flags:
 *	For getdev() and getdgrp():
 *		DTAB_ANDCRITERIA	Devices must meet all criteria
 *					instead of any of the criteria
 *		DTAB_EXCLUDEFLAG	The list of devices or device groups
 *					is the list that is to be excluded,
 *					not those to select from.
 *		DTAB_LISTALL		List all device groups, even those that
 *					have no valid members (getdgrp() only).
 */

#define	DTAB_ANDCRITERIA		0x01
#define	DTAB_EXCLUDEFLAG		0x02
#define	DTAB_LISTALL			0x04


/*
 * Miscellaneous Definitions
 *
 *	DTAB_MXALIASLN	Maximum alias length
 */

#define	DTAB_MXALIASLN			14

/*
 * Device Management Structure definitions
 *	reservdev	Reserved device description
 */


/*
 * struct reservdev
 *
 *	Structure describes a reserved device.
 *
 *  Elements:
 *	char   *devname		Alias of the reserved device
 *	pid_t	key		Key used to reserve the device
 */

struct reservdev{
	char   *devname;
	pid_t	key;
};

/*
 * Device Management Functions:
 *
 *	devattr()	Returns a device's attribute
 *	devreserv()	Reserves a device
 *	devfree()	Frees a reserved device
 *	reservdev()	Return list of reserved devices
 *	getdev()	Get devices that match criteria
 *	getdgrp()	Get device-groups containing devices 
 *			that match criteria
 *	listdev()	List attributes defined for a device
 *	listdgrp()	List members of a device-group
 */

	char		       *devattr();
	int			devfree();
	char		      **devreserv();
	char		      **getdev();
	char		      **getdgrp();
	char		      **listdev();
	char		      **listdgrp();
	struct reservdev      **reservdev();

/*
 * getvol() definitions
 */

#define	DM_BATCH	0x0001
#define DM_ELABEL	0x0002
#define DM_FORMAT	0x0004
#define DM_FORMFS	0x0008
#define DM_WLABEL	0x0010
#define DM_OLABEL	0x0020

	int			getvol();	
   070701000020cc000041fd0000000200000002000000042719347c00000000000000230000000c00000000000000000000000f00000000usr/include/fs    0707010000206f000081240000000200000002000000012719347c000002c7000000230000000c00000000000000000000001900000000usr/include/fs/fs_subr.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/fs/fs_subr.h.sl 1.1 4.0 10/15/90 20082 AT&T-SF"
#ifndef	_FS_FS_SUBR_H
#define _FS_FS_SUBR_H


/*
 * Utilities shared among file system implementations.
 */
extern int	fs_nosys();
extern int	fs_sync();
extern void	fs_rwlock();
extern void	fs_rwunlock();
extern int	fs_cmp();
extern int	fs_frlock();
extern int	fs_setfl();
extern int	fs_poll();
extern int	fs_vcode();
extern int	fs_pathconf();

#endif /* _FS_FS_SUBR_H */
 070701000020cf000041ed0000000200000002000000022719347c00000000000000230000000c00000000000000000000001400000000usr/include/fs/proc   070701000020cd000081240000000200000002000000012719347c00001211000000230000000c00000000000000000000001d00000000usr/include/fs/proc/prdata.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _PROC_PRDATA_H
#define _PROC_PRDATA_H

#ident	"@(#)/usr/include/fs/proc/prdata.h.sl 1.1 4.0 10/15/90 2351 AT&T-SF"
#define	min(a,b)	((a) <= (b) ? (a) : (b))
#define	max(a,b)	((a) >= (b) ? (a) : (b))
#define	round(r)	(((r)+sizeof(int)-1)&(~(sizeof(int)-1)))

#define	PNSIZ	5			/* size of /proc name entries */

/*
 * Macros for mapping between i-numbers and pids.
 */
#define	PRBIAS	64
#define	itop(n)	((int)((n)-PRBIAS))	/* i-number to pid */
#define	ptoi(n)	((int)((n)+PRBIAS))	/* pid to i-number */

typedef struct prnode {
	struct prnode	*pr_free;	/* freelist pointer */
	struct vnode	*pr_vnext;	/* linked list of invalid vnodes */
	struct vnode	pr_vnode;	/* associated vnode */
	struct proc	*pr_proc;	/* process being traced */
	short		pr_mode;	/* file mode bits */
	short		pr_opens;	/* count of opens */
	short		pr_writers;	/* count of opens for writing */
	short		pr_flags;	/* private flags */
} prnode_t;

/*
 * Conversion macros.
 */
#define	VTOP(vp)	((struct prnode *)(vp)->v_data)
#define	PTOV(pnp)	((struct vnode *)&(pnp)->pr_vnode)

/*
 * Flags for pr_flags.
 */
#define	PREXCL		0x01	/* Exclusive-use (disallow opens for write) */
#define	PRINVAL		0x02	/* vnode is invalid (security provision) */

/*
 * Flags to prlock().
 */
#define	ZNO	0	/* Fail on encountering a zombie process. */
#define	ZYES	1	/* Allow zombies. */

/*
 * Assign one set to another (possible different sizes).
 *
 * Assigning to a smaller set causes members to be lost.
 * Assigning to a larger set causes extra members to be cleared.
 */
#define	prassignset(ap, sp)					\
{								\
	register int _i_ = sizeof(*(ap))/sizeof(u_long);	\
	while (--_i_ >= 0)					\
		((u_long*)(ap))[_i_] =				\
		  (_i_ >= sizeof(*(sp))/sizeof(u_long)) ?	\
		  0L : ((u_long*)(sp))[_i_];			\
}

/*
 * Determine whether or not a set (of arbitrary size) is empty.
 */
#define prisempty(sp) setisempty((u_long *)(sp), sizeof(*(sp))/sizeof(u_long))

#ifdef _KERNEL

#include "sys/types.h"
#include "sys/proc.h"
#include "sys/uio.h"
#include "vm/seg.h"

#if defined(__STDC__)

int		prusrio(proc_t *, enum uio_rw, struct uio *);
int		prisreadable(proc_t *, cred_t *);
int		prlock(struct prnode *, int, int);
void		prunlock(struct prnode *);
void		prgetstatus(proc_t *, prstatus_t *);
void		prgetaction(proc_t *, user_t *, u_int, struct sigaction *);
int		prnsegs(proc_t *);
void		prgetmap(proc_t *, prmap_t *);
vnode_t		*prvnode(proc_t *, struct seg *, caddr_t);
void		prgetpsinfo(proc_t *, struct prpsinfo *);
int		setisempty(u_long *, unsigned);

#else

int		prusrio();
int		prisreadable();
int		prlock();
void		prunlock();
void		prgetstatus();
void		prgetaction();
int		prnsegs();
void		prgetmap();
vnode_t		*prvnode();
void		prgetpsinfo();
int		setisempty();

#endif

/*
 * Machine-dependent routines (defined in prmachdep.c).
 */

#if defined(__STDC__)

user_t		*prumap(proc_t *);
void		prunmap(proc_t *);
void		prgetregs(user_t *, gregset_t);
void		prsetregs(user_t *, gregset_t);
greg_t		prgetpc(gregset_t);
int		prhasfp(void);
void		prgetfpregs(proc_t *, fpregset_t *);
void		prsetfpregs(proc_t *, fpregset_t *);
caddr_t		prgetpsaddr(proc_t *);
void		prstep(proc_t *, user_t *);
void		prsvaddr(proc_t *, user_t *, caddr_t);
caddr_t		prmapin(proc_t *, caddr_t, int);
void		prmapout(proc_t *, caddr_t, caddr_t, int);
caddr_t		prfastmapin(proc_t *, caddr_t, int);
void		prfastmapout(proc_t *, caddr_t, caddr_t, int);

#else

user_t		*prumap();
void		prunmap();
void		prgetregs();
void		prsetregs();
greg_t		prgetpc();
int		prhasfp();
void		prgetfpregs();
void		prsetfpregs();
caddr_t		prgetpsaddr();
void		prstep();
void		prsvaddr();
caddr_t		prmapin();
void		prmapout();
caddr_t		prfastmapin();
void		prfastmapout();

#endif

extern int procfstype;
extern int prmounted;		/* Set to 1 if /proc is mounted. */
extern struct vfs *procvfs;	/* Points to /proc vfs entry. */
extern dev_t procdev;
extern struct vnodeops prvnodeops;
extern struct vfsops prvfsops;
extern struct prnode prrootnode;

/*
 * Prototypes for other external functions; these should appear elsewhere
 * but don't.
 */
#if defined(__STDC__)

int	donice(proc_t *, cred_t *, int, int *);
int	fsig(proc_t *);
int	getudev(void);
void	setrun(proc_t *);	
int	suser(cred_t *);

#else

int	donice();
int	fsig();
int	getudev();
void	setrun();
int	stop();
int	suser();

#endif

#endif	/* _KERNEL */

#endif	/* _PROC_PRDATA_H */
   070701000050a4000081240000000200000002000000012719347c0000048c000000230000000c00000000000000000000001700000000usr/include/libgenIO.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/libgenIO.h.sl 1.1 4.0 10/15/90 56148 AT&T-SF"

/*
 * Code review updated version.
 */

/* device types */

#define G_NO_DEV	0	/* device does not require special treatment */
#define	G_FILE		1	/* file, not a device */
#define G_3B2_HD	2	/* 3B2 hard disk */
#define G_3B2_FD	3	/* 3B2 floppy diskette */
#define G_3B2_CTC	4	/* 3B2 cartridge tape */
#define G_SCSI_HD	5	/* scsi hard disk */
#define G_SCSI_FD	6	/* scsi floppy diskette */
#define G_SCSI_9T	7	/* scsi 9-track tape */
#define G_SCSI_Q24	8	/* scsi QIC-24 tape */
#define G_SCSI_Q120	9	/* scsi QIC-120 tape */
#define G_386_HD	10	/* 386 hard disk */
#define G_386_FD	11	/* 386 floppy disk */
#define G_386_Q24	12	/* 386 QIC-24 tape */
#define	G_TAPE		13	/* 9 Track tape */
#define	G_DEV_MAX	14	/* last valid device type */

/* special defines for the 3B2 cartridge tape */

#define O_CTSPECIAL	0200
#define STREAMON	's'
07070100005198000081240000000200000002000000012719347c00000390000000230000000c00000000000000000000001300000000usr/include/libw.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/libw.h.sl 1.1 4.0 10/01/90 31139 AT&T-SF"

#ifndef _LIBW_H
#define _LIBW_H
#include	<stdlib.h>

#ifndef _EUCWIDTH_T
#define _EUCWIDTH_T
typedef struct {
	short int _eucw1, _eucw2, _eucw3;	/*	EUC width	*/
	short int _scrw1, _scrw2, _scrw3;	/*	screen width	*/
	short int _pcw;		/*	WIDE_CHAR width	*/
	char _multibyte;	/*	1=multi-byte, 0=single-byte	*/
} eucwidth_t;
#endif

#ifdef __STDC__
void getwidth(eucwidth_t *);
int mbftowc(char *, wchar_t *, int (*)(), int *);
int scrwidth(wchar_t);
int wisprint(wchar_t);
#else
void getwidth();
int mbftowc();
int scrwidth();
int wisprint();
#endif /* __STDC__ */
#endif /* _LIBW_H */
0707010000519f000081240000000200000002000000012719347c00000475000000230000000c00000000000000000000001700000000usr/include/maillock.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/maillock.h.sl 1.1 4.0 10/01/90 11378 AT&T-SF"
#ident "@(#)maillock.h	2.8 'attmail mail(1) command'"

#ifdef SVR3
#     define	MAILDIR		"/usr/mail/"
#     define	SAVEDIR		"/usr/mail/:saved/"
#else
#     define	MAILDIR		"/var/mail/"
#     define	SAVEDIR		"/var/mail/:saved/"
#endif

#define	L_SUCCESS	0
#define	L_NAMELEN	1	/* recipient name > 13 chars */
#define	L_TMPLOCK	2	/* problem creating temp lockfile */
#define L_TMPWRITE	3	/* problem writing pid into temp lockfile */
#define	L_MAXTRYS	4	/* cannot link to lockfile after N tries */
#define	L_ERROR		5	/* Something other than EEXIST happened */
#define	L_MANLOCK	6	/* cannot set mandatory lock on temp lockfile */

#if defined(__STDC__) || defined(__cplusplus)
extern int maillock(char *user, int retrycnt);
extern int mailunlock(void);
#else
extern int maillock();
extern int mailunlock();
#endif
   070701000051a8000081240000000200000002000000012719347c00001161000000230000000c00000000000000000000001500000000usr/include/nserve.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/nserve.h.sl 1.1 4.0 10/15/90 21970 AT&T-SF"

#ifndef _NSERVE_H
#define _NSERVE_H

#ifndef _SYS_NSERVE_H
#include <sys/nserve.h>
#endif
/*
 *
 *	name server header file.  contains defines necessary for
 *	any program that wants to talk with the name server.
 *
 */
#define NSVERSION	1	/* coincides with load n7 SVR3		*/

/*
 * Pathname defines:
 */

#define NSPID	  "/etc/rfs/nspid"	/* lock file for ns, also has pid	*/
#define NS_PIPE   "/etc/rfs/nspip"	/* stream pipe for ns		*/
#define NSDIR	  "/etc/rfs"		/* name server working directory.	*/
#define DOMMASTER "/etc/rfs/dom.master"	/* file for outside domains 	*/
#define SAVEDB	  "/etc/rfs/save.db"		/* saves database when ns exits	*/
#define PASSFILE  "/etc/rfs/%s/loc.passwd"	/* location of local passwd	*/
#define VERPASSWD "/etc/rfs/verify/%s/passwd"	/* passwd for verification  */
#define DOMPASSWD "/etc/rfs/auth.info/%s/passwd"	/* passwd for dom  "%s"  */
							/* contains the domain name.	*/
#define NSDOM	  "/etc/rfs/domain"	/* place to save domain name	*/

/* other defines	*/
#define PRIMENAME "PRIMARY"	/* default name for unknown primary	*/
#define CORRECT	  "correct"	/* message stating password is correct	*/
#define INCORRECT "sorry"	/* message stating password is wrong	*/
#define REC_TIME  10

/* sizes	*/

#define	SZ_RES	14	/* maximum size of resource name 		     */
#define SZ_MACH	9	/* maximum size of machine name.		     */
#define SZ_PATH 64	/* size of "pathname" of resource		     */
#define SZ_DESC	32	/* size of description				     */
#define SZ_DELEMENT 14	/* max size of one element of a domain name	     */

/* types	*/
#define FILE_TREE 1	/* sharable file tree	*/

/* flags	*/
#define READONLY  1
#define READWRITE 2

/* command types	*/
#define NS_SNDBACK	0	/* actually a "null" type	*/
#define	NS_ADV		1	/* advertise a resource		*/
#define NS_UNADV	2	/* unadvertise a resource	*/
#define NS_GET		3	/* unused query			*/
#define NS_QUERY	4	/* query by name and type.	*/
#define NS_INIT		5	/* called to setup name service */
#define NS_SENDPASS	7	/* register passwd w/ primary	*/
#define NS_VERIFY	8	/* verify validity of your pwd	*/
#define NS_MODADV	9	/* modify an advertisement	*/
#define NS_BYMACHINE	10	/* inv query by owner and type	*/
#define NS_IQUERY	11	/* general inverse query	*/
#define NS_IM_P		12	/* I am primary poll		*/
#define NS_IM_NP	13	/* I am secondary poll		*/
#define NS_FINDP	14	/* find which machine is prime	*/
#define NS_REL		15	/* relinquish being primary	*/

/* return codes	*/
#define FAILURE		0
#define SUCCESS		1
#define MORE_DATA 	2	/* or'ed into return when more coming */

/* error codes returned by the name server 			*/

#define R_NOERR  0	/* no error				*/
#define R_FORMAT 1	/* format error				*/
#define R_NSFAIL 2	/* name server failure			*/
#define R_NONAME 3	/* name does not exist			*/
#define R_IMP	 4	/* request type not implemented or bad	*/
#define R_PERM	 5	/* no permission for this operation	*/
#define R_DUP	 6	/* name not unique (for advertise)	*/
#define R_SYS	 7	/* a system call failed in name server  */
#define R_EPASS  8	/* error accessing primary passwd file	*/
#define R_INVPW  9   	/* invalid password			*/
#define R_NOPW   10	/* no passwd in primary passwd file	*/
#define R_SETUP  11	/* error in ns_setup()			*/
#define R_SEND   12	/* error in ns_send()			*/
#define R_RCV    13	/* error in ns_rcv()			*/
#define R_INREC	 14	/* in recovery, try again		*/
#define R_FAIL	 15	/* unknown failure			*/

/* name server request structure	*/

struct nssend {
	short	ns_code;	/* request code (e.g., NS_ADV)	*/
	short	ns_type;	/* type of data, unused for now	*/
	short	ns_flag;	/* read/write flag		*/
	char	*ns_name;	/* name of resource		*/
	char	*ns_desc;	/* description of resource	*/
	char	*ns_path;	/* local pathname of resource	*/
	struct address	*ns_addr; /* address of resource's owner*/
	char	**ns_mach;	/* list of client machines	*/
};

/* function declarations	*/

int	ns_setup();
int	ns_close();
int	ns_send();
struct nssend	*ns_rcv();

/* macros	*/
#define	SET_NODELAY(f)	fcntl(f,F_SETFL,fcntl(f,F_GETFL,0)|O_NDELAY)
#define	CLR_NODELAY(f)	fcntl(f,F_SETFL,fcntl(f,F_GETFL,0)&~O_NDELAY)

#endif 	/* _NSERVE_H */
   070701000051b3000081240000000200000002000000012719347c0000074d000000230000000c00000000000000000000001100000000usr/include/pn.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/pn.h.sl 1.1 4.0 10/15/90 10535 AT&T-SF"

/* switch table structure */

typedef struct {
	char *sw_opcode;	/* opcode */
	int sw_idx;		/* index */
} pntab_t;

#define RFS 105			/* for rfsdaemon */

#define NUMSWENT 3		/* the number of entries in sw_tab */

/* these are the indicies into sw_tab.
   note that the orders must match the opcodes */

#define RF_RF 0			/* remote file service */
#define RF_NS 1			/* name service */
#define RF_AK 2			/* acknowledgement */

#define NUMDUENT 1		/* the number of entries in du_tab */

/* these are the indicies into du_tab.
   note that the orders must match the opcodes */

#define MNT 0			/* mount case */

#define PASSWDLEN	20		/* length of password */
#define C_RETRY		2		/* command retry count */
#define DEVSTR		"/dev/%s"
#define LISTNMSG	"NLPS:000:001:%d"
#define CANONSTR	"c4ll"		/* canonical pntab */
#define CANON_CLEN	16		/* canonical length of pntab */
#define OPCODLEN	4		/* 3 chars + null */

/* negotiate data packect */

typedef struct {
	long n_hetero;		/* heterogeneity indication */
	char n_passwd[PASSWDLEN];	/* password */
	struct rf_token n_token;	/* client's token */
	char n_netname[MAXDNAME];	/* netnodename */
} ndata_t;

typedef struct {
	char pn_op[OPCODLEN];
	long pn_lo;
	long pn_hi;
} pnhdr_t;

/* these version numbers specify compatibility between
	different versions of protocol negotiations */

#define LO_VER	1		/* lo version of this library */
#define HI_VER	1		/* hi version of this library */

/* these are the flags for the negotiate routine */

#define	SERVER	0
#define	CLIENT	1

#define TIMOD	"timod"
   070701000008ca000041fd0000000200000002000000022719347c00000000000000230000000c00000000000000000000001000000000usr/include/rpc   070701000008e3000081240000000200000002000000012719347c0000145a000000230000000c00000000000000000000001700000000usr/include/rpc/auth.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/auth.h.sl 1.1 4.0 10/15/90 43208 AT&T-SF"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*	PROPRIETARY NOTICE (Combined)
*
* This source code is unpublished proprietary information
* constituting, or derived under license from AT&T's UNIX(r) System V.
* In addition, portions of such source code were derived from Berkeley
* 4.3 BSD under license from the Regents of the University of
* California.
*
*
*
*	Copyright Notice 
*
* Notice of copyright on this source code product does not indicate 
*  publication.
*
*	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
*	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
*          All rights reserved.
*/ 

/*
 * auth.h, Authentication interface.
 *
 * The data structures are completely opaque to the client. The client
 * is required to pass a AUTH * to routines that create rpc
 * "sessions".
 */
#ifndef _RPC_AUTH_H
#define _RPC_AUTH_H

#define MAX_AUTH_BYTES	400
#define MAXNETNAMELEN	255	/* maximum length of network user's name */

/*
 * Status returned from authentication check
 */
enum auth_stat {
	AUTH_OK=0,
	/*
	 * failed at remote end
	 */
	AUTH_BADCRED=1,			/* bogus credentials (seal broken) */
	AUTH_REJECTEDCRED=2,		/* client should begin new session */
	AUTH_BADVERF=3,			/* bogus verifier (seal broken) */
	AUTH_REJECTEDVERF=4,		/* verifier expired or was replayed */
	AUTH_TOOWEAK=5,			/* rejected due to security reasons */
	/*
	 * failed locally
	*/
	AUTH_INVALIDRESP=6,		/* bogus response verifier */
	AUTH_FAILED=7			/* some unknown reason */
};

#if (mc68000 || sparc || vax || i386 || u3b2)
typedef u_long u_int32;	/* 32-bit unsigned integers */
#endif

union des_block {
	struct {
		u_int32 high;
		u_int32 low;
	} key;
	char c[8];
};
typedef union des_block des_block;
extern bool_t xdr_des_block();

/*
 * Authentication info. Opaque to client.
 */
struct opaque_auth {
	enum_t	oa_flavor;		/* flavor of auth */
	caddr_t	oa_base;		/* address of more auth stuff */
	u_int	oa_length;		/* not to exceed MAX_AUTH_BYTES */
};


/*
 * Auth handle, interface to client side authenticators.
 */
typedef struct {
	struct	opaque_auth	ah_cred;
	struct	opaque_auth	ah_verf;
	union	des_block	ah_key;
	struct auth_ops {
		void	(*ah_nextverf)();
		int	(*ah_marshal)();	/* nextverf & serialize */
		int	(*ah_validate)();	/* validate varifier */
		int	(*ah_refresh)();	/* refresh credentials */
		void	(*ah_destroy)();	/* destroy this structure */
	} *ah_ops;
	caddr_t ah_private;
} AUTH;


/*
 * Authentication ops.
 * The ops and the auth handle provide the interface to the authenticators.
 *
 * AUTH	*auth;
 * XDR	*xdrs;
 * struct opaque_auth verf;
 */
#define AUTH_NEXTVERF(auth)		\
		((*((auth)->ah_ops->ah_nextverf))(auth))
#define auth_nextverf(auth)		\
		((*((auth)->ah_ops->ah_nextverf))(auth))

#define AUTH_MARSHALL(auth, xdrs)	\
		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))
#define auth_marshall(auth, xdrs)	\
		((*((auth)->ah_ops->ah_marshal))(auth, xdrs))

#define AUTH_VALIDATE(auth, verfp)	\
		((*((auth)->ah_ops->ah_validate))((auth), verfp))
#define auth_validate(auth, verfp)	\
		((*((auth)->ah_ops->ah_validate))((auth), verfp))

#define AUTH_REFRESH(auth)		\
		((*((auth)->ah_ops->ah_refresh))(auth))
#define auth_refresh(auth)		\
		((*((auth)->ah_ops->ah_refresh))(auth))

#define AUTH_DESTROY(auth)		\
		((*((auth)->ah_ops->ah_destroy))(auth))
#define auth_destroy(auth)		\
		((*((auth)->ah_ops->ah_destroy))(auth))


extern struct opaque_auth _null_auth;


/*
 * These are the various implementations of client side authenticators.
 */

/*
 * System style authentication
 * AUTH *authsys_create(machname, uid, gid, len, aup_gids)
 *	char *machname;
 *	uid_t uid;
 *	gid_t gid;
 *	int len;
 *	gid_t *aup_gids;
 */
#ifdef _KERNEL
extern AUTH *authkern_create();		/* takes no parameters */
#else
extern AUTH *authsys_create();
extern AUTH *authsys_create_default();	/* takes no parameters */
extern AUTH *authnone_create();		/* takes no parameters */

/* Will get obsolete in near future */
#define authunix_create(machname, uid, gid, len, aup_gids) \
	authsys_create(machname, uid, gid, len, aup_gids)
#define authunix_create_default() authsys_create_default()

#endif

/*
 * DES style authentication
 * AUTH *authdes_seccreate(servername, window, timehost, ckey)
 *	char *servername;		- network name of server
 *	u_int window;			- time to live
 *	char *timehost;			- optional hostname to sync with
 *	des_block *ckey;		- optional conversation key to use
 */
/* Will get obsolete in near future */
#ifdef _KERNEL
extern int authdes_create();
#else
extern AUTH *authdes_create();
#endif
extern AUTH *authdes_seccreate();

#define AUTH_NONE	0		/* no authentication */
#define	AUTH_NULL	0		/* backward compatibility */
#define	AUTH_SYS	1		/* unix style (uid, gids) */
#define AUTH_UNIX	AUTH_SYS
#define	AUTH_SHORT	2		/* short hand unix style */
#define AUTH_DES	3		/* des style (encrypted timestamps) */

#endif /* !_RPC_AUTH_H */
  070701000008e4000081240000000200000002000000012719347c000009ee000000230000000c00000000000000000000001b00000000usr/include/rpc/auth_des.h    /*	Copyright (c) 1984, 1986, 1987, 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_AUTHDES_H
#define _RPC_AUTHDES_H

#ident	"@(#)/usr/include/rpc/auth_des.h.sl 1.1 4.0 10/15/90 20260 AT&T-SF"

/*      @(#)auth_des.h 1.7 88/10/25 SMI      */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * auth_des.h, Protocol for DES style authentication for RPC
 *  
 */

/*
 * There are two kinds of "names": fullnames and nicknames
 */
enum authdes_namekind {
	ADN_FULLNAME, 
	ADN_NICKNAME
};

/*
 * A fullname contains the network name of the client, 
 * a conversation key and the window
 */
struct authdes_fullname {
	char *name;		/* network name of client, up to MAXNETNAMELEN */
	des_block key;		/* conversation key */
	u_long window;		/* associated window */
};


/*
 * A credential 
 */
struct authdes_cred {
	enum authdes_namekind adc_namekind;
	struct authdes_fullname adc_fullname;
	u_long adc_nickname;
};



/*
 * A des authentication verifier 
 */
struct authdes_verf {
	union {
		struct timeval adv_ctime;	/* clear time */
		des_block adv_xtime;		/* crypt time */
	} adv_time_u;
	u_long adv_int_u;
};

/*
 * des authentication verifier: client variety
 *
 * adv_timestamp is the current time.
 * adv_winverf is the credential window + 1.
 * Both are encrypted using the conversation key.
 */
#define adv_timestamp	adv_time_u.adv_ctime
#define adv_xtimestamp	adv_time_u.adv_xtime
#define adv_winverf	adv_int_u

/*
 * des authentication verifier: server variety
 *
 * adv_timeverf is the client's timestamp + client's window
 * adv_nickname is the server's nickname for the client.
 * adv_timeverf is encrypted using the conversation key.
 */
#define adv_timeverf	adv_time_u.adv_ctime
#define adv_xtimeverf	adv_time_u.adv_xtime
#define adv_nickname	adv_int_u

#endif	/* _RPC_AUTHDES_H */
  070701000008e5000081240000000200000002000000012719347c000008a2000000230000000c00000000000000000000001b00000000usr/include/rpc/auth_sys.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/auth_sys.h.sl 1.1 4.0 10/15/90 1335 AT&T-SF"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*	PROPRIETARY NOTICE (Combined)
*
* This source code is unpublished proprietary information
* constituting, or derived under license from AT&T's UNIX(r) System V.
* In addition, portions of such source code were derived from Berkeley
* 4.3 BSD under license from the Regents of the University of
* California.
*
*
*
*	Copyright Notice 
*
* Notice of copyright on this source code product does not indicate 
*  publication.
*
*	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
*	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
*          All rights reserved.
*/ 


/*
 * auth_sys.h, Protocol for UNIX style authentication parameters for RPC
 *
 */

#ifndef _RPC_AUTH_SYS_H
#define _RPC_AUTH_SYS_H

/*
 * The system is very weak.  The client uses no encryption for  it
 * credentials and only sends null verifiers.  The server sends backs
 * null verifiers or optionally a verifier that suggests a new short hand
 * for the credentials.
 */

/* The machine name is part of a credential; it may not exceed 255 bytes */
#define MAX_MACHINE_NAME 255

/* gids compose part of a credential; there may not be more than 16 of them */
#define NGRPS 16

/*
 * "Unix" (sys) style credentials.
 */
struct authsys_parms {
	u_long	 aup_time;
	char	*aup_machname;
	uid_t	 aup_uid;
	gid_t	 aup_gid;
	u_int	 aup_len;
	gid_t	*aup_gids;
};
/* For backword compatibility */
#define authunix_parms authsys_parms

extern bool_t xdr_authsys_parms();
/* For backword compatibility. Will get obsolete */
#define xdr_authunix_parms(xdrs, p) xdr_authsys_parms(xdrs, p)

/* 
 * If a response verifier has flavor AUTH_SHORT, 
 * then the body of the response verifier encapsulates the following structure;
 * again it is serialized in the obvious fashion.
 */
struct short_hand_verf {
	struct opaque_auth new_cred;
};

#endif /* !_RPC_AUTH_SYS_H */
  070701000008e6000081240000000200000002000000012719347c000004c7000000230000000c00000000000000000000001c00000000usr/include/rpc/auth_unix.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/auth_unix.h.sl 1.1 4.0 10/15/90 20056 AT&T-SF"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*	PROPRIETARY NOTICE (Combined)
*
* This source code is unpublished proprietary information
* constituting, or derived under license from AT&T's UNIX(r) System V.
* In addition, portions of such source code were derived from Berkeley
* 4.3 BSD under license from the Regents of the University of
* California.
*
*
*
*	Copyright Notice 
*
* Notice of copyright on this source code product does not indicate 
*  publication.
*
*	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
*	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
*          All rights reserved.
*/ 
/*
 * auth_unix.h, Protocol for UNIX style authentication parameters for RPC
 */

#ifndef _RPC_AUTH_UNIX_H
#define _RPC_AUTH_UNIX_H

/*
 * This file is now obsolete. Users should switch to <rpc/auth_sys.h>
 */
#include <rpc/auth_sys.h>

#endif /* !_RPC_AUTH_UNIX_H */
 070701000008e7000081240000000200000002000000012719347c00002cae000000230000000c00000000000000000000001700000000usr/include/rpc/clnt.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/clnt.h.sl 1.1 4.0 10/15/90 63403 AT&T-SF"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*	PROPRIETARY NOTICE (Combined)
*
* This source code is unpublished proprietary information
* constituting, or derived under license from AT&T's UNIX(r) System V.
* In addition, portions of such source code were derived from Berkeley
* 4.3 BSD under license from the Regents of the University of
* California.
*
*
*
*	Copyright Notice 
*
* Notice of copyright on this source code product does not indicate 
*  publication.
*
*	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
*	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
*          All rights reserved.
*/

/*
 * clnt.h - Client side remote procedure call interface.
 *
 */

#ifndef _RPC_CLNT_H
#define _RPC_CLNT_H

#include <rpc/rpc_com.h>
/*
 * rpc calls return an enum clnt_stat.  This should be looked at more,
 * since each implementation is required to live with this (implementation
 * independent) list of errors.
 */
enum clnt_stat {
	RPC_SUCCESS=0,			/* call succeeded */
	/*
	 * local errors
	 */
	RPC_CANTENCODEARGS=1,		/* can't encode arguments */
	RPC_CANTDECODERES=2,		/* can't decode results */
	RPC_CANTSEND=3,			/* failure in sending call */
	RPC_CANTRECV=4,			/* failure in receiving result */
	RPC_TIMEDOUT=5,			/* call timed out */
	RPC_INTR=18,			/* call interrupted */
	RPC_UDERROR=23,			/* recv got uderr indication */
	/*
	 * remote errors
	 */
	RPC_VERSMISMATCH=6,		/* rpc versions not compatible */
	RPC_AUTHERROR=7,		/* authentication error */
	RPC_PROGUNAVAIL=8,		/* program not available */
	RPC_PROGVERSMISMATCH=9,		/* program version mismatched */
	RPC_PROCUNAVAIL=10,		/* procedure unavailable */
	RPC_CANTDECODEARGS=11,		/* decode arguments error */
	RPC_SYSTEMERROR=12,		/* generic "other problem" */

	/*
	 * rpc_call & clnt_create errors
	 */
	RPC_UNKNOWNHOST=13,		/* unknown host name */
	RPC_UNKNOWNPROTO=17,		/* unknown protocol */
	RPC_UNKNOWNADDR=19,		/* Remote address unknown */
	RPC_NOBROADCAST=21,		/* Broadcasting not supported */

	/*
	 * rpcbind errors
	 */
	RPC_RPCBFAILURE=14,		/* the pmapper failed in its call */
#define RPC_PMAPFAILURE RPC_RPCBFAILURE
	RPC_PROGNOTREGISTERED=15,	/* remote program is not registered */
	RPC_N2AXLATEFAILURE=22,		/* Name to address translation failed */
	/*
	 * Misc error in the TLI library
	 */
	RPC_TLIERROR=20,
	/*
	 * unspecified error
	 */
	RPC_FAILED=16
};


/*
 * Error info.
 */
struct rpc_err {
	enum clnt_stat re_status;
	union {
		struct {
			int errno;	/* related system error */
			int t_errno;	/* related tli error number */
		} RE_err;
		enum auth_stat RE_why;	/* why the auth error occurred */
		struct {
			u_long low;	/* lowest verion supported */
			u_long high;	/* highest verion supported */
		} RE_vers;
		struct {		/* maybe meaningful if RPC_FAILED */
			long s1;
			long s2;
		} RE_lb;		/* life boot & debugging only */
	} ru;
#define	re_errno	ru.RE_err.errno
#define	re_terrno	ru.RE_err.t_errno
#define	re_why		ru.RE_why
#define	re_vers		ru.RE_vers
#define	re_lb		ru.RE_lb
};


/*
 * Client rpc handle.
 * Created by individual implementations
 * Client is responsible for initializing auth, see e.g. auth_none.c.
 */
typedef struct {
	AUTH	*cl_auth;			/* authenticator */
	struct clnt_ops {
		enum clnt_stat	(*cl_call)();	/* call remote procedure */
		void		(*cl_abort)();	/* abort a call */
		void		(*cl_geterr)();	/* get specific error code */
		bool_t		(*cl_freeres)();/* frees results */
		void		(*cl_destroy)();/* destroy this structure */
		bool_t		(*cl_control)();/* the ioctl() of rpc */
	} *cl_ops;
	caddr_t			cl_private;	/* private stuff */
#ifndef _KERNEL
	char			*cl_netid;	/* network token */
	char			*cl_tp;		/* device name */
#endif
} CLIENT;


/*
 * Timers used for the pseudo-transport protocol when using datagrams
 */
struct rpc_timers {
	u_short		rt_srtt;	/* smoothed round-trip time */
	u_short		rt_deviate;	/* estimated deviation */
	u_long		rt_rtxcur;	/* current (backed-off) rto */
};

/*
 * Feedback values used for possible congestion and rate control
 */
#define	FEEDBACK_REXMIT1	1	/* first retransmit */
#define	FEEDBACK_OK		2	/* no retransmits */

#define	RPCSMALLMSGSIZE	400	/* a more reasonable packet size */

#define	KNC_STRSIZE	128	/* maximum length of knetconfig strings */
struct knetconfig {
	unsigned long	knc_semantics;	/* token name */
	char		*knc_protofmly;	/* protocol family */
	char		*knc_proto;	/* protocol */
	dev_t		knc_rdev;	/* device id */
	unsigned long	knc_unused[8];
};

/*
 * client side rpc interface ops
 */

/*
 * enum clnt_stat
 * CLNT_CALL(rh, proc, xargs, argsp, xres, resp, timeout)
 * 	CLIENT *rh;
 *	u_long proc;
 *	xdrproc_t xargs;
 *	caddr_t argsp;
 *	xdrproc_t xres;
 *	caddr_t resp;
 *	struct timeval timeout;
 */
#define	CLNT_CALL(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))
#define	clnt_call(rh, proc, xargs, argsp, xres, resp, secs)	\
	((*(rh)->cl_ops->cl_call)(rh, proc, xargs, argsp, xres, resp, secs))

/*
 * void
 * CLNT_ABORT(rh);
 * 	CLIENT *rh;
 */
#define	CLNT_ABORT(rh)	((*(rh)->cl_ops->cl_abort)(rh))
#define	clnt_abort(rh)	((*(rh)->cl_ops->cl_abort)(rh))

/*
 * struct rpc_err
 * CLNT_GETERR(rh);
 * 	CLIENT *rh;
 */
#define	CLNT_GETERR(rh, errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))
#define	clnt_geterr(rh, errp)	((*(rh)->cl_ops->cl_geterr)(rh, errp))

/*
 * bool_t
 * CLNT_FREERES(rh, xres, resp);
 * 	CLIENT *rh;
 *	xdrproc_t xres;
 *	caddr_t resp;
 */
#define	CLNT_FREERES(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))
#define	clnt_freeres(rh,xres,resp) ((*(rh)->cl_ops->cl_freeres)(rh,xres,resp))

/*
 * bool_t
 * CLNT_CONTROL(cl, request, info)
 *	CLIENT *cl;
 *	u_int request;
 *	char *info;
 */
#define	CLNT_CONTROL(cl, rq, in) ((*(cl)->cl_ops->cl_control)(cl, rq, in))
#define	clnt_control(cl, rq, in) ((*(cl)->cl_ops->cl_control)(cl, rq, in))


/*
 * control operations that apply to all transports
 */
#define	CLSET_TIMEOUT		1	/* set timeout (timeval) */
#define	CLGET_TIMEOUT		2	/* get timeout (timeval) */
#define	CLGET_SERVER_ADDR	3	/* get server's address (sockaddr) */
#define	CLGET_FD		6	/* get connections file descriptor */
#define	CLGET_SVC_ADDR		7	/* get server's address (netbuf) */
#define	CLSET_FD_CLOSE		8	/* close fd while clnt_destroy */
#define	CLSET_FD_NCLOSE		9	/* Do not close fd while clnt_destroy */
/*
 * Connectionless only control operations
 */
#define	CLSET_RETRY_TIMEOUT 4   /* set retry timeout (timeval) */
#define	CLGET_RETRY_TIMEOUT 5   /* get retry timeout (timeval) */

/*
 * void
 * CLNT_DESTROY(rh);
 * 	CLIENT *rh;
 */
#define	CLNT_DESTROY(rh)	((*(rh)->cl_ops->cl_destroy)(rh))
#define	clnt_destroy(rh)	((*(rh)->cl_ops->cl_destroy)(rh))


/*
 * RPCTEST is a test program which is accessable on every rpc
 * transport/port.  It is used for testing, performance evaluation,
 * and network administration.
 */

#define	RPCTEST_PROGRAM		((u_long)1)
#define	RPCTEST_VERSION		((u_long)1)
#define	RPCTEST_NULL_PROC	((u_long)2)
#define	RPCTEST_NULL_BATCH_PROC	((u_long)3)

/*
 * By convention, procedure 0 takes null arguments and returns them
 */

#define	NULLPROC ((u_long)0)

/*
 * Below are the client handle creation routines for the various
 * implementations of client side rpc.  They can return NULL if a
 * creation failure occurs.
 */

#ifndef _KERNEL
/*
 * Generic client creation routine. Supported protocols are which belong
 * to the nettype name space
 */
extern CLIENT *
clnt_create(/*hostname, prog, vers, nettype*/); /*
	char *hostname;			-- hostname
	u_long prog;			-- program number
	u_long vers;			-- version number
	char *nettype;			-- network type
*/

/*
 * Generic client creation routine. It takes a netconfig structure
 * instead of nettype
 */
extern CLIENT *
clnt_tp_create(/*hostname, prog, vers, netconf*/); /*
	char *hostname;			-- hostname
	u_long prog;			-- program number
	u_long vers;			-- version number
	struct netconfig *netconf; 	-- network config structure
*/

/*
 * Generic TLI create routine
 */
extern CLIENT *
clnt_tli_create(/*fd, netconf, svcaddr, prog, vers, sendsz, recvsz*/); /*
	register int fd;		-- fd
	struct netconfig *nconf;	-- netconfig structure
	struct netbuf *svcaddr;		-- servers address
	u_long prog;			-- program number
	u_long vers;			-- version number
	u_int sendsz;			-- send size
	u_int recvsz;			-- recv size
*/

/*
 * Low level clnt create routine for connectionful transports, e.g. tcp.
 */
extern CLIENT *
clnt_vc_create(/*fd, svcaddr, prog, vers, sendsz, recvsz*/); /*
	int fd;				-- open file descriptor
	struct netbuf *svcaddr;		-- servers address
	u_long prog;			-- program number
	u_long vers;			-- version number
	u_int sendsz;			-- buffer recv size
	u_int recvsz;			-- buffer send size
*/

/*
 * Low level clnt create routine for connectionless transports, e.g. udp.
 */
extern CLIENT *
clnt_dg_create(/*fd, svcaddr, program, version, sendsz, recvsz*/); /*
	int fd;				-- open file descriptor
	struct netbuf *svcaddr;		-- servers address
	u_long program;			-- program number
	u_long version;			-- version number
	u_int sendsz;			-- buffer recv size
	u_int recvsz;			-- buffer send size
*/

/*
 * Memory based rpc (for speed check and testing)
 * CLIENT *
 * clnt_raw_create(prog, vers)
 *	u_long prog;			-- program number
 *	u_long vers;			-- version number
 */
extern CLIENT *clnt_raw_create();


/*
 * Print why creation failed
 */
void clnt_pcreateerror(/* char *msg */);	/* stderr */
char *clnt_spcreateerror(/* char *msg */);	/* string */

/*
 * Like clnt_perror(), but is more verbose in its output
 */
void clnt_perrno(/* enum clnt_stat num */);	/* stderr */

/*
 * Print an error message, given the client error code
 */
void clnt_perror(/* CLIENT *clnt, char *msg */); 	/* stderr */
char *clnt_sperror(/* CLIENT *clnt, char *msg */);	/* string */

/*
 * If a creation fails, the following allows the user to figure out why.
 */
struct rpc_createerr {
	enum clnt_stat cf_stat;
	struct rpc_err cf_error; /* useful when cf_stat == RPC_PMAPFAILURE */
};

extern struct rpc_createerr rpc_createerr;

/*
 * The simplified interface:
 * enum clnt_stat
 * rpc_call(host, prognum, versnum, procnum, inproc, in, outproc, out, nettype)
 *	char *host;
 *	u_long prognum, versnum, procnum;
 *	xdrproc_t inproc, outproc;
 *	char *in, *out;
 *	char *nettype;
 */
extern enum clnt_stat rpc_call();

/*
 * RPC broadcast interface
 * extern enum clnt_stat
 * rpc_broadcast(prog, vers, proc, xargs, argsp, xresults, resultsp,
 *			eachresult, nettype)
 *	u_long		prog;		-- program number
 *	u_long		vers;		-- version number
 *	u_long		proc;		-- procedure number
 *	xdrproc_t	xargs;		-- xdr routine for args
 *	caddr_t		argsp;		-- pointer to args
 *	xdrproc_t	xresults;	-- xdr routine for results
 *	caddr_t		resultsp;	-- pointer to results
 *	resultproc_t	eachresult;	-- call with each result obtained
 *	char		*nettype;	-- Transport type
 */
extern enum clnt_stat rpc_broadcast();

#endif /* !KERNEL */

/*
 * Copy error message to buffer.
 */
char *clnt_sperrno(/* enum clnt_stat num */);	/* string */

#ifdef PORTMAP
/* For backword compatibility */
#include <rpc/clnt_soc.h>
#endif

#endif /* !_RPC_CLNT_H */
  070701000008e8000081240000000200000002000000012719347c00000a14000000230000000c00000000000000000000001b00000000usr/include/rpc/clnt_soc.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/clnt_soc.h.sl 1.1 4.0 10/15/90 6440 AT&T-SF"

/* @(#)clnt_soc.h 1.3 88/12/17 SMI 	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * clnt.h - Client side remote procedure call interface.
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
 */

#ifndef _RPC_CLNT_SOC_H
#define _RPC_CLNT_SOC_H

/*
 * All the following declarations are only for backward compatibility
 * with SUNOS 4.0.
 */

#include <sys/socket.h>
#include <netinet/in.h>

#define UDPMSGSIZE	8800	/* rpc imposed limit on udp msg size */

/*
 * enum clnt_stat
 * callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
 *	char *host;
 *	u_long prognum, versnum, procnum;
 *	xdrproc_t inproc, outproc;
 *	char *in, *out;
 *	char *nettype;
 */
extern int callrpc();

/*
 * TCP based rpc
 * CLIENT *
 * clnttcp_create(raddr, prog, vers, fdp, sendsz, recvsz)
 *	struct sockaddr_in *raddr;
 *	u_long prog;
 *	u_long version;
 *	int *fdp;
 *	u_int sendsz;
 *	u_int recvsz;
 */
extern CLIENT *clnttcp_create();

/*
 * UDP based rpc.
 * CLIENT *
 * clntudp_create(raddr, program, version, wait, fdp)
 *	struct sockaddr_in *raddr;
 *	u_long program;
 *	u_long version;
 *	struct timeval wait;
 *	int *fdp;
 *
 * Same as above, but you specify max packet sizes.
 * CLIENT *
 * clntudp_bufcreate(raddr, program, version, wait, fdp, sendsz, recvsz)
 *	struct sockaddr_in *raddr;
 *	u_long program;
 *	u_long version;
 *	struct timeval wait;
 *	int *fdp;
 *	u_int sendsz;
 *	u_int recvsz;
 *
 */
extern CLIENT *clntudp_create();
extern CLIENT *clntudp_bufcreate();

/*
 * Memory based rpc (for speed check and testing)
 * CLIENT *
 * clntraw_create(prog, vers)
 *	u_long prog;
 *	u_long vers;
 */
extern CLIENT *clntraw_create();

#endif /* _RPC_CLNT_SOC_H */
070701000008ea000081240000000200000002000000012719347c00000998000000230000000c00000000000000000000001b00000000usr/include/rpc/key_prot.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/key_prot.h.sl 1.1 4.0 10/15/90 60066 AT&T-SF"

/* @(#)key_prot.h 1.1 88/12/14 Copyr 1986 Sun Micro */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*	@(#)key_prot.h 1.4 89/05/01 SMI	*/

/* 
 * Compiled from key_prot.x using rpcgen.
 * DO NOT EDIT THIS FILE!
 * This is NOT source code!
 */

#ifndef _RPC_KEY_PROT_H
#define _RPC_KEY_PROT_H

#define KEY_PROG 100029
#define KEY_VERS 1
#define KEY_SET 1
#define KEY_ENCRYPT 2
#define KEY_DECRYPT 3
#define KEY_GEN 4
#define KEY_GETCRED 5

#define PROOT 3
#define HEXMODULUS "d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b"
#define HEXKEYBYTES 48
#define KEYSIZE 192
#define KEYBYTES 24
#define KEYCHECKSUMSIZE 16

enum keystatus {
	KEY_SUCCESS = 0,
	KEY_NOSECRET = 1,
	KEY_UNKNOWN = 2,
	KEY_SYSTEMERR = 3
};
typedef enum keystatus keystatus;
bool_t xdr_keystatus();

#ifndef _KERNEL

typedef char keybuf[HEXKEYBYTES];
bool_t xdr_keybuf();

#endif

typedef char *netnamestr;
bool_t xdr_netnamestr();


struct cryptkeyarg {
	netnamestr remotename;
	des_block deskey;
};
typedef struct cryptkeyarg cryptkeyarg;
bool_t xdr_cryptkeyarg();


struct cryptkeyres {
	keystatus status;
	union {
		des_block deskey;
	} cryptkeyres_u;
};
typedef struct cryptkeyres cryptkeyres;
bool_t xdr_cryptkeyres();

#define MAXGIDS 16

struct unixcred {
	uid_t uid;
	uid_t gid;
	struct {
		u_int gids_len;
		u_int *gids_val;
	} gids;
};
typedef struct unixcred unixcred;
bool_t xdr_unixcred();


struct getcredres {
	keystatus status;
	union {
		unixcred cred;
	} getcredres_u;
};
typedef struct getcredres getcredres;
bool_t xdr_getcredres();

#endif /*!_rpc_key_prot_h*/
070701000008eb000081240000000200000002000000012719347c000005f1000000230000000c00000000000000000000001a00000000usr/include/rpc/nettype.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/nettype.h.sl 1.1 4.0 10/15/90 1281 AT&T-SF"

/*      @(#)nettype.h 1.4 88/12/14 SMI      */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * nettype.h, Nettype definitions.
 * All for the topmost layer of rpc
 *
 */

#ifndef _RPC_NETTYPE_H
#define _RPC_NETTYPE_H

#include <netconfig.h>

#define _RPC_NONE	0
#define _RPC_NETPATH	1
#define _RPC_VISIBLE	2
#define _RPC_CIRCUIT_V	3
#define _RPC_DATAGRAM_V	4
#define _RPC_CIRCUIT_N	5
#define _RPC_DATAGRAM_N	6
#define _RPC_TCP	7
#define _RPC_UDP	8

extern int _rpc_setconf();
extern int _rpc_endconf();
extern struct netconfig *_rpc_getconf();
extern struct netconfig *_rpc_getconfip();
#endif /* !_RPC_NETTYPE_H */
   070701000008ec000081240000000200000002000000012719347c00000886000000230000000c00000000000000000000001c00000000usr/include/rpc/pmap_clnt.h   /*	Copyright (c) 1984, 1986, 1987, 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_PMAPCLNT_H
#define _RPC_PMAPCLNT_H

#ident	"@(#)/usr/include/rpc/pmap_clnt.h.sl 1.1 4.0 10/15/90 7799 AT&T-SF"

/*	@(#)pmap_clnt.h 1.14 88/10/25 SMI	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * pmap_clnt.h
 * Supplies C routines to get to portmap services.
 */

/*
 * Usage:
 *	success = pmap_set(program, version, protocol, port);
 *	success = pmap_unset(program, version);
 *	port = pmap_getport(address, program, version, protocol);
 *	head = pmap_getmaps(address);
 *	clnt_stat = pmap_rmtcall(address, program, version, procedure,
 *		xdrargs, argsp, xdrres, resp, tout, port_ptr)
 *		(works for udp only.) 
 * 	clnt_stat = clnt_broadcast(program, version, procedure,
 *		xdrargs, argsp,	xdrres, resp, eachresult)
 *		(like pmap_rmtcall, except the call is broadcasted to all
 *		locally connected nets.  For each valid response received,
 *		the procedure eachresult is called.  Its form is:
 *	done = eachresult(resp, raddr)
 *		bool_t done;
 *		caddr_t resp;
 *		struct sockaddr_in raddr;
 *		where resp points to the results of the call and raddr is the
 *		address if the responder to the broadcast.
 */

extern bool_t		pmap_set();
extern bool_t		pmap_unset();
extern struct pmaplist	*pmap_getmaps();
enum clnt_stat		pmap_rmtcall();
enum clnt_stat		clnt_broadcast();
extern u_short		pmap_getport();

#endif	/* _RPC_PMAPCLNT_H */
  070701000008ed000081240000000200000002000000012719347c00000c5a000000230000000c00000000000000000000001c00000000usr/include/rpc/pmap_prot.h   /*	Copyright (c) 1984, 1986, 1987, 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_PMAPPROT_H
#define _RPC_PMAPPROT_H

#ident	"@(#)/usr/include/rpc/pmap_prot.h.sl 1.1 4.0 10/15/90 11559 AT&T-SF"

/*	@(#)pmap_prot.h 1.19 88/11/28 SMI	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * pmap_prot.h
 * Protocol for the local binder service, or pmap.
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
 *
 * The following procedures are supported by the protocol:
 *
 * PMAPPROC_NULL() returns ()
 * 	takes nothing, returns nothing
 *
 * PMAPPROC_SET(struct pmap) returns (bool_t)
 * 	TRUE is success, FALSE is failure.  Registers the tuple
 *	[prog, vers, prot, port].
 *
 * PMAPPROC_UNSET(struct pmap) returns (bool_t)
 *	TRUE is success, FALSE is failure.  Un-registers pair
 *	[prog, vers].  prot and port are ignored.
 *
 * PMAPPROC_GETPORT(struct pmap) returns (long unsigned).
 *	0 is failure.  Otherwise returns the port number where the pair
 *	[prog, vers] is registered.  It may lie!
 *
 * PMAPPROC_DUMP() RETURNS (struct pmaplist *)
 *
 * PMAPPROC_CALLIT(unsigned, unsigned, unsigned, string<>)
 * 	RETURNS (port, string<>);
 * usage: encapsulatedresults = PMAPPROC_CALLIT(prog, vers, proc, encapsulatedargs);
 * 	Calls the procedure on the local machine.  If it is not registered,
 *	this procedure is quite; ie it does not return error information!!!
 *	This procedure only is supported on rpc/udp and calls via
 *	rpc/udp.  This routine only passes null authentication parameters.
 *	This file has no interface to xdr routines for PMAPPROC_CALLIT.
 *
 * The service supports remote procedure calls on udp/ip or tcp/ip socket 111.
 */

#include <rpc/types.h>

#define PMAPPORT		((u_short)111)
#define PMAPPROG		((u_long)100000)
#define PMAPVERS		((u_long)2)
#define PMAPVERS_PROTO		((u_long)2)
#define PMAPVERS_ORIG		((u_long)1)

#define PMAPPROC_NULL		((u_long)0)
#define PMAPPROC_SET		((u_long)1)
#define PMAPPROC_UNSET		((u_long)2)
#define PMAPPROC_GETPORT	((u_long)3)
#define PMAPPROC_DUMP		((u_long)4)
#define PMAPPROC_CALLIT		((u_long)5)

struct pmap {
	long unsigned pm_prog;
	long unsigned pm_vers;
	long unsigned pm_prot;
	long unsigned pm_port;
};
typedef struct pmap PMAP;
extern bool_t xdr_pmap();

struct pmaplist {
	struct pmap pml_map;
	struct pmaplist *pml_next;
};
typedef struct pmaplist PMAPLIST;
#ifndef _KERNEL
extern bool_t xdr_pmaplist();
#endif

#endif	/* _RPC_PMAPPROT_H */
  070701000008ee000081240000000200000002000000012719347c00000597000000230000000c00000000000000000000001b00000000usr/include/rpc/pmap_rmt.h    /*	Copyright (c) 1984, 1986, 1987, 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_PMAPRMT_H
#define _RPC_PMAPRMT_H

#ident	"@(#)/usr/include/rpc/pmap_rmt.h.sl 1.1 4.0 10/15/90 24814 AT&T-SF"

/*	@(#)pmap_rmt.h 1.5 88/10/25 SMI	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * Structures and XDR routines for parameters to and replies from
 * the portmapper remote-call-service.
 */

struct rmtcallargs {
	u_long prog, vers, proc, arglen;
	caddr_t args_ptr;
	xdrproc_t xdr_args;
};

bool_t xdr_rmtcall_args();

struct rmtcallres {
	u_long *port_ptr;
	u_long resultslen;
	caddr_t results_ptr;
	xdrproc_t xdr_results;
};

bool_t xdr_rmtcallres();

#endif	/* _RPC_PMAPRMT_H */
 070701000008ef000081240000000200000002000000012719347c0000047d000000230000000c00000000000000000000001600000000usr/include/rpc/raw.h /*	Copyright (c) 1984, 1986, 1987, 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_RAW_H
#define _RPC_RAW_H

#ident	"@(#)/usr/include/rpc/raw.h.sl 1.1 4.0 10/15/90 57568 AT&T-SF"

/*	@(#)raw.h 1.2 88/10/25 SMI	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * raw.h
 *
 * Raw interface
 * The common memory area over which they will communicate
 */

char *_rawcombuf;

#endif	/* _RPC_RAW_H */
   070701000008f0000081240000000200000002000000012719347c00000793000000230000000c00000000000000000000001600000000usr/include/rpc/rpc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/rpc.h.sl 1.1 4.0 10/15/90 49503 AT&T-SF"

/*	@(#)rpc.h 1.13 88/12/17 SMI	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * rpc.h, Just includes the billions of rpc header files necessary to 
 * do remote procedure calling.
 *
 */
#ifndef _RPC_RPC_H
#define _RPC_RPC_H

#include <rpc/types.h>		/* some typedefs */

#ifndef _KERNEL
#include <tiuser.h>
#include <fcntl.h>
#include <memory.h>
#else
#include <sys/tiuser.h>
#include <sys/fcntl.h>
#include <netinet/in.h>
#include <sys/t_kuser.h>
#endif

#include <rpc/xdr.h>		/* generic (de)serializer */
#include <rpc/auth.h>		/* generic authenticator (client side) */
#include <rpc/clnt.h>		/* generic client side rpc */

#include <rpc/rpc_msg.h>	/* protocol for rpc messages */
#include <rpc/auth_sys.h>	/* protocol for unix style cred */
#include <rpc/auth_des.h>	/* protocol for des style cred */

#include <rpc/svc.h>		/* service manager and multiplexer */
#include <rpc/svc_auth.h>	/* service side authenticator */

#ifndef _KERNEL
#include <rpc/rpcb_clnt.h>	/* rpcbind interface functions */
#endif
#endif /* ! _RPC_RPC_H */
 070701000008f1000081240000000200000002000000012719347c00000621000000230000000c00000000000000000000001a00000000usr/include/rpc/rpc_com.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/rpc_com.h.sl 1.1 4.0 10/15/90 51109 AT&T-SF"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*	PROPRIETARY NOTICE (Combined)
*
* This source code is unpublished proprietary information
* constituting, or derived under license from AT&T's UNIX(r) System V.
* In addition, portions of such source code were derived from Berkeley
* 4.3 BSD under license from the Regents of the University of
* California.
*
*
*
*	Copyright Notice 
*
* Notice of copyright on this source code product does not indicate 
*  publication.
*
*	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
*	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
*          All rights reserved.
*/ 
/*
 * rpc_com.h, Common definitions for both the server and client side.
 * All for the topmost layer of rpc
 *
 * Copyright (C) 1988, Sun Microsystems, Inc.
 */

#ifndef _RPC_RPCCOM_H
#define _RPC_RPCCOM_H

/*
 * File descriptor to be used on xxx_create calls to get default descriptor
 */
#define	RPC_ANYSOCK	-1
#define RPC_ANYFD	RPC_ANYSOCK	
/*
 * The max size of the transport, if the size cannot be determined
 * by other means.
 */
#define MAXTR_BSIZE 9000

extern u_int _rpc_get_t_size();
extern u_int _rpc_get_a_size();
extern int _rpc_dtbsize();
extern char *_rpc_gethostname();

#endif /* _RPC_RPCCOM_H */
   070701000008f2000081240000000200000002000000012719347c00000ef4000000230000000c00000000000000000000001a00000000usr/include/rpc/rpc_msg.h /*	Copyright (c) 1984, 1986, 1987, 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_RPCMSG_H
#define _RPC_RPCMSG_H

#ident	"@(#)/usr/include/rpc/rpc_msg.h.sl 1.1 4.0 10/15/90 347 AT&T-SF"

/*      @(#)rpc_msg.h 1.11 88/10/25 SMI      */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * rpc_msg.h
 * rpc message definition
 */
#define RPC_MSG_VERSION		((u_long) 2)
#define RPC_SERVICE_PORT	((u_short) 2048)

/*
 * Bottom up definition of an rpc message.
 * NOTE: call and reply use the same overall stuct but
 * different parts of unions within it.
 */

enum msg_type {
	CALL=0,
	REPLY=1
};

enum reply_stat {
	MSG_ACCEPTED=0,
	MSG_DENIED=1
};

enum accept_stat {
	SUCCESS=0,
	PROG_UNAVAIL=1,
	PROG_MISMATCH=2,
	PROC_UNAVAIL=3,
	GARBAGE_ARGS=4,
	SYSTEM_ERR=5
};

enum reject_stat {
	RPC_MISMATCH=0,
	AUTH_ERROR=1
};

/*
 * Reply part of an rpc exchange
 */

/*
 * Reply to an rpc request that was accepted by the server.
 * Note: there could be an error even though the request was
 * accepted.
 */
struct accepted_reply {
	struct opaque_auth	ar_verf;
	enum accept_stat	ar_stat;
	union {
		struct {
			u_long	low;
			u_long	high;
		} AR_versions;
		struct {
			caddr_t	where;
			xdrproc_t proc;
		} AR_results;
		/* and many other null cases */
	} ru;
#define	ar_results	ru.AR_results
#define	ar_vers		ru.AR_versions
};

/*
 * Reply to an rpc request that was rejected by the server.
 */
struct rejected_reply {
	enum reject_stat rj_stat;
	union {
		struct {
			u_long low;
			u_long high;
		} RJ_versions;
		enum auth_stat RJ_why;  /* why authentication did not work */
	} ru;
#define	rj_vers	ru.RJ_versions
#define	rj_why	ru.RJ_why
};

/*
 * Body of a reply to an rpc request.
 */
struct reply_body {
	enum reply_stat rp_stat;
	union {
		struct accepted_reply RP_ar;
		struct rejected_reply RP_dr;
	} ru;
#define	rp_acpt	ru.RP_ar
#define	rp_rjct	ru.RP_dr
};

/*
 * Body of an rpc request call.
 */
struct call_body {
	u_long cb_rpcvers;	/* must be equal to two */
	u_long cb_prog;
	u_long cb_vers;
	u_long cb_proc;
	struct opaque_auth cb_cred;
	struct opaque_auth cb_verf; /* protocol specific - provided by client */
};

/*
 * The rpc message
 */
struct rpc_msg {
	u_long			rm_xid;
	enum msg_type		rm_direction;
	union {
		struct call_body RM_cmb;
		struct reply_body RM_rmb;
	} ru;
#define	rm_call		ru.RM_cmb
#define	rm_reply	ru.RM_rmb
};
#define	acpted_rply	ru.RM_rmb.ru.RP_ar
#define	rjcted_rply	ru.RM_rmb.ru.RP_dr


/*
 * XDR routine to handle a rpc message.
 * xdr_callmsg(xdrs, cmsg)
 * 	XDR *xdrs;
 * 	struct rpc_msg *cmsg;
 */
extern bool_t	xdr_callmsg();

/*
 * XDR routine to pre-serialize the static part of a rpc message.
 * xdr_callhdr(xdrs, cmsg)
 * 	XDR *xdrs;
 * 	struct rpc_msg *cmsg;
 */
extern bool_t	xdr_callhdr();

/*
 * XDR routine to handle a rpc reply.
 * xdr_replymsg(xdrs, rmsg)
 * 	XDR *xdrs;
 * 	struct rpc_msg *rmsg;
 */
extern bool_t	xdr_replymsg();

/*
 * Fills in the error part of a reply message.
 * _seterr_reply(msg, error)
 * 	struct rpc_msg *msg;
 * 	struct rpc_err *error;
 */
extern void	_seterr_reply();

#endif	/* _RPC_RPCMSG_H */
070701000008f3000081240000000200000002000000012719347c00000a00000000230000000c00000000000000000000001c00000000usr/include/rpc/rpcb_clnt.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/rpcb_clnt.h.sl 1.1 4.0 10/15/90 13211 AT&T-SF"

/* @(#)rpcb_clnt.h 1.3 88/12/05 SMI */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * rpcb_clnt.h
 * Supplies C routines to get to rpcbid services.
 *
 */

/*
 * Usage:
 *	success = rpcb_set(program, version, nconf, address);
 *	success = rpcb_unset(program, version, nconf);
 *	success = rpcb_getaddr(program, version, nconf, host);
 *	head = rpcb_getmaps(nconf, host);
 *	clnt_stat = rpcb_rmtcall(nconf, host, program, version, procedure,
 *		xdrargs, argsp, xdrres, resp, tout, addr_ptr)
 * 	clnt_stat = rpc_broadcast(program, version, procedure,
 *		xdrargs, argsp,	xdrres, resp, eachresult, nettype)
 *		(like rpcb_rmtcall, except the call is broadcasted to all
 *		locally connected nets.  For each valid response received,
 *		the procedure eachresult is called.  Its form is:
 *		done = eachresult(resp, raddr, netconf)
 *			bool_t done;
 *			caddr_t resp;
 *			struct netbuf *raddr;
 *			struct netconfig *netconf;
 *		where resp points to the results of the call and raddr is the
 *		address if the responder to the broadcast. netconf is the
 *		on which the response came.
 *	success = rpcb_gettime(host, timep)
 *	uaddr = rpcb_taddr2uaddr(nconf, taddr);
 *	taddr = rpcb_uaddr2uaddr(nconf, uaddr);
 */

#ifndef _RPC_RPCB_CLNT_H
#define _RPC_RPCB_CLNT_H

#include <rpc/types.h>
#include <rpc/rpcb_prot.h>

extern bool_t		rpcb_set();
extern bool_t		rpcb_unset();
extern RPCBLIST		*rpcb_getmaps();
extern enum clnt_stat	rpcb_rmtcall();
extern enum clnt_stat	rpc_broadcast();
extern bool_t		rpcb_getaddr();
extern bool_t		rpcb_gettime();
extern char		*rpcb_taddr2uaddr();
extern struct netbuf	*rpcb_uaddr2taddr();

#endif /*!_RPC_RPCB_CLNT_H*/
070701000008f4000081240000000200000002000000012719347c00000f93000000230000000c00000000000000000000001c00000000usr/include/rpc/rpcb_prot.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/rpcb_prot.h.sl 1.1 4.0 10/15/90 14036 AT&T-SF"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*	PROPRIETARY NOTICE (Combined)
*
* This source code is unpublished proprietary information
* constituting, or derived under license from AT&T's UNIX(r) System V.
* In addition, portions of such source code were derived from Berkeley
* 4.3 BSD under license from the Regents of the University of
* California.
*
*
*
*	Copyright Notice 
*
* Notice of copyright on this source code product does not indicate 
*  publication.
*
*	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
*	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
*          All rights reserved.
*/ 
/*
 * rpcb_prot.h
 * Protocol for the local rpcbinder service
 */

/*
 * The following procedures are supported by the protocol:
 *
 * RPCBPROC_NULL() returns ()
 * 	takes nothing, returns nothing
 *
 * RPCBPROC_SET(RPCB) returns (bool_t)
 * 	TRUE is success, FALSE is failure.  Registers the tuple
 *	[prog, vers, netid] with address
 *
 * RPCBPROC_UNSET(RPCB) returns (bool_t)
 *	TRUE is success, FALSE is failure.  Un-registers tuple
 *	[prog, vers, netid].  address is ignored.
 *
 * RPCBPROC_GETADDR(RPCB) returns (Universal address).
 *	0 is failure.  Otherwise returns the universal address where the pair
 *	[prog, vers, netid] is registered.
 *
 * RPCBPROC_DUMP() RETURNS (RPCBLIST *)
 *	used for dumping the entire rpcbind maps
 *
 * RPCBPROC_CALLIT(unsigned, unsigned, unsigned, string<>)
 * 	RETURNS (address, string<>);
 * usage: encapsulatedresults = RPCBPROC_CALLIT(prog, vers, proc, encapsulatedargs);
 * 	Calls the procedure on the local machine.  If it is not registered,
 *	this procedure is quiet; i.e. it does not return error information!!!
 *	This routine only passes null authentication parameters.
 *	This file has no interface to xdr routines for RPCBPROC_CALLIT.
 *
 * RPCBPROC_GETTIME() returns (bool_t).
 *	TRUE is success, FALSE is failure.  Gets the remote machines time
 *
 */

#ifndef _RPC_RPCB_PROT_H
#define _RPC_RPCB_PROT_H

#include <rpc/types.h>

#define RPCBPROG		((u_long)100000)
#define RPCBVERS		((u_long)3)

/*
 * All the defined procedures on it
 */
#define RPCBPROC_NULL		((u_long)0)
#define RPCBPROC_SET		((u_long)1)
#define RPCBPROC_UNSET		((u_long)2)
#define RPCBPROC_GETADDR	((u_long)3)
#define RPCBPROC_DUMP		((u_long)4)
#define RPCBPROC_CALLIT		((u_long)5)
#define RPCBPROC_GETTIME	((u_long)6)
#define RPCBPROC_UADDR2TADDR	((u_long)7)
#define RPCBPROC_TADDR2UADDR	((u_long)8)

/*
 * All rpcbind stuff (vers 3)
 */

/*
 * A mapping of (program, version, network ID) to address
 */
struct rpcb {
	u_long r_prog;			/* program number */
	u_long r_vers;			/* version number */
	char *r_netid;			/* network id */
	char *r_addr;			/* universal address */
	char *r_owner;			/* owner of the mapping */
};
typedef struct rpcb RPCB;
extern bool_t xdr_rpcb();

extern bool_t xdr_netbuf();

/*
 * A list of mappings
 */
struct rpcblist {
	RPCB rpcb_map;
	struct rpcblist *rpcb_next;
};
typedef struct rpcblist RPCBLIST;
extern bool_t xdr_rpcblist();

/*
 * Remote calls arguments
 */
struct rpcb_rmtcallargs {
	u_long prog;			/* program number */
	u_long vers;			/* version number */
	u_long proc;			/* procedure number */
	u_long arglen;			/* arg len */
	caddr_t args_ptr;		/* argument */
	xdrproc_t xdr_args;		/* XDR routine for argument */
};
extern bool_t xdr_rpcb_rmtcallargs();

/*
 * Remote calls results
 */
struct rpcb_rmtcallres {
	char *addr_ptr;			/* remote universal address */
	u_long resultslen;		/* results length */
	caddr_t results_ptr;		/* results */
	xdrproc_t xdr_results;		/* XDR routine for result */
};
extern bool_t xdr_rpcb_rmtcallres();

#endif /*!_RPC_RPCB_PROT_H*/
 070701000008f5000081240000000200000002000000012719347c0000057d000000230000000c00000000000000000000001900000000usr/include/rpc/rpcent.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/rpcent.h.sl 1.1 4.0 10/15/90 17121 AT&T-SF"

/*	@(#)rpcent.h 1.1 88/12/06 SMI	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * rpcent.h,
 * For converting rpc program numbers to names etc.
 *
 */

#ifndef _RPC_RPCENT_H
#define _RPC_RPCENT_H

struct rpcent {
	char	*r_name;	/* name of server for this rpc program */
	char	**r_aliases;	/* alias list */
	int	r_number;	/* rpc program number */
};

extern struct rpcent *getrpcbyname(), *getrpcbynumber(), *getrpcent();
extern int setrpcent();
extern void endrpcent();

#endif /* _RPC_RPCENT_H */
   070701000008f6000081240000000200000002000000012719347c00002948000000230000000c00000000000000000000001600000000usr/include/rpc/svc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/svc.h.sl 1.1 4.0 10/15/90 29577 AT&T-SF"

/*      @(#)svc.h 1.35 88/12/17 SMI      */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * svc.h, Server-side remote procedure call interface.
 *
 */

#ifndef _RPC_SVC_H
#define _RPC_SVC_H

#include <rpc/rpc_com.h>

/*
 * This interface must manage two items concerning remote procedure calling:
 *
 * 1) An arbitrary number of transport connections upon which rpc requests
 * are received. They are created and registered by routines in svc_generic.c,
 * svc_vc.c and svc_dg.c; they in turn call xprt_register and 
 * xprt_unregister.
 *
 * 2) An arbitrary number of locally registered services.  Services are
 * described by the following four data: program number, version number,
 * "service dispatch" function, a transport handle, and a boolean that
 * indicates whether or not the exported program should be registered with a
 * local binder service;  if true the program's number and version and the
 * address from the transport handle are registered with the binder.
 * These data are registered with rpcbind via svc_reg().
 *
 * A service's dispatch function is called whenever an rpc request comes in
 * on a transport.  The request's program and version numbers must match
 * those of the registered service.  The dispatch function is passed two
 * parameters, struct svc_req * and SVCXPRT *, defined below.
 */

enum xprt_stat {
	XPRT_DIED,
	XPRT_MOREREQS,
	XPRT_IDLE
};

/*
 * Server side transport handle
 */
typedef struct {
#ifdef _KERNEL
	TIUSER		*xp_tiptr;
#else
	int		xp_fd;
#define xp_sock		xp_fd
#endif
	u_short		xp_port;	 /* associated port number.
					  * Obsoleted, but still used to
					  * specify whether rendezvouser
					  * or normal connection
					  */
	struct xp_ops {
	    bool_t	(*xp_recv)();	 /* receive incoming requests */
	    enum xprt_stat (*xp_stat)(); /* get transport status */
	    bool_t	(*xp_getargs)(); /* get arguments */
	    bool_t	(*xp_reply)();	 /* send reply */
	    bool_t	(*xp_freeargs)();/* free mem allocated for args */
	    void	(*xp_destroy)(); /* destroy this struct */
	} *xp_ops;
#ifndef _KERNEL
	int		xp_addrlen;	 /* length of remote addr. Obsoleted */
	char		*xp_tp;		 /* transport provider device name */
	char		*xp_netid;	 /* network token */
#endif
	struct netbuf	xp_ltaddr;	 /* local transport address */
	struct netbuf	xp_rtaddr;	 /* remote transport address */
#ifndef _KERNEL
	char		xp_raddr[16];	 /* remote address. Now obsoleted */
#endif
	struct opaque_auth xp_verf;	 /* raw response verifier */
	caddr_t		xp_p1;		 /* private: for use by svc ops */
#ifdef _KERNEL
	u_int		xp_p1len;	 /* size of p1 */
#endif
	caddr_t		xp_p2;		 /* private: for use by svc ops */
	caddr_t		xp_p3;		 /* private: for use by svc lib */
} SVCXPRT;

/*
 *  Approved way of getting address of caller
 */
#define svc_getrpccaller(x) (&(x)->xp_rtaddr)
#ifdef _KERNEL
#define svc_getcaller(x) (&(x)->xp_rtaddr.buf)
#endif

/*
 * Operations defined on an SVCXPRT handle
 *
 * SVCXPRT		*xprt;
 * struct rpc_msg	*msg;
 * xdrproc_t		 xargs;
 * caddr_t		 argsp;
 */
#define SVC_RECV(xprt, msg)				\
	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))
#define svc_recv(xprt, msg)				\
	(*(xprt)->xp_ops->xp_recv)((xprt), (msg))

#define SVC_STAT(xprt)					\
	(*(xprt)->xp_ops->xp_stat)(xprt)
#define svc_stat(xprt)					\
	(*(xprt)->xp_ops->xp_stat)(xprt)

#define SVC_GETARGS(xprt, xargs, argsp)			\
	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))
#define svc_getargs(xprt, xargs, argsp)			\
	(*(xprt)->xp_ops->xp_getargs)((xprt), (xargs), (argsp))

#define SVC_REPLY(xprt, msg)				\
	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))
#define svc_reply(xprt, msg)				\
	(*(xprt)->xp_ops->xp_reply) ((xprt), (msg))

#define SVC_FREEARGS(xprt, xargs, argsp)		\
	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))
#define svc_freeargs(xprt, xargs, argsp)		\
	(*(xprt)->xp_ops->xp_freeargs)((xprt), (xargs), (argsp))

#define SVC_DESTROY(xprt)				\
	(*(xprt)->xp_ops->xp_destroy)(xprt)
#define svc_destroy(xprt)				\
	(*(xprt)->xp_ops->xp_destroy)(xprt)


/*
 * Service request
 */
struct svc_req {
	u_long		rq_prog;	/* service program number */
	u_long		rq_vers;	/* service protocol version */
	u_long		rq_proc;	/* the desired procedure */
	struct opaque_auth rq_cred;	/* raw creds from the wire */
	caddr_t		rq_clntcred;	/* read only cooked cred */
	SVCXPRT		*rq_xprt;	/* associated transport */
};


/*
 * Service registration
 *
 * svc_reg(xprt, prog, vers, dispatch, nconf)
 *	SVCXPRT *xprt;
 *	u_long prog;
 *	u_long vers;
 *	void (*dispatch)();
 *	struct netconfig *nconf;
 */
extern bool_t	svc_reg();

/*
 * Service un-registration
 *
 * svc_unreg(prog, vers)
 *	u_long prog;
 *	u_long vers;
 */
extern void	svc_unreg();

/*
 * Transport registration.
 *
 * xprt_register(xprt)
 *	SVCXPRT *xprt;
 */
extern void	xprt_register();

/*
 * Transport un-register
 *
 * xprt_unregister(xprt)
 *	SVCXPRT *xprt;
 */
extern void	xprt_unregister();


/*
 * When the service routine is called, it must first check to see if it
 * knows about the procedure;  if not, it should call svcerr_noproc
 * and return.  If so, it should deserialize its arguments via 
 * SVC_GETARGS (defined above).  If the deserialization does not work,
 * svcerr_decode should be called followed by a return.  Successful
 * decoding of the arguments should be followed the execution of the
 * procedure's code and a call to svc_sendreply.
 *
 * Also, if the service refuses to execute the procedure due to too-
 * weak authentication parameters, svcerr_weakauth should be called.
 * Note: do not confuse access-control failure with weak authentication!
 *
 * NB: In pure implementations of rpc, the caller always waits for a reply
 * msg.  This message is sent when svc_sendreply is called.  
 * Therefore pure service implementations should always call
 * svc_sendreply even if the function logically returns void;  use
 * xdr.h - xdr_void for the xdr routine.  HOWEVER, connectionful rpc allows
 * for the abuse of pure rpc via batched calling or pipelining.  In the
 * case of a batched call, svc_sendreply should NOT be called since
 * this would send a return message, which is what batching tries to avoid.
 * It is the service/protocol writer's responsibility to know which calls are
 * batched and which are not.  Warning: responding to batch calls may
 * deadlock the caller and server processes!
 */

extern bool_t	svc_sendreply();
extern void	svcerr_decode();
extern void	svcerr_weakauth();
extern void	svcerr_noproc();
extern void	svcerr_progvers();
extern void	svcerr_auth();
extern void	svcerr_noprog();
#ifndef _KERNEL
extern void	svcerr_systemerr();
#endif
    
/*
 * Lowest level dispatching -OR- who owns this process anyway.
 * Somebody has to wait for incoming requests and then call the correct
 * service routine.  The routine svc_run does infinite waiting; i.e.,
 * svc_run never returns.
 * Since another (co-existant) package may wish to selectively wait for
 * incoming calls or other events outside of the rpc architecture, the
 * routine svc_getreq is provided.  It must be passed readfds, the
 * "in-place" results of a select call (see select, section XXX).
 */

#ifndef _KERNEL
/*
 * Global keeper of rpc service descriptors in use
 * dynamic; must be inspected before each call to select 
 */
extern fd_set svc_fdset;
#define svc_fds svc_fdset.fds_bits[0]	/* compatibility */

/*
 * a small program implemented by the svc_rpc implementation itself;
 * also see clnt.h for protocol numbers.
 */
extern void rpctest_service();
#endif /* !_KERNEL */

extern void	svc_getreq();
#ifndef _KERNEL
extern void	svc_getreqset();	/* takes fdset instead of int */
#endif
extern void	svc_run();


#ifndef _KERNEL
/*
 * These are the existing service side transport implementations
 */
/*
 * Transport independent svc_create routine.
 */
extern int
svc_create(/* dispatch, prognum, versnum, nettype*/); /*
	void (*dispatch)();		-- dispatch routine
	u_long prognum;			-- program number
	u_long versnum;			-- version number
	char *nettype;			-- network type
*/

/*
 * Generic server creation routine. It takes a netconfig structure
 * instead of a nettype.
 */
extern SVCXPRT	*
svc_tp_create(/* dispatch, prognum, versnum, nconf*/); /*
	void (*dispatch)();		-- dispatch routine
	u_long prognum;			-- program number
	u_long versnum;			-- version number
	struct netconfig *nconf;	-- netconfig structure
*/

/*
 * Generic TLI create routine
 */
extern SVCXPRT *
svc_tli_create(/* fd, nconf, bindaddr, sendsz, recvsz*/) ; /*
	int fd;			 	-- connection end point
	struct netconfig *nconf;	-- netconfig structure for network
	struct t_bind *bindaddr;	-- local bind address
	u_int sendsz;			-- max sendsize
	u_int recvsz;			-- max recvsize
*/

/*
 * Connectionless and connectionful create routines
 */
extern SVCXPRT	*
svc_vc_create(/* fd, sendsize, recvsize*/); /*
	int fd;				-- open connection end point
	u_int sendsize;			-- max send size
	u_int recvsize;			-- max recv size
*/

extern SVCXPRT	*
svc_dg_create(/* fd, sendsize, recvsize*/); /*
	int fd;				-- open connection end point
	u_int sendsize;			-- max send size
	u_int recvsize;			-- max recv size
*/

/*
 * the routine takes any *open* TLI file
 * descriptor as its first input and is used for open connections.
 */
extern SVCXPRT *
svc_fd_create(/* fd, sendsize, recvsize*/); /*
	int fd;				-- open connection end point
	u_int sendsize;			-- max send size
	u_int recvsize;			-- max recv size
*/

/*
 * Memory based rpc (for speed check and testing)
 */
extern SVCXPRT *
svc_raw_create();

#ifdef PORTMAP
/* For backword compatibility */
#include <rpc/svc_soc.h>
#endif

#else
/* kernel based rpc
 */
extern int svc_tli_kcreate();
#endif /* !_KERNEL */
#endif /* !_RPC_SVC_H */
070701000008f7000081240000000200000002000000012719347c000004b2000000230000000c00000000000000000000001b00000000usr/include/rpc/svc_auth.h    /*	Copyright (c) 1984, 1986, 1987, 1988 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_SVCAUTH_H
#define _RPC_SVCAUTH_H

#ident	"@(#)/usr/include/rpc/svc_auth.h.sl 1.1 4.0 10/15/90 47532 AT&T-SF"

/*      @(#)svc_auth.h 1.10 88/10/25 SMI      */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * svc_auth.h, Service side of rpc authentication.
 */

/*
 * Server side authenticator
 */
extern enum auth_stat _authenticate();

#endif	/* _RPC_SVCAUTH_H */
  070701000008f8000081240000000200000002000000012719347c00000835000000230000000c00000000000000000000001a00000000usr/include/rpc/svc_soc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/svc_soc.h.sl 1.1 4.0 10/15/90 33281 AT&T-SF"

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*	PROPRIETARY NOTICE (Combined)
*
* This source code is unpublished proprietary information
* constituting, or derived under license from AT&T's UNIX(r) System V.
* In addition, portions of such source code were derived from Berkeley
* 4.3 BSD under license from the Regents of the University of
* California.
*
*
*
*	Copyright Notice 
*
* Notice of copyright on this source code product does not indicate 
*  publication.
*
*	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
*	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
*          All rights reserved.
*/ 

/*      @(#)svc_soc.h 1.8 89/05/01 SMI      */

/*
 * svc.h, Server-side remote procedure call interface.
 */

#ifndef _RPC_SVC_SOC_H
#define _RPC_SVC_SOC_H

/*
 * All the following declarations are only for backward compatibility
 * with SUNOS 4.0.
 */

#include <sys/socket.h>
#include <netinet/in.h>

/*
 *  Approved way of getting address of caller
 */
#define svc_getcaller(x) ((struct sockaddr_in *)(x)->xp_rtaddr.buf)

/*
 * Service registration
 *
 * svc_register(xprt, prog, vers, dispatch, protocol)
 *	SVCXPRT *xprt;
 *	u_long prog;
 *	u_long vers;
 *	void (*dispatch)();
 *	int protocol;  /* like TCP or UDP, zero means do not register 
 */
extern bool_t svc_register();

/*
 * Service un-registration
 *
 * svc_unregister(prog, vers)
 *	u_long prog;
 *	u_long vers;
 */
extern void svc_unregister();

/*
 * Memory based rpc for testing and timing.
 */
extern SVCXPRT *svcraw_create();

/*
 * Udp based rpc. For compatibility reasons
 */
extern SVCXPRT *svcudp_create();
extern SVCXPRT *svcudp_bufcreate();

/*
 * Tcp based rpc.
 */
extern SVCXPRT *svctcp_create();
extern SVCXPRT *svcfd_create();

#else

#endif /* !_RPC_SVC_SOC_H */
   070701000008f9000081240000000200000002000000012719347c0000081a000000230000000c00000000000000000000001800000000usr/include/rpc/types.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _RPC_TYPES_H
#define _RPC_TYPES_H

#ident	"@(#)/usr/include/rpc/types.h.sl 1.1 4.0 10/15/90 61479 AT&T-SF"

/*      @(#)types.h 1.23 88/10/25 SMI      */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * Rpc additions to <sys/types.h>
 */
#include <sys/types.h>

#define	bool_t	int
#define	enum_t	int
#define __dontcare__	-1

#ifndef FALSE
#	define	FALSE	(0)
#endif

#ifndef TRUE
#	define	TRUE	(1)
#endif

#ifndef NULL
#	define NULL 0
#endif

#ifndef _KERNEL
#define mem_alloc(bsize)	malloc(bsize)
#define mem_free(ptr, bsize)	free(ptr)
#else
#include <sys/kmem.h>		/* XXX */
extern _VOID *kmem_alloc();
#define mem_alloc(bsize)	kmem_alloc((u_int)bsize, KM_SLEEP)
#define mem_free(ptr, bsize)	kmem_free((caddr_t)(ptr), (u_int)(bsize))

#ifdef DEBUG
extern int	rpc_log();
extern int	rpclog;

#define		RPCLOG(A, B, C) ((void)((rpclog) && rpc_log((A), (B), (C))))
#else
#define		RPCLOG(A, B, C)
#endif

#endif

#ifdef _NSL_RPC_ABI
/* For internal use only when building the libnsl RPC routines */
#define select	_abi_select
#define gettimeofday	_abi_gettimeofday
#define syslog	_abi_syslog
#define getgrent	_abi_getgrent
#define endgrent	_abi_endgrent
#define setgrent	_abi_setgrent
#endif

#include <sys/time.h>

#endif	/* _RPC_TYPES_H */
  070701000008fa000081240000000200000002000000012719347c000023d2000000230000000c00000000000000000000001600000000usr/include/rpc/xdr.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/rpc/xdr.h.sl 1.1 4.0 10/15/90 9301 AT&T-SF"

/*      @(#)xdr.h 1.26 88/12/17 SMI      */

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * xdr.h, External Data Representation Serialization Routines.
 *
 */

#ifndef _RPC_XDR_H
#define _RPC_XDR_H

#include <sys/byteorder.h>	    /* For all ntoh* and hton*() kind of macros */
/*
 * XDR provides a conventional way for converting between C data
 * types and an external bit-string representation.  Library supplied
 * routines provide for the conversion on built-in C data types.  These
 * routines and utility routines defined here are used to help implement
 * a type encode/decode routine for each user-defined type.
 *
 * Each data type provides a single procedure which takes two arguments:
 *
 *	bool_t
 *	xdrproc(xdrs, argresp)
 *		XDR *xdrs;
 *		<type> *argresp;
 *
 * xdrs is an instance of a XDR handle, to which or from which the data
 * type is to be converted.  argresp is a pointer to the structure to be
 * converted.  The XDR handle contains an operation field which indicates
 * which of the operations (ENCODE, DECODE * or FREE) is to be performed.
 *
 * XDR_DECODE may allocate space if the pointer argresp is null.  This
 * data can be freed with the XDR_FREE operation.
 *
 * We write only one procedure per data type to make it easy
 * to keep the encode and decode procedures for a data type consistent.
 * In many cases the same code performs all operations on a user defined type,
 * because all the hard work is done in the component type routines.
 * decode as a series of calls on the nested data types.
 */

/*
 * Xdr operations.  XDR_ENCODE causes the type to be encoded into the
 * stream.  XDR_DECODE causes the type to be extracted from the stream.
 * XDR_FREE can be used to release the space allocated by an XDR_DECODE
 * request.
 */
enum xdr_op {
	XDR_ENCODE=0,
	XDR_DECODE=1,
	XDR_FREE=2
};

/*
 * This is the number of bytes per unit of external data.
 */
#define BYTES_PER_XDR_UNIT	(4)
#define RNDUP(x)  ((((x) + BYTES_PER_XDR_UNIT - 1) / BYTES_PER_XDR_UNIT) \
		    * BYTES_PER_XDR_UNIT)

/*
 * A xdrproc_t exists for each data type which is to be encoded or decoded.
 *
 * The second argument to the xdrproc_t is a pointer to an opaque pointer.
 * The opaque pointer generally points to a structure of the data type
 * to be decoded.  If this pointer is 0, then the type routines should
 * allocate dynamic storage of the appropriate size and return it.
 * bool_t	(*xdrproc_t)(XDR *, caddr_t *);
 */
typedef	bool_t (*xdrproc_t)();

/*
 * The XDR handle.
 * Contains operation which is being applied to the stream,
 * an operations vector for the paticular implementation (e.g. see xdr_mem.c),
 * and two private fields for the use of the particular impelementation.
 */
typedef struct {
	enum xdr_op	x_op;		/* operation; fast additional param */
	struct xdr_ops {
		bool_t	(*x_getlong)();	/* get a long from underlying stream */
		bool_t	(*x_putlong)();	/* put a long to " */
		bool_t	(*x_getbytes)();/* get some bytes from " */
		bool_t	(*x_putbytes)();/* put some bytes to " */
		u_int	(*x_getpostn)();/* returns bytes off from beginning */
		bool_t  (*x_setpostn)();/* lets you reposition the stream */
		long *	(*x_inline)();	/* buf quick ptr to buffered data */
		void	(*x_destroy)();	/* free privates of this xdr_stream */
	} *x_ops;
	caddr_t 	x_public;	/* users' data */
	caddr_t		x_private;	/* pointer to private data */
	caddr_t 	x_base;		/* private used for position info */
	int		x_handy;	/* extra private word */
} XDR;

/*
 * Operations defined on a XDR handle
 *
 * XDR		*xdrs;
 * long		*longp;
 * caddr_t	 addr;
 * u_int	 len;
 * u_int	 pos;
 */
#define XDR_GETLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
#define xdr_getlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_getlong)(xdrs, longp)

#define XDR_PUTLONG(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
#define xdr_putlong(xdrs, longp)			\
	(*(xdrs)->x_ops->x_putlong)(xdrs, longp)

#define XDR_GETBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
#define xdr_getbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)

#define XDR_PUTBYTES(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
#define xdr_putbytes(xdrs, addr, len)			\
	(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)

#define XDR_GETPOS(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)
#define xdr_getpos(xdrs)				\
	(*(xdrs)->x_ops->x_getpostn)(xdrs)

#define XDR_SETPOS(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
#define xdr_setpos(xdrs, pos)				\
	(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)

#define	XDR_INLINE(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)
#define	xdr_inline(xdrs, len)				\
	(*(xdrs)->x_ops->x_inline)(xdrs, len)

#define	XDR_DESTROY(xdrs)				\
	(*(xdrs)->x_ops->x_destroy)(xdrs)
#define	xdr_destroy(xdrs) XDR_DESTROY(xdrs)

/*
 * Support struct for discriminated unions.
 * You create an array of xdrdiscrim structures, terminated with
 * a entry with a null procedure pointer.  The xdr_union routine gets
 * the discriminant value and then searches the array of structures
 * for a matching value.  If a match is found the associated xdr routine
 * is called to handle that part of the union.  If there is
 * no match, then a default routine may be called.
 * If there is no match and no default routine it is an error.
 */
#define NULL_xdrproc_t ((xdrproc_t)0)
struct xdr_discrim {
	int	value;
	xdrproc_t proc;
};

/*
 * In-line routines for fast encode/decode of primitve data types.
 * Caveat emptor: these use single memory cycles to get the
 * data from the underlying buffer, and will fail to operate
 * properly if the data is not aligned.  The standard way to use these
 * is to say:
 *	if ((buf = XDR_INLINE(xdrs, count)) == NULL)
 *		return (FALSE);
 *	<<< macro calls >>>
 * where ``count'' is the number of bytes of data occupied
 * by the primitive data types.
 *
 * N.B. and frozen for all time: each data type here uses 4 bytes
 * of external representation.
 */
#define IXDR_GET_LONG(buf)		((long)ntohl((u_long)*(buf)++))
#define IXDR_PUT_LONG(buf, v)		(*(buf)++ = (long)htonl((u_long)v))

#define IXDR_GET_BOOL(buf)		((bool_t)IXDR_GET_LONG(buf))
#define IXDR_GET_ENUM(buf, t)		((t)IXDR_GET_LONG(buf))
#define IXDR_GET_U_LONG(buf)		((u_long)IXDR_GET_LONG(buf))
#define IXDR_GET_SHORT(buf)		((short)IXDR_GET_LONG(buf))
#define IXDR_GET_U_SHORT(buf)		((u_short)IXDR_GET_LONG(buf))

#define IXDR_PUT_BOOL(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_ENUM(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_LONG(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_SHORT(buf, v)		IXDR_PUT_LONG((buf), ((long)(v)))
#define IXDR_PUT_U_SHORT(buf, v)	IXDR_PUT_LONG((buf), ((long)(v)))

/*
 * These are the "generic" xdr routines.
 */
extern bool_t	xdr_void();
extern bool_t	xdr_int();
extern bool_t	xdr_u_int();
extern bool_t	xdr_long();
extern bool_t	xdr_u_long();
extern bool_t	xdr_short();
extern bool_t	xdr_u_short();
extern bool_t	xdr_bool();
extern bool_t	xdr_enum();
extern bool_t	xdr_array();
extern bool_t	xdr_bytes();
extern bool_t	xdr_opaque();
extern bool_t	xdr_string();
extern bool_t	xdr_union();
#ifndef _KERNEL
extern bool_t	xdr_char();
extern bool_t	xdr_u_char();
extern bool_t	xdr_vector();
extern bool_t	xdr_float();
extern bool_t	xdr_double();
extern bool_t	xdr_reference();
extern bool_t	xdr_pointer();
extern bool_t	xdr_wrapstring();
#endif /* !_KERNEL */

/*
 * Common opaque bytes objects used by many rpc protocols;
 * declared here due to commonality.
 */
#define MAX_NETOBJ_SZ 1024 
struct netobj {
	u_int	n_len;
	char	*n_bytes;
};
typedef struct netobj netobj;
extern bool_t   xdr_netobj();

/*
 * These are the public routines for the various implementations of
 * xdr streams.
 */
extern void   xdrmem_create();		/* XDR using memory buffers */
#ifndef _KERNEL
extern void   xdrstdio_create();	/* XDR using stdio library */
extern void   xdrrec_create();		/* XDR pseudo records for tcp */
extern bool_t xdrrec_endofrecord();	/* make end of xdr record */
extern bool_t xdrrec_skiprecord();	/* move to beginning of next record */
extern bool_t xdrrec_eof();		/* true if no more input */
#else
extern void xdrmbuf_init();		/* XDR using kernel mbufs */
#endif /* !_KERNEL */

#endif /* !_RPC_XDR_H */
  070701000051bd000081240000000200000002000000012719347c00000424000000230000000c00000000000000000000001200000000usr/include/std.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/std.h.sl 1.1 4.0 10/15/90 11361 AT&T-SF"

/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */

/*
 *	@(#) std.h 1.1 88/03/30 inccmd:std.h
 */
#define	SYSBSIZE	BSIZE		/* system block size */
#define	SYSBSHIFT	BSHIFT

#define	EFFBSIZE	SYSBSIZE	/* efficient block size */
#define	EFFBSHIFT	SYSBSHIFT

#define	MULWSIZE	2		/* multiplier 'word' */
#define	MULWSHIFT	1
#define	MULLSIZE	4		/* multiplier 'long' */
#define	MULLSHIFT	2
#define	MULBSIZE	512		/* multiplier 'block' */
#define	MULBSHIFT	9
#define	MULKSIZE	1024		/* multiplier 'k' */
#define	MULKSHIFT	10

#define	SYSTOMUL(sysblk)	((sysblk) * (SYSBSIZE / MULBSIZE))
070701000051bf000081240000000200000002000000012719347c0000028b000000230000000c00000000000000000000001200000000usr/include/sum.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sum.h.sl 1.1 4.0 10/15/90 26879 AT&T-SF"

/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */

/*
 *	$Header: RCS/sum.h,v 1.4 88/04/26 05:38:41 root Exp $
 */
struct suminfo {
	long	si_nbytes;
	long	si_sum;
};
 070701000058b9000041fd000000020000000200000004271c4ec000000000000000230000000c00000000000000000000001000000000usr/include/sys   07070100005a38000081240000000200000002000000012719347c000008db000000230000000c00000000000000000000001700000000usr/include/sys/acct.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ACCT_H
#define _SYS_ACCT_H

#ident	"@(#)/usr/include/sys/acct.h.sl 1.1 4.0 10/15/90 22446 AT&T-SF"
/*
 * Accounting structures
 */

typedef	ushort comp_t;		/* "floating point" */
		/* 13-bit fraction, 3-bit exponent  */

/* SVR4 acct structure */
struct	acct
{
	char	ac_flag;		/* Accounting flag */
	char	ac_stat;		/* Exit status */
	uid_t	ac_uid;			/* Accounting user ID */
	gid_t	ac_gid;			/* Accounting group ID */
	dev_t	ac_tty;			/* control typewriter */
	time_t	ac_btime;		/* Beginning time */
	comp_t	ac_utime;		/* acctng user time in clock ticks */
	comp_t	ac_stime;		/* acctng system time in clock ticks */
	comp_t	ac_etime;		/* acctng elapsed time in clock ticks */
	comp_t	ac_mem;			/* memory usage */
	comp_t	ac_io;			/* chars transferred */
	comp_t	ac_rw;			/* blocks read or written */
	char	ac_comm[8];		/* command name */
};	

/* Account commands will use this header to read SVR3
** accounting data files.
*/

struct	o_acct
{
	char	ac_flag;		/* Accounting flag */
	char	ac_stat;		/* Exit status */
	o_uid_t	ac_uid;			/* Accounting user ID */
	o_gid_t	ac_gid;			/* Accounting group ID */
	o_dev_t	ac_tty;			/* control typewriter */
	time_t	ac_btime;		/* Beginning time */
	comp_t	ac_utime;		/* acctng user time in clock ticks */
	comp_t	ac_stime;		/* acctng system time in clock ticks */
	comp_t	ac_etime;		/* acctng elapsed time in clock ticks */
	comp_t	ac_mem;			/* memory usage */
	comp_t	ac_io;			/* chars transferred */
	comp_t	ac_rw;			/* blocks read or written */
	char	ac_comm[8];		/* command name */
};	

extern	struct	acct	acctbuf;
extern	struct	vnode	*acctp;		/* vnode of accounting file */

#if !defined(_KERNEL)
#if defined(__STDC__)
extern int acct(const char *);
#else
extern int acct();
#endif
#endif /* !defined(_KERNEL) */

#define	AFORK	01		/* has executed fork, but no exec */
#define	ASU	02		/* used super-user privileges */
#define	ACCTF	0300		/* record type: 00 = acct */
#define AEXPND	040		/* expanded acct structure */

#endif	/* _SYS_ACCT_H */
 07070100005877000081240000000200000002000000012719347c000002eb000000230000000c00000000000000000000001600000000usr/include/sys/adv.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sys/adv.h.sl 1.1 4.0 10/15/90 50010 AT&T-SF"
 
/*
 *	advertise structure.
 *	one entry per advertised object.
 */

struct	advertise	{
	int	a_flags;		/* defines are in sys/nserve.h	*/
	int	a_count;		/* number of active rmounts	*/
	char	a_name [NMSZ];		/* name sent to name server	*/
	struct	rcvd	*a_queue;	/* receive queue for this name	*/
	char	*a_clist;		/* ref to authorization list	*/
} ;

#ifdef INKERNEL

extern	struct	advertise	advertise[];

#endif
 07070100005878000081240000000200000002000000012719347c0000055c000000230000000c00000000000000000000001900000000usr/include/sys/alttbl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ALTTBL_H
#define _SYS_ALTTBL_H
#ident	"@(#)/usr/include/sys/alttbl.h.sl 1.1 4.0 10/15/90 44528 AT&T-SF"

/*
 * ALTTBL.H
 *
 * This file defines the bad block table for the hard disk driver.
 *	The same table structure is used for the bad track table.
*/

#define MAX_ALTENTS     253	/* Maximum # of slots for alts	*/
				/* allowed for in the table.	*/

#define ALT_SANITY      0xdeadbeef      /* magic # to validate alt table */
#define ALT_VERSION	0x02		/* version of table 		 */

struct  alt_table {
	ushort  alt_used;	/* # of alternates already assigned	*/
	ushort  alt_reserved;	/* # of alternates reserved on disk	*/
	daddr_t alt_base;	/* 1st sector (abs) of the alt area	*/
	daddr_t alt_bad[MAX_ALTENTS];	/* list of bad sectors/tracks	*/
};

struct alt_info {	/* table length should be multiple of 512	*/
	long    alt_sanity;	/* to validate correctness		*/
	ushort  alt_version;	/* to corroborate vintage		*/
	ushort  alt_pad;	/* padding for alignment		*/
	struct alt_table alt_trk;	/* bad track table	*/
	struct alt_table alt_sec;	/* bad sector table	*/
};

#endif /* _SYS_ALTTBL_H */
070701000058e1000081240000000200000002000000012719347c000006d1000000230000000c00000000000000000000001700000000usr/include/sys/ansi.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ansi.h.sl 1.1 4.0 10/15/90 46064 AT&T-SF"

#ifndef	_SYS_ANSI_H
#define	_SYS_ANSI_H
/*
 * definitions for Integrated Workstation Environment ANSI x3.64 
 * terminal control language parser 
 */

#define ANSI_MAXPARAMS	5	/* maximum number of ANSI paramters */
#define ANSI_MAXTAB	40	/* maximum number of tab stops */
#define ANSI_MAXFKEY	30	/* max length of function key with <ESC>Q */


#define	ANSIPSZ		64	/* max packet size sent by ANSI */

/*
 * Font values for ansistate
 */
#define	ANSI_FONT0	0	/* Primary font (default) */
#define	ANSI_FONT1	1	/* First alternate font */
#define	ANSI_FONT2	2	/* Second alternate font */

#define	ANSI_BLKOUT	0x8000	/* Scroll lock, for M_START, M_STOP */

struct ansi_state {		/* state for ansi x3.64 emulator */
	ushort	a_flags;	/* flags for this x3.64 terminal */
	unchar	a_font;		/* font type */
	unchar	a_state;	/* state in output esc seq processing */
	unchar	a_gotparam;	/* does output esc seq have a param */
	ushort	a_curparam;	/* current param # of output esc seq */
	ushort	a_paramval;	/* value of current param */
	short	a_params[ANSI_MAXPARAMS];  /* parameters of output esc seq */
	char	a_fkey[ANSI_MAXFKEY];	/* work space for function key */
	mblk_t	*a_wmsg;	/* ptr to data message being assembled */
	queue_t	*a_wqp;		/* ptr to write queue for associated stream */
	queue_t	*a_rqp;		/* ptr to read queue for associated stream */
};


typedef struct ansi_state ansistat_t;

#endif /* _SYS_ANSI_H */
   07070100005943000081240000000200000002000000012719347c000003e7000000230000000c00000000000000000000001800000000usr/include/sys/ascii.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ASCII_H
#define _SYS_ASCII_H

#ident	"@(#)/usr/include/sys/ascii.h.sl 1.1 4.0 10/15/90 52300 AT&T-SF"

#define A_NUL	0
#define A_SOH	1
#define A_STX	2
#define A_ETX	3
#define A_EOT	4
#define A_ENQ	5
#define A_ACK	6
#define A_BEL	7
#define A_BS	8
#define A_HT	9
#define A_NL	10
#define A_LF	10
#define A_VT	11
#define A_FF	12
#define A_NP	12
#define A_CR	13
#define A_SO	14
#define A_SI	15
#define A_DLE	16
#define A_DC1	17
#define A_DC2	18
#define A_DC3	19
#define A_DC4	20
#define A_NAK	21
#define A_SYN	22
#define A_ETB	23
#define A_CAN	24
#define A_EM	25
#define A_SUB	26
#define A_ESC	27
#define A_FS	28
#define A_GS	29
#define A_RS	30
#define A_US	31
#define A_DEL	127
#define A_CSI	0x9b

#endif /* _SYS_ASCII_H */
 07070100005944000081240000000200000002000000012719347c000013f0000000230000000c00000000000000000000001600000000usr/include/sys/asy.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/asy.h.sl 1.1 4.0 10/15/90 2574 AT&T-SF"

#define SPL()		spltty()/* protection from interrupts */

/*
 * Definitions for INS8250 / 16550  chips
 */

	/* defined as offsets from the data register */
#define DAT     0   /* receive/transmit data */
#define ICR     1   /* interrupt control register */
#define ISR     2   /* interrupt status register */
#define LCR     3   /* line control register */
#define MCR     4   /* modem control register */
#define LSR     5   /* line status register */
#define MSR     6   /* modem status register */
#define DLL     0   /* divisor latch (lsb) */
#define DLH     1   /* divisor latch (msb) */

/*
 * INTEL 8210-A/B & 16450/16550 Registers Structure.
 */

/* Line Control Register */
#define		WLS0	0x01		/*word length select bit 0 */	
#define		WLS1	0x02		/*word length select bit 2 */	
#define		STB	0x04		/* number of stop bits */
#define		PEN	0x08		/* parity enable */
#define		EPS	0x10		/* even parity select */
#define		SETBREAK 0x40		/* break key */
#define		DLAB	0x80		/* divisor latch access bit */
#define 	RXLEN   0x03    /* # of data bits per received/xmitted character */
#define 	STOP1   0x00
#define 	STOP2   0x04
#define 	PAREN   0x08
#define 	PAREVN  0x10
#define 	PARMARK 0x20
#define 	SNDBRK  0x40
#define 	DLAB    0x80


#define		BITS5	0x00		/* 5 bits per char */
#define		BITS6	0x01		/* 6 bits per char */
#define		BITS7	0x02		/* 7 bits per char */
#define		BITS8	0x03		/* 8 bits per char */

/* Line Status Register */
#define		RCA	0x01		/* data ready */
#define		OVRRUN	0x02		/* overrun error */
#define		PARERR	0x04		/* parity error */
#define		FRMERR	0x08		/* framing error */
#define		BRKDET 0x10		/* a break has arrived */
#define		XHRE	0x20		/* tx hold reg is now empty */
#define		XSRE	0x40		/* tx shift reg is now empty */
#define		RFBE	0x80		/* rx FIFO Buffer error */

/* Interrupt Id Regisger */
#define		MSTATUS	0x00
#define		TxRDY	0x02
#define		RxRDY	0x04
#define		ERROR_INTR	0x08

/* Interrupt Enable Register */
#define		FFTMOUT 0x0c		/* tmp for ringbuf mary */
#define		RSTATUS 0x06		/* tmp for ringbuf mary */
#define		RIEN	0x01		/* Received Data Ready */
#define		TIEN	0x02		/* Tx Hold Register Empty */
#define		SIEN	0x04	/* Receiver Line Status */
#define		MIEN	0x08	/* Modem Status */

/* Modem Control Register */
#define		DTR		0x01	/* Data Terminal Ready */
#define		RTS		0x02	/* Request To Send */
#define		OUT1		0x04	/* Aux output - not used */
#define		OUT2		0x08	/* turns intr to 386 on/off */	
#define		ASY_LOOP	0x10	/* loopback for diagnostics */

/* Modem Status Register */
#define		DCTS		0x01	/* Delta Clear To Send */
#define		DDSR		0x02	/* Delta Data Set Ready */
#define		DRI		0x04	/* Trail Edge Ring Indicator */
#define		DDCD		0x08	/* Delta Data Carrier Detect */
#define		CTS		0x10	/* Clear To Send */
#define		DSR		0x20	/* Data Set Ready */
#define		RI		0x40	/* Ring Indicator */
#define		DCD		0x80	/* Data Carrier Detect */

#define 	DELTAS(x) 	((x)&(DCTS|DDSR|DRI|DDCD))
#define 	STATES(x) 	((x)(CTS|DSR|RI|DCD))


#define 	asychan(dev)    (dev&0x0f)
#define 	asymajor(dev)   ((dev>>8)&0x7f)
#define 	FIFOEN	0x8f	/* fifo enabled, w/ 8 byte trigger */

/* asy_flags definitions */
#define 	XBRK	0x01            /* xmitting break in progress */
#define		HWDEV	0x02		/* Hardware device being used */
#define		HWFLWO	0x04		/* H/W Flow ON */
#define		HWFLWS	0x08		/* Start H/W after CSTOP */
#define		ASY82510	0x40	/* 1 - 82510 , 0 - 16450/16550/8250 */
#define		ASYHERE	0x80		/* adapter is present */
#define 	BRKTIME	HZ/4

/*
 * Defines for ioctl calls (VP/ix)
 */

#define AIOC			('A'<<8)
#define AIOCINTTYPE		(AIOC|60)	/* set interrupt type */
#define AIOCDOSMODE		(AIOC|61)	/* set DOS mode */
#define AIOCNONDOSMODE		(AIOC|62)	/* reset DOS mode */
#define AIOCSERIALOUT		(AIOC|63)	/* serial device data write */
#define AIOCSERIALIN		(AIOC|64)	/* serial device data read */
#define AIOCSETSS		(AIOC|65)	/* set start/stop chars */
#define AIOCINFO		(AIOC|66)	/* tell usr what device we are */

/* Ioctl alternate names used by VP/ix */
#define VPC_SERIAL_DOS		AIOCDOSMODE	
#define VPC_SERIAL_NONDOS	AIOCNONDOSMODE
#define VPC_SERIAL_INFO		AIOCINFO
#define VPC_SERIAL_OUT		AIOCSERIALOUT
#define VPC_SERIAL_IN		AIOCSERIALIN

/* Serial in/out requests */
#define SO_DIVLLSB		1
#define SO_DIVLMSB		2
#define SO_LCR			3
#define SO_MCR			4
#define SI_MSR			1
#define SIO_MASK(elem)		(1<<((elem)-1))


/*
 * Asychronous configuration Structures 
 */

struct asy{
	int		asy_flags;
	unsigned	asy_dat;
	unsigned	asy_icr;
	unsigned	asy_isr;
	unsigned	asy_lcr;
	unsigned	asy_mcr;
	unsigned	asy_lsr;
	unsigned	asy_msr;
	unsigned	asy_vect;
	struct msgb	*asyrbp;
	minor_t		asy_dev;
#ifdef MERGE386
	int (*asy_ppi_func)();		/* Merge asy func pointer */
	unsigned char *asy_ppi_data;	/* merge data */
#endif /* MERGE386 */
};

07070100005a52000081240000000200000002000000012719347c000012c3000000230000000c00000000000000000000001800000000usr/include/sys/async.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RAIO_H
#define _SYS_RAIO_H

#ident	"@(#)/usr/include/sys/async.h.sl 1.1 4.0 10/15/90 11641 AT&T-SF"

#include <sys/types.h>
#include <sys/buf.h>
#include <sys/ioccom.h>

/*
 *		File Contents
 *		=============
 *
 *	This file contains data which must be included in an 
 *	application program using the async raw disk I/O facility.
 */

typedef struct  areqbuf {
	long	au_cmd;			/* async read/wrtie command */
	long	au_daddr;		/* destination on disk */
	char	*au_maddr;		/* user virtual address */
	long	au_size;		/* bytes to transfer */
 	char	*au_ref;		/* user context reference ptr */
} AREQBUF;

/* 
 * Command bits
 * Pyramid's AU_ORDWRITE command is treated as AU_WRITE
 */
#define	AU_READ		01		/* read request */
#define	AU_WRITE	02		/* unordered write request */
#define	AU_CMDMASK	07		/* mask of command bits */

/* 
 * data structure for locking raio memory
 */
typedef struct	asyncmlock
{
	char	*avaddr;		/* starting virtual addr */
	uint	asize;			/* size of area to be locked */
} ASYNCMLOCK;

typedef struct aiostat
{
	short	iostatus;		/* I/O completion status for request */
	short	iobsize;		/* verification (from AREQBUF au_size) */
	char	*iomaddr;		/* verification (from AREQBUF au_maddr)*/
 	char	*ioref;			/* user context ref ptr (from AREQBUF au_ref )*/
} IOSTAT;

/*
 * The max # of RAIO status can be polled at one time
 * This parameter can be adjusted as needed
 */
#define	MAXSTATUS	15

typedef struct asyncstatus
{
	long		acount;			/* # of status being returned */
	IOSTAT		astatus[MAXSTATUS];	/* raiostst_t array */
} ASYNCSTATUS;

/* 
 * Starting raw disk async I/O (DKIOCASTRT)
 *
 * 'S' and '1' define a unique ioctl command number. 
 * Using _IOW specifies that the parameter is for input only.
 */

#define DKIOCASTRT	_IOW('S', 1, AREQBUF)

/* 
 * Pull I/O completion status (DKIOCASTAT)
 *
 * 'S' and '2' define a unique ioctl command number. 
 * Using _IOR specifies that the parameter is for output only.
 */

#define DKIOCASTAT	_IOR('S', 2, ASYNCSTATUS)

/* 
 * Locking memory for I/O (DKIOCMLOCK)
 *
 * 'S' and '3' define a unique ioctl command number. 
 * Using _IOW specifies that the parameter is for input only.
 */

#define DKIOCMLOCK	_IOW('S', 3, ASYNCMLOCK)

/* 
 * Obtaining version # of the raw disk async I/ O Facility (DKIOCAIOVERS)
 *
 * 'S' and '4' define a unique ioctl command number. 
 * Using _IOR specifies that the parameter is for output only.
 */

#define DKIOCAIOVERS	_IOR('S', 4, long)

#define AIOVERSION	1

#ifdef _KERNEL

typedef struct raiobuf
{
	buf_t		abuf;		/* regular buf */
	long		absize;		/* au_size in AREQBUF */
	caddr_t		amaddr;		/* au_maddr in AREQBUF */
 	char		*aref;		/* au_ref in AREQBUF */
	uint		aflags;		/* buffer flag extension, see below  */ 
} raiobuf_t;

/* bit definition of aflags in raiobuf_t */ 
#define	B_RAIOSIG	0x1		/* send SIGIO when I/O is done */

/*
 * A new flag, B_RAIO, is added in buf.h to denote an raw disk async io buffer. 
 * The use of B_RAIO is as follows:  If B_RAIO is set, then the driver has
 * the buffer. Otherwise, the request is either in the raw disk asynchronous i/o 
 * done queue, or has been processed (and is fully free).
 */

#define	israiobuf(bp)	((bp)->b_flags & B_RAIO)

typedef struct raiolist
{
	raiobuf_t	*ahead;		/* first raiobuf in list */
	raiobuf_t	*atail;		/* last raiobuf in list */
} raiolist_t;				

extern	raiobuf_t	raiopool[];	/* buffer pool */
extern	int		nraiobuf;	/* number of raio buffers allocated */

/*
 * macros to get and release buffers for raw disk aio. 
 */

#define	getrabuf() \
	raiofree; if (raiofree) raiofree = (raiobuf_t *)(raiofree->abuf.av_forw);

#define	relrabuf(bp) \
	(bp)->abuf.av_forw = (buf_t *)raiofree; raiofree = (bp); \
	((buf_t *)(bp))->b_flags = 0; \
	(bp)->aflags = 0;

/* 
 * Remove an entry from the done queue
 */

#define	RMDONEQ(bp) \
		if ((bp)->b_back == NULL) \
			raio_done.ahead = (raiobuf_t *)(bp)->b_forw; \
		else \
			(bp)->b_back->b_forw = (bp)->b_forw; \
		if ((bp)->b_forw == NULL) \
			raio_done.atail = (raiobuf_t *)(bp)->b_back; \
		else \
			(bp)->b_forw->b_back = (bp)->b_back;

#define	RAIOCMD(x) \
		((((x) >> 8) & 0377) == 'S')	

struct	aiomap
{
	caddr_t oldaddr;	/* actual user address where I/O started */
	caddr_t newaddr;	/* kernel address I/O job mapped to */
	int npgs;		/* number of pages of I/O job */
	u_int	phys1;		/* physical byte address of I/O job in page1 */
	u_int	phys2;		/* physical byte address of I/O job in page2 */
				/* phys2 is always physically page aligned */
};

#endif _KERNEL

#endif	/* _SYS_RAIO_H*/
 07070100005945000081240000000200000002000000012719347c000018a7000000230000000c00000000000000000000001a00000000usr/include/sys/asyncio.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ASYNCIO_H
#define _SYS_ASYNCIO_H

#ident	"@(#)/usr/include/sys/asyncio.h.sl 1.1 4.0 10/15/90 26801 AT&T-SF"
/*
**		File Contents
**		=============
**
**	This file contains data which must be included in an 
**	application program using the Async system call facility.
*/

/*
**	Structure user used to pass async I/O request parameters to asyncio()
*/

typedef	struct aioop {
	ushort		aio_cmd;	/* one of the command codes defined below */
	ushort		aio_flags;	/* the flags defined below 		  */
	int		aio_error;	/* error code; the field is used to save  */
					/* error encountered in processing the    */
					/* asyncio() function. It is not for      */
					/* any error found in the actual I/O	  */
					/* run asynchronously because the    	  */
					/* aioop struct may be reused after       */
					/* returning from asyncio() function.	  */
	char		*aio_bufp;	/* ptr to the buffer for the operation	  */
	uint		aio_bufs;	/* size of buffer pointed to by aio_bufp  */
	int		aio_fd;		/* file descriptor on which to do I/O	  */
	off_t		aio_offset;	/* relative offset in bytes               */
	pcparms_t	aio_pri;	/* I/O priority  			  */
	ecb_t		aio_ecb;	/* ecb for event notification      	  */
} aioop_t;

/*	The possible values for the aio_cmd field 	*/

#define	AIOC_READ	0x01		/* read from the file descriptor aio_fd   */

#define	AIOC_WRITE	0x02		/* write to the file descriptor aio_fd    */

/*	The flags in the aio_flags and a_flags field are defined as follows.	  */

#define AIOF_SEEK_SET	0x01		/* This flag has the same meaning as an   */
					/* lseek with whence set to 0. An explicit*/
					/* seek will be done before an I/O request*/
					/* is queued. This flag has no effect on  */
					/* a non-I/O async call.		  */

#define AIOF_SEEK_CUR	0x02		/* This flag has the same meaning as an   */
					/* lseek with whence set to 1. An explicit*/
					/* seek will be done before an I/O request*/
					/* is queued. This flag has no effect on  */
					/* a non-I/O async call.		  */

#define AIOF_SEEK_FLAGS	(AIOF_SEEK_SET | AIOF_SEEK_CUR) 

#define	AIOF_NONBLOCK	0x04		/* This flag has the same meaning as the  */
					/* O_NONBLOCK flag for the file descriptor*/
					/* ar_ofilep. If set, it overrides the    */
					/* O_NONBLOCK setting of ar_ofilep and 	  */  
					/* will be used for this I/O. Note, the   */
					/* effect of this flag is local to this   */
					/* request only and does not apply to     */
					/* any I/Os on the same file descriptor.  */

#define	AIOF_SCHEDPRI	0x08		/* When set, indicate the request comes	  */
					/* with a priority parameter to override  */
					/* default FIFO operation. The request	  */
					/* should be processed with the specified */
					/* priority				  */

#define AIOF_UFLAGS	(AIOF_SEEK_SET|AIOF_SEEK_CUR|AIOF_NONBLOCK|AIOF_SCHEDPRI) 
					/* User defined flags			  */

#define	AIOF_ACCEPTED	0x10		/* When set, indicate the request has 	  */
					/* been accepted and will be processed by */
					/* the server.				  */

#define	AIOF_ERROR	0x20		/* When set, indicate the request has 	  */
					/* been rejected during the validity 	  */
					/* check. The actual error code will be   */
					/* set in rt_error.			  */

#define AIOF_PROCESS	(AIOF_ACCEPTED | AIOF_ERROR)

					/* If neither of AIOF_ACCEPTED nor AIOF_ERROR
					** is set, the request was not processed at all
					** because some system resources are not avail.
					*/
/*
**	The following structure describes the data
**	returned for an ET_ASYNC event.
*/
   
typedef struct evd_async {
 	long		ea_rval;	/* # of bytes read/write*/
 	int		ea_errno;	/* error code		*/
 	off_t		ea_offset;	/* initial file offest	*/
} evd_async_t;

/*
**		The Async System Call Facility Version Number
**		=============================================
**
**	In order to be able to make changes to the Async Facility in the
**	future, we define a version number which is automatically passed
**	through from the application program to the libraries and then
**	to the kernel.  If we want to change the Async interface, we
**	just increase the version number so the library routines
**	and the kernel can tell the difference.  This works with either
**	private or shared libraries.
**	The current version number is as follows.
**
*/

#define	ASYNC_VERSION	2	/* The current version number.	*/

/*	The following are previously used version numbers which are
**	still supported.
*/

/*	None yet.
*/

/*	The following are previously used version numbers which are no
**	longer supported.
*/

#define	ASYNC_VER_PROTO	1	/* Version number used in the	*/
				/* first prototype of Async I/O.*/
/*
**		The Async Facility Interfaces
**		=============================
**
**	When a user program calls one of the functions described on one of
**	the async facility manual pages, it is actually invoking one of the
**	following macros.  The purpose of the macros is to pass the
**	version number to the library routines.  The library routines
**	will, in turn, pass the version number down to the kernel.  This
**	will allow us to make changes to the Async facility in the future 
**	and still support old *.o and a.out files.
**
*/

#define	aread(fildes, bufp, bufs, ecbp)	\
	__aread(ASYNC_VERSION, fildes, bufp, bufs, ecbp)

#define	awrite(fildes, bufp, bufs, ecbp)	\
	__awrite(ASYNC_VERSION, fildes, bufp, bufs, ecbp)

#define	asyncio(asyncp, asyncs)	\
	__asyncio(ASYNC_VERSION, asyncp, asyncs)

#define	acancel(eidp, eids) \
	__acancel(ASYNC_VERSION, eidp, eids)


/*
**		Function Prototypes
**		===================
**
**	The following are prototypes for the library functions which
**	users call (indirectly using the macros defined above).
**
*/

#if defined(__STDC__)

int	__aread(const int, const int, char *, const uint, \
		ecb_t *);
int	__awrite(const int, const int, char *, const uint, \
		ecb_t *);
int	__asyncio(const int, aioop_t *, const int);
int	__acancel(const int, const long *const, const int);

#else

int	__aread();
int	__awrite();
int	__asyncio();
int	__acancel();

#endif

#endif	/* _SYS_ASYNCIO_H */
 07070100005946000081240000000200000002000000012719347c00000c8c000000230000000c00000000000000000000001b00000000usr/include/sys/asyncsys.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ASYNCSYS_H
#define _SYS_ASYNCSYS_H

#ident	"@(#)/usr/include/sys/asyncsys.h.sl 1.1 4.0 10/15/90 7778 AT&T-SF"

/*
**	Structure used by library routines, aread.c, awrite.c,
**	and asyncio.c to pass async request parameters 
**	to syscall async().
*/

typedef	struct asyncop {
	int		a_syscall;	/* syscall to be done asynchronously 	  */
	int		a_sysarg[MAXSYSARGS];	/* syscall arguments 	  	  */
	ushort		a_flags;	/* the flags defined below 		  */
	int		a_error;	/* error code; the field is used to save  */
					/* error encountered in processing the    */
					/* async() system call. It is not for     */
					/* any error found in the actual system   */
					/* call run asynchronously because the    */
					/* aioop struct may be reused after       */
					/* returning from async() call.		  */
	off_t		a_offset;	/* relative offset in bytes               */
	pcparms_t	a_pri;		/* syscall priority 			  */
	ecb_t		a_ecb;		/* ecb for event notification      	  */
} asyncop_t;

#ifdef _KERNEL
/*
**	Structure used to pass asynchronous system call
**	request from user process to server
**
**	Note, ar_fflink and ar_fblink must be the first two fields in this
**	structure or the list manipulation routines will break.
*/

typedef struct aioreq {
	struct	aioreq	*ar_fflink;	/* file async request forward link 	  */
	struct	aioreq	*ar_fblink;	/* file async request backward link	  */
	struct	aioreq	*ar_sflink;	/* aioserver request forward link 	  */
	struct	aioreq	*ar_sblink;	/* aioserver request backward link	  */
	proc_t	 	*ar_procp;	/* proc requests the async sys call 	  */
	struct	sysent	*ar_syscallp;	/* sys call to do asynchronously 	  */
	int		ar_args[MAXSYSARGS];/* args to async sys call 	          */
	daddr_t		ar_ulimit;	/* client's ulimit 			  */
	file_t		*ar_ofilep;	/* original file table entry 		  */
	file_t		ar_aiofile;	/* file table entry server will use 	  */
	pcparms_t	ar_pri;		/* system call priority 		  */
	ecb_t		ar_ecb;		/* ecb specified by the user		  */
	evkev_t		*ar_evkevp;	/* ptr to kernel allocated evkev struct,  */
					/* null if no event to be posted 	  */
	proc_t		*ar_serverp;	/* procp of server acting on this 	  */
					/* request. Null if on request queue 	  */
} aioreq_t;

extern	short	 naioproc;		/* # of async requests allowed per  */
					/* process			    */
extern	int	 min_aio_servers;	/* min # of aio servers to make at  */
extern  int	 max_aio_servers;	/* max # of servers allowed 	    */
extern	int	 aio_server_timeout;	/* # of seconds server should wait  */
extern	int	 aio_size;		/* # of aio request structs in pool */
extern	aioreq_t aio[];			/* pool of aio request structs      */
extern	proc_t	 *aiodaemonp;		/* aiodaemon's process table pointer*/

extern	void	 aiodaemon();		/* aiodaemon entry point	    */
extern	void	 stop_aio();		/* stop outstanding async call 	    */
extern	void	 aioinit();		/* initialize aio linked lists	    */	
#endif

#endif	/* _SYS_ASYNCSYS_H */
07070100005947000081240000000200000002000000012719347c00000c92000000230000000c00000000000000000000001a00000000usr/include/sys/at_ansi.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_AT_ANSI_H
#define _SYS_AT_ANSI_H

#ident	"@(#)/usr/include/sys/at_ansi.h.sl 1.1 4.0 10/15/90 37532 AT&T-SF"

/*
 * definitions for PC AT x3.64 terminal emulator
 */

#define ANSI_MAXPARAMS	5	/* maximum number of ANSI paramters */
#define ANSI_MAXTAB	40	/* maximum number of tab stops */
#define ANSI_MAXFKEY	30	/* max length of function key with <ESC>Q */

#define	ANSI_MOVEBASE	0x0001	/* if set move base when scrolling */

/*
 * Font values for ansistate
 */
#define	ANSI_FONT0	0	/* Primary font (default) */
#define	ANSI_FONT1	1	/* First alternate font */
#define	ANSI_FONT2	2	/* Second alternate font */

/*
 * directions for moving bytes in screen memory.
 * UP means toward higher addresses.
 * DOWN means toward lower addresses.
 */
#define UP 	0
#define DOWN 	1

struct attrmask {
	unchar attr;		/* new attribute to turn on */
	unchar mask;		/* old attributes to leave on */
};

struct ansistate {	/* state for ansi x3.64 emulator */
	ushort	*scraddr;	/* pointer to char/attribute buffer */
	short	ansiid;		/* unique id for this x3.64 terminal */
	ushort	flags;		/* flags for this x3.64 terminal */
	ushort	width;		/* number of characters horizontally */
	ushort	height;		/* number of characters vertically */
	ushort	scrsize;	/* number of characters on screen */
	struct	attrmask	*attrmask; /* attribute masks/values ptr */
	char	nattrmsks;	/* size of attrmask array */
	unchar	normattr;	/* "normal" attribute */
	unchar	undattr;	/* attribute to use when underlining */
	unchar	font;		/* font type */
	int 	(*bell)();	/* ptr to bell function */
	int 	(*clrdisplay)(); /* ptr to clrdisplay function */
	int 	(*moveit)();	/* ptr to moveit function */
	int 	(*setcursor)();	/* ptr to setcursor function */
	int 	(*setbase)();	/* ptr to setbase function */
	int 	(*storeword)();	/* ptr to storeword function */
	int 	(*shiftset)();	/* ptr to shiftset function */
	int	(*undattrset)(); /* ptr to undattrset function */
	void	(*sendscreen)(); /* ptr to sendscreen function */
	void	(*setlock)();	/* ptr to setlock function */
	int	(*addstring)();	/* ptr to add function key string function */
	caddr_t	dspec;		/* device specific information */
	ushort	curbase;	/* upper left hand corner of screen in buffer */
	short	line;		/* current line number */
	short	column;		/* current column number */
	ushort	cursor;		/* current address of cursor, 0-based */
	unchar	state;		/* state in output esc seq processing */
	unchar	undstate;	/* underline processing state */
	unchar	attribute;	/* current attribute for characters */
	unchar	gotparam;	/* does output esc seq have a param */
	ushort	curparam;	/* current param # of output esc seq */
	ushort	paramval;	/* value of current param */
	short	params[ANSI_MAXPARAMS];	/* parameters of output esc seq */
	unchar	ntabs;		/* number of tab stops set */
	unchar	tabs[ANSI_MAXTAB];	/* list of tab stops */
	char	fkey[ANSI_MAXFKEY];	/* work space for function key */
};


#endif	/* _SYS_AT_ANSI_H */
  07070100005948000081240000000200000002000000012719347c000003bb000000230000000c00000000000000000000001700000000usr/include/sys/auxv.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _AUXV_H
#define _AUXV_H

#ident	"@(#)/usr/include/sys/auxv.h.sl 1.1 4.0 10/15/90 19283 AT&T-SF"
typedef struct
{
       int     a_type;
       union {
               long    a_val;
#ifdef __STDC__
               void    *a_ptr;
#else
               char    *a_ptr;
#endif
               void    (*a_fcn)();
       } a_un;
} auxv_t;

#define AT_NULL		0
#define AT_IGNORE	1
#define AT_EXECFD	2
#define AT_PHDR		3	/* &phdr[0] */
#define AT_PHENT	4	/* sizeof(phdr[0]) */
#define AT_PHNUM	5	/* # phdr entries */
#define AT_PAGESZ	6	/* getpagesize(2) */
#define AT_BASE		7	/* ld.so base addr */
#define AT_FLAGS	8	/* processor flags */
#define AT_ENTRY	9	/* a.out entry point */

#endif
 07070100005949000081240000000200000002000000012719347c00000810000000230000000c00000000000000000000001900000000usr/include/sys/bitmap.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_BITMAP_H
#define _SYS_BITMAP_H

#ident	"@(#)/usr/include/sys/bitmap.h.sl 1.1 4.0 10/15/90 26963 AT&T-SF"

/*
 * Operations on bitmaps of arbitrary size
 * A bitmap is a vector of 1 or more ulongs.
 * The user of the package is responsible for range checks and keeping
 * track of sizes.
 */

/*
 * REQUIRES sys/types.h
 */

#define BT_NBIPUL	32	/* n bits per ulong */
#define BT_ULSHIFT	5	/* log base 2 of BT_NBIPUL,
				 * to extract word index
				 */
#define BT_ULMASK	0x1f	/* to extract bit index */

/* 
 * bitmap is a ulong *, bitindex an index_t
 *
 * The macros BT_WIM and BT_BIW internal; there is no need
 * for users of this package to use them.
 */

/*
 * word in map
 */
#define BT_WIM(bitmap, bitindex) \
	((bitmap)[(bitindex) >> BT_ULSHIFT])
/*
 * bit in word
 */
#define BT_BIW(bitindex) \
	(1 << ((bitindex) & BT_ULMASK))

/*
 * These are public macros
 *
 * BT_BITOUL == n bits to n ulongs
 */
#define BT_BITOUL(nbits) \
	(((nbits) + BT_NBIPUL -1) / BT_NBIPUL)
#define BT_TEST(bitmap, bitindex) \
	((BT_WIM((bitmap), (bitindex)) & BT_BIW(bitindex)) ? 1 : 0)
#define BT_SET(bitmap, bitindex) \
	{ BT_WIM((bitmap), (bitindex)) |= BT_BIW(bitindex); }
#define BT_CLEAR(bitmap, bitindex) \
	{ BT_WIM((bitmap), (bitindex)) &= ~BT_BIW(bitindex); }


#if defined(__STDC__)
/*
 * return next available bit index from map with specified number of bits
 */
extern index_t	bt_availbit(ulong *bitmap, size_t nbits);
/*
 * find the highest order bit that is on, and is within or below
 * the word specified by wx
 */
extern void	bt_gethighbit(ulong *mapp, int wx, int *bitposp);
extern int 	bt_range(ulong *bitmap, size_t *pos1, size_t *pos2, size_t nbits);
#else
extern index_t	bt_availbit();
extern void	bt_gethighbit();
extern int	bt_range();
#endif

#endif	/* _SYS_BITMAP_H */
0707010000594a000081240000000200000002000000012719347c000002f8000000230000000c00000000000000000000001b00000000usr/include/sys/bitmasks.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_BITMASKS_H
#define _SYS_BITMASKS_H

#ident	"@(#)/usr/include/sys/bitmasks.h.sl 1.1 4.0 10/15/90 63950 AT&T-SF"

/*	setmask[i] has the low order i bits set.  For example,
 *	setmask[5] == 0x1F.
 */

extern int setmask[33];

/*	sbittab[i] has bit number i set.  For example,
 *	sbittab[5] == 0x20.
 */

extern int sbittab[];

/*	cbittab[i] has all bits on except bit i which is off.  For example,
 *	cbittab[5] == 0xFFFFFFDF.
 */

extern int cbittab[];

#endif	/* _SYS_BITMASKS_H */
0707010000594b000081240000000200000002000000012719347c0000054e000000230000000c00000000000000000000001700000000usr/include/sys/boot.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_BOOT_H
#define _SYS_BOOT_H

#ident	"@(#)/usr/include/sys/boot.h.sl 1.1 4.0 10/15/90 32485 AT&T-SF"

#define BOOTADDR 0x2004000

#define AUTOBOOT 0
#define DEMANDBOOT 1
#define UNIXBOOT 2

#define FDBOOTBLK 0

#define FLOPDISK  0
#define HARDDISK0 1
#define HARDDISK1 2
#define HARDDISK HARDDISK0
#define ICD	  3

#define ICDBLKSZ	512	/* Size of In-Core Disk block   */
#define ICDNSWAP	400	/* Size of swap area in ICD.    */

#define ICDROOT		0 	/* Minor device number of root  */
				/* file system on a In-Core     */
				/* Disk at installation.        */
#define ICDSWAP		1	/* Minor device number of swap  */
				/* space on an In-Core Disk.    */

#define	FLOPMINOR	0x85	/* Minor device number of root	*/
				/* file system on a bootable	*/
				/* floppy disk.			*/

#define BOOTNAME 80

struct bootcmd {
	char b_type;		/* type of boot (auto or demand) */
	char b_dev;		/* source of boot (HARDDISK, FLOPDISK, or ..) */
	char b_name[BOOTNAME];	/* full pathname of file to boot */
};

struct blk_acs {
	unsigned long blkno;
	unsigned long bufptr;
};

#endif	/* _SYS_BOOT_H */
  0707010000594c000081240000000200000002000000012719347c00001a93000000230000000c00000000000000000000001a00000000usr/include/sys/boothdr.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_BOOTHDR_H
#define _SYS_BOOTHDR_H

#ident	"@(#)/usr/include/sys/boothdr.h.sl 1.1 4.0 10/15/90 31229 AT&T-SF"
/*
 * Each object file existing in the /boot directory contains an 
 * optional header containing the following information.  This header
 * is created by the mkboot(1M) program from the /etc/master data base.
 */

#define	OFFSET(ptr,base)	((offset) ((char*)(ptr) - (char*)(base)))
#define	POINTER(offset,base)	((char*)(base) + (offset))

#define	ROUNDUP(p)		(((int)(p)+sizeof(int)-1) & ~(sizeof(int)-1))

typedef	unsigned short		offset;

#define	PARAMNMSZ	8	/* maximun size of a parameter name in /etc/master data base */
#define	PREFIXLEN	4	/* length of module prefix */

/*
 * Optional header for object files (all offsets are computed
 * from the base of this structure)
 */

struct	master
	{
	unsigned short		magic;		/* "3b"; to distinguish from UNIX a.out header */
	unsigned short		flag;		/* /etc/master: flags */
	unsigned char		vec;		/* /etc/master: first vector for integral device */
	unsigned char		nvec;		/* /etc/master: number of interrupt vectors */
	char			prefix[PREFIXLEN+1];	/* /etc/master: module prefix, '\0' terminated */
	unsigned long 		soft;		/* /etc/master: software module external major number */
	unsigned long		ndev;		/* /etc/master: number of devices/controller */
	unsigned char		ipl;		/* /etc/master: interrupt priority level */
	short			ndep;		/* number of dependent modules */
	short			nparam;		/* number of parameters */
	short			nrtn;		/* number of routine names */
	short			nvar;		/* number of variables */
	offset			o_depend;	/* ==> additional modules required */
	offset			o_param;	/* ==> parameters for this module */
	offset			o_routine;	/* ==> routines to be stubbed if module is not loaded */
	offset			o_variable;	/* ==> variables to be generated */
	};

/*
 *	Magic number to distinguish from UNIX optional a.out header
 */
#define	MMAGIC	0x3362

/*
 *	FLAG bits
 */
#define	KERNEL	0x8000		/* this is a kernel a.out file */
#define	FUNDRV	0x0200		/* (f) framework/stream type device */
#define	FUNMOD	0x0100		/* (m) framework/stream module */
#define	ONCE	0x0080		/* (o) allow only one specification of device */
#define	REQADDR	0x0040		/* (a) xx_addr array must be generated */
#define	TTYS	0x0020		/* (t) cdevsw[].d_ttys mustpoint to first generated data structure */
#define	REQ	0x0010		/* (r) required device */
#define	BLOCK	0x0008		/* (b) block type device */
#define	CHAR	0x0004		/* (c) character type device */
#define	SOFT	0x0002		/* (s) software device driver */
#define	NOTADRV	0x0001		/* (x) not a driver; a configurable module */
#define FSTYP	0x0400		/* (j) file system module */
#define EXECTYP 0x800		/* (e) exec system module */
#define SCHEDCLASS 0x1000	/* (d) scheduler class module */
#define NEWDRV	0x2000		/* (n) new driver interface */

/*
 * Dependencies: if the current module is loaded, then the following
 *               modules must also be loaded
 */
struct	depend
	{
	offset		name;		/* module name */
	};

/*
 * Parameters: each parameter defined for this module is saved to allow
 *             references from other modules
 */
struct	param
	{
	char		name[PARAMNMSZ];/* parameter name */
	char		type;		/* string ("), integer (N) */
	union	{
		int number;		/* integer value */
		offset string;		/* ==> string */
		}
			value;
	};

/*
 * Routines: if the current module is not loaded, then the following
 *           routines must be stubbed off
 */
struct	routine
	{
	char		id;		/*  routine type */
	offset		name;		/* ==> routine name */
	};

/*
 *	Routine types
 */
#define RNULL		0		/* void rtn() {} */
#define RNOSYS		1		/* rtn() { return(nosys()); } */
#define RNODEV		2		/* rtn() { return(nodev()); } */
#define RTRUE		3		/* rtn() { return(1); } */
#define RFALSE		4		/* rtn() { return(0); } */
#define RFSNULL 	5
#define RFSTRAY		6
#define NOPKG   	7
#define NOREACH		8
#define RNULLMAG	9
#define RNOEXEC		10
#define RNOCORE		11
#define RNODEVFLAG	12

/*
 * Variables: each variable to be generated by the boot program is
 *            described by this structure
 */
struct	variable
	{
	int		size;		/* total size of single element */
	offset		name;		/* ==> variable name */
	offset		dimension;	/* ==> array dimension; NULL if not an array */
	short		ninit;		/* number of elements to be initialized */
	offset		initializer;	/* ==> initialization */
	};

/*
 * Initializer structure: a variable is initialized by an array of initializer
 *                        elements; each element contains the type of the field
 *                        and either the initial value, or the offset to the
 *                        expression which, when evaluated, will be the initial
 *                        value.
 */
struct	format
	{
	unsigned char	type;		/* flags and type of the field */
	unsigned char	strlen;		/* %<strlen>c */

					/* type&FEXPR:  ==> expression */
	offset		value;		/* type&FSKIP:  %<number> */
					/* otherwise:   literal value */
	};

/*
 * Format types
 */
#define	FSKIP	0x80			/* %<n>  no initialization; skip `value' bytes */
#define	FEXPR	0x40			/* POINTER((offset)value, &opthdr) -> expression */
#define	FTYPE	0x3F			/* One of:                     */
#define	FCHAR	1			/*	%c    character        */
#define	FSHORT	2			/*	%s    short integer    */
#define	FINT	3			/*	%i    integer          */
#define	FLONG	4			/*	%l    long integer     */
#define	FSTRING	5			/*	%<n>c character string */

/*
 * Expressions are stored in prefix polish notation.  Each element of
 * the expression is one of the elements below.
 *
 *		operator:  +, -, * or /
 *		function:  <, or >	(min or max)
 *		builtin:   #Dname\0
 *		builtin:   #Cname\0
 *		builtin:   #Sname\0
 *		builtin:   #Mname\0
 *		sizeof:    #name\0
 *		address:   &name\0
 *		string:    "string\0
 *		identifier:Iname\0
 *		number:    Ninteger
 */

#define	ELENGTH	256

union	element
	{
	char		operator;		/* +, -, * or / */
	char		function;		/* < or > */
	char		nD[ELENGTH];		/* D number of subdevices */
	char		nC[ELENGTH];		/* C number of controllers */
	char		nS[ELENGTH];		/* S number of logical units */
	char		nM[ELENGTH];		/* M internal major number */
	char		size_of[ELENGTH];	/* # name */
	char		address_of[ELENGTH];	/* & name */
	char		string[ELENGTH];	/* " name */
	char		identifier[1+PARAMNMSZ];/* I name */
	unsigned char	literal[1+sizeof(int)];	/* N integer */
	};

#define	XBUMP(p,what)	(union element *)((int)(p) + ((sizeof((p)->what)==ELENGTH)? \
							1+strlen((char *)((p)->what)) : \
							sizeof((p)->what)))

#endif	/* _SYS_BOOTHDR_H */
 0707010000594d000081240000000200000002000000012719347c000009b4000000230000000c00000000000000000000001b00000000usr/include/sys/bootinfo.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_BOOTINFO_H
#define _SYS_BOOTINFO_H

#ident	"@(#)/usr/include/sys/bootinfo.h.sl 1.1 4.0 10/15/90 36960 AT&T-SF"

/*
 *	Definition of bootinfo structure.  This is used to pass
 *	information between the bootstrap and the kernel.
 */

#define BKI_MAGIC	0xff1234ff

#define B_MAXARGS	15		/* max. number of boot args */
#define B_STRSIZ	100		/* max length of boot arg. string */

struct bootmem {
	paddr_t		base;
	long		extent;
	ushort		flags;
	};

struct bootinfo {
	ulong	bootflags;		/* miscellaneous flags */

	struct hdparams { 		/* hard disk parameters */
		ushort	hdp_ncyl;	/* # cylinders (0 = no disk) */
		unchar	hdp_nhead;	/* # heads */
		unchar	hdp_nsect;	/* # sectors per track */
		ushort	hdp_precomp;	/* write precomp cyl */
		ushort	hdp_lz;		/* landing zone */
	} hdparams[2];			/* hard disk parameters */

	int	memavailcnt;
	struct	bootmem	memavail[B_MAXARGS];

	int	memusedcnt;
	struct	bootmem	memused[B_MAXARGS];

	int	bargc;			    /* count of boot arguments */
	char	bargv[B_MAXARGS][B_STRSIZ]; /* argument strings */

	char	id[5];			/* Contents of F000:E000 */
#ifdef MBUS
	caddr_t	bpsloc;
#endif
	int	checksum;
};

#if defined(MB1) || defined(MB2)
	unsigned long ramfsloc;
	unsigned long ramfssiz;
#endif

/* flags for struct mem flags */

#define B_MEM_NODMA	0x01
#define B_MEM_KTEXT	0x02
#define	B_MEM_KDATA	0x04
#define B_MEM_BOOTSTRAP	0x8000	/* Used internally by bootstrap */

#define BF_FLOPPY	0x01		/* booted from floppy */
#define BF_MB2SA	0x20000000	/* Kernel booted from MSA */
#define BF_TAPE		0x40000000	/* Kernel booted from tape */
#define BF_DEBUG	0x80000000	/* Bootloader  debug flag set by user */

#ifdef MB1
#define BOOTINFO_LOC	((paddr_t)0x1700)
#define KPTBL_LOC	((paddr_t)0x2000)  /* 8K Reserved for kernel pg table */
#endif

#if defined (MB2) 
#define BOOTINFO_LOC	((paddr_t)0xd000)
#define KPTBL_LOC	((paddr_t)0xe000)  /* 8K Reserved for kernel pg table */
#endif

#if defined (MB1) || defined (MB2) 
extern char * bpsinfo;			   /* defined by vuifile */
#endif

#if defined (AT386)
#define BOOTINFO_LOC	((paddr_t)0x600)
#define KPTBL_LOC	((paddr_t)0x1000)  /* Reserved for kernel page table */
#endif

extern struct bootinfo bootinfo;

#endif	/* _SYS_BOOTINFO_H */
0707010000594e000081240000000200000002000000012719347c00001fcd000000230000000c00000000000000000000001600000000usr/include/sys/buf.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ifndef _SYS_BUF_H
#define _SYS_BUF_H

#ident	"@(#)/usr/include/sys/buf.h.sl 1.1 4.0 10/15/90 53546 AT&T-SF"

/*
 *	Each buffer in the pool is usually doubly linked into 2 lists:
 *	the device with which it is currently associated (always)
 *	and also on a list of blocks available for allocation
 *	for other use (usually).
 *	The latter list is kept in last-used order, and the two
 *	lists are doubly linked to make it easy to remove
 *	a buffer from one list when it was found by
 *	looking through the other.
 *	A buffer is on the available list, and is liable
 *	to be reassigned to another disk block, if and only
 *	if it is not marked BUSY.  When a buffer is busy, the
 *	available-list pointers can be used for other purposes.
 *	Most drivers use the forward ptr as a link in their I/O active queue.
 *	A buffer header contains all the information required to perform I/O.
 *	Most of the routines which manipulate these things are in bio.c.
 */
typedef struct	buf {
	uint	b_flags;		/* see defines below */
	struct	buf *b_forw;		/* headed by d_tab of conf.c */
	struct	buf *b_back;		/*  "  */
	struct	buf *av_forw;		/* position on free list, */
	struct	buf *av_back;		/*     if not BUSY*/
	o_dev_t	b_dev;			/* major+minor device name */
	unsigned b_bcount;		/* transfer count */
	union {
	    caddr_t b_addr;		/* low order core address */
	    int	*b_words;		/* words for clearing */
	    daddr_t *b_daddr;		/* disk blocks */
	} b_un;

#define paddr(X)	(paddr_t)(X->b_un.b_addr)

	daddr_t	b_blkno;		/* block # on device */
	char	b_oerror;		/* OLD error field returned after I/O */
	char	b_res;			/* XENIX Compatibility	*/
	ushort	b_cylin;		/* XENIX Compatibility	*/
	unsigned int b_resid;		/* words not transferred after error */
	daddr_t	b_sector;		/* physical sector of disk request */
	clock_t	b_start;		/* request start time */
	struct  proc  *b_proc;		/* process doing physical or swap I/O */
	struct	page  *b_pages;		/* page list for PAGEIO */
	clock_t	b_reltime;      /* previous release time */
	/* Begin new stuff */
#define b_actf	av_forw
#define	b_actl	av_back
#define	b_active b_bcount
#define	b_errcnt b_resid
	long	b_bufsize;		/* size of allocated buffer */
	int	(*b_iodone)();		/* function called by iodone */
	struct	vnode *b_vp;		/* vnode associated with block */
	struct 	buf *b_chain;		/* chain together all buffers here */
	int	b_reqcnt;		/* number of I/O request generated */
	int	b_error;		/* expanded error field */
	dev_t	b_edev;			/* expanded dev field */
	char *b_private;		/* private data structure */
} buf_t;

/*
 * Bufhd structures used at the head of the hashed buffer queues.
 * We only need three words for these, so this abbreviated
 * definition saves some space.
 */
struct bufhd {
	long	b_flags;		/* see defines below */
	struct	buf *b_forw, *b_back;	/* fwd/bkwd pointer in chain */
};
struct diskhd {
	long b_flags;                   /* not used, needed for consistency */
 	struct  buf *b_forw, *b_back;   /* queue of unit queues */
 	struct  buf *av_forw, *av_back; /* queue of bufs for this unit */
 	long    b_bcount;               /* active flag */
};

extern	struct	buf	bfreelist;	/* head of available list */
struct	pfree	{
	int	b_flags;
	struct	buf	*av_forw;
};
extern	struct	pfree	pfreelist;
extern	int		pfreecnt;
extern	struct	buf	pbuf[];
#ifndef BUFDEFINE
extern	char		*buffers[];
#endif

/*
 *	These flags are kept in b_flags.
 */
#define B_WRITE   0x0000	/* non-read pseudo-flag */
#define B_READ    0x0001	/* read when I/O occurs */
#define B_DONE    0x0002	/* transaction finished */
#define B_ERROR   0x0004	/* transaction aborted */
#define B_BUSY    0x0008	/* not on av_forw/back list */
#define B_PHYS    0x0010	/* Physical IO potentially using UNIBUS map */
#define B_MAP     0x0020	/* This block has the UNIBUS map allocated */
#define B_WANTED  0x0040	/* issue wakeup when BUSY goes off */
#define B_AGE     0x0080	/* delayed write for correct aging */
#define B_ASYNC   0x0100	/* don't wait for I/O completion */
#define B_DELWRI  0x0200	/* delayed write - wait until buffer needed */
#define B_OPEN    0x0400	/* open routine called */
#define B_STALE   0x0800
#define B_VERIFY  0x1000
#define B_FORMAT  0x2000
#define B_S52K	  0x8000	/* 2k buffer flag */
#define B_PRIVLG  0xf000	/* privileged operation (internal driver use) */

/* fix these numbers; remove ones we don't need */
#define	B_PAGEIO	0x10000		/* do I/O to pages on bp->p_pages */
#define	B_DONTNEED	0x20000		/* after write, need not be cached */
#define	B_TAPE		0x40000		/* this is a magtape (no bdwrite) */
#define	B_UAREA		0x80000		/* add u-area to a swap operation */
#define	B_REMAPPED	0x100000	/* buffer is kernel addressable */
#define	B_FREE		0x200000	/* free page when done */
#define	B_PGIN		0x400000	/* pagein op, so swap() can count it */
#define	B_CACHE		0x800000	/* did bread find us in the cache ? */
#define	B_INVAL		0x1000000	/* does not contain valid info  */
#define	B_FORCE		0x2000000	/* semi-permanent removal from cache */
#define	B_HEAD		0x4000000	/* a buffer header, not a buffer */
#define	B_NOCACHE	0x8000000	/* don't cache block when released */
#define	B_BAD		0x10000000	/* bad block revectoring in progress */
#define B_KERNBUF	0x20000000	/* buffer is a kernel buffer */
#define	B_DMA_REMAPPED	0x40000000	/* > 16MB DMA remap */
#define	B_RAIO		0x80000000	/* raw disk async I/O */

/*
 * Insq/Remq for the buffer hash lists (used by pageio).
 */
#define	bremhash(bp) { \
	(bp)->b_back->b_forw = (bp)->b_forw; \
	(bp)->b_forw->b_back = (bp)->b_back; \
}
#define	binshash(bp, dp) { \
	(bp)->b_forw = (dp)->b_forw; \
	(bp)->b_back = (dp); \
	(dp)->b_forw->b_back = (bp); \
	(dp)->b_forw = (bp); \
}

/*
 * Insq/Remq for the buffer free lists.
 */
#define	bremfree(bp) { \
	(bp)->av_back->av_forw = (bp)->av_forw; \
	(bp)->av_forw->av_back = (bp)->av_back; \
}
#define	binsheadfree(bp, dp) { \
	(dp)->av_forw->av_back = (bp); \
	(bp)->av_forw = (dp)->av_forw; \
	(dp)->av_forw = (bp); \
	(bp)->av_back = (dp); \
}
#define	binstailfree(bp, dp) { \
	(dp)->av_back->av_forw = (bp); \
	(bp)->av_back = (dp)->av_back; \
	(dp)->av_back = (bp); \
	(bp)->av_forw = (dp); \
}

/*
 *	Fast access to buffers in cache by hashing.
 */

#define bhash(d, b)	((struct buf *)&hbuf[((int)d+(int)b)&v.v_hmask])

struct	hbuf {
	int	b_flags;
	struct	buf	*b_forw;
	struct	buf	*b_back;
	int	b_pad;			/* round size to 2^n */
};

extern	struct	hbuf	hbuf[];

/*
 * Pick up the device's error number and pass it to the user;
 * if there is an error but the number is 0 set a generalized code
 */
#define geterror(bp) \
	(((bp)->b_flags & B_ERROR) == 0 ? 0 : \
	(bp)->b_error ? (bp)->b_error : \
	(bp)->b_oerror ? (bp)->b_oerror : EIO)
/*
 * Unlink a buffer from the available list and mark it busy.
 * (internal interface)
 */
#define notavail(bp) \
{\
	register s;\
\
	s = spl6();\
	(bp)->av_back->av_forw = (bp)->av_forw;\
	(bp)->av_forw->av_back = (bp)->av_back;\
	(bp)->b_flags |= B_BUSY;\
	bfreelist.b_bcount--;\
	splx(s);\
}

struct buf	*bread();
struct buf	*breada();
void		bwrite();
void		bdwrite();
void		bawrite();
void		brelse();
int		incore();
int		getfreeblk();
struct buf	*getblk();
struct buf	*ngeteblk();
struct buf	*geteblk();
int		iowait();
void		iodone();
void		clrbuf();
void		bflush();
void		blkflush();
void		bdflush();
void		bdwait();
void		binval();
void		binit();
int		biowait();
int		get_error();
struct buf	*pageio_setup();
void		pageio_done();
void		biodone();
void		bioerror();
void		buf_breakup();

#if defined(__STDC__)
extern void dma_breakup(void (*)(), struct buf *);
extern void dma_pageio(void (*)(), struct buf *);
extern void dma_access(u_char, u_int, u_int, u_char, u_char);
#else
extern void dma_breakup();
extern void dma_pageio();
extern void dma_access();
#endif

#ifdef i386
#define 	bimap(bp)	((caddr_t)(paddr(bp)))
#endif

#define bigetl(bp,cp) (*(long *)((paddr(bp))+cp))
#endif	/* _SYS_BUF_H */
   07070100005954000081240000000200000002000000012719347c0000033d000000230000000c00000000000000000000001800000000usr/include/sys/callo.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CALLO_H
#define _SYS_CALLO_H

#ident	"@(#)/usr/include/sys/callo.h.sl 1.1 4.0 10/15/90 51068 AT&T-SF"
/*
 *	The callout structure is for a routine arranging
 *	to be called by the clock interrupt
 *	(clock.c) with a specified argument,
 *	in a specified amount of time.
 *	Used, for example, to time tab delays on typewriters.
 */

struct	callo
{
	int	c_time;		/* incremental time */
	int	c_id;		/* timeout id */
	caddr_t	c_arg;		/* argument to routine */
	void	(*c_func)();	/* routine */
};
extern	struct	callo	callout[];

#endif	/* _SYS_CALLO_H */
   07070100005955000081240000000200000002000000012719347c00000446000000230000000c00000000000000000000001800000000usr/include/sys/cdump.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CDUMP_H
#define _SYS_CDUMP_H

#ident	"@(#)/usr/include/sys/cdump.h.sl 1.1 4.0 10/15/90 8380 AT&T-SF"

#define	BLKSZ		512
#define CHDR_OFFSET	1024
#define	CRASHSANITY	"crashdump"
#define	MAXBLKS		1422
#define NVR_OFFSET	512

struct	crash_hdr
{
	char	sanity[10] ;
	int	timestamp ,
		mem_size ,
		seq_num ;
} ;
#ifdef TEST
#undef BLKSZ
#undef CHDR_OFFSET
#undef MAXBLKS
#undef NVR_OFFSET
#undef MAINSTORE
#undef SIZOFMEM
#undef SPMEM
#undef PRINTF
#undef STRCMP
#undef GETS
#undef RNVRAM
#undef FD_ACS

#define BLKSZ		100
#define CHDR_OFFSET	80
#define MAXBLKS		5
#define NVR_OFFSET	20
#define MAINSTORE	mainstore
#define SIZOFMEM	sizofmem
#define SPMEM		(mainstore + 100)
#define PRINTF		printf
#define STRCMP		strcmp
#define GETS		gets

extern	int	mainstore ;
extern	int	sizofmem ;
#endif

#endif	/* _SYS_CDUMP_H */
  07070100005956000081240000000200000002000000012719347c00000827000000230000000c00000000000000000000001a00000000usr/include/sys/chanmux.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/chanmux.h.sl 1.1 4.0 10/15/90 39410 AT&T-SF"

#ifndef	_SYS_CHANMUX_H
#define	_SYS_CHANMUX_H

#define	CMUX_NUMSWTCH	10	/* keep history of last 10 switches */
#define	CMUXPSZ	32		/* maximun output packet size */

typedef struct cmux_stat {
	unsigned long cmux_num;
	unsigned long cmux_flg;
	queue_t *cmux_rqp;		/* saved pointer to read queue */
	queue_t *cmux_wqp;		/* saved pointer to write queue */
	struct ws_stat *cmux_wsp;
	unsigned long cmux_enqueue;	/* should messages be enqueued? */
	dev_t cmux_dev;			/* device number for this channel */
} cmux_t;

struct cmux_swtch {
	clock_t sw_time;
	unsigned long sw_chan; /* channel number made active */
};


typedef struct cmux_linkblk {
	unsigned long cmlb_iocresp; /* ACK or NACK? */
	unsigned long cmlb_flg; /* in use? */
	mblk_t *cmlb_iocmsg;
	unsigned long cmlb_err;
	struct linkblk cmlb_lblk;
} cmux_link_t;


typedef struct ws_stat {
	unsigned long w_ioctlchan;
	unsigned long w_ioctllstrm;
	unsigned long w_ioctlcnt;
	mblk_t *w_iocmsg;
	unsigned long w_state;
	cmux_t **w_cmuxpp;
	unsigned long w_numchan;
	cmux_link_t *w_princp; /* numchan allocated */
	cmux_link_t *w_lstrmsp;
	unsigned long w_numlstrms;
	unsigned long w_lstrms;
	unsigned long w_numswitch;
	struct cmux_swtch w_swtchtimes[CMUX_NUMSWTCH];
} cmux_ws_t;


typedef struct cmux_lstrm {
	cmux_ws_t *lstrm_wsp;
	unsigned long lstrm_flg;
	unsigned long lstrm_id;
	unsigned long lstrm_err;
} cmux_lstrm_t;


#define	MAXCMUXPSZ	1024
#define	CMUX_STRMALLOC	2
#define	CMUX_CHANALLOC	8
#define CMUX_WSALLOC	4


/*
 * Internal state bits.
 */

#define	CMUX_OPEN	0x1
#define	CMUX_CLOSE	0x2
#define	CMUX_WCLOSE	0x4
#define	CMUX_IOCTL	0x8

/*
 * cmux_lstrm_t flag bits
 */

#define	CMUX_SECSTRM	0x1
#define	CMUX_PRINCSTRM	0x2
#define	CMUX_PRINCSLEEP	0x4
#endif /* _SYS_CHANMUX_H */
 07070100005957000081240000000200000002000000012719347c000008a5000000230000000c00000000000000000000001700000000usr/include/sys/char.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/char.h.sl 1.1 4.0 10/15/90 57326 AT&T-SF"

#ifndef	_SYS_CHAR_H
#define	_SYS_CHAR_H

#define	IBSIZE	16		/* "standard" input data block size */
#define	OBSIZE	64		/* "standard" output data block size */
#define	EBSIZE	16		/* "standard" echo data block size */

#ifndef MIN
#define	MIN(a,b) (((a)<(b))?(a):(b))
#endif

#define	MAXCHARPSZ	1024
#define	CHARPSZ	64

typedef struct copystate {
	ulong cpy_arg;
	ulong cpy_state;
} copy_state_t;

#define CHR_IN_0	0x0
#define CHR_IN_1	0x1
#define CHR_OUT_0	0xF000
#define CHR_OUT_1	0xF001


struct char_stat {
	queue_t *c_rqp;		/* saved pointer to read queue */
	queue_t *c_wqp;		/* saved pointer to write queue */
	unsigned long c_state;	/* internal state of tty module */
	mblk_t *c_rmsg;		/* ptr to read-side message being built */
	mblk_t *c_wmsg;		/* ptr to write-side message being built */
	charmap_t *c_map_p;	/* pointer to shared charmap_t with principal
				   stream */
	scrn_t *c_scrmap_p;
	xqInfo *c_xqinfo;
	struct v86dat *c_stashed_p_v86;
	proc_t *c_rawprocp;
	pid_t c_rawpid;
	kbstate_t c_kbstat;	/* pointer to keyboard state struct */
	copy_state_t c_copystate;
	xqEvent c_xevent;
	struct mouseinfo c_mouseinfo; /* the next 3 for mouse processing */
	mblk_t *c_heldmseread;
	int c_oldbutton;
#ifdef MERGE386
	void (*c_merge_kbd_ppi)(); /* Merge keyboard ppi function pointer */
	void (*c_merge_mse_ppi)(); /* Merge mouse ppi function pointer */
	struct mcon *c_merge_mcon; /* pointer to merge console structure */
#endif /* MERGE386 */
};

typedef struct char_stat charstat_t;

#ifdef MERGE386
struct chr_merge {
	void (*merge_kbd_ppi)();
	void (*merge_mse_ppi)();
	struct mcon *merge_mcon;
};

typedef struct chr_merge chr_merge_t;
#endif /* MERGE386 */
	

/*
 * Internal state bits.
 */

#define	C_RAWMODE	0x00000001
#define C_XQUEMDE	0x00000002
#define C_FLOWON	0x00000004
#define	C_MSEBLK	0x00000008
#define C_MSEINPUT	0x00000010

#endif /* _SYS_CHAR_H */
   07070100005958000081240000000200000002000000012719347c000010a7000000230000000c00000000000000000000001800000000usr/include/sys/class.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/



#ifndef _SYS_CLASS_H
#define _SYS_CLASS_H

#ident	"@(#)/usr/include/sys/class.h.sl 1.1 4.0 10/15/90 55523 AT&T-SF"


/*
 * NOTE: Developers making use of the scheduler class switch mechanism
 * to develop scheduling class modules should be aware that the
 * architecture is not frozen and the kernel interface for scheduling
 * class modules may change in future releases of System V.  Support
 * for the current interface is not guaranteed and class modules
 * developed to this interface may require changes in order to work
 * with future releases of the system.
 */


extern int	nclass;		/* number of configured scheduling classes */
extern char	*initclass;	/* class of init process */

typedef struct class {
	char	*cl_name;	/* class name */
	void	(*cl_init)();	/* class specific initialization function */
	struct classfuncs *cl_funcs;	/* pointer to classfuncs structure */
} class_t;

extern struct class	class[];	/* the class table */

typedef struct classfuncs {
	int		(*cl_admin)();
	int		(*cl_enterclass)();
	void		(*cl_exitclass)();
	int		(*cl_fork)();
	void		(*cl_forkret)();
	int		(*cl_getclinfo)();
	void		(*cl_getglobpri)();
	void		(*cl_parmsget)();
	int		(*cl_parmsin)();
	int		(*cl_parmsout)();
	int		(*cl_parmsset)();
	void		(*cl_preempt)();
	int		(*cl_proccmp)();
	void		(*cl_setrun)();
	void		(*cl_sleep)();
	void		(*cl_stop)();
	void		(*cl_swapin)();
	void 		(*cl_swapout)();
	void		(*cl_tick)();
	void		(*cl_trapret)();	/* Don't move without changing */
						/*  .set in ml/ttrap.s */
	void		(*cl_wakeup)();
	int		(*cl_filler[11])();
} classfuncs_t;


#define	CL_ADMIN(clp, uaddr, reqpcid, reqpcredp) \
(*(clp)->cl_funcs->cl_admin)(uaddr, reqpcid, reqpcredp)

#define	CL_ENTERCLASS(clp, clparmsp, pp, pstatp, pprip, pflagp, pcredpp, clprocpp, reqpcid, reqpcredp) \
(*(clp)->cl_funcs->cl_enterclass)\
  (clparmsp, pp, pstatp, pprip, pflagp, pcredpp, clprocpp, reqpcid, reqpcredp)

#define	CL_EXITCLASS(pp, clprocp) (*(pp)->p_clfuncs->cl_exitclass)(clprocp)

#define CL_FORK(pp, pclprocp, cprocp, cpstatp, cpprip, cpflagp, cpcredpp, clprocpp) \
(*(pp)->p_clfuncs->cl_fork)\
  (pclprocp, cprocp, cpstatp, cpprip, cpflagp, cpcredpp, clprocpp)

#define	CL_FORKRET(cp, cclprocp, pclprocp) \
(*(cp)->p_clfuncs->cl_forkret)(cclprocp, pclprocp)

#define	CL_GETCLINFO(clp, clinfop, reqpcid, reqpcredp) \
(*(clp)->cl_funcs->cl_getclinfo)(clinfop, reqpcid, reqpcredp)

#define CL_GETGLOBPRI(clp, clparmsp, globprip) \
(*(clp)->cl_funcs->cl_getglobpri)(clparmsp, globprip)

#define	CL_PARMSGET(pp, clprocp, clparmsp) \
    (*(pp)->p_clfuncs->cl_parmsget)(clprocp, clparmsp)

#define CL_PARMSIN(clp, clparmsp, rqpcid, rqpcredp, tgpcid, tgpcredp, tgpclpp) \
(*(clp)->cl_funcs->cl_parmsin)\
(clparmsp, rqpcid, rqpcredp, tgpcid, tgpcredp, tgpclpp)

#define CL_PARMSOUT(clp, clparmsp, reqpcid, reqpcredp, targpcredp) \
(*(clp)->cl_funcs->cl_parmsout)(clparmsp, reqpcid, reqpcredp, targpcredp)

#define	CL_PARMSSET(pp, clparmsp, clprocp, reqpcid, reqpcredp) \
    (*(pp)->p_clfuncs->cl_parmsset)(clparmsp, clprocp, reqpcid, reqpcredp)

#define CL_PREEMPT(pp, clprocp) (*(pp)->p_clfuncs->cl_preempt)(clprocp)

#define CL_PROCCMP(pp, clproc1p, clproc2p) \
    (*(pp)->p_clfuncs->cl_proccmp)(clproc1p, clproc2p)

#define CL_SETRUN(pp, clprocp) (*(pp)->p_clfuncs->cl_setrun)(clprocp)

#define CL_SLEEP(pp, clprocp, chan, disp) \
    (*(pp)->p_clfuncs->cl_sleep)(clprocp, chan, disp)

#define CL_STOP(pp, clprocp, why, what) \
    (*(pp)->p_clfuncs->cl_stop)(clprocp, why, what)

#define CL_SWAPIN(clp, fmem, procpp, runflagp) \
    (*(clp)->cl_funcs->cl_swapin)(fmem, procpp, runflagp)

#define CL_SWAPOUT(clp, fmem, justloaded, procpp, unloadokp) \
    (*(clp)->cl_funcs->cl_swapout)(freemem, justloaded, procpp, unloadokp)

#define CL_TICK(pp, clprocp) (*(pp)->p_clfuncs->cl_tick)(clprocp)

#define CL_TRAPRET(pp, clprocp) (*(pp)->p_clfuncs->cl_trapret)(clprocp)

#define CL_WAKEUP(pp, clprocp, preemptflg) \
    (*(pp)->p_clfuncs->cl_wakeup) (clprocp, preemptflg)

#endif	/* _SYS_CLASS_H */
 07070100005959000081240000000200000002000000012719347c00000269000000230000000c00000000000000000000001800000000usr/include/sys/clock.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CLOCK_H
#define _SYS_CLOCK_H

#ident	"@(#)/usr/include/sys/clock.h.sl 1.1 4.0 10/15/90 6324 AT&T-SF"
 
#define	SECHR	(60*60)	/* seconds/hr */
#define	SECDAY	(24*SECHR)	/* seconds/day */
#define	SECYR	(365*SECDAY)	/* seconds/common year */

#if defined(__STDC__)

void delay(long);

#else

void delay();

#endif

#endif	/* _SYS_CLOCK_H */
   0707010000595a000081240000000200000002000000012719347c00000535000000230000000c00000000000000000000001a00000000usr/include/sys/cmn_err.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CMN_ERR_H
#define _SYS_CMN_ERR_H

#ident	"@(#)/usr/include/sys/cmn_err.h.sl 1.1 4.0 10/15/90 8383 AT&T-SF"

/* Common error handling severity levels */

#define CE_CONT  0	/* continuation				*/
#define CE_NOTE  1	/* notice				*/
#define CE_WARN	 2	/* warning				*/
#define CE_PANIC 3	/* panic				*/

/*	Codes for where output should go.
*/

#define	PRW_BUF		0x01	/* Output to putbuf.		*/
#define	PRW_CONS	0x02	/* Output to console.		*/

extern short	prt_where;

#define VA_LIST _VOID *
#define VA_START(list, name) list = \
  (_VOID*)((char*)&name+((sizeof(name)+(sizeof(int)-1))&~(sizeof(int)-1)))
#define VA_ARG(list, mode) ((mode *) \
  (list=(_VOID*)((char*)list+sizeof(mode))))[-1]

#if defined(__STDC__)
/*PRINTFLIKE2*/
extern void cmn_err(int, char *, ...);
/*PRINTFLIKE1*/
extern void printf(char *, ...);
/*PRINTFLIKE1*/
extern void panic(char *, ...);
extern void nomemmsg(char *, int, int, int);
#else
extern void cmn_err();
extern void printf();
extern void nomemmsg();
extern void panic();
#endif	/* __STDC__ */

#endif	/* _SYS_CMN_ERR_H */
   0707010000595b000081240000000200000002000000012719347c00000ac3000000230000000c00000000000000000000001700000000usr/include/sys/conf.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CONF_H
#define _SYS_CONF_H

#ident	"@(#)/usr/include/sys/conf.h.sl 1.1 4.0 10/15/90 24855 AT&T-SF"

/*
 * Declaration of block device switch. Each entry (row) is
 * the only link between the main unix code and the driver.
 * The initialization of the device switches is in the file conf.c.
 */
struct bdevsw {
	int	(*d_open)();
	int	(*d_close)();
	int	(*d_strategy)();
	int	(*d_print)();
	int	(*d_size)();
	int	(*d_xpoll)();
	int	(*d_xhalt)();
	char	*d_name;
	struct iobuf	*d_tab;
	int	*d_flag;
};

extern struct bdevsw bdevsw[];
extern struct bdevsw shadowbsw[];

/*
 * Character device switch.
 */
struct cdevsw {
	int	(*d_open)();
	int	(*d_close)();
	int	(*d_read)();
	int	(*d_write)();
	int	(*d_ioctl)();
	int	(*d_mmap)();
	int	(*d_segmap)();
	int	(*d_poll)();
	int	(*d_xpoll)();
	int	(*d_xhalt)();
	struct tty *d_ttys;
	struct streamtab *d_str;
	char	*d_name;
	int	*d_flag;
};

extern struct cdevsw cdevsw[];
extern struct cdevsw shadowcsw[];


/*
 * And the console co routine.  This is declared as
 * a configuration parameter so that it can be changed
 * to match /dev/console.
 */
struct  conssw {
    int (*co)();
    int co_dev;
    int (*ci)();
};

extern struct conssw conssw;



/*
 * Device flags.
 *
 * Bit 0 to bit 15 are reserved for kernel.
 * Bit 16 to bit 31 are reserved for different machines.
 */
#define D_NEW		0x00	/* new-style driver */
#define	D_OLD		0x01	/* old-style driver */
#define D_DMA		0x02    /* driver does DMA  */
/*
 * Added for UFS.
 */
#define D_SEEKNEG       0x04    /* Negative seek offsets are OK */
#define D_TAPE          0x08    /* Magtape device (no bdwrite when cooked) */
/*
 * Added for pre-4.0 drivers backward compatibility.
 */
#define D_NOBRKUP	0x10	/* No breakup needed for new drivers */

#define ROOTFS_NAMESZ	7	/* Maximum length of root fstype name */

#define	FMNAMESZ	8

struct fmodsw {
	char	f_name[FMNAMESZ+1];
	struct streamtab *f_str;
	int	*f_flag;		/* same as device flag */
};
extern struct fmodsw fmodsw[];

extern int	bdevcnt;
extern int	cdevcnt;
extern int	fmodcnt;

/*
 * Line discipline switch.
 */
struct linesw {
	int	(*l_open)();
	int	(*l_close)();
	int	(*l_read)();
	int	(*l_write)();
	int	(*l_ioctl)();
	int	(*l_input)();
	int	(*l_output)();
	int	(*l_mdmint)();
};
extern struct linesw linesw[];

extern int	linecnt;
/*
 * Terminal switch
 */
struct termsw {
	int	(*t_input)();
	int	(*t_output)();
	int	(*t_ioctl)();
};
extern struct termsw termsw[];

extern int	termcnt;

#endif	/* _SYS_CONF_H */
 0707010000595c000081240000000200000002000000012719347c00000a10000000230000000c00000000000000000000001700000000usr/include/sys/cram.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CRAM_H
#define _SYS_CRAM_H

#ident	"@(#)/usr/include/sys/cram.h.sl 1.1 4.0 10/15/90 56225 AT&T-SF"

/*
 * Defines for accessing the PC AT CMOS ram.
 */

#define	CMOS_ADDR	0x70	/* I/O port address for CMOS ram address */
#define	CMOS_DATA	0x71	/* I/O port address for CMOS ram data */

#define	DSB		0x0e	/* Diagnostic status byte ram address */
#define	SSB		0x0f	/* Shutdown status byte ram address */
#define DDTB		0x10	/* Diskette drive type byte ram address */
#define	FDTB		0x12	/* Fixed disk type byte ram address */
#define	EB		0x14	/* Equipment byte ram address */
#define	BMLOW		0x15	/* Base mem size low byte ram address */
#define	BMHIGH		0x16	/* Base mem size high byte ram address */
#define	EMLOW		0x17	/* Expansion mem size low byte ram address */
#define	EMHIGH		0x18	/* Expansion mem size high byte ram address */
#define	DCEB		0x19	/* Drive C Extended byte ram address */
#define	DDEB		0x1a	/* Drive D Extended byte ram address */
#define	CKSUMLOW	0x2e	/* Checksum low byte ram address */
#define	CKSUMHIGH	0x2f	/* Checksum high byte ram address */
#define	EMLOW2		0x30	/* Expansion mem size low byte ram address */
#define	EMHIGH2		0x31	/* Expansion mem size high byte ram address */
#define	DCB		0x32	/* Date century byte ram address */
#define	IF		0x33	/* Information flag ram address */

/*
 * ioctls for accessing CMOS ram.
 */
#define CMOSIOC	('C' << 8)

#define	CMOSREAD	(CMOSIOC | 0x01)
#define	CMOSWRITE	(CMOSIOC | 0x02)

extern unsigned char	CMOSread();

/*
 * defines for XENIX compatibility
 */

/* Ports for interacting with chip at */

#define CMOSADDR	0x70 	/* Use to select RAM address */
#define CMOSDATA	0x71	/* R/W data */

/* Number of cmos bytes */

#define CMOSSIZE	0x40	/* 64 addressable bytes in chip */

/* Addresses of interest */

#define CMOSDIAG	0x0e	/* Diagnostic Status */
#define CMOSFDT		0x10	/* Floppy Disk Type */
#define CMOSHDT		0x12	/* Hard Disk Type; bits 7-4 are 1st drive */
#define CMOSEQP		0x14	/* Diskette, Video, and CoProcessor info */
#define CMOSADF		0x2d	/* Additional flags - Compaq VDU info */

/* Shifts of interest */

#define VID_SHFT	4	/* Shift display type bits into 0-3 */

/* masks of interest */
#define CMPQVDU		0x04	/* Compaq VDU bit */
#define CMPQDMM		0x01	/* Compaq Dual Mode Monitor bit */

#endif	/* _SYS_CRAM_H */
0707010000595d000081240000000200000002000000012719347c000006b9000000230000000c00000000000000000000001700000000usr/include/sys/cred.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CRED_H
#define _SYS_CRED_H

#ident	"@(#)/usr/include/sys/cred.h.sl 1.1 4.0 10/15/90 3320 AT&T-SF"
/*
 * User credentials.  The size of the cr_groups[] array is configurable
 * but is the same (ngroups_max) for all cred structures; cr_ngroups
 * records the number of elements currently in use, not the array size.
 */

typedef struct cred {
	ushort	cr_ref;			/* reference count */
	ushort	cr_ngroups;		/* number of groups in cr_groups */
	uid_t	cr_uid;			/* effective user id */
	gid_t	cr_gid;			/* effective group id */
	uid_t	cr_ruid;		/* real user id */
	gid_t	cr_rgid;		/* real group id */
	uid_t	cr_suid;		/* "saved" user id (from exec) */
	gid_t	cr_sgid;		/* "saved" group id (from exec) */
	gid_t	cr_groups[1];		/* supplementary group list */
} cred_t;

#ifdef _KERNEL

#define	crhold(cr)	(cr)->cr_ref++

extern int ngroups_max;

#if defined(__STDC__)

extern void cred_init(void);
extern void crfree(cred_t *);
extern cred_t *crget(void);
extern cred_t *crcopy(cred_t *);
extern cred_t *crdup(cred_t *);
extern cred_t *crgetcred(void);
extern int suser(cred_t *);
extern int groupmember(gid_t, cred_t *);
extern int hasprocperm(cred_t *, cred_t *);

#else

extern void cred_init();
extern void crfree();
extern cred_t *crget();
extern cred_t *crcopy();
extern cred_t *crdup();
extern cred_t *crgetcred();
extern int suser();
extern int groupmember();
extern int hasprocperm();


#endif	/* __STDC */


#endif

#endif	/* _SYS_CRED_H */
   0707010000595e000081240000000200000002000000012719347c00000987000000230000000c00000000000000000000001900000000usr/include/sys/crtctl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_CRTCTL_H
#define _SYS_CRTCTL_H

#ident	"@(#)/usr/include/sys/crtctl.h.sl 1.1 4.0 10/15/90 42288 AT&T-SF"
/*
 *	Define the cursor control codes
 */
#define ESC	033	/* Escape for command */

/* Commands */
#define CUP	0101	/* Cursor up */
#define CDN	0102	/* Cursor down */
#define CRI	0103	/* Cursor right */
#define CLE	0104	/* Cursor left */
#define NL	0134	/* Terminal newline function */
#define HOME	0105	/* Cursor home */
#define VHOME	0106	/* cursor home to variable portion */
#define LCA	0107	/* Load cursor, followed by (x,y) in (col,row) */
#define CRTN	0133	/* Return cursor to beginning of line */

#define STB	0110	/* Start blink */
#define SPB	0111	/* Stop blink */
#define CS	0112	/* Clear Screen */
#define CM	0135	/* Clear Memory */
#define EEOL	0113	/* Erase to end of line */
#define EEOP	0114	/* Erase to end of page */
#define DC	0115	/* Delete character */
#define DL	0116	/* Delete line */
#define IC	0117	/* Insert character */
#define IL	0120	/* Insert line */
#define KBL	0121	/* keyboard lock */
#define KBU	0122	/* keyboard unlock */
#define ATAB	0123	/* Set column of tabs */
#define STAB	0124	/* Set single tab */
#define CTAB	0125	/* Clear Tabs */
#define USCRL	0126	/* Scroll up one line */
#define DSCRL	0127	/* Scroll down one line */
#define ASEG	0130	/* Advance segment */
#define BPRT	0131	/* Begin protect */
#define EPRT	0132	/* End   protect */

#define SVSCN	0136	/* Define variable portion of screen (OS only) */
#define UVSCN	0137	/* Scroll Up variable portion of screen */
#define DVSCN	0140	/* Scroll Down variable portion of screen */

#define SVID	0141	/* Set Video Attributes */
#define CVID	0142	/* Clear Video Attributes */
#define DVID	0143	/* Define Video Attributes */
/* Video Attribute Definitions */
#define VID_NORM	000	/* normal */
#define VID_UL		001	/* underline */
#define VID_BLNK	002	/* blink */
#define VID_REV	004	/* reverse video */
#define VID_DIM	010	/* dim intensity */
#define VID_BOLD	020	/* bright intensity */
#define VID_OFF	040	/* blank out field */

#define BRK	000	/* transmit break */
#define HIQ	001	/* Put remainder of write on high priority queue. */

#endif	/* _SYS_CRTCTL_H */
 0707010000595f000081240000000200000002000000012719347c000011d6000000230000000c00000000000000000000001600000000usr/include/sys/ddi.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DDI_H
#define _SYS_DDI_H

#ident	"@(#)/usr/include/sys/ddi.h.sl 1.1 4.0 10/15/90 63172 AT&T-SF"

/*
 * ddi.h -- the flag and function definitions needed by DDI-conforming
 * drivers.  This header file contains #undefs to undefine macros that
 * drivers would otherwise pick up in order that function definitions
 * may be used. Programmers should place the include of "sys/ddi.h"
 * after any header files that define the macros #undef'ed or the code
 * may compile incorrectly.
 */

/*
 * define min() and max() as macros so that drivers will not pick up the
 * min() and max() kernel functions since they do unsigned comparison only.
 */
#define min(a, b)   ((a) < (b) ? (a) : (b))
#define max(a, b)   ((a) < (b) ? (b) : (a))


/*
 * The following macros designate a kernel parameter for drv_getparm 
 * and drv_setparm. Implementation-specific parameter defines should
 * start at 100.
 */

#define	TIME	1
#define	UPROCP	2
#define	PPGRP	3
#define	LBOLT	4
#define	SYSRINT	5
#define	SYSXINT	6
#define	SYSMINT	7
#define	SYSRAWC	8
#define	SYSCANC	9
#define	SYSOUTC	10
#define	PPID	11
#define	PSID	12
#define UCRED	13

#ifndef NMAJORENTRY
#define NMAJORENTRY	256
#endif

extern int drv_getparm();
extern int drv_setparm();

extern int drv_getevtoken();
extern void drv_relevtoken();

extern void drv_usecwait();
extern clock_t drv_hztousec();
extern clock_t drv_usectohz();

/* convert external to internal major number */
extern int etoimajor();
/* convert internal to extern major number */
extern int itoemajor();

/* The following declaration takes the place of an inline function
 * defined in sys/inline.h .
 */

extern paddr_t kvtophys();	

#include	<sys/buf.h>
#include	<sys/uio.h>

#if defined(__STDC__)
extern int physiock(void(*)(), struct buf*, dev_t, int, daddr_t, struct uio*);
extern int drv_priv(struct cred *);
#else
extern int drv_priv();
extern int physiock();
#endif

/* The following declarations take the place of macros in 
 * sysmacros.h The undefs are for any case where a driver includes 
 * sysmacros.h, even though DDI conforming drivers must not.
 */

#undef getemajor
#undef geteminor
#undef getmajor
#undef getminor
#undef makedevice
#undef cmpdev
#undef expdev

extern major_t getemajor();
extern minor_t geteminor();
extern major_t getmajor();
extern minor_t getminor();
extern dev_t makedevice();
extern dev_t cmpdev();
extern dev_t expdev();

/* The following macros from param.h are also being converted to
 * functions and #undefs must be done here as well since param.h
 * will be included by most if not every driver 
 */

#undef btop
#undef btopr
#undef ptob

extern unsigned long btop();
extern unsigned long btopr();
extern unsigned long ptob();


/* Drivers must include map.h to pick up the structure definition */
/* for the map structure and the declaration of the function malloc(). */
/* Unfortunately, map.h also includes definitions of macros that */
/* drivers should be calling as functions. The following #undefs allow */
/* kernel code to use the macros while drivers call the functions */

#undef mapinit
#undef mapwant

extern void mapinit();
extern unsigned long mapwant();
extern void setmapwant();

/* when DKI changes are folded back in to DDI, the functions mapinit
 * mapwant and setmapwant should be updated to be the following DKI
 * functions:
 */

extern void rminit();
extern unsigned long rmwant();
extern void rmsetwant();



/* STREAMS drivers and modules must include stream.h to pick up the */
/* needed structure and flag definitions. As was the case with map.h, */
/* macros used by both the kernel and drivers in times past now have */
/* a macro definition for the kernel and a function definition for */
/* drivers. The following #undefs allow drivers to include stream.h */
/* but call the functions rather than macros. */

#undef OTHERQ
#undef RD
#undef WR
#undef datamsg
#undef putnext
#undef splstr

extern struct queue *OTHERQ();	/* stream.h */
extern struct queue *RD();
extern struct queue *WR();
extern int datamsg();
extern int putnext();
extern int splstr();

/* declarations of functions for allocating and deallocating the space */
/* for a buffer header (just a header, not the associated buffer) */

extern struct buf *getrbuf();
extern void freerbuf();

/* end of ddi.h */
#endif	/* _SYS_DDI_H */
  07070100005960000081240000000200000002000000012719347c000003fa000000230000000c00000000000000000000001800000000usr/include/sys/debug.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DEBUG_H
#define _SYS_DEBUG_H

#ident	"@(#)/usr/include/sys/debug.h.sl 1.1 4.0 10/15/90 15967 AT&T-SF"

#define	YES 1
#define	NO  0

#if DEBUG == YES

#if defined(__STDC__)
extern int assfail(char *, char *, int);
#define ASSERT(EX) ((void)((EX) || assfail(#EX, __FILE__, __LINE__)))
#else
extern int assfail();
#define ASSERT(EX) ((void)((EX) || assfail("EX", __FILE__, __LINE__)))
#endif	/* end __STDC__ */

#define DB_ISKV(A) ((unsigned)(A) >= KVBASE && (unsigned)(A) < UVUBLK)

#else	/* else DEBUG */

#define ASSERT(x)
#define DB_ISKV(A) 1
#endif	/* end DEBUG */

#ifdef MONITOR
#define MONITOR(id, w1, w2, w3, w4) monitor(id, w1, w2, w3, w4)
#else
#define MONITOR(id, w1, w2, w3, w4)
#endif

#define STATIC

#endif	/* _SYS_DEBUG_H */
  07070100005961000081240000000200000002000000012719347c00000bd3000000230000000c00000000000000000000001b00000000usr/include/sys/debugreg.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DEBUGREG_H
#define _SYS_DEBUGREG_H

#ident	"@(#)/usr/include/sys/debugreg.h.sl 1.1 4.0 10/15/90 12324 AT&T-SF"

/*
** Specify masks for accessing the i386 debug registers.
*/

/*
** The debug registers are found in an array (debugreg) in the u block.
** On the i386, there are 4 registers to specify linear addresses.
** dr4 and dr5 are reserved.
*/
#define DR_FIRSTADDR 0  /* u.u_debugreg[DR_FIRSTADDR] */
#define DR_LASTADDR 3   /* u.u_debugreg[DR_LASTADDR]  */

/*
** The debug status is found in dr6 after a debug trap.
*/
#define DR_STATUS 6           /* u.u_debugreg[DR_STATUS]     */
#define DR_TRAP0 0x1          /* Trap from debug register #0 */
#define DR_TRAP1 0x2          /* Trap from debug register #1 */
#define DR_TRAP2 0x4          /* Trap from debug register #2 */
#define DR_TRAP3 0x8          /* Trap from debug register #3 */
#define DR_ICEALSO   0x2000   /* Flag bit reserved for the in-circuit-emulator*/
#define DR_SINGLESTEP 0x4000  /* Trap resulting from the single-step flag */
#define DR_TASKSWITCH 0x8000  /* Trap resulting from a task-switch */

/*
** dr7 controls the rest of the debug registers.
** use shifts and masks because arrays of fields tend to get aligned.
** For example,
**    dr7 & DR_LOCAL_ENABLE_MASK
**    dr7 >> (DR_LOCAL_ENABLE_SHIFT + r# * DR_ENABLE_SIZE) & 0x1
**    dr7 >> (DR_CONTROL_SHIFT + r# * DR_CONTROL_SIZE) & DR_RW_MASK
** Note that the GLOBAL bits below and always turned off by the kernel.
*/
#define DR_CONTROL 7               /* u.u_debugreg[DR_CONTROL] */
#define DR_LOCAL_ENABLE_MASK 0x55  /* Enable all 4 regs for ldt addresses   */
#define DR_GLOBAL_ENABLE_MASK 0xAA /* Enable all 4 regs for gdt addresses   */
#define DR_CONTROL_RESERVED 0xFC00 /* Bits reserved by Intel                */
#define DR_LOCAL_SLOWDOWN 0x100    /* Slow the pipeline for ldt addresses   */
#define DR_GLOBAL_SLOWDOWN 0x200   /* Slow the pipeline for gdt addresses   */

#define DR_LOCAL_ENABLE_SHIFT 0    /* Additional shift to the local enable  */
#define DR_GLOBAL_ENABLE_SHIFT 1   /* Additional shift to the global enable */
#define DR_ENABLE_SIZE 2           /* There are 2 enable bits per register  */

#define DR_CONTROL_SHIFT 16        /* Shift to get to register control bits */
#define DR_CONTROL_SIZE 4          /* There are 4 control bits per register */
#define DR_RW_MASK 0x3             /* Two of these bits specify r/w access  */
#define DR_RW_EXECUTE 0x0          /* Settings for the read/write mask      */
#define DR_RW_WRITE 0x1
#define DR_RW_READ 0x3
#define DR_LEN_MASK 0xC            /* Two of these bits specify data length */
#define DR_LEN_1 0x0               /* Settings for data length              */
#define DR_LEN_2 0x4
#define DR_LEN_4 0xC

#endif	/* _SYS_DEBUGREG_H */
 07070100005962000081240000000200000002000000012719347c0000022e000000230000000c00000000000000000000001600000000usr/include/sys/dir.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DIR_H
#define _SYS_DIR_H

#ident	"@(#)/usr/include/sys/dir.h.sl 1.1 4.0 10/15/90 60813 AT&T-SF"
/* WARNING!!!  This stub will be removed for release 4.0. Please 
*  be advised to change any source code using this header file */
#include <sys/fs/s5dir.h>

#endif	/* _SYS_DIR_H */
  07070100005963000081240000000200000002000000012719347c0000037b000000230000000c00000000000000000000001900000000usr/include/sys/dirent.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DIRENT_H
#define _SYS_DIRENT_H

#ident	"@(#)/usr/include/sys/dirent.h.sl 1.1 4.0 10/15/90 14905 AT&T-SF"

/*
 * File-system independent directory entry.
 */
struct dirent {
	ino_t		d_ino;		/* "inode number" of entry */
	off_t		d_off;		/* offset of disk directory entry */
	unsigned short	d_reclen;	/* length of this record */
	char		d_name[1];	/* name of file */
};

typedef	struct	dirent	dirent_t;

#if !defined(_POSIX_SOURCE)
#if defined(__STDC__) && !defined(_KERNEL)
int getdents(int, struct dirent *, unsigned);
#else
int getdents( );
#endif
#endif /* !defined(_POSIX_SOURCE) */

#endif	/* _SYS_DIRENT_H */
 07070100005964000081240000000200000002000000012719347c00000968000000230000000c00000000000000000000001700000000usr/include/sys/disp.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DISP_H
#define _SYS_DISP_H

#ident	"@(#)/usr/include/sys/disp.h.sl 1.1 4.0 10/15/90 9335 AT&T-SF"

#ifndef _SYS_PRIOCNTL_H
#include <sys/priocntl.h>
#endif


/*
 * The following is the format of a dispatcher queue entry.
 */
typedef struct dispq {
	struct proc	*dq_first;	/* first proc on queue or NULL */
	struct proc	*dq_last;	/* last proc on queue or NULL */
	int		dq_sruncnt;	/* no. of loaded, runnable procs on queue */
} dispq_t;


#ifdef _KERNEL

/*
 * Global scheduling variables.
 */
extern int	runrun;		/* preemption flag */
extern int	kprunrun;	/* kernel preemption flag */
extern int	npwakecnt;	/* count of non-preemptive wakeups */
extern struct proc *curproc;	/* currently running process */
extern int	curpri;		/* priority of current process */
extern int	maxrunpri;	/* priority of highest priority active queue */


/*
 * Public scheduling functions.
 */
#if defined(__STDC__)

extern boolean_t	dispdeq(proc_t *pp);
extern int	getcid(char *clname, id_t *cidp);
extern int	parmsin(pcparms_t *parmsp, proc_t *reqpp, proc_t *targpp);
extern int	parmsout(pcparms_t *parmsp, proc_t *reqpp, proc_t *targpp);
extern int	parmsset(pcparms_t *parmsp, proc_t *reqpp, proc_t *targpp);
extern void	dispinit();
extern void	getglobpri(pcparms_t *parmsp, int *globprip);
extern void	parmsget(proc_t *pp, pcparms_t *parmsp);
extern void	preempt();
extern void	setbackdq(proc_t *pp);
extern void	setfrontdq(proc_t *pp);
#ifndef KPERF
extern void	swtch();
#endif /* KPERF */
extern void	dq_sruninc(int pri);
extern void	dq_srundec(int pri);

#else

extern boolean_t	dispdeq();
extern int	getcid(), parmsin(), parmsout(), parmsset();
extern void	dispinit(), getglobpri(), parmsget(), preempt();
extern void	setbackdq(), setfrontdq(), swtch(), dq_sruninc(), dq_srundec();

#endif	/* __STDC__ */


#ifdef	KPERF
#define PREEMPT() \
{ \
	if (kprunrun != 0) { \
		preempt(); \
	} \
	else if (kpftraceflg) { \
		asm("  movl	%eip, Kpc"); \
		kperf_write(KPT_PREEMPT,Kpc,curproc); \
	} \
}

#else	/* !KPERF */

#define	PREEMPT()	if (kprunrun != 0){ \
				preempt(); \
			}

#endif	/* KPERF */

#endif	/* _KERNEL */

#endif	/* _SYS_DISP_H */
07070100005965000081240000000200000002000000012719347c00000295000000230000000c00000000000000000000001500000000usr/include/sys/dl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DL_H
#define _SYS_DL_H

#ident	"@(#)/usr/include/sys/dl.h.sl 1.1 4.0 10/15/90 65485 AT&T-SF"

typedef	struct dl {
	ulong	dl_lop;
	long	dl_hop;
} dl_t;

extern dl_t	ladd();
extern dl_t	lsub();
extern dl_t	lmul();
extern dl_t	ldivide();
extern dl_t	lshiftl();
extern dl_t	llog10();
extern dl_t	lexp10();

extern dl_t	lzero;
extern dl_t	lone;
extern dl_t	lten;

#endif	/* _SYS_DL_H */
   07070100005966000081240000000200000002000000012719347c00004d12000000230000000c00000000000000000000001700000000usr/include/sys/dlpi.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_DLPI_H
#define _SYS_DLPI_H

#ident	"@(#)/usr/include/sys/dlpi.h.sl 1.1 4.0 10/15/90 53421 AT&T-SF"

/*
 * dlpi.h header for Data Link Provider Interface
 */

/*
 * This header file has encoded the values so an existing driver 
 * or user which was written with the Logical Link Interface(LLI)
 * can migrate to the DLPI interface in a binary compatible manner.
 * Any fields which require a specific format or value are flagged
 * with a comment containing the message LLI compatibility.
 */

/*
 * Primitives for Local Management Services
 */
#define DL_INFO_REQ		0x00	/* Information Req, LLI compatibility */
#define DL_INFO_ACK		0x03	/* Information Ack, LLI compatibility */
#define DL_ATTACH_REQ		0x0b	/* Attach a PPA */
#define DL_DETACH_REQ		0x0c	/* Detach a PPA */
#define DL_BIND_REQ		0x01	/* Bind dlsap address, LLI compatibility */
#define DL_BIND_ACK		0x04	/* Dlsap address bound, LLI compatibility */
#define DL_UNBIND_REQ		0x02	/* Unbind dlsap address, LLI compatibility */
#define DL_OK_ACK		0x06	/* Success acknowledgment, LLI compatibility */
#define DL_ERROR_ACK		0x05	/* Error acknowledgment, LLI compatibility */
#define DL_SUBS_BIND_REQ	0x1b	/* Bind Subsequent DLSAP address */
#define DL_SUBS_BIND_ACK	0x1c	/* Subsequent DLSAP address bound */

/*
 * Primitives used for Connectionless Service
 */
#define DL_UNITDATA_REQ		0x07	/* datagram send request, LLI compatibility */
#define DL_UNITDATA_IND		0x08	/* datagram receive indication, LLI compatibility */
#define DL_UDERROR_IND		0x09	/* datagram error indication, LLI compatibility */
#define DL_UDQOS_REQ		0x0a	/* set QOS for subsequent datagram transmissions */

/*
 * Primitives used for Connection-Oriented Service
 */
#define DL_CONNECT_REQ		0x0d	/* Connect request */
#define DL_CONNECT_IND		0x0e	/* Incoming connect indication */
#define DL_CONNECT_RES		0x0f	/* Accept previous connect indication */
#define DL_CONNECT_CON		0x10	/* Connection established */

#define DL_TOKEN_REQ		0x11	/* Passoff token request */
#define DL_TOKEN_ACK		0x12	/* Passoff token ack */

#define DL_DISCONNECT_REQ	0x13	/* Disconnect request */
#define DL_DISCONNECT_IND	0x14	/* Disconnect indication */

#define DL_RESET_REQ		0x17	/* Reset service request */
#define DL_RESET_IND		0x18	/* Incoming reset indication */
#define DL_RESET_RES		0x19	/* Complete reset processing */
#define DL_RESET_CON		0x1a	/* Reset processing complete */


/*
 * DLPI interface states
 */
#define	DL_UNATTACHED		0x04	/* PPA not attached */
#define DL_ATTACH_PENDING	0x05	/* Waiting ack of DL_ATTACH_REQ */
#define DL_DETACH_PENDING	0x06	/* Waiting ack of DL_DETACH_REQ */
#define	DL_UNBOUND		0x00	/* PPA attached, LLI compatibility */
#define	DL_BIND_PENDING		0x01	/* Waiting ack of DL_BIND_REQ, LLI compatibility */
#define	DL_UNBIND_PENDING	0x02	/* Waiting ack of DL_UNBIND_REQ, LLI compatibility */
#define	DL_IDLE			0x03	/* dlsap bound, awaiting use, LLI compatibility */
#define DL_UDQOS_PENDING	0x07	/* Waiting ack of DL_UDQOS_REQ */
#define	DL_OUTCON_PENDING	0x08	/* outgoing connection, awaiting DL_CONN_CON */
#define	DL_INCON_PENDING	0x09	/* incoming connection, awaiting DL_CONN_RES */
#define DL_CONN_RES_PENDING	0x0a	/* Waiting ack of DL_CONNECT_RES */
#define	DL_DATAXFER		0x0b	/* connection-oriented data transfer */
#define	DL_USER_RESET_PENDING	0x0c	/* user initiated reset, awaiting DL_RESET_CON */
#define	DL_PROV_RESET_PENDING	0x0d	/* provider initiated reset, awaiting DL_RESET_RES */
#define DL_RESET_RES_PENDING	0x0e	/* Waiting ack of DL_RESET_RES */
#define DL_DISCON8_PENDING	0x0f	/* Waiting ack of DL_DISC_REQ when in DL_OUTCON_PENDING */
#define DL_DISCON9_PENDING	0x10	/* Waiting ack of DL_DISC_REQ when in DL_INCON_PENDING */
#define DL_DISCON11_PENDING	0x11	/* Waiting ack of DL_DISC_REQ when in DL_DATAXFER */
#define DL_DISCON12_PENDING	0x12	/* Waiting ack of DL_DISC_REQ when in DL_USER_RESET_PENDING */
#define DL_DISCON13_PENDING	0x13	/* Waiting ack of DL_DISC_REQ when in DL_DL_PROV_RESET_PENDING */
#define DL_SUBS_BIND_PND	0x14	/* Waiting ack of DL_SUBS_BIND_REQ */


/*
 * DL_ERROR_ACK error return values
 */
#define	DL_ACCESS	0x02	/* Improper permissions for request, LLI compatibility */
#define	DL_BADADDR	0x01	/* DLSAP address in improper format or invalid */
#define	DL_BADCORR	0x05	/* Sequence number not from outstanding DL_CONN_IND */
#define	DL_BADDATA	0x06	/* User data exceeded provider limit */
#define	DL_BADPPA	0x08	/* Specified PPA was invalid */
#define DL_BADPRIM	0x09	/* Primitive received is not known by DLS provider */
#define DL_BADQOSPARAM	0x0a	/* QOS parameters contained invalid values */
#define DL_BADQOSTYPE	0x0b	/* QOS structure type is unknown or unsupported */
#define	DL_BADSAP	0x00	/* Bad LSAP selector, LLI compatibility */
#define DL_BADTOKEN	0x0c	/* Token used not associated with an active stream */
#define DL_BOUND	0x0d	/* Attempted second bind with dl_max_conind or  */
				/*	dl_conn_mgmt > 0 on same DLSAP or PPA */
#define	DL_INITFAILED	0x0e	/* Physical Link initialization failed */
#define DL_NOADDR	0x0f	/* Provider couldn't allocate alternate address */
#define	DL_NOTINIT	0x10	/* Physical Link not initialized */
#define	DL_OUTSTATE	0x03	/* Primitive issued in improper state, LLI compatibility */
#define	DL_SYSERR	0x04	/* UNIX system error occurred, LLI compatibility */
#define	DL_UNSUPPORTED	0x07	/* Requested service not supplied by provider */
#define DL_UNDELIVERABLE 0x11	/* Previous data unit could not be delivered */
#define DL_NOTSUPPORTED  0x12	/* Primitive is known but not supported by DLS provider */


/*
 * DLPI media types supported
 */
#define	DL_CSMACD	0x0	/* IEEE 802.3 CSMA/CD network, LLI Compatibility */
#define	DL_TPB		0x1	/* IEEE 802.4 Token Passing Bus, LLI Compatibility */
#define	DL_TPR		0x2	/* IEEE 802.5 Token Passing Ring, LLI Compatibility */
#define	DL_METRO	0x3	/* IEEE 802.6 Metro Net, LLI Compatibility */
#define	DL_ETHER	0x4	/* Ethernet Bus, LLI Compatibility */
#define	DL_HDLC		0x05	/* ISO HDLC protocol support, bit synchronous */
#define DL_CHAR		0x06	/* Character Synchronous protocol support, eg BISYNC */
#define	DL_CTCA		0x07	/* IBM Channel-to-Channel Adapter */


/*
 * DLPI provider service supported.
 * These must be allowed to be bitwise-OR for dl_service_mode in
 * DL_INFO_ACK.
 */
#define DL_CODLS	0x01	/* support connection-oriented service */
#define DL_CLDLS	0x02	/* support connectionless data link service */
#define	DL_CL_ETHER	0x04	/* support Ethernet service class */


/*
 * DLPI provider style.
 * The DLPI provider style which determines whether a provider
 * requires a DL_ATTACH_REQ to inform the provider which PPA
 * user messages should be sent/received on.
 */
#define	DL_STYLE1	0x0500	/* PPA is implicitly bound by open(2) */
#define	DL_STYLE2	0x0501	/* PPA must be explicitly bound via DL_ATTACH_REQ */

/*
 * DLPI flag for MORE IDU's for a single SDU
 */
#define	DL_MORE		0x08

/*
 * DLPI Originator for Disconnect and Resets
 */
#define	DL_PROVIDER	0x0700
#define	DL_USER		0x0701

/*
 * DLPI Disconnect Reasons
 */
#define	DL_CONREJ_DEST_UNKNOWN			0x0800
#define	DL_CONREJ_DEST_UNREACH_PERMANENT	0x0801
#define	DL_CONREJ_DEST_UNREACH_TRANSIENT	0x0802
#define	DL_CONREJ_QOS_UNAVAIL_PERMANENT		0x0803
#define	DL_CONREJ_QOS_UNAVAIL_TRANSIENT		0x0804
#define	DL_CONREJ_PERMANENT_COND		0x0805
#define	DL_CONREJ_TRANSIENT_COND		0x0806
#define	DL_DISC_ABNORMAL_CONDITION		0x0807
#define	DL_DISC_NORMAL_CONDITION		0x0808
#define DL_DISC_PERMANENT_CONDITION		0x0809
#define	DL_DISC_TRANSIENT_CONDITION		0x080a
#define	DL_DISC_UNSPECIFIED			0x080b

/*
 * DLPI Reset Reasons
 */
#define	DL_RESET_FLOW_CONTROL	0x0900
#define	DL_RESET_LINK_ERROR	0x0901
#define	DL_RESET_RESYNCH	0x0902

/*
 * DLPI Quality Of Service definition for use in QOS structure definitions.
 * The QOS structures are used in connection establishment, DL_INFO_ACK,
 * and setting connectionless QOS values.
 */

/*
 * Throughput
 *
 * This parameter is specified for both directions.
 */
typedef struct {
		long	dl_target_value;	/* desired bits/second desired */
		long	dl_accept_value;	/* min. acceptable bits/second */
} dl_through_t;

/*
 * transit delay specification 
 *
 * This parameter is specified for both directions.
 * expressed in milliseconds assuming a DLSDU size of 128 octets.
 * The scaling of the value to the current DLSDU size is provider dependent.
 */
typedef struct {
		long	dl_target_value;	/* desired value of service */
		long	dl_accept_value;	/* min. acceptable value of service */
} dl_transdelay_t;

/*
 * priority specification
 * priority range is 0-100, with 0 being highest value.
 */
typedef struct {
		long	dl_min;
		long	dl_max;
} dl_priority_t;


/*
 * protection specification
 *
 */
#define DL_NONE			0x0B01	/* no protection supplied */
#define DL_MONITOR		0x0B02	/* protection against passive monitoring */
#define DL_MAXIMUM		0x0B03	/* protection against modification, replay, */
					/* addition, or deletion */

typedef struct {
		long	dl_min;
		long	dl_max;
} dl_protect_t;


/*
 * Resilience specification
 * probabilities are scaled by a factor of 10,000 with a time interval
 * of 10,000 seconds.
 */
typedef struct {
		long	dl_disc_prob;	/* probability of provider init DISC */
		long	dl_reset_prob;	/* probability of provider init RESET */
} dl_resilience_t;


/*
 * QOS type definition to be used for negotiation with the
 * remote end of a connection, or a connectionless unitdata request.
 * There are two type definitions to handle the negotiation 
 * process at connection establishment. The typedef dl_qos_neg_t
 * is used to present a range for parameters. This is used
 * in the DL_CONNECT_REQ and DL_CONNECT_IND messages. The typedef
 * dl_qos_sel_t is used to select a specific value for the QOS
 * parameters. This is used in the DL_CONNECT_RES, DL_CONNECT_CON,
 * and DL_INFO_ACK messages to define the selected QOS parameters
 * for a connection.
 *
 * NOTE
 *	A DataLink provider which has unknown values for any of the fields
 *	will use a value of DL_UNKNOWN for all values in the fields.
 *
 * NOTE
 *	A QOS parameter value of DL_QOS_DONT_CARE informs the DLS
 *	provider the user requesting this value doesn't care 
 *	what the QOS parameter is set to. This value becomes the
 *	least possible value in the range of QOS parameters.
 *	The order of the QOS parameter range is then:
 *
 *		DL_QOS_DONT_CARE < 0 < MAXIMUM QOS VALUE
 */
#define DL_UNKNOWN		-1
#define DL_QOS_DONT_CARE	-2

/*
 * Every QOS structure has the first 4 bytes containing a type
 * field, denoting the definition of the rest of the structure.
 * This is used in the same manner has the dl_primitive variable
 * is in messages.
 *
 * The following list is the defined QOS structure type values and structures.
 */
#define DL_QOS_CO_RANGE1	0x0101
#define DL_QOS_CO_SEL1		0x0102
#define DL_QOS_CL_RANGE1	0x0103
#define DL_QOS_CL_SEL1		0x0104

typedef struct {
		ulong		dl_qos_type;
		dl_through_t	dl_rcv_throughput;
		dl_transdelay_t	dl_rcv_trans_delay;
		dl_through_t	dl_xmt_throughput;
		dl_transdelay_t	dl_xmt_trans_delay;
		dl_priority_t	dl_priority;
		dl_protect_t	dl_protection;
		long		dl_residual_error;
		dl_resilience_t	dl_resilience;
}	dl_qos_co_range1_t;

typedef struct {
		ulong		dl_qos_type;
		long		dl_rcv_throughput;
		long		dl_rcv_trans_delay;
		long		dl_xmt_throughput;
		long		dl_xmt_trans_delay;
		long		dl_priority;
		long		dl_protection;
		long		dl_residual_error;
		dl_resilience_t	dl_resilience;
}	dl_qos_co_sel1_t;

typedef struct {
		ulong		dl_qos_type;
		dl_transdelay_t	dl_trans_delay;
		dl_priority_t	dl_priority;
		dl_protect_t	dl_protection;
		long		dl_residual_error;
}	dl_qos_cl_range1_t;

typedef struct {
		ulong		dl_qos_type;
		long		dl_trans_delay;
		long		dl_priority;
		long		dl_protection;
		long		dl_residual_error;
}	dl_qos_cl_sel1_t;

/*
 * DLPI interface primitive definitions.
 *
 * Each primitive is sent as a stream message.  It is possible that
 * the messages may be viewed as a sequence of bytes that have the
 * following form without any padding. The structure definition
 * of the following messages may have to change depending on the
 * underlying hardware architecture and crossing of a hardware
 * boundary with a different hardware architecture.
 *
 * Fields in the primitives having a name of the form
 * dl_reserved cannot be used and have the value of
 * binary zero, no bits turned on.
 *
 * Each message has the name defined followed by the
 * stream message type (M_PROTO, M_PCPROTO, M_DATA)
 */

/*
 *	LOCAL MANAGEMENT SERVICE PRIMITIVES
 */

/*
 * DL_INFO_REQ, M_PCPROTO type
 */
typedef struct {
	ulong	dl_primitive;
} dl_info_req_t;

/*
 * DL_INFO_ACK, M_PCPROTO type
 */
typedef struct {
	ulong		dl_primitive;
	ulong		dl_max_sdu;
	ulong		dl_min_sdu;
	ulong		dl_addr_length;
	ulong		dl_mac_type;
	ulong		dl_reserved;
	ulong		dl_current_state;
	ulong		dl_reserved2;
	ulong		dl_service_mode;
	ulong		dl_qos_length;
	ulong		dl_qos_offset;
	ulong		dl_qos_range_length;
	ulong		dl_qos_range_offset;
	long		dl_provider_style;
	ulong 		dl_addr_offset;
	ulong		dl_growth;
} dl_info_ack_t;

/*
 * DL_ATTACH_REQ, M_PROTO type
 */
typedef struct {
	ulong		dl_primitive;
	ulong		dl_ppa;
} dl_attach_req_t;

/*
 * DL_DETACH_REQ, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
} dl_detach_req_t;

/*
 * DL_BIND_REQ, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_sap;
	ulong	dl_max_conind;
	ushort	dl_service_mode;
	ushort	dl_conn_mgmt;
} dl_bind_req_t;

/*
 * DL_BIND_ACK, M_PCPROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_sap;
	ulong	dl_addr_length;
	ulong	dl_addr_offset;
	ulong	dl_max_conind;
	ulong	dl_growth;
} dl_bind_ack_t;

/*
 * DL_SUBS_BIND_REQ, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong 	dl_subs_sap_offset;
	ulong	dl_subs_sap_len;
} dl_subs_bind_req_t;

/*
 * DL_SUBS_BIND_ACK, M_PCPROTO type
 */
typedef struct {
	ulong dl_primitive;
	ulong dl_subs_sap_offset;
	ulong dl_subs_sap_len;
} dl_subs_bind_ack_t;

/*
 * DL_UNBIND_REQ, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
} dl_unbind_req_t;

/*
 * DL_OK_ACK, M_PCPROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_correct_primitive;
} dl_ok_ack_t;

/*
 * DL_ERROR_ACK, M_PCPROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_error_primitive;
	ulong	dl_errno;
	ulong	dl_unix_errno;
} dl_error_ack_t;


/*
 *	CONNECTION-ORIENTED SERVICE PRIMITIVES
 */

/*
 * DL_CONNECT_REQ, M_PROTO type
 */
typedef struct {
	ulong			dl_primitive;
	ulong			dl_dest_addr_length;
	ulong			dl_dest_addr_offset;
	ulong			dl_qos_length;
	ulong			dl_qos_offset;
	ulong			dl_growth;
} dl_connect_req_t;

/*
 * DL_CONNECT_IND, M_PROTO type
 */
typedef struct {
	ulong			dl_primitive;
	ulong			dl_correlation;
	ulong			dl_called_addr_length;
	ulong			dl_called_addr_offset;
	ulong			dl_calling_addr_length;
	ulong			dl_calling_addr_offset;
	ulong			dl_qos_length;
	ulong			dl_qos_offset;
	ulong			dl_growth;
} dl_connect_ind_t;

/*
 * DL_CONNECT_RES, M_PROTO type
 */
typedef struct {
	ulong			dl_primitive;
	ulong			dl_correlation;
	ulong			dl_resp_token;
	ulong			dl_qos_length;
	ulong			dl_qos_offset;
	ulong			dl_growth;
} dl_connect_res_t;

/*
 * DL_CONNECT_CON, M_PROTO type
 */
typedef struct {
	ulong			dl_primitive;
	ulong			dl_resp_addr_length;
	ulong			dl_resp_addr_offset;
	ulong			dl_qos_length;
	ulong			dl_qos_offset;
	ulong			dl_growth;
	
} dl_connect_con_t;

/*
 * DL_TOKEN_REQ, M_PCPROTO type
 */
typedef struct {
	ulong		dl_primitive;
} dl_token_req_t;

/*
 * DL_TOKEN_ACK, M_PCPROTO type
 */
typedef struct {
	ulong		dl_primitive;
	ulong		dl_token;
}dl_token_ack_t;

/*
 * DL_DISCONNECT_REQ, M_PROTO type
 */
typedef struct {
	ulong		dl_primitive;
	ulong		dl_reason;
	ulong		dl_correlation;
} dl_disconnect_req_t;

/*
 * DL_DISCONNECT_IND, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_originator;
	ulong	dl_reason;
	ulong	dl_correlation;
} dl_disconnect_ind_t;

/*
 * DL_RESET_REQ, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
} dl_reset_req_t;

/*
 * DL_RESET_IND, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_originator;
	ulong	dl_reason;
} dl_reset_ind_t;

/*
 * DL_RESET_RES, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
} dl_reset_res_t;

/*
 * DL_RESET_CON, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
} dl_reset_con_t;


/*
 *	CONNECTIONLESS SERVICE PRIMITIVES
 */

/*
 * DL_UNITDATA_REQ, M_PROTO type, with M_DATA block(s)
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_dest_addr_length;
	ulong	dl_dest_addr_offset;
	ulong	dl_reserved[2];
} dl_unitdata_req_t;

/*
 * DL_UNITDATA_IND, M_PROTO type, with M_DATA block(s)
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_dest_addr_length;
	ulong	dl_dest_addr_offset;
	ulong	dl_src_addr_length;
	ulong	dl_src_addr_offset;
	ulong	dl_reserved;
} dl_unitdata_ind_t;

/*
 * DL_UDERROR_IND, M_PROTO type
 * 	(or M_PCPROTO type if LLI-based provider)
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_dest_addr_length;
	ulong	dl_dest_addr_offset;
	ulong	dl_reserved;
	ulong	dl_errno;
} dl_uderror_ind_t;

/*
 * DL_UDQOS_REQ, M_PROTO type
 */
typedef struct {
	ulong	dl_primitive;
	ulong	dl_qos_length;
	ulong	dl_qos_offset;
} dl_udqos_req_t;

union DL_primitives {
	ulong			dl_primitive;
	dl_info_req_t		info_req;
	dl_info_ack_t		info_ack;
	dl_attach_req_t		attach_req;
	dl_detach_req_t		detach_req;
	dl_bind_req_t		bind_req;
	dl_bind_ack_t		bind_ack;
	dl_unbind_req_t		unbind_req;
	dl_subs_bind_req_t	subs_bind_req;
	dl_subs_bind_ack_t	subs_bind_ack;
	dl_ok_ack_t		ok_ack;
	dl_error_ack_t		error_ack;
	dl_connect_req_t	connect_req;
	dl_connect_ind_t	connect_ind;
	dl_connect_res_t	connect_res;
	dl_connect_con_t	connect_con;
	dl_token_req_t		token_req;
	dl_token_ack_t		token_ack;
	dl_disconnect_req_t	disconnect_req;
	dl_disconnect_ind_t	disconnect_ind;
	dl_reset_req_t		reset_req;
	dl_reset_ind_t		reset_ind;
	dl_reset_res_t		reset_res;
	dl_reset_con_t		reset_con;
	dl_unitdata_req_t	unitdata_req;
	dl_unitdata_ind_t	unitdata_ind;
	dl_uderror_ind_t	uderror_ind;
	dl_udqos_req_t		udqos_req;
};

#define	DL_INFO_REQ_SIZE	sizeof(dl_info_req_t)
#define	DL_INFO_ACK_SIZE	sizeof(dl_info_ack_t)
#define	DL_ATTACH_REQ_SIZE	sizeof(dl_attach_req_t)
#define	DL_DETACH_REQ_SIZE	sizeof(dl_detach_req_t)
#define	DL_BIND_REQ_SIZE	sizeof(dl_bind_req_t)
#define	DL_BIND_ACK_SIZE	sizeof(dl_bind_ack_t)
#define	DL_UNBIND_REQ_SIZE	sizeof(dl_unbind_req_t)
#define DL_SUBS_BIND_REQ_SIZE	sizeof(dl_subs_bind_req_t)
#define DL_SUBS_BIND_ACK_SIZE	sizeof(dl_subs_bind_ack_t)
#define	DL_OK_ACK_SIZE		sizeof(dl_ok_ack_t)
#define	DL_ERROR_ACK_SIZE	sizeof(dl_error_ack_t)
#define	DL_CONNECT_REQ_SIZE	sizeof(dl_connect_req_t)
#define	DL_CONNECT_IND_SIZE	sizeof(dl_connect_ind_t)
#define	DL_CONNECT_RES_SIZE	sizeof(dl_connect_res_t)
#define	DL_CONNECT_CON_SIZE	sizeof(dl_connect_con_t)
#define	DL_TOKEN_REQ_SIZE	sizeof(dl_token_req_t)
#define	DL_TOKEN_ACK_SIZE	sizeof(dl_token_ack_t)
#define	DL_DISCONNECT_REQ_SIZE	sizeof(dl_disconnect_req_t)
#define	DL_DISCONNECT_IND_SIZE	sizeof(dl_disconnect_ind_t)
#define	DL_RESET_REQ_SIZE	sizeof(dl_reset_req_t)
#define	DL_RESET_IND_SIZE	sizeof(dl_reset_ind_t)
#define	DL_RESET_RES_SIZE	sizeof(dl_reset_res_t)
#define	DL_RESET_CON_SIZE	sizeof(dl_reset_con_t)
#define	DL_UNITDATA_REQ_SIZE	sizeof(dl_unitdata_req_t)
#define	DL_UNITDATA_IND_SIZE	sizeof(dl_unitdata_ind_t)
#define	DL_UDERROR_IND_SIZE	sizeof(dl_uderror_ind_t)
#define	DL_UDQOS_REQ_SIZE	sizeof(dl_udqos_req_t)
 
#endif /* _SYS_DLPI_H */
  07070100005967000081240000000200000002000000012719347c0000185e000000230000000c00000000000000000000001600000000usr/include/sys/dma.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/dma.h.sl 1.1 4.0 10/15/90 29985 AT&T-SF"

/*      Copyright (c) 1988, 1989 Intel Corp.            */
/*        All Rights Reserved   */
/*
 *      INTEL CORPORATION PROPRIETARY INFORMATION
 *
 *      This software is supplied under the terms of a license
 *      agreement or nondisclosure agreement with Intel Corpo-
 *      ration and may not be copied or disclosed except in
 *      accordance with the terms of that agreement.
 */

#ifndef _SYS_DMA_H
#define	_SYS_DMA_H

#ifndef _SYS_I8237A_H
#include "sys/i8237A.h"
#endif

/* the DMA Status Structure */
struct dma_stat {
        paddr_t         targaddr;      /* physical address of buffer */
        paddr_t         targaddr_hi;   /* more for 64-bit addresses */
        paddr_t         reqraddr;      /* physical address of buffer */
        paddr_t         reqraddr_hi;   /* more for 64-bit addresses */
        unsigned short  count;         /* size of bytes in buffer */
        unsigned short  count_hi;      /* more for big blocks */
};

/* the DMA Buffer Descriptor structure */
struct dma_buf {
        unsigned short  reserved;    /* alignment pad */
        unsigned short   count;      /* size of block */
        paddr_t   address;	     /* phys addr of data block */
        paddr_t   physical;	     /* phys addr of next dma_buf */
        struct dma_buf  *next_buf;   /* next buffer descriptor */
        unsigned short  reserved_hi; /* alignment pad */
        unsigned short  count_hi;    /* for big blocks */
        unsigned long   address_hi;  /* for 64-bit addressing */
        unsigned long   physical_hi; /* for 64-bit addressing */
};

/* the DMA Command Block structure */
struct dma_cb {
        struct dma_cb  *next;       /* free list link */
        struct dma_buf *targbufs;   /* list of target data buffers */
        struct dma_buf *reqrbufs;   /* list of requestor data buffers */
        unsigned char  command;     /* Read/Write/Translate/Verify */
        unsigned char  targ_type;   /* Memory/IO */
        unsigned char  reqr_type;   /* Memory/IO */
        unsigned char  targ_step;   /* Inc/Dec/Hold */
        unsigned char  reqr_step;   /* Inc/Dec/Hold */
        unsigned char  trans_type;  /* Single/Demand/Block/Cascade */
        unsigned char  targ_path;   /* 8/16/32 */
        unsigned char  reqr_path;   /* 8/16/32 */
        unsigned char  cycles;      /* 1 or 2 */
        unsigned char  bufprocess;  /* Single/Chain/Auto-Init */
        unsigned short dummy;           /* alignment pad */
        char           *procparms;  /* parameter buffer for appl call */
        int            (*proc)();   /* address of application call routine */
};

#define DMA_CMD_READ    0x0
#define DMA_CMD_WRITE   0x1
#define DMA_CMD_TRAN    0x2
#define DMA_CMD_VRFY    0x3

#define DMA_TYPE_MEM    0x0
#define DMA_TYPE_IO     0x1

#define DMA_STEP_INC    0x0
#define DMA_STEP_DEC    0x1
#define DMA_STEP_HOLD   0x2

#define DMA_TRANS_SNGL  0x0
#define DMA_TRANS_DMND  0x1
#define DMA_TRANS_BLCK  0x2
#define DMA_TRANS_CSCD  0x3

#define DMA_PATH_8      0x0
#define DMA_PATH_16     0x1
#define DMA_PATH_32     0x2
#define DMA_PATH_64     0x3

/***
** We could use DMA_PATH_64 to mean this but why not
** just put in a separate define.
***/
#define DMA_PATH_16B    0x4     /* 16-bit path but byte count */

#define DMA_CYCLES_1    0x0
#define DMA_CYCLES_2    0x1

/***
** For the EISA bus we will use the following definitions for DMA_CYCLES
**    DMA_CYCLES_1 = Compatible timing
**    DMA_CYCLES_2 = Type "A" timing
**    DMA_CYCLES_3 = Type "B" timing
**    DMA_CYCLES_4 = Burst timing
***/
#define DMA_CYCLES_3    0x2
#define DMA_CYCLES_4    0x3

#define DMA_BUF_SNGL    0x0
#define DMA_BUF_CHAIN   0x1
#define DMA_BUF_AUTO    0x2

#define DMA_SLEEP       0x0
#define DMA_NOSLEEP     0x1

/* some common defined constants */
#ifndef PDMA
#define PDMA 5
#endif

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

/* public function routines */
#if defined(__STDC__)
extern void            dma_init(void);
extern void            dma_intr(int);
extern int             dma_prog(struct dma_cb *, int, unsigned char);
extern int             dma_swsetup(struct dma_cb *, int, unsigned char);
extern void            dma_swstart(struct dma_cb *, int, unsigned char);
extern void            dma_stop(int);
extern void            dma_enable(int);
extern void            dma_disable(int);
extern struct dma_cb  *dma_get_cb(unsigned char);
extern void            dma_free_cb(struct dma_cb *);
extern struct dma_buf *dma_get_buf(unsigned char);
extern void            dma_free_buf(struct dma_buf *);
#else
extern void            dma_init();
extern void            dma_intr();
extern int             dma_prog();
extern int             dma_swsetup();
extern unsigned char   dma_get_best_mode();
extern void            dma_swstart();
extern void            dma_stop();
extern void             dma_enable();
extern void            dma_disable();
extern struct dma_cb  *dma_get_cb();
extern void            dma_free_cb();
extern struct dma_buf *dma_get_buf();
extern void            dma_free_buf();
#endif

/* backward compatibility (XENIX)? */
struct dmareq
{   struct dmareq       *d_nxt;         /* reserved */
    unsigned short       d_chan;        /* specifies channel */
    unsigned short       d_mode;        /* direction of transfer */
    paddr_t              d_addr;        /* physical src or dst */
    long                 d_cnt;         /* byte or word (16 bit chan) count */
    int                (*d_proc)();     /* address of dma routine */
    char                *d_params;      /* driver defineable param block */
};

#endif /* _SYS_DMA_H */
  07070100005968000081240000000200000002000000012719347c00000712000000230000000c00000000000000000000001a00000000usr/include/sys/dmaable.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/dmaable.h.sl 1.1 4.0 10/15/90 20640 AT&T-SF"

#define	DMAABLESZ	4096		/* DMA boundary - in clicks - only on 386 */

#define	DO_DMA_CHECK		(tune.t_dmalimit > 0)
#define	DMA_CHECK_ENABLED	(tune.t_dmalimit > 0 && tune.t_dmalimit < pages_end)

#define	DMAABLE_PFN(pfn)	((pfn) < tune.t_dmalimit)
#define	LAST_DMAABLE_PFN	(tune.t_dmalimit)

extern	u_int	dma_freemem;	/* currently free dmaable memory */
extern	u_int	dma_limit_pfn;	/* Last dmaable click (inclusive) */
extern	int	dma_check_on;	/* Tuneable set and memory exceeds DMA capacity */
extern	page_t	*dma_limit_pp;	/* Last dmaable page structure (inclusive) */

extern	page_t	*dma_freelist;	/* Freelist pointer for DMA pages for remapping */
extern	u_int	dmaable_pages;	/* Total free pages on this free list */
extern  u_int	dmaable_free;	/* Current free pages on this free list */
extern	int	dmaable_sleep;	/* Processes sleep on this flag for DMA pages */
extern	mon_t	dma_pagelock;	/* multiprocessor sempahore lock for this freelist */

#define	DMA_PFN(pfn)	((pfn) <= dma_limit_pfn)
#define	DMA_PP(pp)	((pp) <= dma_limit_pp)
#define	DMA_BYTE(b)	(btoct(b) <= dma_limit_pfn)


extern	int	dmaable_rawio();
extern	int	dma_check_strategy();
extern	int	dma_stub_strategy();

struct	dma_checksw {
	int	(*d_strategy)();
	int	d_flags;
};

extern struct dma_checksw	*dma_checksw;

/*
 *	flag values
 */

#define	DMA_NOFLAGS	0x000
#define	DMA_OLDSTYLE	0x001
#define	DMA_NEWSTYLE	0x002
#define	DMA_GENSTRAT	0x004
#define	DMA_BREAKUP	0x008

#define	REASONABLE_DMA_PAGES	100
  07070100005969000081240000000200000002000000012719347c000007ea000000230000000c00000000000000000000001700000000usr/include/sys/dnlc.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/




#ifndef _SYS_DNLC_H
#define _SYS_DNLC_H

#ident	"@(#)/usr/include/sys/dnlc.h.sl 1.1 4.0 10/15/90 2479 AT&T-SF"
/*
 * This structure describes the elements in the cache of recent
 * names looked up.
 */

#define	NC_NAMLEN	15	/* maximum name segment length we bother with */

struct ncache {
	struct ncache *hash_next; 	/* hash chain, MUST BE FIRST */
	struct ncache *hash_prev;
	struct ncache *lru_next; 	/* LRU chain */
	struct ncache *lru_prev;
	struct vnode *vp;		/* vnode the name refers to */
	struct vnode *dp;		/* vnode of parent of name */
	char namlen;			/* length of name */
	char name[NC_NAMLEN];		/* segment name */
	struct cred *cred;		/* credentials */
};

/*
 * Stats on usefulness of name cache.
 */
struct ncstats {
	int	hits;		/* hits that we can really use */
	int	misses;		/* cache misses */
	int	enters;		/* number of enters done */
	int	dbl_enters;	/* number of enters tried when already cached */
	int	long_enter;	/* long names tried to enter */
	int	long_look;	/* long names tried to look up */
	int	lru_empty;	/* LRU list empty */
	int	purges;		/* number of purges of cache */
};

#define	ANYCRED	((cred_t *) -1)
#define	NOCRED	((cred_t *) 0)

extern int		ncsize;
extern struct ncache	*ncache;

/*
 * External routines.
 */

#if defined(__STDC__)

void	dnlc_init(void);
void	dnlc_enter(vnode_t *, char *, vnode_t *, cred_t *);
vnode_t	*dnlc_lookup(vnode_t *, char *, cred_t *);
void	dnlc_purge(void);
int	dnlc_purge1(void);
void	dnlc_purge_vp(vnode_t *);
int	dnlc_purge_vfsp(vfs_t *, int);
void	dnlc_remove(vnode_t *, char *);

#else

void	dnlc_init();
void	dnlc_enter();
vnode_t	*dnlc_lookup();
void	dnlc_purge();
int	dnlc_purge1();
void	dnlc_purge_vp();
int	dnlc_purge_vfsp();
void	dnlc_remove();

#endif

#endif	/* _SYS_DNLC_H */
  0707010000596b000081240000000200000002000000012719347c000017ee000000230000000c00000000000000000000001600000000usr/include/sys/elf.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ELF_H
#define _SYS_ELF_H

#ident	"@(#)/usr/include/sys/elf.h.sl 1.1 4.0 10/15/90 19618 AT&T-SF"


#include <sys/elftypes.h>


#define ELF32_FSZ_ADDR	4
#define ELF32_FSZ_HALF	2
#define ELF32_FSZ_OFF	4
#define ELF32_FSZ_SWORD	4
#define ELF32_FSZ_WORD	4


/*	"Enumerations" below use ...NUM as the number of
 *	values in the list.  It should be 1 greater than the
 *	highest "real" value.
 */


/*	ELF header
 */

#define EI_NIDENT	16

typedef struct {
	unsigned char	e_ident[EI_NIDENT];	/* ident bytes */
	Elf32_Half	e_type;			/* file type */
	Elf32_Half	e_machine;		/* target machine */
	Elf32_Word	e_version;		/* file version */
	Elf32_Addr	e_entry;		/* start address */
	Elf32_Off	e_phoff;		/* phdr file offset */
	Elf32_Off	e_shoff;		/* shdr file offset */
	Elf32_Word	e_flags;		/* file flags */
	Elf32_Half	e_ehsize;		/* sizeof ehdr */
	Elf32_Half	e_phentsize;		/* sizeof phdr */
	Elf32_Half	e_phnum;		/* number phdrs */
	Elf32_Half	e_shentsize;		/* sizeof shdr */
	Elf32_Half	e_shnum;		/* number shdrs */
	Elf32_Half	e_shstrndx;		/* shdr string index */
} Elf32_Ehdr;

#define EI_MAG0		0		/* e_ident[] indexes */
#define EI_MAG1		1
#define EI_MAG2		2
#define EI_MAG3		3
#define EI_CLASS	4
#define EI_DATA		5
#define EI_VERSION	6
#define EI_PAD		7

#define ELFMAG0		0x7f		/* EI_MAG */
#define ELFMAG1		'E'
#define ELFMAG2		'L'
#define ELFMAG3		'F'
#define ELFMAG		"\177ELF"
#define SELFMAG		4

#define ELFCLASSNONE	0		/* EI_CLASS */
#define ELFCLASS32	1
#define ELFCLASS64	2
#define ELFCLASSNUM	3

#define ELFDATANONE	0		/* EI_DATA */
#define ELFDATA2LSB	1
#define ELFDATA2MSB	2
#define ELFDATANUM	3

#define ET_NONE		0		/* e_type */
#define ET_REL		1
#define ET_EXEC		2
#define ET_DYN		3
#define ET_CORE		4
#define ET_NUM		5

#define	ET_LOPROC	0xff00		/* processor specific range */
#define	ET_HIPROC	0xffff

#define EM_NONE		0		/* e_machine */
#define EM_M32		1		/* AT&T WE 32100 */
#define EM_SPARC	2		/* Sun SPARC */
#define EM_386		3		/* Intel 80386 */
#define EM_68K		4		/* Motorola 68000 */
#define EM_88K		5		/* Motorola 88000 */
#define EM_486		6		/* Intel 80486 */
#define EM_860		7		/* Intel i860 */
#define EM_NUM		8


#define EV_NONE		0		/* e_version, EI_VERSION */
#define EV_CURRENT	1
#define EV_NUM		2


/*	Program header
 */

typedef struct {
	Elf32_Word	p_type;		/* entry type */
	Elf32_Off	p_offset;	/* file offset */
	Elf32_Addr	p_vaddr;	/* virtual address */
	Elf32_Addr	p_paddr;	/* physical address */
	Elf32_Word	p_filesz;	/* file size */
	Elf32_Word	p_memsz;	/* memory size */
	Elf32_Word	p_flags;	/* entry flags */
	Elf32_Word	p_align;	/* memory/file alignment */
} Elf32_Phdr;

#define PT_NULL		0		/* p_type */
#define PT_LOAD		1
#define PT_DYNAMIC	2
#define PT_INTERP	3
#define PT_NOTE		4
#define PT_SHLIB	5
#define PT_PHDR		6
#define PT_NUM		7

#define PT_LOPROC	0x70000000	/* processor specific range */
#define PT_HIPROC	0x7fffffff

#define PF_R		0x4		/* p_flags */
#define PF_W		0x2
#define PF_X		0x1

#define PF_MASKPROC	0xf0000000	/* processor specific values */


/*	Section header
 */

typedef struct {
	Elf32_Word	sh_name;	/* section name */
	Elf32_Word	sh_type;	/* SHT_... */
	Elf32_Word	sh_flags;	/* SHF_... */
	Elf32_Addr	sh_addr;	/* virtual address */
	Elf32_Off	sh_offset;	/* file offset */
	Elf32_Word	sh_size;	/* section size */
	Elf32_Word	sh_link;	/* misc info */
	Elf32_Word	sh_info;	/* misc info */
	Elf32_Word	sh_addralign;	/* memory alignment */
	Elf32_Word	sh_entsize;	/* entry size if table */
} Elf32_Shdr;

#define SHT_NULL	0		/* sh_type */
#define SHT_PROGBITS	1
#define SHT_SYMTAB	2
#define SHT_STRTAB	3
#define SHT_RELA	4
#define SHT_HASH	5
#define SHT_DYNAMIC	6
#define SHT_NOTE	7
#define SHT_NOBITS	8
#define SHT_REL		9
#define SHT_SHLIB	10
#define SHT_DYNSYM	11
#define SHT_NUM		12
#define SHT_LOUSER	0x80000000
#define SHT_HIUSER	0xffffffff

#define	SHT_LOPROC	0x70000000	/* processor specific range */
#define	SHT_HIPROC	0x7fffffff

#define SHF_WRITE	0x1		/* sh_flags */
#define SHF_ALLOC	0x2
#define SHF_EXECINSTR	0x4

#define SHF_MASKPROC	0xf0000000	/* processor specific values */

#define SHN_UNDEF	0		/* special section numbers */
#define SHN_LORESERVE	0xff00
#define SHN_ABS		0xfff1
#define SHN_COMMON	0xfff2
#define SHN_HIRESERVE	0xffff

#define SHN_LOPROC	0xff00		/* processor specific range */
#define SHN_HIPROC	0xff1f


/*	Symbol table
 */

typedef struct {
	Elf32_Word	st_name;
	Elf32_Addr	st_value;
	Elf32_Word	st_size;
	unsigned char	st_info;	/* bind, type: ELF_32_ST_... */
	unsigned char	st_other;
	Elf32_Half	st_shndx;	/* SHN_... */
} Elf32_Sym;

#define STN_UNDEF	0

/*	The macros compose and decompose values for S.st_info
 *
 *	bind = ELF32_ST_BIND(S.st_info)
 *	type = ELF32_ST_TYPE(S.st_info)
 *	S.st_info = ELF32_ST_INFO(bind, type)
 */

#define ELF32_ST_BIND(info)		((info) >> 4)
#define ELF32_ST_TYPE(info)		((info) & 0xf)
#define ELF32_ST_INFO(bind,type)	(((bind)<<4)+((type)&0xf))

#define STB_LOCAL	0		/* BIND */
#define STB_GLOBAL	1
#define STB_WEAK	2
#define STB_NUM		3

#define STB_LOPROC	13		/* processor specific range */
#define STB_HIPROC	15

#define STT_NOTYPE	0		/* TYPE */
#define STT_OBJECT	1
#define STT_FUNC	2
#define STT_SECTION	3
#define STT_FILE	4
#define STT_NUM		5

#define STT_LOPROC	13		/* processor specific range */
#define STT_HIPROC	15


/*	Relocation
 */

typedef struct {
	Elf32_Addr	r_offset;
	Elf32_Word	r_info;		/* sym, type: ELF32_R_... */
} Elf32_Rel;

typedef struct {
	Elf32_Addr	r_offset;
	Elf32_Word	r_info;		/* sym, type: ELF32_R_... */
	Elf32_Sword	r_addend;
} Elf32_Rela;

/*	The macros compose and decompose values for Rel.r_info, Rela.f_info
 *
 *	sym = ELF32_R_SYM(R.r_info)
 *	type = ELF32_R_TYPE(R.r_info)
 *	R.r_info = ELF32_R_INFO(sym, type)
 */

#define ELF32_R_SYM(info)	((info)>>8)
#define ELF32_R_TYPE(info)	((unsigned char)(info))
#define ELF32_R_INFO(sym,type)	(((sym)<<8)+(unsigned char)(type))

#endif
  0707010000596c000081240000000200000002000000012719347c00000395000000230000000c00000000000000000000001a00000000usr/include/sys/elf_386.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ELF_I386_H
#define _SYS_ELF_I386_H

#ident	"@(#)/usr/include/sys/elf_386.h.sl 1.1 4.0 10/15/90 1061 AT&T-SF"
#define	EF_I386_NONE		0
#define	EF_I386_FP		1	/* Floating point chip saved state */
#define	EF_I386_WEITEK		2	/* Weitek chip saved state */

#define R_386_NONE		0	/* relocation type */
#define R_386_32		1
#define R_386_PC32		2
#define R_386_GOT32		3
#define R_386_PLT32		4
#define R_386_COPY		5
#define R_386_GLOB_DAT		6
#define R_386_JMP_SLOT		7
#define R_386_RELATIVE		8
#define R_386_GOTOFF		9
#define R_386_GOTPC		10
#define R_386_NUM		11	/* must be > last */

#define ELF_386_MAXPGSZ		0x1000	/* maximum page size */

#endif
   0707010000596d000081240000000200000002000000012719347c00000231000000230000000c00000000000000000000001b00000000usr/include/sys/elftypes.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ELFTYPES_H
#define _SYS_ELFTYPES_H

#ident	"@(#)/usr/include/sys/elftypes.h.sl 1.1 4.0 10/15/90 11291 AT&T-SF"
typedef unsigned long	Elf32_Addr;
typedef unsigned short	Elf32_Half;
typedef unsigned long	Elf32_Off;
typedef long		Elf32_Sword;
typedef unsigned long	Elf32_Word;

#endif
   0707010000596e000081240000000200000002000000012719347c00000625000000230000000c00000000000000000000001700000000usr/include/sys/elog.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ELOG_H
#define _SYS_ELOG_H

#ident	"@(#)/usr/include/sys/elog.h.sl 1.1 4.0 10/15/90 8054 AT&T-SF"
/*
 * "True" major device numbers. These correspond
 * to standard positions in the configuration
 * table, but are used for error logging
 * purposes only.
 */

#define CNTL	1
#define SYS	2
#define CAC	3
#define PF	4

/*
 * IO statistics are kept for each physical unit of each
 * block device (within the driver). Primary purpose is
 * to establish a guesstimate of error rates during
 * error logging.
 */

struct iostat {
	long	io_ops;		/* number of read/writes */
	long	io_misc;	/* number of "other" operations */
	long	io_qcnt;	/* number of jobs assigned to drive */
	ushort io_unlog;	/* number of unlogged errors */
};

/*
 * structure for system accounting
 */
struct iotime {
	struct iostat ios;
	long	io_bcnt;	/* total blocks transferred */
	clock_t	io_resp;	/* total block response time */
	clock_t	io_act;		/* total drive active time (cumulative utilization) */
	int	io_pad;		/* round size to 2^n */
};
#define	io_cnt	ios.io_ops
#define io_qc ios.io_qcnt
/* drive utilization times can be calculated by system software as follows */

/* Average drive utilization = (io_cact/io_elapt) */
/* Average drive utilization for last interval = (io_liact/io_intv) */

#endif	/* _SYS_ELOG_H */
   0707010000596f000081240000000200000002000000012719347c00000b8d000000230000000c00000000000000000000001700000000usr/include/sys/emap.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EMAP_H
#define _SYS_EMAP_H

#ident	"@(#)/usr/include/sys/emap.h.sl 1.1 4.0 10/15/90 12202 AT&T-SF"

/* Channel mapping ioctl's */
/*	LDIOC  ('D'<< 8) */

/* Channel Mapping ioctl command definitions
 * #define LDSMAP (LDIOC|10)
 * #define LDGMAP (LDIOC|11)
 * #define LDNMAP (LDIOC|12)
 * 	Above are now defined in termios.h */

/* Emapping state (t_mstate) */
#define	ES_NULL		0	/* Mapping not enabled */
#define	ES_START	1	/* Base mapping state */
#define	ES_DEAD		2	/* Dead key received */
#define	ES_COMP1	3	/* Compose key received */
#define	ES_COMP2	4	/* Compose and 1st following keys received */

#ifdef i386
typedef	struct emtab	*emp_t;
typedef	struct emind	*emip_t;
typedef	struct emout	*emop_t;
typedef	unsigned char	*emcp_t;
#else
typedef	struct emtab	far *emp_t;
typedef	struct emind	far *emip_t;
typedef	struct emout	far *emop_t;
typedef	unsigned char	far *emcp_t;
#endif

extern	emcp_t	emmapout();

/* Emap control structure */
struct emap {
	emp_t	e_p;			/* ptr to mapping tables struct */
	struct	buf *e_bp;		/* buf hdr for mapping tables */
	short	e_count;		/* use count */
	short	e_ndind;		/* number of dead indexes */
	short	e_ncind;		/* number of compose indexes */
	short	e_nsind;		/* number of string indexes */
};

extern struct emap emap[];		/* allocated in space.h */


/* Emapping tables structures */

struct emind {
	unsigned char	e_key;
	unsigned char	e_ind;
};

struct emout {
	unsigned char	e_key;
	unsigned char	e_out;
};

struct emtab {
	unsigned char	e_imap[256];	/* 8-bit  input map */
	unsigned char	e_omap[256];	/* 8-bit output map */
	unsigned char	e_comp;		/* compose key */
	unsigned char	e_beep;		/* beep on error flag */
	short		e_cind;		/* offset of compose indexes */
	short		e_dctab;	/* offset of dead/compose table */
	short		e_sind;		/* offset of string indexes */
	short		e_stab;		/* offset of string table */
	struct emind	e_dind[1];	/* start of dead key indexes */
};

struct emp_tty {
	char	t_mstate;	/* emapping state */
	unsigned char	t_mchar;/* saved emapping char */
	char	t_merr;		/* emapping error flag */
	char	t_xstate;	/* extended state */
	struct emap	*t_mp;	/* emapping table */
	unsigned char	t_schar;/* save timeout char instead of using lflag */
	char	t_yyy[3];	/* reserved */
};

#define	E_TABSZ		2048		/* size of an emtab */
#if BSIZE < E_TABSZ
/* ERROR ****)))))	*/		/* a buf must hold an emtab */
#endif

#ifndef _STRUCTOFF_	/* Also defined in x.out.h */
#define _STRUCTOFF_
#define	STRUCTOFF(structure, field)	(int) &(((struct structure *)0)->field)
#endif	/* _STRUCTOFF_ */

#define	E_DIND		(STRUCTOFF(emtab, e_dind[0]))
#define	E_ESC		'\0'		/* key maps to dead/compose/string */

#endif	/* _SYS_EMAP_H */
   07070100005970000081240000000200000002000000012719347c00001349000000230000000c00000000000000000000001700000000usr/include/sys/erec.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EREC_H
#define _SYS_EREC_H

#ident	"@(#)/usr/include/sys/erec.h.sl 1.1 4.0 10/15/90 28085 AT&T-SF"
/*
 * Every error record has a header as follows.
 */



struct errhdr {
	short	e_type;		/* record type */
	short	e_len;		/* bytes in record (with header) */
	time_t	e_time;		/* time of day */
};

/*
 * Error record types
 */

#define E_GOTS	010		/* Start for UNIX/TS */
#define E_GORT	011		/* Start for UNIX/RT */
#define E_STOP	012		/* Stop */
#define E_TCHG	013		/* Time change */
#define E_CCHG	014		/* Configuration change */
#define E_BLK	020		/* Block device error */
#define E_STRAY	030		/* Stray interrupt */
#define E_MEM	031		/* Memory error */
#define E_CNTL	041		/* IO Controller error */
#define E_SYS	042		/* System error */
#define E_CAC	043		/* Cache error */
#define E_PF	044		/* Prefetch error MAC 32 only */


/* Device descriptors for logging start up record. */

struct ddesc {
	char d_name[9];		/* Device name */
	long lb_addr;		/* Device address */
	long su_equip;		/* Device equippage */
};


/*
 * Error logging startup record. One of these is
 * sent to the logging daemon when logging is
 * first activated.
 */

struct estart {
	short	e_cpu;		/* cpu type */
	struct	utsname e_name;	/* system names */
	int	e_mmcnt;	/* Memory size */
	struct ddesc e_conf[NBEDT]; /* Configured hardware */
	long	e_dcnt;		/* # devices found in EDT */
};

/*
 * Error logging termination record that is sent to the daemon
 * when it stops error logging.
 */

#define eend errhdr

/*
 * A time change record is sent to the daemon whenever
 * the system's time of day is changed.
 */

struct etimchg {
	time_t	e_ntime;	/* new time */
};


/*
 * A configuration change message is sent to
 * the error logging daemon whenever a block device driver
 * is attached or detached (MERT only).
 */

struct econfchg {
	char	e_trudev;	/* "true" major device number */
	char	e_cflag;	/* driver attached or detached */
};

#define E_ATCH	1
#define E_DTCH	0

/*
 * Template for the error record that is logged by block device
 * drivers.
 */

struct eblock {
	o_dev_t	e_num;		/* device number (major + minor) */
	ushort	e_bytes;	/* number of bytes to transfer */
	short	e_bflags;	/* read/write, error, etc */
	daddr_t	e_bnum;		/* logical block number */
	struct iostat e_stats;	/* unit I/O statistics */
	paddr_t e_badd;		/* physical buffer address */
	unsigned long	e_stat1;	/* job completion status */
	unsigned long	e_stat2;	/* extended err status 1 */
	unsigned long	e_stat3;	/* extended err status 2 */
};

/*
 * Flags (selected subset of flags in buffer header)
 */

#define E_WRITE	0
#define E_READ	1
#define E_NOIO	02
#define E_PHYS	04
#define E_MAP	010
#define E_ERROR	020

/*
 * Template for the stray interrupt record that is logged
 * every time an unexpected interrupt occurs.
 */

struct estray {
	unsigned int	e_saddr;	/* stray loc or device addr */
};

/*
 * Memory error record that is logged whenever one
 * of those things occurs
 */

struct emem {
	 long	e_mcsr[2];	/* registers: MASC CSR0, CSR1 */
};

/*
 * Template for the IO controller error reported via SYSERR 
 */

struct ecntl {
	char	dev_name[9];	/* device name */
	long	lb_addr;	/* bus address */
	long	unit_equip;	/* device equippage */
	long	d_csr;		/* device csr content */
	long	d_errcode;	/* device error code */
};

/*
 * Template for local bus SYSERR
 */

struct esys {
	char	md_name[9];	/* master device name */
	long	mlb_addr;	/* master local bus address */
	long	e_mcsr;		/* CSR content of local bus master */
	char	sd_name[9];	/* slave device name */
	long	slb_addr;	/* slave local bus address */
	long	e_scsr;		/* CSR content of local bus slave */
};


/* This structure will be used to log a prefetch error reported via
 * the dedicated PFERR interrupt.
 */

struct	epf {
	long	e_pc;		/* PC address of error */
	long	e_psw;		/* PSW on error */
	long	e_cccsr;	/* CC CSR on error */
	char	e_dname[9];	/* Slave device name */
	long	e_lbaddr;	/* Slave local bus address */
	long	e_scsr1;	/* Slave CSR content */
	long	e_scsr2;	/* Slave CSR content */
};

/* This structure will be used to log a cache error */

struct ecache {
	long	e_cccsr;	/* CC CSR on error */
	char	e_dname[9];	/* Slave device name */
	long	e_lbaddr;	/* Slave local bus address */
	long	e_scsr1;	/* Slave CSR content */
	long	e_scsr2;	/* Slave CSR content */
};


/*
 * The following structure is used by geru() which finds and clears
 * error data in device control and status registers.
 */

struct eunit {
	struct edt *edtp;	/* edt pointer to error device */
	long csr1;		/* device control and status register */
	long csr2;		/* address trap register if MASC is err dev */
};

#endif	/* _SYS_EREC_H */
   07070100005971000081240000000200000002000000012719347c000003c4000000230000000c00000000000000000000001600000000usr/include/sys/err.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ERR_H
#define _SYS_ERR_H

#ident	"@(#)/usr/include/sys/err.h.sl 1.1 4.0 10/15/90 56821 AT&T-SF"
/*
 * structure of the err buffer area
 */
#define	NESLOT	20
#define	E_LOG	01
#define	E_SLP	02

struct err {
	int		e_nslot;		/* number of errslots */
	int		e_flag;			/* state flags */
	struct errhdr	**e_org;		/* origin of buffer pool */
	struct errhdr	**e_nxt;		/* next slot to allocate */
	struct errslot {
		int	slot[8];
	} e_slot[NESLOT];			/* storage area */
	struct map	e_map[(NESLOT+3)/2];	/* free space in map */
	struct errhdr	*e_ptrs[NESLOT];	/* pointer to logged errors */
};

extern struct err err;

struct errhdr	*geteslot();
struct errhdr	*geterec();

#endif	/* _SYS_ERR_H */
07070100005972000081240000000200000002000000012719347c00001d60000000230000000c00000000000000000000001800000000usr/include/sys/errno.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ERRNO_H
#define _SYS_ERRNO_H

#ident	"@(#)/usr/include/sys/errno.h.sl 1.1 4.0 10/15/90 58840 AT&T-SF"

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * Error codes
 */

#define	EPERM	1	/* Not super-user			*/
#define	ENOENT	2	/* No such file or directory		*/
#define	ESRCH	3	/* No such process			*/
#define	EINTR	4	/* interrupted system call		*/
#define	EIO	5	/* I/O error				*/
#define	ENXIO	6	/* No such device or address		*/
#define	E2BIG	7	/* Arg list too long			*/
#define	ENOEXEC	8	/* Exec format error			*/
#define	EBADF	9	/* Bad file number			*/
#define	ECHILD	10	/* No children				*/
#define	EAGAIN	11	/* No more processes			*/
#define	ENOMEM	12	/* Not enough core			*/
#define	EACCES	13	/* Permission denied			*/
#define	EFAULT	14	/* Bad address				*/
#define	ENOTBLK	15	/* Block device required		*/
#define	EBUSY	16	/* Mount device busy			*/
#define	EEXIST	17	/* File exists				*/
#define	EXDEV	18	/* Cross-device link			*/
#define	ENODEV	19	/* No such device			*/
#define	ENOTDIR	20	/* Not a directory			*/
#define	EISDIR	21	/* Is a directory			*/
#define	EINVAL	22	/* Invalid argument			*/
#define	ENFILE	23	/* File table overflow			*/
#define	EMFILE	24	/* Too many open files			*/
#define	ENOTTY	25	/* Not a typewriter			*/
#define	ETXTBSY	26	/* Text file busy			*/
#define	EFBIG	27	/* File too large			*/
#define	ENOSPC	28	/* No space left on device		*/
#define	ESPIPE	29	/* Illegal seek				*/
#define	EROFS	30	/* Read only file system		*/
#define	EMLINK	31	/* Too many links			*/
#define	EPIPE	32	/* Broken pipe				*/
#define	EDOM	33	/* Math arg out of domain of func	*/
#define	ERANGE	34	/* Math result not representable	*/
#define	ENOMSG	35	/* No message of desired type		*/
#define	EIDRM	36	/* Identifier removed			*/
#define	ECHRNG	37	/* Channel number out of range		*/
#define	EL2NSYNC 38	/* Level 2 not synchronized		*/
#define	EL3HLT	39	/* Level 3 halted			*/
#define	EL3RST	40	/* Level 3 reset			*/
#define	ELNRNG	41	/* Link number out of range		*/
#define	EUNATCH 42	/* Protocol driver not attached		*/
#define	ENOCSI	43	/* No CSI structure available		*/
#define	EL2HLT	44	/* Level 2 halted			*/
#define	EDEADLK	45	/* Deadlock condition.			*/
#define	ENOLCK	46	/* No record locks available.		*/

/* Convergent Error Returns */
#define EBADE	50	/* invalid exchange			*/
#define EBADR	51	/* invalid request descriptor		*/
#define EXFULL	52	/* exchange full			*/
#define ENOANO	53	/* no anode				*/
#define EBADRQC	54	/* invalid request code			*/
#define EBADSLT	55	/* invalid slot				*/
#define EDEADLOCK 56	/* file locking deadlock error		*/

#define EBFONT	57	/* bad font file fmt			*/

/* stream problems */
#define ENOSTR	60	/* Device not a stream			*/
#define ENODATA	61	/* no data (for no delay io)		*/
#define ETIME	62	/* timer expired			*/
#define ENOSR	63	/* out of streams resources		*/

#define ENONET	64	/* Machine is not on the network	*/
#define ENOPKG	65	/* Package not installed                */
#define EREMOTE	66	/* The object is remote			*/
#define ENOLINK	67	/* the link has been severed */
#define EADV	68	/* advertise error */
#define ESRMNT	69	/* srmount error */

#define	ECOMM	70	/* Communication error on send		*/
#define EPROTO	71	/* Protocol error			*/
#define	EMULTIHOP 74	/* multihop attempted */
#define EBADMSG 77	/* trying to read unreadable message	*/
#define ENAMETOOLONG 78	/* path name is too long */
#define EOVERFLOW 79	/* value too large to be stored in data type */
#define ENOTUNIQ 80	/* given log. name not unique */
#define EBADFD	 81	/* f.d. invalid for this operation */
#define EREMCHG	 82	/* Remote address changed */

/* shared library problems */
#define ELIBACC	83	/* Can't access a needed shared lib.	*/
#define ELIBBAD	84	/* Accessing a corrupted shared lib.	*/
#define ELIBSCN	85	/* .lib section in a.out corrupted.	*/
#define ELIBMAX	86	/* Attempting to link in too many libs.	*/
#define ELIBEXEC 87	/* Attempting to exec a shared library.	*/
#define	EILSEQ 88	/* Illegal byte sequence. */
#define ENOSYS 89	/* Unsupported file system operation */
#define ELOOP	90	/* Symbolic link loop */
#define	ERESTART 91	/* Restartable system call */
#define ESTRPIPE 92	/* if pipe/FIFO, don't sleep in stream head */
#define ENOTEMPTY 93	/* directory not empty */
#define EUSERS	94	/* Too many users (for UFS) */

/* BSD Networking Software */
	/* argument errors */
#define	ENOTSOCK	95		/* Socket operation on non-socket */
#define	EDESTADDRREQ	96		/* Destination address required */
#define	EMSGSIZE	97		/* Message too long */
#define	EPROTOTYPE	98		/* Protocol wrong type for socket */
#define	ENOPROTOOPT	99		/* Protocol not available */
#define	EPROTONOSUPPORT	120		/* Protocol not supported */
#define	ESOCKTNOSUPPORT	121		/* Socket type not supported */
#define	EOPNOTSUPP	122		/* Operation not supported on socket */
#define	EPFNOSUPPORT	123		/* Protocol family not supported */
#define	EAFNOSUPPORT	124		/* Address family not supported by 
					   protocol family */
#define	EADDRINUSE	125		/* Address already in use */
#define	EADDRNOTAVAIL	126		/* Can't assign requested address */
	/* operational errors */
#define	ENETDOWN	127		/* Network is down */
#define	ENETUNREACH	128		/* Network is unreachable */
#define	ENETRESET	129		/* Network dropped connection because
					   of reset */
#define	ECONNABORTED	130		/* Software caused connection abort */
#define	ECONNRESET	131		/* Connection reset by peer */
#define	ENOBUFS		132	       	/* No buffer space available */
#define	EISCONN		133		/* Socket is already connected */
#define	ENOTCONN	134		/* Socket is not connected */
/* XENIX has 135 - 142 */
#define	ESHUTDOWN	143		/* Can't send after socket shutdown */
#define	ETOOMANYREFS	144		/* Too many references: can't splice */
#define	ETIMEDOUT	145		/* Connection timed out */
#define	ECONNREFUSED	146		/* Connection refused */
#define	EHOSTDOWN	147		/* Host is down */
#define	EHOSTUNREACH	148		/* No route to host */
#define EWOULDBLOCK	EAGAIN
#define EALREADY	149		/* operation already in progress */
#define EINPROGRESS	150		/* operation now in progress */

/* SUN Network File System */
#define	ESTALE		151		/* Stale NFS file handle */

/* Pyramid's AIO Compatibility - raw disk async I/O */

#define EIORESID	500		/* block not fully transferred */

/* XENIX Support */
/* XENIX error numbers */
#define EUCLEAN 	135	/* Structure needs cleaning */
#define	ENOTNAM		137	/* Not a XENIX named type file */
#define	ENAVAIL		138	/* No XENIX semaphores available */
#define	EISNAM		139	/* Is a named type file */
#define EREMOTEIO	140	/* Remote I/O error */
#define EINIT		141	/* Reserved for future */
#define EREMDEV		142	/* Error 142 */
/* End XENIX Support */

#endif	/* _SYS_ERRNO_H */
07070100005973000081240000000200000002000000012719347c0000063d000000230000000c00000000000000000000001800000000usr/include/sys/ertyp.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ERTYP_H
#define _SYS_ERTYP_H

#ident	"@(#)/usr/include/sys/ertyp.h.sl 1.1 4.0 10/15/90 22564 AT&T-SF"
/* bit position definintions for errno */

/* standard non-fatal messages (high byte of errno) */

#define	NON_FATALOC	24	/* location of non-fatal info in errno */
#define	NON_FATAL	1L << NON_FATALOC	/* smallest non-fatal error */

#define	SELF_CHECK	(0x80L << NON_FATALOC)
#define	NVRAM_WARN	(0x40L << NON_FATALOC)
#define	NVRAM_FAIL	(0x20L << NON_FATALOC)

/* additional information for disk sanity failures (2nd byte of errno) */

#define	DSK_ERLOC	16	/* location of disk error info in errno */

#define	DSK_IDLOC	(DSK_ERLOC + 7)		/* high bit is which disk */
#define	DSK_PHYS	(1L << DSK_ERLOC)
#define	DSK_WORD	(2L << DSK_ERLOC)
#define	DSK_COPY	(3L << DSK_ERLOC)
#define	DSK_INIT	(4L << DSK_ERLOC)
#define	DSK_PATTERN	(5L << DSK_ERLOC)
#define	DSK_MAP		6L		/* 6 & up for bad map sect 0 & up */

#define	DSK_ERTYP	(1L << DSK_ERLOC)	/* smallest disk error */

/* standard fatal errors (low short of errno) */

#define	CONFIG_FAIL	0x1L
#define	DISK_FAIL	0x2L
#define	BOOT_FAIL	0x4L
#define	MEM_FAIL	0x8L
#define	INCOMPATIBLE	0x10L
#define	FKEY_FAIL	0x20L
#define	EXC_FAIL	0x40L
#define	INT_FAIL	0x80L

/* sane flag for FWERR_NVR info described in nvram.h */
#define GOODERROR	0x600dbeef

#endif	/* _SYS_ERTYP_H */
   07070100005974000081240000000200000002000000012719347c000003d8000000230000000c00000000000000000000001600000000usr/include/sys/euc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EUC_H
#define _SYS_EUC_H

#ident	"@(#)/usr/include/sys/euc.h.sl 1.1 4.0 10/15/90 58452 AT&T-SF"

#ifndef	NOTASCII
#define	SS2	0x8e
#define	SS3	0x8f

	/* NOTE: c of following macros must be the 1st byte of characters */
#define	ISASCII(c)	(!((c) & ~0177))
#define	NOTASCII(c)	((c) & ~0177)
#define	ISSET2(c)	((c) == SS2)
#define	ISSET3(c)	((c) == SS3)
#define ISPRINT(c, wp)	(wp._multibyte && !ISASCII(c) || isprint(c))
			/* eucwidth_t wp; */

typedef struct {
	short int _eucw1, _eucw2, _eucw3;	/*	EUC width	*/
	short int _scrw1, _scrw2, _scrw3;	/*	screen width	*/
	short int _pcw;		/*	WIDE_CHAR width	*/
	char _multibyte;	/*	1=multi-byte, 0=single-byte	*/
} eucwidth_t;
#endif


#endif	/* _SYS_EUC_H */
07070100005975000081240000000200000002000000012719347c00000827000000230000000c00000000000000000000001b00000000usr/include/sys/eucioctl.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EUCIOCTL_H
#define _SYS_EUCIOCTL_H

#ident	"@(#)/usr/include/sys/eucioctl.h.sl 1.1 4.0 10/15/90 21828 AT&T-SF"

/*
 * /usr/include/sys/eucioctl.h:
 *
 *	Header for EUC width information to LD modules.
 */

#ifndef EUC_IOC
# define EUC_IOC		(('E' | 128) << 8)
#endif
#define EUC_WSET	(EUC_IOC | 1)
#define EUC_WGET	(EUC_IOC | 2)
#define EUC_MSAVE	(EUC_IOC | 3)
#define EUC_MREST	(EUC_IOC | 4)
#define EUC_IXLOFF	(EUC_IOC | 5)
#define EUC_IXLON	(EUC_IOC | 6)
#define EUC_OXLOFF	(EUC_IOC | 7)
#define EUC_OXLON	(EUC_IOC | 8)

/*
 * This structure should really be the same one as defined in "euc.h",
 * but we want to minimize the number of bytes sent downstream to each
 * module -- this should make it 8 bytes -- therefore, we take only the
 * info we need.  The major assumptions here are that no EUC character
 * set has a character width greater than 255 bytes, and that no EUC
 * character consumes more than 255 screen columns.  Let me know if this
 * is an unsafe assumption...
 */

struct eucioc {
	unsigned char eucw[4];
	unsigned char scrw[4];
};
typedef struct eucioc	eucioc_t;

/*
 * The following defines are for LD modules to broadcast the state of
 * their "icanon" bit.
 *
 * The message type is M_CTL; message block 1 has a data block containing
 * an "iocblk"; EUC_BCAST is put into the "ioc_cmd" field.  The "b_cont"
 * of the first message block points to a second message block.  The second
 * message block is type M_DATA; it contains 1 byte that is either EUC_B_RAW
 * or EUC_B_CANON depending on the state of the "icanon" bit.  EUC line
 * disciplines should take care to broadcast this information when they are
 * in multibyte character mode.
 */

#define EUC_BCAST	EUC_IOC|16

#define EUC_B_CANON	'\177'
#define EUC_B_RAW	'\001'	/* MUST be non-zero! */

#endif	/* _SYS_EUCIOCTL_H */
 07070100005976000081240000000200000002000000012719347c0000105c000000230000000c00000000000000000000001600000000usr/include/sys/evc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/evc.h.sl 1.1 4.0 10/15/90 2314 AT&T-SF"
/*	Copyright (c) 1989 Intel Corp.		*/
/*	  All Rights Reserved  	*/
/*
 *	INTEL CORPORATION PROPRIETARY INFORMATION
 *
 *	This software is supplied under the terms of a license
 *	agreement or nondisclosure agreement with Intel Corpo-
 *	ration and may not be copied or disclosed except in
 *	accordance with the terms of that agreement.
 */

/* evc.h - board specific defines for Olivetti EVC-1 */

/* 
 * Copyright 1989 Ing. C. Olivetti & C. S.p.A.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Olivetti not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.  Olivetti makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * OLIVETTI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL OLIVETTI BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */
/* 
 *
 * (C) Copyright 1989 Olivetti Advanced Technology Center, Inc.
 * All rights reserved.
 */

/*
 * Register offsets to be used for accessing the video board.
 */

#define	OfsEVC1BoardEnableReg	0x0C84
#define	OfsEVC1BoardIdReg0	0x0C80
#define	OfsEVC1BoardIdReg1	0x0C81
#define	OfsEVC1BoardIdReg2	0x0C82
#define	OfsEVC1BoardIdReg3	0x0C83
#define	OfsEVC1BoardControlReg	0x0880
#define	OfsEVC1BoardConfigReg	0x0884

/***********  Board Enable Definitions ********/

#define	EISA_DISABLE	0x00	/* WRITE MASK that disables the board */
#define	EISA_ENABLE	0x01	/* RW 1= Enable EVC-1 board */
#define	EISA_IOCHKERR	0x02	/* RO 0= EVC-1 OK */
#define	EISA_STARTRS	0x04	/* WO 1-to-0 = Reset EVC-1 board (500 nanosec.) */
#define	EISA_STOPRS	0x00	/*    stop reset sequence. */


/***********  Board Identification Definitions ***********/

#define	EVC1Id0	0x3D
#define	EVC1Id1	0x89
#define	EVC1Id2	0x10
#define	EVC1Id3	0x11

/***********  Board Control Definitions ********/

#define	EVC1Setup	0x01	/* RW 1= Enable VGA, 0= Setup VGA */
#define	EVC1Access	0x02	/* RW 1= VGA path, 0= direct path */
#define	EVC1Address	0x04	/* RW 1= direct at 3.25 GB, 0= direct at 14 MB */
#define EVC1_MEMHIGH	0xD0000000
#define EVC1_MEMLOW	0x00E00000
#define	EVC1MonitorMask	0x70	/* RO monitor ID bits */

/***********  Monitor Identification Definitions ********/

#define	MONVGAMono	5	/* VGA Monochrome */
#define	MONVGAColor	3	/* VGA Color */
#define	MONHiRMono	4	/* High Resolution Monochrome */
#define	MONHiRColor	2	/* High Resolution Color */
#define	MONNone		7	/* No monitor attached */


/***********  Board Config Definitions ********/

#define	EVC1Buswidth	0x01	/* 1= 8 bits, 0= 16 bits */



/***********  Macros for Register Writes ********/

/*
#define	EVC1StartSetup	( (EVC1Setup & (~EVC1Setup)) | EVC1Access )
#define	EVC1StopSetup	( EVC1Setup | EVC1Access )
*/
#define	EVC1StartSetup	( (EVC1Setup & (~EVC1Setup)) | EVC1Access | EVC1Address )
#define	EVC1StopSetup	( EVC1Setup | EVC1Access | EVC1Address )
#define	EVC1Bus16	(EVC1Buswidth & (~EVC1Buswidth))
#define	EVC1Bus8	(EVC1Buswidth)

#define	EVC1DirectHIGH	( EVC1Setup | EVC1Address )
#define	EVC1DirectLOW	( EVC1Setup )


/* definitions used in 'vtables.c' */

#define	EVC_BASE	EVC1_MEMHIGH
#define	EVC_SIZE	0x00100000
#define	EVC_HGSIZE	307200L

07070100005977000081240000000200000002000000012719347c00000b58000000230000000c00000000000000000000001800000000usr/include/sys/evecb.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EVECB_H
#define _SYS_EVECB_H

#ident	"@(#)/usr/include/sys/evecb.h.sl 1.1 4.0 10/15/90 25752 AT&T-SF"

/*			File Contents
**			=============
**
**	This file contains the definition of an event control block,
**	or ecb.  This was originally in the events.h header file.
**	It was broken out separately because other header files need
**	the definition of an ecb because they include an ecb as one
**	member of a larger structure that they define.  Note that they
**	include an ecb and not a pointer to an ecb.  One such file is
**	hrtcntl.h.  On the other hand, events.h requires hrtcntl.h to
**	be included before itself because an event_t contains a tofd_t
**	structure (again, not a pointer).
*/


/*			Required Header Files
**			=====================
**
**	The following header files must be includes before including
**	this file.
**
**		REQUIRES	sys/types.h
*/

/*			The ecb_t Structure
**			===================
**
**	The following structure describes an event control block.
**	It is used by many of system calls to specify the parameters of
**	an event that the system is to post for some situation.  See
**	events.h for more details.
*/

typedef struct ecb {
	short	ecb_eqd;	/* The event queue descriptor	*/
				/* to which the event should be	*/
				/* posted.			*/
	ushort	ecb_flags;	/* Various flags defined below.	*/
	long	ecb_eid;	/* The value for the ev_eid	*/
				/* field of the event to be	*/
				/* posted.			*/
	long	ecb_evpri;	/* The value for the ev_pri	*/
				/* field of the event to be	*/
				/* posted.			*/
} ecb_t;


/*	The following are the flags for the ecb_flags field of the
**	ecb_t structure.
*/

#define	ECBF_POSTCAN	0x0001	/* Post an event if the		*/
				/* operation is cancelled.  The	*/
				/* EF_CANCEL flag will be set	*/
				/* in the posted event.  By	*/
				/* default, events are not 	*/
				/* posted when an operation is	*/
				/* cancelled.  This flag 	*/
				/* applies only to the asyncio	*/
				/* and hrtalarm functions.	*/
#define	ECBF_LATEERR	0x0002	/* This flag applies only to	*/
				/* the hrtalarm function.  If a	*/
				/* T_TODALARM specifies a time	*/
				/* which has passed, give an 	*/
				/* error return.  The default	*/
				/* is to post the normal	*/
				/* ET_TIMER event immediately.	*/
#define	ECBF_NOSIGQ	0x0004	/* This flag applies only to	*/
				/* the evsig function.  If set,	*/
				/* then don't post a separate	*/
				/* event for each signal of the	*/
				/* same type which occurs. 	*/
				/* Post only if no ET_SIG event	*/
				/* for the same signal is 	*/
				/* already posted but not yet	*/
				/* received.			*/

#endif	/* _SYS_EVECB_H */
07070100005978000081240000000200000002000000012719347c000065ce000000230000000c00000000000000000000001900000000usr/include/sys/events.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EVENTS_H
#define _SYS_EVENTS_H

#ident	"@(#)/usr/include/sys/events.h.sl 1.1 4.0 10/15/90 9672 AT&T-SF"
/*			File Contents
**			=============
**
**	This file contains data which must be included in an 
**	application program using the events facility.
*/


/*			Required Header Files
**			=====================
**
**	The following header files must be includes before including
**	this file.
**
**		REQUIRES	sys/types.h
**		REQUIRES	sys/signal.h
**		REQUIRES	sys/evecb.h
**		REQUIRES	sys/hrtcntl.h
**		REQUIRES	sys/priocntl.h
**		REQUIRES	sys/procset.h
*/

/*			The Events VFS Version Number
**			=============================
**
**	In order to be able to make changes to the events VFS in the
**	future, we define a version number which is automatically passed
**	through from the application program to the libraries and then
**	to the kernel.  If we want to change the events interface, we
**	just increase the version number so the events library routines
**	and the kernel can tell the difference.  This works with either
**	private or shared libraries.
**	The current version number is as follows.
*/

typedef ulong	evver_t;	/* Type for the version nbr.	*/

#define	EV_VERSION	2	/* The current version number.	*/

/*	The following are previously used version numbers which are
**	still supported.
*/

/*	None yet.
*/

/*	The following are previously used version numbers which are no
**	longer supported.
*/

#define	EV_VER_PROTO1	1	/* Version number used in the	*/
				/* first prototype of events.	*/

/*			The Events Function Interfaces
**			==============================
**
**	When a user program calls one of the functions described on one
**	of the events manual pages, it is actually invoking one of the
**	following macros.  The purpose of the macros is to pass the
**	version number to the library routines.  The library routines
**	will, in turn, pass the version number down to the kernel.  This
**	will allow us to make changes to the events VFS in the future 
**	and still support old *.o and a.out files.
**
**	Thanks to Jeff Smits for the idea of using macros here.
*/

#define	evpost(elp, els, flags)	\
	__evpost(EV_VERSION, elp, els, flags)

#define	evpoll(cmd, elp, els, top) \
	__evpoll(EV_VERSION, cmd, elp, els, top)

#define	evpollmore(elp, els) \
	__evpollmore(EV_VERSION, elp, els)

#define	evtrap(cmd, elp, els, tid, handlerp, tap) \
	__evtrap(EV_VERSION, cmd, elp, els, tid, handlerp, tap)

#define	evtrapcancel(tidp, tids) \
	__evtrapcancel(EV_VERSION, tidp, tids)
	
#define	evcntl(cmd, arg1, arg2) \
	__evcntl(EV_VERSION, cmd, arg1, arg2)

#define	evqcntl(eqd, cmd, arg) \
	__evqcntl(EV_VERSION, eqd, cmd, arg)

#define	evexit(idtype, id, ecbp) \
	__evexit(EV_VERSION, idtype, id, ecbp)

#define	evexitset(psp, hostid, ecbp) \
	__evexitset(EV_VERSION, psp, hostid, ecbp)

#define	evsig(sigsetp, ecbp, silp, sils) \
	__evsig(EV_VERSION, sigsetp, ecbp, silp, sils)

/*			Miscellaneous Definitions
**			=========================
**
**	In our implementation, an event queue identifier is just
**	a file descriptor since we implement events as a VFS.
**	The following value is intended to represent the absence
**	of an event queue.  Therefore, it must have a value that
**	could not be an event queue identifier; i.e., for us, a
**	file descriptor.  We don't want to use a negative value
**	since a negative return value usually indicates an error.
**	Only -1 should really be used to indicate an error but,
**	by convention, many programmers test for "rtrn < 0".
**	Therefore, the following is the largest positive value
**	which we can fit into an short.  Change it if necessary
**	when porting to another system.
*/

#define	EQ_NOQUEUE	0x7fff	/* No event queue.	*/


/*	The following symbol is used to represent the set of all trap
**	identifiers.  It is used in place of a pointer to a list of
**	trap identifiers so its value must be distinguishable from a
**	pointer.  It cannot be zero either since zero is used to
**	indicate that no trap identifiers are being specified.  Change
**	it if necessary when porting.
*/

#define	TR_ALL	((long *)-1)		/* All trap identifiers.*/

/*			The evtypes_t Enumeration
**			=========================
**
**	The following are the event types.  These are the values
**	for the ev_type field of the event_t structure.
*/

typedef enum evtypes {

		ET_POST,	/* A user event created with	*/
				/* the evpost function call.	*/
		ET_ASYNC,	/* Return from an asynchronous	*/
				/* system call such as asyncio.	*/
		ET_TIMER,	/* Expiration of a timer set by */
				/* the hrtalarm function call.	*/
		ET_SIG,		/* An event indicating the fact */
				/* that a signal was sent to a	*/
				/* process.  Posted due to an	*/
				/* evsig function call.		*/
		ET_STREAM,	/* A change of state of a	*/
				/* stream head.  Posted due to	*/
				/* an I_SETEV type streams	*/
				/* ioctl.			*/
		ET_DRIVER,	/* The event was posted by a	*/
				/* device driver or streams	*/
				/* module.			*/
		ET_EXIT		/* A message created on process */
				/* exit due to a previous call	*/
				/* of evexit.			*/
} evtypes_t;

/*			The event_t Structure
**			=====================
**
**	The following structure describes an event at user
**	level.  It is the parameter passed on many of the
**	events function calls.
*/


typedef struct event {
	int		ev_eqd;		/* The event queue	*/
					/* descriptor.  For us,	*/
					/* a file descriptor.	*/
	long		ev_flags;	/* Flags defined below.	*/
	long		ev_eid;		/* The event identifier.*/
	long		ev_eidlim;	/* High limit of event	*/
					/* identifiers for	*/
					/* range type match	*/
					/* (EF_EIDRNG set).	*/
	long		ev_pri;		/* The event's priority.*/
	hostid_t	ev_hostid;	/* The hostid of the	*/
					/* system on which the	*/
					/* process ev_pid was	*/
					/* running when it 	*/
					/* requested that the	*/
					/* event be posted.	*/
	int		ev_pfd;		/* A file descriptor	*/
					/* being passed with	*/
					/* the event (only if	*/
					/* EF_PFD is set).	*/
	evtypes_t	ev_type;	/* The event type as	*/
					/* defined above.	*/
	pid_t		ev_pid;		/* The process id of	*/
					/* the poster of the	*/
					/* event.		*/
	uid_t		ev_uid;		/* The effective user	*/
					/* id of the poster of	*/
					/* the event.		*/
	int		ev_error;	/* An error code.	*/
					/* Values are defined	*/
					/* in sys/errno.h.	*/
					/* This field has a	*/
					/* value only if 	*/
					/* EF_ERROR is set in	*/
					/* the ev_flags field.	*/
	hrtime_t	ev_time;	/* The time that the	*/
					/* event was posted.	*/
	size_t		ev_datamax;	/* Size of buffer for	*/
					/* event type dependent	*/
					/* data (in bytes).	*/
	size_t		ev_datasize;	/* Actual nbr of bytes	*/
					/* of event type	*/
					/* dependent data.	*/
	char		*ev_data;	/* Ptr to the dependent	*/
					/* data.		*/
} event_t;

/*			The event_t Structure (Continued)
**			=================================
**
**	The following is a list of flags that can be set in the
**	ev_flags field of the event_t structure.  They are divided
**	into various categories which are described following the
**	list.
*/

#define	EF_PRI		0x0001	/* Return the highest priority	*/
				/* event on the queue.		*/
				/* Otherwise, return the first	*/
				/* (FIFO order) event.		*/
#define	EF_TYPE		0x0002	/* The ev_type field must match	*/
				/* on an evpoll or evtrap.	*/
#define	EF_EID		0x0004	/* The ev_eid field must match	*/
				/* on an evpoll or evtrap.	*/
#define	EF_EIDRNG	0x0008	/* The eid must be greater than	*/
				/* or equal to ev_eid and less	*/
				/* than or equal to ev_eidlim 	*/
				/* on an ev_poll or ev_trap.	*/
#define	EF_SHM		0x0010	/* Event dependent data is to	*/
				/* be transferred in shared	*/
				/* memory.  Otherwise, copy	*/
				/* into and out of the kernel.	*/
#define	EF_DISCARD	0x0020	/* Receive event in discard	*/
				/* mode.  Throw away data which	*/
				/* won't fit in the buffer.	*/
				/* Otherwise, save it for a	*/
				/* possible evpollmore.		*/
#define	EF_QUICKD	0x0040	/* Data may be or has been sent	*/
				/* or returned in the ev_data	*/
				/* field of the event rather	*/
				/* than in a buffer.		*/
#define	EF_PFD		0x0080	/* Flag set if a file 		*/
				/* descriptor is being passed	*/
				/* in the ev_pfd field.		*/
#define	EF_TIME		0x0100	/* The ev_time field should be	*/
				/* supplied in the returned	*/
				/* event.  The ev_time.hrt_res	*/
				/* field has been set by the	*/
				/* caller.			*/
#define	EF_DONE		0x0200	/* The event has occurred.  	*/
				/* Otherwise, it is being	*/
				/* waited for.			*/
#define	EF_MORE		0x0400	/* There is more dependent data	*/
				/* with this event than buffer	*/
				/* space allocated.		*/
#define	EF_CANCEL	0x0800	/* Indicates that the event was */
				/* posted as a result of	*/
				/* something being cancelled	*/
				/* rather than completing.	*/
#define	EF_ERROR	0x1000	/* Indicates that an error has	*/
				/* occurred.			*/

/*			The event_t Structure (Continued)
**			=================================
**
**	The above flags are divided into the following categories.
**
**		EV_FLAGS_USER	Set by the user and interrogated by
**				the system.
**		EV_FLAGS_SYS	Set by the system and interrogated by
**				the user.
**		EV_FLAGS_POST	Subset of EV_FLAGS_USR that are valid
**				on an evpost function.  The other flags
**				(in EV_FLAGS_USR but not in
**				EV_FLAGS_POST) are valid only with
**				evpoll and evtrap.
**		EV_FLAGS_MORE	Subset of EV_FLAGS_USR.  The setting of
**				these flags on an evpollmore must
**				match their setting on the original
**				evpoll or evtrap.
*/

#define	EV_FLAGS_USER	(EF_PRI | EF_TYPE | EF_EID | EF_EIDRNG | \
			 EF_SHM | EF_DISCARD | EF_QUICKD | \
			 EF_PFD | EF_TIME)
#define	EV_FLAGS_SYS	(EF_DONE | EF_MORE  | EF_CANCEL | EF_ERROR)
#define	EV_FLAGS_POST	(EF_SHM | EF_QUICKD | EF_PFD)
#define	EV_FLAGS_MORE	(EF_PRI | EF_TYPE | EF_EID | EF_EIDRNG)


/*	The following symbol defines the maximum number of bytes of data
**	which can be passed in EF_QUICKD mode.  It must be equal to the
**	size of the ev_data field in the event_t structure defined
**	above.
*/

#define	EV_MAXQD	sizeof(char *)

/*			Data for the evpost Function
**			============================
**
**	The following are the possible flags which can be passed as
**	an argument to evpost.
*/

#define	EPF_NONBLOCK	0x0001	/* Don't wait if events can't	*/
				/* be posted immediately.	*/

/*			Data for the evpoll and evtrap Functions
**			========================================
**
**	The following are the possible commands for the evpoll and 
**	evtrap functions.
*/

typedef enum evpollcmds {

	EC_ONE,		/* Return one event.			*/
	EC_ANY,		/* Return any which are done, but at	*/
			/* least one.				*/
	EC_ALL		/* Return only if all are done.		*/
} evpollcmds_t;

/*	The following is the structure of the optional "tap" (trap
**	argument pointer) argument to evtrap.
*/

typedef struct evta {
	pcparms_t	*eta_prip;	/* Ptr to the scheduler	*/
					/* priority at which 	*/
					/* this trap handler is	*/
					/* to run or NULL if no	*/
					/* change in priority 	*/
					/* is requested.	*/
	long		*eta_hlp;	/* Ptr to a list of 	*/
					/* tid's to hold when	*/
					/* this handler is 	*/
					/* called or TR_ALL or	*/
					/* NULL to hold only	*/
					/* the tid being 	*/
					/* handled.		*/
	size_t		eta_hls;	/* Nbr of elements in	*/
					/* the hold array	*/
					/* eta_hlp.		*/
	uint		eta_flags;	/* Various flags as	*/
					/* defined below.	*/
} evta_t;

/*	The flags in eta_flags are as follows.
*/

#define	ETAF_RESTART	0x0001	/* Set if restartable system	*/
				/* calls are to be restarted	*/
				/* after calling the trap	*/
				/* handler for this trap id.	*/
#define	ETAF_ALTSTACK	0x0002	/* Set if this trap handler is	*/
				/* to be called on an alternate	*/
				/* stack.			*/

/*			Data for the evtrap Handler Function
**			====================================
**
**	The following is the type of the context argument which is
**	passed to a user trap handler.  Since a user program is not
**	suppossed to reference the contents of this struture, it is
**	defined in terms of another structure which is defined in
**	evsys.h
*/

typedef struct evcntxt	evcontext_t;

/*			Data for the evcntl Commands
**			============================
**
**	The following are the commands for the evcntl function.
*/

typedef enum evcntlcmds {
	EC_TRAPHOLD,	/* Add to the current set of held trap	*/
			/* identifiers.				*/
	EC_TRAPSET,	/* Redefine the contents of the current	*/
			/* set of held trap identifiers.	*/
	EC_TRAPRELSE,	/* Delete from the current set of held	*/
			/* trap identifiers.			*/
	EC_TRAPPAUSE,	/* An EC_TRAPRELSE followed by a 	*/
			/* pause() but done as one atomic op.	*/
	EC_TRAPRET,	/* Return from one or more trap 	*/
			/* handlers to a user specfied context.	*/
	EC_TRAPEND,	/* Process has exited all trap handlers.*/
	EC_ALTSTACK,	/* Specify use of an alternate stack 	*/
			/* when calling a trap handler.		*/
	EC_GETPRINFO,	/* Get the per-process event		*/
			/* information.				*/
	EC_SETPRINFO,	/* Set the per-process event		*/
			/* information.				*/
	EC_GETCFGINFO,	/* Get the events VFS configuration	*/
			/* information.				*/
	EC_GETMEMINFO	/* Get the events VFS memory usage	*/
			/* information.				*/
} evcntlcmds_t;

/*		Data for the evqcntl Commands
**		=============================
**
**	The following are the commands for the evqcntl
**	function.
*/

typedef enum evqcntlcmds {
	EC_GETCM,	/* Get the current close mode of the	*/
			/* queue.				*/
	EC_SETCM,	/* Set close mode for the queue.	*/
	EC_GETQINFO,	/* Get the current values of the queue	*/
			/* parameters.				*/
	EC_SETQINFO	/* Set the settable queue parameters.	*/
} evqcntlcmds_t;

/*
**	The following are the different close modes which can be
**	set for a queue using the EC_SETCM command of the evqcntl
**	function.
*/

typedef enum evcm {
	ECM_DELALL,	/* Delete all events on the queue when	*/
			/* the last close of the queue occurs.	*/
	ECM_DELNONE,	/* Leave all events on the queue when	*/
			/* the last close of the queue occurs.	*/
	ECM_DELSYS,	/* Delete all events posted by the 	*/
			/* system (ev_type != ET_POST) when the	*/
			/* last close of the queue occurs.	*/
	ECM_DELUSER	/* Delete only those events with type	*/
			/* equal to ET_POST when the last close	*/
			/* of the queue occurs.			*/
} evcm_t;

/*			The evcntl evaltstk_t Structure
**			===============================
**
**	The following is the evaltstk_t structure.  It is used with
**	the evcntl command EC_ALTSTACK.
*/

typedef struct evaltstk {
	caddr_t		etas_stkp;	/* Ptr to the start of	*/
					/* the stack.		*/
	ulong		etas_stks;	/* Size of the stack in	*/
					/* bytes.		*/
	uint		etas_flags;	/* The flags defined	*/
					/* below.		*/
} evaltstk_t;


/*	The flags for the etas_flags field are as follows.
*/

#define	EASF_DISABLE	0x0001	/* The use of an alternate	*/
				/* stack is or should be	*/
				/* disabled.  Can be set by the	*/
				/* user or the kernel.		*/
#define	EASF_ONSTACK	0x0002	/* The process is currently	*/
				/* running on the alternate	*/
				/* stack.  Set only by the 	*/
				/* kernel to return to the user	*/

/*	The following values are just ballpark figures.  The first one
**	should really involve sizeof(pcb_t) and sizeof(evcntxt_t) but
**	we don't want these definitions to have to be known to all
**	programs which include this header file.
*/

#define	ETAS_MINSIZE	 256	/* Minimum size for alternate	*/
				/* stack.			*/
#define	ETAS_SIZE	2048	/* Recommended size for 	*/
				/* alternate stack.		*/

/*			The evcntl evprinfo_t Structure
**			===============================
**
**	The following is the evprinfo_t structure.  It is used with the
**	evcntl commands EC_SETPRINFO and EC_SETPRINFO.
*/

typedef struct evprinfo {
	ushort	evpi_maxtraps;	/* Maximum number of trap	*/
				/* expressions allowed for this	*/
				/* process.  The default is 	*/
				/* evci_maxtraps in the		*/
				/* evcinfo_t structure.		*/
	ushort	evpi_maxeterms;	/* Maximum number of terms	*/
				/* allowed in an expression.	*/
				/* The default value is		*/
				/* evci_maxeterms in the	*/
				/* evcinfo_t structure.		*/
} evprinfo_t;

/*			The evcntl evcinfo_t Structure
**			==============================
**
**	The following is the evcinfo_t structure.  It is used with the
**	evcntl command EC_GETCFGINFO.
*/

typedef struct evcinfo {

	/*	The following are global limits on data allocation for
	**	the entire events VFS.
	*/

	ushort	evci_mevqueues;		/* Max nbr of event	*/
					/* queue structures	*/
					/* (evqueue_t) to 	*/
					/* allocate.		*/
	ushort	evci_mevkevs;		/* Max nbr of kernel	*/
					/* event structures	*/
					/* (evkev_t) to 	*/
					/* allocate.		*/
	ushort	evci_mevexrefs;		/* Max nbr of event	*/
					/* expression reference	*/
					/* structures		*/
					/* (evexref_t) to 	*/
					/* allocate.		*/
	ushort	evci_mevexprs;		/* Max nbr of event	*/
					/* expression 		*/
					/* structures (evexpr_t)*/
					/* to allocate.		*/
	ushort	evci_mevterms;		/* Max nbr of event	*/
					/* term structures	*/
					/* (evterm_t) to	*/
					/* allocate.		*/
	ushort	evci_mevsexprs;		/* Max nbr of event	*/
					/* satisfied expression	*/
					/* structures		*/
					/* (evsexpr_t) to	*/
					/* allocate.		*/
	ushort	evci_mevsterms;		/* Max nbr of event	*/
					/* satisfied term	*/
					/* structures		*/
					/* (evsterm_t) to	*/
					/* allocate.		*/
	ushort	evci_mevtids;		/* Max nbr of trap	*/
					/* identifier structures*/
					/* (evtid_t) to 	*/
					/* allocate.		*/
	ushort	evci_mevretrys;		/* Max nbr of retry	*/
					/* structures		*/
					/* (evretry_t) to	*/
					/* allocate.		*/
	ushort	evci_mevexits;		/* Max nbr of event	*/
					/* exit structures	*/
					/* (evexit_t) to	*/
					/* allocate.		*/

/*			The evcntl evcinfo_t Structure (Continued)
**			==========================================
*/

	ushort	evci_mevsigs;		/* Max nbr of event	*/
					/* signal structures	*/
					/* (evsig_t) to		*/
					/* allocate.		*/
	ushort	evci_mevstrds;		/* Max nbr of stream	*/
					/* data structures	*/
					/* (evd_stream_t) to	*/
					/* allocate.		*/
	ushort	evci_mevdirents;	/* Max nbr of directory	*/
					/* entries (dirent_t)	*/
					/* to allocate.		*/
	ulong	evci_mevdata;		/* Max nbr of bytes to	*/
					/* allocate for holding	*/
					/* events type dependent*/
					/* data and other	*/
					/* miscellaneous uses.	*/
	ushort	evci_tidhts;		/* Number of entries in	*/
					/* the trap id hash	*/
					/* table.  Must be a	*/
					/* power of 2.		*/
	ushort	evci_fnhts;		/* Number of entries in	*/
					/* the file name hash	*/
					/* table.  Must be a 	*/
					/* power of 2.		*/

/*			The evcntl evcinfo_t Structure (Continued)
**			==========================================
*/

	/*	The following are default per-queue limits which can
	**	be modified with evqcntl.
	*/

	ushort	evci_maxev;		/* Default max nbr of	*/
					/* events allowed on a	*/
					/* queue.		*/
	ulong	evci_maxdpe;		/* Default max nbr of	*/
					/* bytes of data allowed*/
					/* per event.		*/
	ulong	evci_maxmem;		/* Default max total	*/
					/* nbr of bytes of data	*/
					/* allowed in memory	*/
					/* for all events on an	*/
					/* event queue.		*/

	/*	The following are default per-process limits which can
	**	be modified with evcntl.
	*/

	ushort	evci_maxtraps;		/* Default max nbr of	*/
					/* trap expressions	*/
					/* allowed for a	*/
					/* process.		*/
	ushort	evci_maxeterms;		/* Default max nbr of	*/
					/* terms allowed in an	*/
					/* expression.		*/
} evcinfo_t;

/*			The evqcntl evinfo_t Structure
**			==============================
**
**	The following is the events information structure.  It is used
**	in conjunction with the evqinfo_t structure below to get
**	information about individual events on the queue being checked
**	with the evqcntl command EC_GETQINFO.
*/

typedef struct evinfo {
	long		evi_flags;	/* Same as ev_flags.	*/
	long		evi_eid;	/* Same as ev_eid.	*/
	long		evi_pri;	/* Same as ev_pri.	*/
	hostid_t	evi_hostid;	/* Same as ev_hostid.	*/
	int		evi_pfd;	/* Same as ev_pfd.	*/
	evtypes_t	evi_type;	/* Same as ev_type.	*/
	pid_t		evi_pid;	/* Same as ev_pid.	*/
	uid_t		evi_uid;	/* Same as ev_uid.	*/
	hrtime_t	evi_time;	/* Same as ev_time.	*/
	size_t		evi_datasize;	/* Same as ev_datasize.	*/
} evinfo_t;

/*			The evqcntl evqinfo_t Structure
**			===============================
**
**	The following is the evqinfo_t structure.  It is used with the
**	evqcntl commands EC_SETQINFO and EC_GETQINFO.  Only the
**	following fields are set from the user's structure for
**	EC_SETQINFO.
**
**		evqi_closemd
**		evqi_maxev	evqi_maxdpe	evqi_maxmem
**
**	The fields on the last line cannot be increased above their
**	system default values (in evinfo) except by the super-user.
*/

/*			The evqcntl evqinfo_t Structure (Continued)
**			===========================================
*/

typedef struct evqinfo {
	ulong		evqi_memsize;	/* Total nbr of bytes of*/
					/* data in private	*/
					/* memory used by all	*/
					/* the events on the	*/
					/* queue.  Data in	*/
					/* shared memory or the	*/
					/* ev_data member of an	*/
					/* event will not be	*/
					/* counted in this	*/
					/* value.		*/
	ulong		evqi_shmsize;	/* Total nbr of bytes	*/
					/* of data in shared	*/
					/* memory for all	*/
					/* events on the queue.	*/
	evinfo_t	*evqi_evinfop;	/* Ptr to an array of	*/
					/* evevinfo_t		*/
					/* structures to return	*/
					/* data about the	*/
					/* events on the queue.	*/
	ushort		evqi_evinfos;	/* Nbr of elements in	*/
					/* the evqi_evinfop	*/
					/* array.		*/
	ushort		evqi_nevents;	/* Nbr of events on the */
					/* queue.		*/
	evcm_t		evqi_closemd;	/* The close mode.  The	*/
					/* values are ECM_XXXX	*/
					/* as defined above.	*/
	ushort		evqi_opencnt;	/* Number of opens (not */
					/* dup's) for the queue.*/
	ulong		evqi_maxev;	/* Max nbr of events	*/
					/* which can be on the	*/
					/* queue.  Initialized	*/
					/* from evci_maxev.	*/
	ulong		evqi_maxdpe;	/* Max data per event	*/
					/* for this queue.	*/
					/* Initialized from	*/
					/* evci_maxdpe.		*/
	ulong		evqi_maxmem;	/* Max total memory for	*/
					/* all events on the	*/
					/* queue.  Initialized	*/
					/* from evci_maxmem.	*/
} evqinfo_t;

/*			Data for the evexit Function
**			============================
**
**	The following structure describes the event dependent data
**	returned for an ET_EXIT event.
*/

typedef struct evd_exit {
	hostid_t	ee_hostid;	/* The host on which	*/
					/* the process exited.	*/
	pid_t		ee_pid;		/* The process id of	*/
					/* the exiting	process.*/
	int		ee_status;	/* The exit status of	*/
					/* the process.		*/
}evd_exit_t;





/*			Data for the evsig Function
**			===========================
**
**	The following are the flags which can be returned in the
**	ev_data field of an ET_SIG event.  This event will always have
**	the EF_QUICKD flag set and the ev_datasize equal to
**	sizeof(char *).
*/

#define	ESF_USER	0x01	/* Signal generated from user	*/
				/* level (system call) such as	*/
				/* kill or sigsend.  Otherwise,	*/
				/* was generated by the kernel.	*/
#define	ESF_INTR	0x02	/* Signal was generated from	*/
				/* interrupt level.		*/


/*	The following structure is used with the evsig function
**	to get back the previous signal event disposition.
*/

typedef struct evsiginfo {
	sigset_t	evsi_sigset;	/* The set of signals	*/
					/* whose disposition is	*/
					/* described in this	*/
					/* structure.		*/
	int		evsi_eqd;	/* The event queue	*/
					/* descriptor to which	*/
					/* a signal event is to	*/
					/* be posted or the	*/
					/* value EQ_NOQUEUE.	*/
	long		evsi_pri;	/* The priority of the	*/
					/* event to be posted.	*/
} evsiginfo_t;


/*	When an ET_STREAM event is posted, the ev_data field will point
**	to a structure of the following format.
*/

typedef struct evd_stream {
	int	es_mask;	/* The condition which has	*/
				/* occurred.  Exactly one of 	*/
				/* the S_XXXX flags will be on	*/
				/* in this word.		*/
	long	es_data;	/* If the bit on in es_mask is	*/
				/* one of those for which a	*/
				/* priority band applies, then	*/
				/* this is the band for which a	*/
				/* message has arrived.		*/
				/* If es_mask is S_ERROR, then	*/
				/* this is the error code.	*/
				/* Otherwise, this field is not	*/
				/* used.			*/
} evd_stream_t;

/*			Function Prototypes
**			===================
**
**	The following are prototypes for the library functions which
**	users call (indirectly using the macros at the start of this
**	file.)
*/

#if !defined(_KERNEL)
#if defined(__STDC__)

int	__evpost(const evver_t, event_t *const, const int, const int);
int	__evpoll(const evver_t, const evpollcmds_t, event_t *const,
		 const int, const hrtime_t *const);
int	__evpollmore(const evver_t, event_t *const, const int);
int	__evtrap(const evver_t, const evpollcmds_t, event_t *const,
		 const int, const long,
		 void (*const)(event_t *, int, long, evcontext_t *),
		 const evta_t *const);
int	__evtrapcancel(const evver_t, long *const, const int);
int	__evcntl(const evver_t, const evcntlcmds_t, const long,
		 const long);
int	__evqcntl(const evver_t, const eqd, const evqcntlcmds_t,
		 const long);
int	__evexit(const evver_t, const idtype_t, const id_t,
		 const ecb_t *const);
int	__evexitset(const evver_t, const procset_t *const,
		    const hostid_t hostid, const ecb_t *const);
int	__evsig(const evver_t, const sigset_t *const,
		const ecb_t *const, evsiginfo_t *const, const int);

#else

int	__evpost();
int	__evpoll();
int	__evpollmore();
int	__evtrap();
int	__evtrapcancel();
int	__evcntl();
int	__evqcntl();
int	__evexit();
int	__evexitset();
int	__evsig();

#endif	/* defined(__STDC__)	*/
#endif	/* !defined(_KERNEL)	*/

#endif	/* _SYS_EVENTS_H */
  07070100005979000081240000000200000002000000012719347c0000f30d000000230000000c00000000000000000000001800000000usr/include/sys/evsys.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EVSYS_H
#define _SYS_EVSYS_H

#ident	"@(#)/usr/include/sys/evsys.h.sl 1.1 4.0 10/15/90 57406 AT&T-SF"
/*			File Contents
**			=============
**
**	This file contains information used in the implementation
**	of the events VFS.  It is intended for inclusion only in
**	the kernel.  User programs and library routines should not
**	need this file.
*/


/*			Required Header Files
**			=====================
**
**	The following header files must be includes before including
**	this file.
**
**		REQUIRES	sys/types.h
**		REQUIRES	sys/signal.h
**		REQUIRES	sys/evecb.h
**		REQUIRES	sys/hrtcntl.h
**		REQUIRES	sys/priocntl.h
**		REQUIRES	sys/procset.h
**		REQUIRES	sys/events.h
**		REQUIRES	sys/vnode.h
**		REQUIRES	sys.cred.h
*/

/*			Miscellaneous Defines
**			=====================
**
**	The following defines are just convenient to have around.
*/

#ifdef _KERNEL

#define	TRUE	1
#define	FALSE	0
#define	NULL	0
#define	ERROR	(-1)
#define	ZERO	0

#endif	/* _KERNEL	*/

/*	The following define is used to represent an unused structure.
**	The value must not be a legal file descriptor and must also
**	not be equal to EQ_NOQUEUE (defined in events.h).  For an
**	example of where this is used, see ev_main.c/ev_sig_initinfo.
*/

#define	EQ_UNUSED	(-1)

/*	The following are used as arguments to functions ev_mem_alloc,
**	ev_kev_post, etc. to indicate whether to wait or not.  Do not
**	change the values of these symbols.
*/

typedef enum evwait {
	EV_NOWAIT,	/* Do not wait.				*/
	EV_WAIT		/* Wait if necessary.			*/
} evwait_t;

/*			Events VFS Parameter Defines
**			============================
**
**	The following defines set parameters of the events file
**	system type which are not intended to be changable by an
**	administrator.
*/

#define	EV_NMSZ		18		/* Maximum length of an	*/
					/* events queue name.	*/
#define	EV_SLPPRI_INT	(PZERO + 1)	/* Our sleep priority	*/
					/* when we want to be	*/
					/* interruptible.	*/
#define	EV_SLPPRI_NINT	PZERO		/* Our sleep priority	*/
					/* when we want to be	*/
					/* non-interruptible.	*/
#define	EV_ROOTINBR	2		/* I-number of our root	*/
					/* inode.		*/

#define	EV_BASEINBR	(EV_ROOTINBR + 1)
					/* Inode number of our	*/
					/* first queue entry.	*/
#define	EV_NSIGS	(NSIG - 1)	/* Actual nbr of signals*/
					/* which are defined.	*/
					/* NSIG is defined in	*/
					/* sys/signal.h.	*/
#define	EV_BSIZE	1024		/* The block size for	*/
					/* our file system.	*/
					/* Must be a power of 2.*/
#define	EV_L2BSIZE	10		/* The base 2 log of	*/
					/* EV_BSIZE.		*/
#define	EV_FSNAME	"events"	/* The name of our VFS.	*/
#define	EV_PKNAME	"memory"	/* Our "pack name" for	*/
					/* statvfs to return.	*/

/*			General Typedefs
**			================
**
**	The following are some generally useful typedefs.
*/

typedef int		err_t;	/* Type of an error code.	*/

/*	With ansi C, the best way to represent a general pointer is as
**	a (void *).  However, (void *) will not be available in all
**	old (pre-ansi) compilers.  Therefore, we define a general
**	pointer type as follows.
*/

#if defined(__STDC__)
	typedef void *	gptr_t;
#else
	typedef char *	gptr_t;
#endif	/* __STDC__	*/

/*			Miscellaneous Macros
**			====================
**
**	The following macro does an spl to the proper level for the
**	events VFS.
*/

#define	spl_ev()	splhi()


/*	The following macros translate between inode numbers and
**	the corresponding queue entry.  Both macros assume that the
**	queue referred to is an actual event queue and not the queue
**	which represents our root directory.
*/

#define	ev_inbrtoqp(INBR)  (ev_actqp[(INBR) - EV_BASEINBR].eaq_qp)
#define	ev_qptoinbr(QP)	   (((QP)->evq_aqp - ev_actqp) + EV_BASEINBR)


/*	The following macro converts a directory offset to an inode
**	number.  It assumes that the directory entry is not for "." or
**	".." which are the first two (pseudo) entries.
*/

#define	ev_dotoinbr(DO)	(((DO) / EV_DIRSZ) - 2 + EV_BASEINBR)


/*	The following macro defines the size of a message queue.
**	It counts each event as using sizeof(event_t) bytes plus
**	whatever space is used by the type dependent data.  Data in
**	the ev_data field (EF_QUICKD set) or in shared memory (EF_SHM
**	set) is not counted.
*/

#define	ev_qsize(QP)	((QP)->evq_nevents * sizeof(event_t) + \
			 (QP)->evq_memsize)

/*	The following macro converts a size in bytes to a size in
**	blocks where the block size is that of the events VFS.  The
**	conversion is done by rounding up.
*/

#define	ev_bytestoblks(BY)  (((BY) + EV_BSIZE - 1) >> EV_L2BSIZE)

/*			Miscellaneous Macros (Continued)
**			================================
**
**	The following macro rounds the value "VAL" up to the next "BND"
**	boundary where "BND" must be a power of 2.
*/

#define	round(VAL, BND)	(((VAL) + (BND) - 1) & ~((BND) - 1))

/*	Get the absolute value of a number.
*/

#define	abs(VAL)	((VAL) < 0  ?  -(VAL)  :  (VAL))

/*	Get the minimum of two values.
*/

#define	min(A, B)	((A) <= (B) ? (A) : (B))

/*
**	The following macro is used to reduce the number of
**	unnecessary calls to ev_istrap().
*/
#define	EV_ISTRAP(PRP)	((PRP)->p_evpdp != NULL && ev_istrap(PRP))


/*			Events Directory Structure (evdir_t)
**			====================================
**
**	The following is the structure of a directory in the events
**	file system.  This directory is only conceptual.  It does
**	not actually exist anywhere but we manufacture directory
**	entries as needed to make "ls" and stuff like that work.
**
**	The closest thing we have to a directory is the "active queue
**	list" which is an array of pointers to active queues.  The
**	array itself is pointed to by ev_actqp.  The index into the
**	array is used to construct an inumber for the queue.  The list
**	is traversed sequentially to read the directory for readdir.
*/

typedef struct evdir {
	ino_t	ev_d_ino;		/* The inode number.	*/
	char	ev_d_nm[EV_NMSZ + 1];	/* The name.		*/
} evdir_t;

#define	EV_DIRSZ	sizeof(evdir_t)

/*			Data Structure Overview
**			=======================
**
**	We use a number of different data structures to maintain
**	information about events and their connection to queues and
**	processes.  The following pictures show the relationships
**	among the various structures.  An arrow pointing in one
**	direction indicates a singly linked list or a pointer.  An
**	arrow pointing in both directions indicates a doubly-linked
**	list or a ring.  Following the pictures are the declarations
**	for all of these structures.
**
**	An evqueue_t structure represents an event queue.  The evkev_t
**	structures represent events on this queue.  They are in fifo
**	order.  Each queue has a ring of evexref_t structures attached
**	to it.  This gives the set of expressions which have one or
**	more terms referencing the queue.  When an event is posted to
**	a queue, following the evexref_t ring shows what poll and trap
**	expressions must be checked to see if the newly posted event
**	caused them to be satisfied.
**
**	Each evexpr_t structure represents an evpoll or evtrap
**	expression.  By an expression, we mean a list of terms (events)
**	connected by the disjunction (EC_ONE or EC_ANY) or conjunction
**	(EC_ALL) operator.  All of the outstanding trap expressions for
**	a process are on a ring headed by the epd_exprs field of the
**	evpd_t table.  The poll expressions are not on this list as
**	their existence is more transitory and they are never held.
**	They are found via the evexref_t list.  The following picture
**	shows the relation of the evqueue_t, evkev_t, and evexref_t
**	structures.
**
**	The events on a queue can be requested in either fifo or 
**	priority order.  Currently, we must search the list of events
**	on the queue linearly for the highest priority event when
**	requested.  This can be very inefficient if there are many
**	events on the queue.  It would be possible to improve this by
**	keeping the events in priority order, perhaps by using a
**	priority queue (heap) and then running a fifo list through them
**	to satisfy fifo requests.  This is only important if queues
**	accumulate long lists of events and then are polled or trapped
**	in priority order.  Implementing such a priority queue is a
**	possible future enhancement.

**			Data Structure Overview (Continued)
**			===================================
**
**
**      _____________	      ____________	      ____________
**      |	    |         |	         |	      |		 |
**      | evqueue_t |/_______\|  evkev_t |/__________\|	 evkev_t |
**      |___________|\       /|__________|\          /|__________|
**           /|\
**            |
**            |
**            |
**            |     ________________	      ________________
**	      |     |              |  	      |              |
**	      |____\|  evexref_t   |/________\|  evexref_t   |
**		   /|______________|\        /|______________|
**			   |			      |
**			   |			      |
**			   |    		      |
**   __________     ______\|/_______	      _______\|/______
**   |        |     |              |  	      |              |
**   | proc_t |/___\|   evexpr_t   |/________\|    evexpr_t  |
**   |________|\   /|______________|\        /|______________|
**			  /|\   		     /|\
**			   |			      |
**			   |			      |
**			   |			      |
**                  ______\|/_______          _______\|/______
**		    |	           |	      |              |
**		    |   evterm_t   |          |    evterm_t  |
**		    |______________|          |______________|
**			  /|\   		     /|\
**			   |			      |
**			   |			      |
**			   |			      |
**                  ______\|/_______          _______\|/______
**		    |	           |	      |              |
**		    |   evterm_t   |          |    evterm_t  |
**		    |______________|          |______________|

**			Data Structure Overview (Continued)
**			===================================
**
**
**	A satisfied poll or trap expression is represented by an 
**	evsexpr_t structure.  These structures are stacked for nested 
**	trap handler calls.  The top of the stack is pointed to by the
**	epd_asexp member of the evpd_t structure.  Also on this stack 
**	are satisfied poll expressions which have been retained after 
**	the evpoll returned because there is data remaining and the 
**	EF_DISCARD flag was not set or a file descriptor was passed with
**	the event and not given to the caller yet.  Satisfied
**	expressions of either type which have not yet been handled are
**	linked together on a doubly linked ring headed by the
**	epd_ppsexprs or epd_ptsexprs member of the evpd_t structure.
**	The first list is for pending poll satisfied expressions and
**	the second is for pending trap satisfied expressions.  The
**	evsexpr_t structure points to the evexpr_t structure for the
**	expression which is satisfied.  The evsexpr_t structure also
**	contains a ring of evsterm_t structures, one for each term of
**	the satisfied expression.
**
**	Each evsterm_t structure, in turn, points to the corresponding
**	evterm_t structure.  Note that the number of satisfied terms may
**	be less than the total number of terms so the two lists are not
**	necessarily of the same size.  Only satisfied terms are on the
**	satisfied expression's satisfied term ring while all terms of
**	the user's expression are on the term ring.
**	The following picture shows the use of the evsexpr_t and
**	evsterm_t structures.

**			Data Structure Overview (Continued)
**			===================================
**
**  _________________     _______________                       _______________
**  |               |     |             |                       |             |
**  |    proc_t     |  __\|  evsexpr_t  |  ____________________\|  evsexpr_t  |
**  |               |  | /|             |  |     _____________ /|             |
**  |   epd_asexp   |__|  |  evse_next  |__|  __\|           |  |  evse_next  |
**  |               |     |             |     | /|  evexpr_t |  |             |
**  |   epd_ptsexpr |     |   evse_ep   |_____|  |           |  |   evse_ep   |
**  |_______________|     |             |        |           |  |             |
**          /|\           |   evse_stp  |        |   eve_tp  |  |   evse_stp  |
**           |            |_____________|        |___________|  |_____________|
**    ______\|/______           /|\                   /|\     
**    |             |            |                     |      
**    |  evsexpr_t  |     ______\|/______        _____\|/_____
**    |             |     |             |  _____\|           |
**    |             |     |   evsterm_t |  |    /|  evterm_t |
**    |  evse_next  |     |             |  |     |           |
**    |_____________|     |   evst_tp   |__|     |  evt_next |
**          /|\           |             |        |___________|
**           |            |  evst_next  |             /|\     
**    ______\|/______     |_____________|              |      
**    |             |           /|\              _____\|/_____
**    |  evsexpr_t  |            |               |           |
**    |             |     ______\|/______        |  evterm_t |
**    |             |     |             |        |           |
**    |  evse_next  |     |   evsterm_t |        |  evt_next |
**    |_____________|     |             |        |___________|
**                        |   evst_tp   |___          /|\
**                        |             |  |           |
**                        |  evst_next  |  |     _____\|/_____
**                        |_____________|  |     |           |
**                                         |____\|  evterm_t |
**                                              /|           |
**                                               |  evt_next |
**                                               |___________|

**			Data Structure Overview (Continued)
**			===================================
**
**                                                    
**
**	The evtid_t structures are used to keep track of trap
**	identifiers supplied as the "tid" argument of the evtrap
**	function call.  There is a hash table used for looking up trap
**	identifiers.  It is pointed to by ev_tidhtp and has evci_tidhts
**	entries where evci_tidhts is in the evcinfo_t structure 
**	described in events.h.  The hash table enables us to find the
**	evtid_t structure for a particular tid quickly.  We must do
**	this every time we process an evtrap system call.  In
**	addition, every trap expression, represented by an evexpr_t
**	structure, contains a pointer, eve_tidlp, to a list of pointers
**	to evtid_t structures.  These are the trap ids which should be
**	held when this trap is taken.  The evtid_t structure contains
**	the level (etid_lvl) at which it is held or 0 if it is not
**	currently held.  This can be compared with the trap level of
**	the top entry on the epd_asexp active expression stack
**	(evse_lvl).  The following picture shows the relation between
**	the evtid_t structures, the hash table, and the evexpr_t
**	structure and its reference list.
**
**
**  
** 
**    ________________
**    |              |
**    |   ev_tidhtp  |__
**    |______________|  |
**                      |
**                      |
**     _________________|
**     |  __________     ___________     ___________
**     |_\|        |     |         |     |         |
**       /| tid    |/___\| evtid_t |/___\| evtid_t |
**        | hash   |\   /|_________|\   /|_________|
**        | table  |  .
**        |        |  .  ___________     ___________     ___________
**        |        |/___\|         |     |         |     |         |
**        |________|\   /| evtid_t |/___\| evtid_t |/___\| evtid_t |
**                       |_________|\   /|_________|\   /|_________|
**                                           /|\            /|\
**                                            |              | 
**    _______________     ___________         |              |
**    |             |  __\|         |         |              |
**    |   evexpr_t  |  | /|  expr   |_________|              |
**    |             |  |  |  tid    |                        |
**    |  eve_tidlp  |__|  |  hold   |                        |
**    |_____________|     |  list   |________________________|
**                        |_________| 
*/

/*			The evlisthd_t Structure
**			========================
**
**	We use many doubly linked lists of structures in the events 
**	VFS.  Most of these are maintained as a ring instead of a list
**	with head and tail pointers.  The reason is that enqueueing and
**	dequeueing are faster since no special test for an empty list
**	is required.  The following structure is used to represent the
**	head of a general doubly linked list or ring.  When used as a
**	ring, it is empty when:
**
**		lh_first == lh_last == &lh_first
**
**	In order for this trick to work, the link fields for the ring 
**	structure must be the first members of the structure.  We do
**	this for various structures below.  In each case, it is
**	indicated which members must not be moved.
*/

typedef struct evlisthd {
	struct evlisthd	*lh_first;	/* First structure on	*/
					/* list.		*/
	struct evlisthd	*lh_last;	/* Last structure on	*/
					/* list.		*/
} evlisthd_t;

/*			The evterm_t Structure
**			======================
**
**	The following structure represents a term of a trap or poll
**	expression.  All of the terms of an expression are linked
**	together in order through the evt_next field.  The list of all
**	the terms of an expression, in order, form the eve_terms ring in
**	the evexpr_t structure.  The first two members of this structure
**	must not be moved.
*/

typedef struct evterm {
	struct evterm	*evt_next;	/* Next term in the	*/
					/* expression.		*/
	struct evterm	*evt_prev;	/* Previous term in the	*/
					/* expression.		*/
	event_t		evt_ev;		/* The event which the	*/
					/* user specified.	*/
	vnode_t		*evt_vp;	/* Ptr to the vnode for */
					/* the event queue	*/
					/* evt_ev.ev_eqd.	*/
	ushort		evt_seq;	/* Sequence nbr of this */
					/* term in the list of	*/
					/* terms for the	*/
					/* expression - zero	*/
					/* origin.		*/
} evterm_t;

/*			The evexpr_t Structure
**			======================
**
**	The following structure represents a trap or poll expression.
**	A doubly linked ring of these structures which represent all
**	outstanding trap or poll expressions for a process is pointed
**	to by the epd_exprs field of a evpd_t structure entry.  Note
**	that the first two members of this structure must not be moved.
*/

typedef struct evexpr {
	struct evexpr	*eve_next;	/* Next expression for	*/
					/* this process.	*/
	struct evexpr	*eve_prev;	/* Previous  expression */
					/* for this process.	*/
	evlisthd_t	eve_terms;	/* The ring of terms in */
					/* the expression.	*/
	event_t		*eve_uevp;	/* Ptr to user's events */
					/* array.  This is 	*/
					/* where evpoll and	*/
					/* evtrap return 	*/
					/* results.		*/
	struct proc	*eve_procp;	/* Ptr to process this	*/
					/* expression is for.	*/
	void		(*eve_lfunc)();	/* Ptr to our library	*/
					/* routine used to 	*/
					/* transfer to a user's	*/
					/* trap handler.	*/
	void		(*eve_ufunc)();	/* Ptr to the user's	*/
					/* trap handler 	*/
					/* function.		*/
	struct evtid	*eve_tidp;	/* Ptr to trap id 	*/
					/* struct for this trap	*/
					/* expression.		*/
	pcparms_t	eve_schedpri;	/* Scheduling priority	*/
					/* to be set when	*/
					/* invoking a trap	*/
					/* handler if the 	*/
					/* eve_trappri flag 	*/
					/* is set.		*/
	struct evtid	**eve_tidlp;	/* Ptr to an array of	*/
					/* pointers to evtid_t	*/
					/* structures.  The 	*/
					/* list of tids to be	*/
					/* held when trapping	*/
					/* on this expression.	*/
	ushort		eve_tidls;	/* Nbr of elements in	*/
					/* the eve_tidlp array.	*/
	evpollcmds_t	eve_cmd;	/* Expression command.  */
					/* One of EC_ONE, 	*/
					/* EC_ANY, or EC_ALL.	*/

/*			The evexpr_t Structure (Continued)
**			==================================
*/

	ushort		eve_poll    :1;	/* Set for an evpoll	*/
					/* expression.  If not	*/
					/* set, then an evtrap	*/
					/* expression.		*/
	ushort		eve_trappri :1;	/* Set if a special	*/
					/* priority was given	*/
					/* with an evtrap.  	*/
					/* Never set when 	*/
					/* eve_poll is set.	*/
	ushort		eve_taken   :1;	/* Set if this 		*/
					/* expression has been	*/
					/* satisfied but user's	*/
					/* handler has not been	*/
					/* called yet.  Don't	*/
					/* try to satisfy it	*/
					/* again.  Never set if	*/
					/* eve_poll is.		*/
	ushort		eve_holdall :1;	/* Set if all future	*/
					/* traps should be held	*/
					/* when calling the	*/
					/* handler for this 	*/
					/* expression.		*/
	ushort		eve_canned  :1;	/* Set if this trap	*/
					/* expression has been	*/
					/* cancelled.		*/
	ushort		eve_restart :1;	/* Set if restartable	*/
					/* system calls should	*/
					/* be restarted after	*/
					/* trapping on this	*/
					/* expression.  Never	*/
					/* set if eve_poll is.	*/
	ushort		eve_astk : 1;	/* Set if we should	*/
					/* switch to alternate	*/
					/* stack before calling	*/
					/* handler for this	*/
					/* expression.		*/
	ushort		eve_nterms;	/* Number of terms in	*/
					/* the event expression.*/
	ushort		eve_refcnt;	/* Count of the number	*/
					/* of evsexpr_t structs	*/
					/* which are pointing 	*/
					/* to this expression.	*/
} evexpr_t;

/*			The evexref_t Structure
**			=======================
**
**	The following structure is used to connect an event queue
**	with the outstanding trap and poll expressions which reference
**	the queue.  Each event queue points to a ring of evexref_t
**	structures.  Each evexref_t structure points to one trap or
**	poll expression as represented by an evexpr_t structure.  Each
**	expression pointed to references the indicated queue in at
**	least one of its terms.  The first two members of this
**	structure must not be moved.
*/

typedef struct evexref {
	struct evexref	*exr_next;	/* Ptr to next reference*/
					/* on the ring for this	*/
					/* queue.		*/
	struct evexref	*exr_prev;	/* Ptr to previous	*/
					/* reference on the 	*/
					/* ring for this queue.	*/
	evexpr_t	*exr_ep;	/* Ptr to the		*/
					/* expression.		*/
} evexref_t;

/*			The evsterm_t Structure
**			=======================
**
**	The following structure is used to represent a satisfied term
**	of a satisfied expression.  All the satisfied terms of the
**	satisfied expression are linked together through the evst_next
**	field.  The start of the ring is the evse_sterms field of the
**	evsexpr_t structure.  Note that this list will contain
**	evsterm_t structures only for satisfied terms of the 
**	expression.  This means that for EC_ONE and
**	EC_ANY, there may be fewer terms in the evsterm_t set than in
**	the evterm_t set for the expression.  The evst_tp field of the
**	evsterm_t structure points to the evterm_t structure which is
**	satisfied.  The evt_seq field of the evterm_t structure
**	indicates which event in the user's event list the term
**	corresponds to.  It is used to find the address of the user's
**	event_t structure to which this satisfied term should be copied.
**	The first two members of this structure must not be moved.
*/

typedef struct evsterm {
	struct evsterm	*evst_next;	/* Next satisfied term.	*/
	struct evsterm	*evst_prev;	/* Previous satisfied	*/
					/* term.		*/
	evterm_t	*evst_tp;	/* Ptr to the term	*/
					/* which has been	*/
					/* satisfied.		*/
	struct evkev	*evst_kevp;	/* Ptr to the event	*/
					/* which satisfies the	*/
					/* term.		*/
} evsterm_t;

/*			The evsexpr_t Structure
**			=======================
**
**	This structure represents a satisfied poll or trap expression.
**	It will be saved for poll only if the satisfied expression must
**	be retained after the evpoll returns.  This occurs if not all
**	of the data was returned and EF_DISCARD was not set for at
**	least one of the terms in the expression or if a file descriptor
**	was passed with the event and has not yet been given to the
**	receiver of the event.  For trap, there will be one evsexpr_t
**	structure for each active trap handler call.  Note that these
**	can be nested and even recursive since the handler can unblock
**	the automatic block which we impose when we call it.  The
**	evsexpr_t structures are stacked for nested trap handler calls.
**	The top (current) entry is pointed to by the epd_asexpr field of
**	the evpd_t structure.  Satisfied *xpression structures for trap
**	handlers which have not yet been called are doubly linked on a
**	ring whose header is epd_ptsexprs.  Satisfied expressions for
**	polls which have not yet been received by the process doing the
**	poll are on a similar ring whose head is epd_ppsexprs.  The
**	first two members of this structure must not be moved.
*/

/*			The evsexpr_t Structure (Continued)
**			===================================
*/

typedef struct evsexpr {
	struct evsexpr	*evse_next;	/* Ptr to next		*/
					/* satisfied expression	*/
					/* on the stack or on a	*/
					/* list.		*/
	struct evsexpr	*evse_prev;	/* Ptr to the previous	*/
					/* satisfied expression	*/
					/* on a list.		*/
	evexpr_t	*evse_ep;	/* Ptr to the		*/
					/* expression which has	*/
					/* been satisfied.	*/
	evlisthd_t	evse_sterms;	/* The ring of		*/
					/* satisfied terms for	*/
					/* this expression.	*/
	short		evse_lvl;	/* The nesting level at	*/
					/* which this trap	*/
					/* handler is running.	*/
	ushort		evse_priset :1;	/* Set if the process'	*/
					/* priority has been 	*/
					/* set from this  expr.	*/
					/* The priority to 	*/
					/* restore is in the	*/
					/* evse_oldpri member.	*/
	ushort		evse_astk : 1;	/* Set if we switched	*/
					/* to the alternate	*/
					/* stack when calling 	*/
					/* the handler with	*/
					/* this expression.	*/
					/* Not set if already	*/
					/* running on alternate	*/
					/* stack before calling	*/
					/* handler with this	*/
					/* satisfied expression.*/
	pcparms_t	evse_oldpri;	/* The scheduling	*/
					/* priority which was 	*/
					/* in effect before	*/
					/* calling the trap	*/
					/* handler.  It must be	*/
					/* restored when the	*/
					/* handler returns.	*/
} evsexpr_t;

/*			The evtid_t Structure
**			=====================
**
**	The following structure is used to maintain information about
**	trap identifiers.  Trap holds exist at a particular level.
**	Level zero is the main program.  Level one is a trap handler
**	called while running in the main program.  Level 2 is a trap
**	handler called while running in a level 1 trap handler.  In
**	general, level N (for N > 1) is a trap handler called while
**	running in a level N-1 handler.
**
**	Every evtid_t structure is on two rings.  The first is headed
**	by the evpd_t structure field epd_tids.  This list contains
**	every evtid_t structure for the process.  The link fields for
**	this ring are etid_pnextp and etid_pprevp.  The evtid_t
**	structure is also on a hash ring.  The link fields for this
**	ring are etid_hnextp and etid_hprevp.
**
**	The global variable ev_tidhtp points to the hash table for these
**	trap identifier structures hashed on the trap id and process
**	identifier.  This table contains evci_tidhts entries.  Each
**	entry in the hash table is an evlisthd_t structure heading the
**	ring of evtid_t structures.  There is one such structure for
**	each trap identifier being used by a process.  If two processes
**	are using the same tid, there will be two separate evtid_t
**	entries.  Each evtid_t entry indicates the level at which it is
**	being held or TR_NOTHELD if it is not currently held.  In
**	addition to traps being held automatically when a trap handler
**	is called, the user can explicitly hold traps using the evcntl
**	system call.  A trap held in this way will have the etid_holdlvl
**	field set in the same way as for an automatic hold.
**
**	This structure also contains a count of the number of pointers
**	which exist to the structure.  When the last use is released
**	for that tid and process, the evtid_t structure is deleted.
**	The hash is performed on the tid and proc id values.
**
**	The first 4 fields of this structure must not be moved.  Note
**	the special code in ev_subrs.c/ev_tid_hash and
**	ev_subrs.c/ev_tid_init which make assumptions about the 
**	locations of these fields.
*/

/*			The evtid_t Structure (Continued)
**			=================================
*/

typedef struct evtid {
	struct evtid	*etid_pnextp;	/* Ptr to the next	*/
					/* evtid_t structure on */
					/* the proc ring.	*/
	struct evtid	*etid_pprevp;	/* Ptr to the previous	*/
					/* evtid_t structure on */
					/* the proc ring.	*/
	struct evtid	*etid_hnextp;	/* Ptr to the next	*/
					/* evtid_t structure on	*/
					/* the hash ring.	*/
	struct evtid	*etid_hprevp;	/* Ptr to the previous	*/
					/* evtid_t structure on	*/
					/* the hash ring.	*/
	long		etid_tid;	/* The trap identifier	*/
					/* being held.		*/
	pid_t		etid_pid;	/* Process id that this	*/
					/* entry belongs to.	*/
	short		etid_holdlvl;	/* The level at which	*/
					/* this tid is being 	*/
					/* held or TR_NOTHELD	*/
					/* if not currently	*/
					/* held.		*/
	ushort		etid_use;	/* Nbr of pointers to	*/
					/* this structure.	*/
} evtid_t;

#define	TR_NOTHELD	-1		/* Value for 		*/
					/* etid_holdlvl when	*/
					/* the trap is not held.*/

/*			The evkev_t Structure
**			=====================
**
**	The following structure is used to represent an event in the
**	kernel.  A ring of these events starts from an event queue.
**	The first two members of this structure must not be moved.
*/

typedef struct evkev {
	struct evkev	*kev_next;	/* Next event on the	*/
					/* same queue as this	*/
					/* one.			*/
	struct evkev	*kev_prev;	/* Previous event on 	*/
					/* the queue.		*/
	event_t		kev_ev;		/* The event info.	*/
	struct vnode	*kev_vp;	/* Ptr to the vnode for */
					/* the queue this event	*/
					/* is to be posted to 	*/
					/* or taken from.	*/
	struct vnode	*kev_pfdvp;	/* Ptr to the vnode for	*/
					/* the file descriptor	*/
					/* being passed in	*/
					/* ev_pfd if EF_PFD is	*/
					/* set in ev_flags.	*/
	union {
		struct anon_map	*kev_amp;	/* Ptr to anon map	*/
						/* structure. For	*/
						/* EF_SHM only.		*/
		struct evsigr	*kev_srp;	/* Ptr to evsigr_t	*/
						/* structure or NULL.	*/
						/* If not null, clear	*/
						/* the EVS_F_BLOCK flag	*/
						/* in the evsigr_t 	*/
						/* structure when this	*/
						/* event is dequeued.	*/
						/* For ET_SIG events	*/
						/* only.		*/
	}		kev_un;		/* An ET_SIG event will	*/
					/* never be in shm.	*/
	size_t		kev_datasent;	/* When event sent in  	*/
					/* parts, this is 	*/
					/* amount already sent.	*/
					/* The value of		*/
					/* kev_ev.ev_datasize	*/
					/* can be used to	*/
					/* determine the amount	*/
					/* of data remaining.	*/

/*			The evkev_t Structure (Continued)
**			=================================
*/

	ushort		kev_onqueue :1;	/* Set if this event is	*/
					/* on a queue.		*/
	ushort		kev_taken   :1;	/* Set if this event 	*/
					/* has been taken (at	*/
					/* least temporarily) 	*/
					/* to satisfy a poll or	*/
					/* trap request.	*/
	char		kev_pfdflags;	/* The f_flag field of	*/
					/* the file table entry	*/
					/* for the passed file	*/
					/* descriptor ev_pfd if	*/
					/* EF_PFD is set in	*/
					/* ev_flags.		*/
} evkev_t;

/*			The evqueue_t Structure
**			=======================
**
**	The following structure is used within the kernel to represent
**	an event queue.  In VFS terms, it is the inode which is pointed
**	to by the vnode.  The following are some notes on the usage of
**	certain fields of this structure.
**
**		evq_memsize	This is the total number of bytes of
**				data in private memory for all events on
**				the queue.  It is the sum of the 
**				ev_datasize fields of all events on the
**				queue for which the EF_SHM and
**				EF_QUICKD flags are off and the
**				ev_datasize is greater than zero.  The 
**				total file size will be the number of 
**				events on the queue (evq_nevents) times
**				the size of an event (sizeof(event_t)) 
**				plus the value of the evq_memsize field.
**				This approximates the space taken up by
**				the event.
**
**		evq_atime	The access time is updated when an
**				event is removed from the queue via 
**				either evpoll or evtrap.
**
**		evq_mtime	The modify time is updated when an
**				event is placed on the queue via 
**				evpost, evsig, or any other mechanism
**				such as hrtcntl, asynchronous system
**				call, etc.
**
**		evq_ctime	The change time is updated when the
**				status of an event queue is changed via
**				one of the evqcntl commands.
**
**	The event queues are kept on a hash ring based on the file name
**	of the queue (evq_name).  The hash table is pointed to by the
**	global variable ev_fnhtp.  The links for the ring are evq_next
**	and evq_prev.  The first two members of this structure must not
**	be moved.
*/

/*			The evqueue_t Structure (Continued)
**			===================================
*/

typedef struct evqueue {
	struct evqueue	*evq_next;	/* Ptr to the next	*/
					/* active event queue	*/
					/* on the ev_fnhtp hash	*/
					/* ring.		*/
	struct evqueue	*evq_prev;	/* Ptr to previous	*/
					/* event queue on the	*/
					/* hash ring.		*/
	evlisthd_t	evq_events;	/* The ring of events	*/
					/* on the queue.	*/
	evlisthd_t	evq_exrefs;	/* The ring of		*/
					/* references to exprs	*/
					/* which reference this	*/
					/* queue.		*/
	ulong		evq_memsize;	/* Total bytes of	*/
					/* private data on the	*/
					/* queue.  Events with	*/
					/* data in shared 	*/
					/* memory or in the	*/
					/* ev_data member of an	*/
					/* event will not be	*/
					/* counted in this	*/
					/* member.		*/
	ulong		evq_shmsize;	/* Total bytes of	*/
					/* shared memory data 	*/
					/* used by all events	*/
					/* on this queue.	*/
	ushort		evq_nevents;	/* Total number of	*/
					/* events on this queue.*/
	evcm_t		evq_closemd :3;	/* The close mode of	*/
					/* the queue.  One of	*/
					/* the ECM_XXXX values	*/
					/* defined in events.h.	*/
					/* We have left an 	*/
					/* extra bit in case 	*/
					/* any new values have	*/
					/* to be added to the	*/
					/* enumeration.		*/
	ushort		evq_wspace  :1;	/* Set if a process is	*/
					/* waiting for space to	*/
					/* post an event to	*/
					/* this queue.		*/
	ushort		evq_wevent  :1;	/* Set if a process is	*/
					/* waiting for an	*/
					/* event to be posted	*/
					/* to this queue.	*/
	ushort		evq_locked  :1;	/* Set if this queue is	*/
					/* locked.		*/
	ushort		evq_wanted  :1;	/* Set if someone is	*/
					/* waiting for the lock	*/
					/* evq_locked to clear.	*/

/*			The evqueue_t Structure (Continued)
**			===================================
*/

	uid_t		evq_uid;	/* User id of owner of	*/
					/* queue.		*/
	gid_t		evq_gid;	/* Group id of owner of	*/
					/* queue.		*/
	mode_t		evq_mode;	/* File mode of queue.	*/
	ushort		evq_opencnt;	/* Count of number of	*/
					/* open's on this queue.*/
	struct evactq	*evq_aqp;	/* Ptr to the entry in	*/
					/* the ev_actqp array	*/
					/* for this queue.	*/
	time_t		evq_atime;	/* Access time of queue.*/
	time_t		evq_mtime;	/* Modify time of queue.*/
	time_t		evq_ctime;	/* Change time of queue.*/
	ulong		evq_maxev;	/* Max nbr of events	*/
					/* allowed on the queue.*/
	ulong		evq_maxdpe;	/* Max nbr of bytes of	*/
					/* data per event.	*/
	ulong		evq_maxmem;	/* Max value for	*/
					/* evq_memsize.		*/
	struct vnode	evq_vnode;	/* The vnode for this	*/
					/* queue.		*/

	char		evq_name[EV_NMSZ + 1];
					/* The name of the	*/
					/* queue.		*/
} evqueue_t;

/*	The following is the default close mode for a newly created
**	event queue.
*/

#define	ECM_DEFAULT	ECM_DELALL


/*	The locking of an event queue is based on the fact that
**	interrupt level routines are allowed to post events to a
**	queue but not to remove them from the queue.  For this reason,
**	any process manipulating the evq_events ring must do an spl_ev()
**	to block out interrupts.
**
**	In addition, there are some routines which sleep in a loop
**	which is traversing the events ring.  These routines must lock
**	the queue using ev_rwlock to prevent interactions.
*/

/*			The evretry_t Structure
**			=======================
**
**	The following structure is used only by the ev_evpost function
**	in ev_main.c.  It is used to remember events which couldn't be
**	posted immediately but which should be retried.
*/

typedef struct evretry {
	struct evretry	*ert_next;	/* Next one on		*/
					/* double-linked ring.	*/
	struct evretry	*ert_prev;	/* Previous one on ring.*/
	event_t		*ert_uevp;	/* Ptr to the user's	*/
					/* event structure in	*/
					/* user address space.	*/
	evkev_t		*ert_kevp;	/* Pointer to the	*/
					/* kernel event to be	*/
					/* posted.		*/
	vnode_t		*ert_vp;	/* Ptr to the vnode for	*/
					/* the queue to which	*/
					/* the event should be	*/
					/* posted.		*/
} evretry_t;

/*			The evexitr_t Structure
**			=======================
**
**	The following structure is used to implement the evexit
**	function.  A ring of these structures exists for each process.
**	The head of this list is the epd_exits member of the evpd_t
**	structure.  The first two members of this structure must not
**	be moved.
*/

typedef struct evexitr {
	struct evexitr	*evx_next;	/* Next entry on the	*/
					/* ring.		*/
	struct evexitr	*evx_prev;	/* Previous entry on 	*/
					/* the ring.		*/
	evkev_t		*evx_kevp;	/* Ptr to preallocated	*/
					/* event structure.	*/
	vnode_t		*evx_vp;	/* Ptr to the vnode for	*/
					/* the queue to which	*/
					/* the event should be	*/
					/* posted.		*/
} evexitr_t;

/*	The following structure is used to pass parameters between
**	ev_evexit and the functions ev_exit_add and ev_exit_cancel which
**	ev_evexit calls indirectly via os/subr.c/dotoprocs.
*/

typedef struct evexitprms {
	cred_t	*exp_crdp;	/* Ptr to the credentials for	*/
				/* the process doing the evexit.*/
	vnode_t	*exp_vp;	/* Ptr to the vnode for the	*/
				/* queue to which the exit	*/
				/* event is to be posted.	*/
	ecb_t	*exp_ecbp;	/* Ptr to the event control	*/
				/* block describing the event	*/
				/* to post.			*/
	cnt_t	*exp_rvp;	/* Pointer to where the return	*/
				/* value should be stored.	*/
	err_t	exp_error;	/* An error returned by the 	*/
				/* function we call.		*/
} evexitprms_t;

/*			The evsigr_t Structure
**			======================
**
**	The following structure is used to implement the evsig
**	function.  An array of these structures is pointed to by the
**	epd_sigrp member of the evpd_t structure.  The size of this
**	array is EV_NSIGS.  The index into the array is the signal
**	number minus one since signal numbers start at one.  The only
**	valid elements of this array are those for which the signal
**	number is in the set epd_sigset in the proc table.
*/

typedef struct evsigr {
	long		evs_pri;	/* Priority of event 	*/
					/* to post.		*/
	int		evs_eqd;	/* Event queue		*/
					/* descriptor from 	*/
					/* which we got evs_vp.	*/
	vnode_t		*evs_vp;	/* Queue to which event */
					/* should be posted.	*/
	ushort		evs_noqueue :1;	/* Set if signal	*/
					/* queueing is not to	*/
					/* be done.  Don't post	*/
					/* an event for the	*/
					/* signal if one has	*/
					/* already been posted	*/
					/* and not received by	*/
					/* a process.		*/
	ushort		evs_blocked :1;	/* Set if an event is	*/
					/* not to be posted for	*/
					/* this signal.  Used 	*/
					/* to implement the	*/
					/* evs_noqueue function.*/
} evsigr_t;

/*			The evpd_t Structure
**			====================
**
**	The following structure contains data concerning a process
**	using the events facility.  One of these structures is pointed
**	to by the p_evpdp field of the proc table entry.  The structure
**	is allocated the first time a process uses any of the events
**	system calls.  At each point where a process can enter the 
**	events VFS for the first time, we must check that an evpd_t
**	structure is allocated and, if not, allocate one.  There are
**	not very many such places since most events operations occur on
**	an open file descriptor and will only get to the events VFS if
**	an event queue has been opened.  The places where we must check
**	are currently:
**
**		ev_vnodeops.c/ev_open	Opening an event queue.
**		ev_vnodeops.c/ev_create	Creating an event queue.
**		ev_sysint.c/ev_evsys	The evsys system call which is
**					used for events stuff which does
**					not apply to a particular event
**					queue.
**		ev_sysint.c/ev_fork	Must set up the child based on
**					the state of the parent.
**
**	The evpd_t structure is freed in ev_exit when the process exits.
**
**	If new entry points are added to events, they may also need
**	checks to insure that an evpd_t structure is always allocated.
**	In particular, be carful when extending events to work in a
**	distributed environment.
*/

/*			The evpd_t Structure (Continued)
**			================================
*/

typedef struct evpd {
	evlisthd_t	epd_exprs;	/* Head of a ring of	*/
					/* all of the event	*/
					/* expressions for	*/
					/* which this process	*/
					/* has an outstanding	*/
					/* evtrap.		*/
	evlisthd_t	epd_ppsexprs;	/* Head of a ring of	*/
					/* pending poll		*/
					/* satisfied		*/
					/* expressions for the	*/
					/* process.		*/
	evlisthd_t	epd_ptsexprs;	/* Head of a ring of	*/
					/* pending trap		*/
					/* satisfied		*/
					/* expressions for the	*/
					/* process.		*/
	evlisthd_t	epd_tids;	/* Head of a ring of	*/
					/* evtid_t structures	*/
					/* for this process.	*/
	k_sigset_t	epd_sigset;	/* Set of signals for	*/
					/* which an event is to	*/
					/* be generated.	*/
	k_sigset_t	epd_sigignset;	/* Set of signals to	*/
					/* set back to SIG_DFL	*/
					/* after the evsig is	*/
					/* cancelled.		*/
	evsexpr_t	*epd_asexp;	/* Ptr to the top of	*/
					/* the stack of active	*/
					/* satisfied poll and	*/
					/* trap expressions.	*/
					/* Trap handlers for	*/
					/* all of the trap 	*/
					/* exprs are currently	*/
					/* active and calls to	*/
					/* them are nested.	*/
					/* Recursive calls of 	*/
					/* the same handler are	*/
					/* possible.		*/
	evsigr_t	*epd_sigrp;	/* Ptr to the start of	*/
					/* an array of		*/
					/* descriptions of	*/
					/* events to be 	*/
					/* generated for	*/
					/* signals.		*/
	evlisthd_t	epd_exits;	/* Head of a ring of	*/
					/* descriptions of	*/
					/* events to be		*/
					/* generated when this	*/
					/* process exits.	*/

/*			The evpd_t Structure (Continued)
**			================================
*/

	ushort		epd_ntraps;	/* Nbr of trap		*/
					/* expressions for this	*/
					/* process.  Ring of	*/
					/* these expressions is	*/
					/* headed by epd_exprs.	*/
	ushort		epd_maxtraps;	/* Max nbr of trap	*/
					/* expressions allowed	*/
					/* for this process.	*/
	ushort		epd_maxeterms;	/* Max nbr of terms	*/
					/* allowed per 		*/
					/* expression for this	*/
					/* process.		*/
	ushort		epd_holdall :1;	/* Set if a TR_ALL hold	*/
					/* has been imposed on	*/
					/* the process by the	*/
					/* call of a trap	*/
					/* handler or by an	*/
					/* evcntl EC_TRAPHOLD	*/
					/* or EC_TRAPSET type	*/
					/* function.		*/
	ushort		epd_restart :1;	/* Flag set if we	*/
					/* interrupted process	*/
					/* to call trap handler	*/
					/* which specified	*/
					/* restart.		*/
	ushort		epd_astk : 1;	/* The process has	*/
					/* specified an		*/
					/* alternate stack.	*/
	ushort		epd_onastk : 1;	/* The process is 	*/
					/* currently running on	*/
					/* the alternate stack.	*/
	ushort		epd_lvl;	/* Trap expression	*/
					/* nesting level on	*/
					/* epd_asexp stack.	*/
					/*			*/
					/*  0 = No stacked 	*/
					/*      expressions.	*/
					/*  1 = Stacked trap	*/
					/*      expression from */
					/*      main program	*/
					/*      level.		*/
					/*  2 = Trap handler	*/
					/*      called while in	*/
					/*      level 1 trap	*/
					/*      handler.	*/
	caddr_t		epd_astkp;	/* Ptr to the user's	*/
					/* alternate stack.	*/
	ulong		epd_astks;	/* Size of the user's	*/
					/* alternate stack in	*/
					/* bytes.		*/
} evpd_t;

/*			The evactq_t Structure
**			======================
**
**	We keep an array of structures to refer to the active event
**	queues.  The global variable ev_actqp is a pointer to the start
**	of this array.  The array is allocated in ev_init at system 
**	startup time.  It has as many entries as the maximum number of
**	event queues we will ever create (evcinfo.evci_mevqueues).  Each
**	entry in the array has the structure defined below.  The 
**	routines ev_aq_* manipulate this array.
**
**	This array is used for several purposed.  One is to provide a
**	"directory" to read.  Since user's must be able to seek to a
**	particular directory entry and read from there, we must have
**	some way of consistently defining where we are in the "/events"
**	directory.  We can't run down a linked list of queues both for
**	performance reasons and because this could give inconsistent
**	results (like returning the same entry twice of an earlier
**	entry was deleted between successive reads).
**
**	Another use for this array is to maintain something like inode
**	numbers which we can use to return for the va_nodeid (inode
**	number) member of the vattr_t structure.  The macros
**	ev_inbrtoqp and ev_qptoinbr are used to translate back and
**	forth between a pointer to a queue and an inumber.  These
**	macros use the index into the ev_actqp array.
**
**	Yet another use of the ev_actqp array is to keep track of
**	generation numbers.  This is needed for NFS.  Because it doesn't
**	keep any state, an inode number can be reused behind its back.
**	The generation number is used to detect that this has happened.
*/

typedef struct evactq {
	evqueue_t	*eaq_qp;	/* Ptr to the queue or 	*/
					/* NULL if not queue	*/
					/* is allocated for 	*/
					/* this entry.		*/
	long		eaq_gen;	/* The generation 	*/
					/* number for this slot.*/
} evactq_t;

/*			The evfid_t Structure
**			=====================
**
**	This structure describes or "file identifier".  It is used to
**	keep track of generation numbers.  This is needed for dumb old
**	stateless NFS which never knows what is going on.
**
**	This structure must map on top of the fid_t structure defined
**	in sys/vfs.h.  A limit on the size of this structure is also
**	defined there.
*/

typedef struct evfid {
	ushort		efid_len;	/* Length of the rest	*/
					/* of this structure	*/
					/* not including this	*/
					/* member.		*/
	evactq_t	*efid_aqp;	/* Ptr to the entry in	*/
					/* the ev_actqp array	*/
					/* for the file (queue).*/
	long		efid_gen;	/* The saved generation	*/
					/* number of a file.	*/
} evfid_t;

/*			Memory Manager Interface
**			========================
**
**	The following definitions are for the different memory types
**	which the memory manager in evmmgt.c must handle.  These
**	symbols are used as the first argument to ev_mem_alloc and
**	ev_mem_free.
**
**	Note that enumeration members are guaranteed to be allocated
**	consecutive values starting at zero unless specific values are
**	assigned.  The code relies on this fact.
*/

typedef enum evmt {

	EV_MT_NONE,	/* No data required indicator.		*/
	EV_MT_EVQ,	/* An evqueue_t structure.		*/
	EV_MT_KEV,	/* A evkev_t structure.			*/
	EV_MT_EXREF,	/* An evexref_t structure.		*/
	EV_MT_EXPR,	/* An evexpr_t structure.		*/
	EV_MT_TERM,	/* An evterm_t structure.		*/
	EV_MT_SEXPR,	/* An evsexpr_t structure.		*/
	EV_MT_STERM,	/* An evsterm_t structure.		*/
	EV_MT_TID,	/* An evtid_t structure.		*/
	EV_MT_RETRY,	/* An evretry_t structure.		*/
	EV_MT_EXITR,	/* An evexitr_t structure.		*/
	EV_MT_SIGR,	/* An array of evsigr_t structure.	*/
	EV_MT_PD,	/* An evpd_t structure.			*/
	EV_MT_FID,	/* An evfid_t structure.		*/
	EV_MT_EXITD,	/* An evd_exit_t structure.		*/
	EV_MT_STREAMD,	/* An evd_stream_t structure.		*/
	EV_MT_DIRENT,	/* An events dirent_t structure.	*/
	EV_MT_DATA,	/* Space for event type dependent data	*/
			/* and other miscellaneous uses.	*/

	EV_MT_NBR	/* The number of different memory types	*/
			/* we handle.  This member must be the	*/
			/* last one in the enumeration.  Add	*/
			/* new types before this one.		*/
} evmt_t;

#define	EV_MT_NMSZ	16	/* Size for the emmi_name field	*/
				/* below.  Should be large 	*/
				/* for the largest name plus a	*/
				/* terminating null byte.	*/

/*			The evmminfo_t Structure
**			========================
**
**	This structure is used by the memory management routines in the
**	file ev_mmgt.c.  No other part of the events VFS should
**	reference this structure.  The structure contains data about
**	one of the data items which the memory manager allocates.  An
**	array of these items, evmminfo, is indexed by the item codes
**	EV_MT_XXX defined above.
*/

typedef struct evmminfo {
	ushort		emmi_size;	/* Size of the item.	*/
	ushort		emmi_wanted :1;	/* Set if one or more	*/
					/* processes are 	*/
					/* waiting to allocate	*/
					/* one of these items	*/
					/* because the number 	*/
					/* allocated reached 	*/
					/* the limit.		*/
	int		emmi_nalloced;	/* The nbr of items 	*/
					/* allocated.		*/
	int		emmi_maxalloc;	/* The maximum nbr of	*/
					/* items to allocate.	*/
					/* This member is	*/
					/* initialized from the	*/
					/* evcinfo table 	*/
					/* defined in our 	*/
					/* master file.		*/
	char		*emmi_firstp;	/* Ptr to start of the	*/
					/* allocated area.  	*/
					/* Used only for	*/
					/* debugging.		*/
	char		*emmi_lastp;	/* Ptr to next byte	*/
					/* beyond end of the	*/
					/* allocated area.	*/
					/* Used only for 	*/
					/* debugging.		*/
	char		*emmi_freep;	/* Ptr to head of free	*/
					/* list of structures.	*/

	char		emmi_name[EV_MT_NMSZ];
					/* Name to be used in	*/
					/* messages about this	*/
					/* structure.		*/
} evmminfo_t;

/*			The evdr_t Structure
**			====================
**
**	This structure is used by drivers and streams modules which
**	wish to post events.  A pointer to one of these structures is
**	an argument to the ev_dr_post function in ev_sysint.c.  The
**	driver interface is described on the evdri(7) manual page.
*/

typedef struct evdr {
	long		evdr_flags;	/* Same as ev_flags in	*/
					/* the event_t 		*/
					/* structure.		*/
	long		evdr_eid;	/* Same as ev_eid in	*/
					/* the event_t 		*/
					/* structure.		*/
	long		evdr_pri;	/* Same as ev_pri in	*/
					/* the event_t 		*/
					/* structure.		*/
	hostid_t	evdr_hostid;	/* Same as ev_hostid in	*/
					/* the event_t 		*/
					/* structure.		*/
	pid_t		evdr_pid;	/* Same as ev_pid in	*/
					/* the event_t 		*/
					/* structure.		*/
	uid_t		evdr_uid;	/* Same as ev_uid in	*/
					/* the event_t 		*/
					/* structure.		*/
	size_t		evdr_datasize;	/* Same as ev_datasize	*/
					/* in the event_t	*/
					/* structure.		*/
	char		*evdr_data;	/* Same as ev_data in	*/
					/* the event_t 		*/
					/* structure.		*/
} evdr_t;

/*			The evcntxt_t Structure
**			=======================
**
**	The following structure is an event trap handler context.
**	It is the structure which is built on the stack when calling
**	a trap handler.  A pointer to this structure is the last
**	argument to the user's handler and is the argument a user must
**	supply to the EC_TRAPRET evcntl command to return to the 
**	interrupted context.
*/

typedef struct evcntxt {
	event_t		*ectxt_elp;	/* Ptr to list of 	*/
					/* events from trap.	*/
	int		ectxt_els;	/* Nbr of events in the	*/
					/* list extxt_elp.	*/
	long		ectxt_tid;	/* The trap identifier	*/
					/* for the expression	*/
					/* which was satisfied.	*/
	struct evcntxt	*ectxt_cntxtp;	/* Pointer to this 	*/
					/* context.		*/
	uint		ectxt_lvl;	/* The nesting level of	*/
					/* this handler.  This	*/
					/* is the level of the	*/
					/* handler called with	*/
					/* a ptr to this 	*/
					/* structure as its 	*/
					/* argument.		*/

	void		(*ectxt_ufunc)();
					/* Ptr to the user's	*/
					/* trap handler 	*/
					/* function.		*/
} evcntxt_t;

/*			Global Data
**			===========
**
**	The following data is defined in the events master file.
*/

#ifdef	_KERNEL

extern evcinfo_t	evcinfo;	/* Event configuration 	*/
					/* information.		*/


/*	The following data is in evfilenames.c
*/

extern evlisthd_t	*ev_fnhtp;	/* Ptr to the hash 	*/
					/* table for file names.*/

/*	The following data is defined in evqueues.c.
*/

extern evactq_t		*ev_actqp;	/* Ptr to an array of	*/
					/* ptrs to active	*/
					/* queues.		*/

/*	The following data is defined in evtids.c.
*/

extern evlisthd_t	*ev_tidhtp;	/* Ptr to the hash 	*/
					/* table for the trap	*/
					/* identifiers.		*/

/*	The following data is defined in evvfsops.c.
*/

extern evdir_t		ev_dotdirs[];	/* The directory 	*/
					/* entries for "." and	*/
					/* "..".		*/
extern vnode_t		*ev_rootvp;	/* Ptr to the vnode 	*/
					/* for the root of the	*/
					/* events VFS.		*/
extern evqueue_t	*ev_rootqp;	/* Ptr to the queue for	*/
					/* the root of the	*/
					/* events VFS.		*/
extern dev_t		ev_dev;		/* Our device code.	*/
extern short		ev_fstype;	/* Our file system type.*/
extern off_t		ev_dirsize;	/* Total size of our 	*/
					/* directory.		*/
extern unchar		ev_mounted;	/* Flag set if our VFS	*/
					/* is mounted.		*/
extern unchar		ev_init_ok;	/* Flag set if events	*/
					/* vfs initialization 	*/
					/* is completed		*/
					/* successfully.	*/

/*			Global Data (Continued)
**			=======================
**
**	The following is kernel (non-events) data which we reference.
*/

extern int		mau_present;	/* Set if a mau is	*/
					/* present on the 	*/
					/* system.		*/

/*			Function Declarations
**			=====================
**
**	The following are all the functions in the events files.
**
**	The following functions are in evcntl.c.
*/

extern err_t		ev_cntl_evsys();
extern err_t		ev_evcntl();
extern err_t		ev_cntl_traphold();
extern err_t		ev_cntl_trapset();
extern err_t		ev_cntl_traprelse();
extern err_t		ev_cntl_trappause();
extern err_t		ev_cntl_trapret();
extern err_t		ev_cntl_trapend();
extern err_t		ev_cntl_altstack();
extern err_t		ev_cntl_getprinfo();
extern err_t		ev_cntl_setprinfo();
extern err_t		ev_cntl_getcfginfo();
extern err_t		ev_cntl_getmeminfo();

/*	The following functions are in evexit.c.
*/

extern err_t		ev_exit_evsys();
extern err_t		ev_evexit();
extern err_t		ev_exit_add();
extern err_t		ev_exit_cancel();
extern void		ev_exit_post();
extern void		ev_exit_free();

/*	These functions are in evexprs.c.
*/

extern err_t		ev_expr_bld();
extern err_t		ev_expr_bldholdlist();
extern err_t		ev_expr_satisfy();
extern err_t		ev_expr_satisfymore();
extern err_t		ev_term_check();
extern err_t		ev_term_satisfy();
extern err_t		ev_expr_dup();
extern err_t		ev_term_dup();
extern void		ev_expr_free();
extern void		ev_term_free();
extern err_t		ev_expr_list();
extern void		ev_expr_unlist();
extern err_t		ev_expr_tolist();
extern void		ev_expr_fromlist();

/*			Functions Declarations (Continued)
**			==================================
**
**	The following functions are in evfilenames.c.
*/

extern err_t		ev_fn_lookup();
extern void		ev_fn_insert();
extern void		ev_fn_delete();
extern evqueue_t	*ev_fn_hash();

/*	The following functions are in evkevs.c
*/

extern err_t		ev_kev_post();
extern void		ev_kev_free();
extern void		ev_kev_enq();
extern void		ev_kev_deq();

/*	These functions are in evmmgt.c.
*/

extern err_t		ev_mem_init();
extern err_t		ev_mem_alloc();
extern void		ev_mem_free();
extern void		ev_mem_rtrninfo();
extern void		ev_mem_statvfs();

/*	The following functions are in evpoll.c.
*/

extern err_t		ev_poll_evsys();
extern err_t		ev_evpoll();
extern void		ev_poll_timeout();
extern err_t		ev_poll_quick();
extern err_t		ev_poll_dupexpr();
extern err_t		ev_poll_bldsexpr();
extern err_t		ev_pollmore_evsys();
extern err_t		ev_evpollmore();

/*	These functions are in evpost.c.
*/

extern err_t		ev_post_evsys();
extern err_t		ev_evpost();
extern err_t		ev_post_event();
extern err_t		ev_post_retry();
extern err_t		ev_post_getpfd();
extern err_t		ev_post_getmem();
extern err_t		ev_post_getshm();
extern err_t		ev_post_err();

/*			Functions Declarations (Continued)
**			==================================
**
**	The following functions are in evqcntl.c.
*/

extern err_t		ev_qcntl_evsys();
extern err_t		ev_evqcntl();
extern err_t		ev_qcntl_getcm();
extern err_t		ev_qcntl_setcm();
extern err_t		ev_qcntl_getqinfo();
extern err_t		ev_qcntl_setqinfo();
extern err_t		ev_qcntl_getevinfo();

/*	The following functions are in evqueues.c.
*/

extern void		ev_aq_insert();
extern void		ev_aq_delete();
extern err_t		ev_qaccess();
extern void		ev_qtrunc();

/*	The following functions are in evsexprs.c.
*/

extern void		ev_sexpr_toproc();
extern err_t		ev_sexpr_dupstk();
extern evsexpr_t	*ev_sexpr_dup();
extern err_t		ev_sexpr_tousr();
extern err_t		ev_sterm_tousr();
extern err_t		ev_sterm_memtousr();
extern err_t		ev_sterm_shmtousr();
extern void		ev_sterm_quickdtousr();
extern err_t		ev_sterm_pfdtousr();
extern void		ev_sexpr_hipri();
extern evsexpr_t	*ev_sexpr_findpending();
extern evsexpr_t	*ev_sexpr_getpending();
extern void		ev_sexpr_push();
extern evsexpr_t	*ev_sexpr_pop();
extern void		ev_sexpr_unsatisfy();
extern void		ev_sexpr_free();
extern void		ev_sterm_free();

/*			Functions Declarations (Continued)
**			==================================
**
**	The following functions are in evsig.c.
*/

extern err_t		ev_sig_evsys();
extern err_t		ev_evsig();
extern void		ev_sig_initinfo();
extern void		ev_sig_saveinfo();
extern err_t		ev_sig_rtrninfo();
extern err_t		ev_sig_dup();
extern void		ev_sig_del();

/*	The following functions are in evsubrs.c.
*/

extern void		ev_proc_check();
extern struct proc	*ev_checkq();
extern void		ev_proc_clean();
extern err_t		ev_trapret();
extern void		ev_untrap();
extern caddr_t		ev_trap_getstk();
extern err_t		ev_eqdtovp();
extern err_t		ev_read_dir();
extern err_t		ev_write_getdata();
extern void		ev_nonfatalerr();

/*	These functions are in evsysint.c.
*/

extern err_t		ev_evsys();
extern int		ev_istrap();
extern int		ev_intr_restart();
extern void		ev_traptousr();
extern err_t		ev_evtrapret();
extern void		ev_exec();
extern void		ev_exit();
extern err_t		ev_fork();
extern void		ev_gotsig();
extern void		ev_signal();
extern void		ev_newpri();
extern err_t		ev_stream_post();
extern err_t		ev_dr_post();

/*			Functions Declarations (Continued)
**			==================================
**
**	The following functions are in evtids.c.
*/

extern err_t		ev_tid_init();
extern err_t		ev_tid_dupproclist();
extern err_t		ev_tid_dupexprlist();
extern void		ev_tid_clean();
extern evtid_t		*ev_tid_add();
extern void		ev_tid_rem();
extern evtid_t		*ev_tid_find();
extern void		ev_tid_hold();
extern void		ev_tid_relse();
extern evtid_t		*ev_tid_hash();

/*	The following functions are in evtrap.c.
*/

extern err_t		ev_trap_evsys();
extern err_t		ev_evtrap();
extern err_t		ev_trapcan_evsys();
extern err_t		ev_evtrapcancel();
extern void		ev_trapcancel();

/*	The following are all of the functions in evvfsops.c.  They
**	must be here because they are forward referenced to define
**	the ev_vfsops array in that file.
*/

extern void		ev_init();
extern err_t		ev_mount();
extern err_t		ev_unmount();
extern err_t		ev_root();
extern err_t		ev_statvfs();
extern err_t		ev_sync();
extern err_t		ev_vget();
extern err_t		ev_mountroot();
extern err_t		ev_swapvp();

/*			Functions Declarations (Continued)
**			==================================
**
**	The following are all of the functions in evvnodeops.c.  They
**	must be here because they are forward referenced to define the
**	ev_vnodeops array in that file.
*/

extern err_t		ev_open();
extern err_t		ev_close();
extern err_t		ev_read();
extern err_t		ev_write();
extern err_t		ev_ioctl();
extern err_t		ev_setfl();
extern err_t		ev_getattr();
extern err_t		ev_setattr();
extern err_t		ev_access();
extern err_t		ev_lookup();
extern err_t		ev_create();
extern err_t		ev_remove();
extern err_t		ev_link();
extern err_t		ev_rename();
extern err_t		ev_mkdir();
extern err_t		ev_rmdir();
extern err_t		ev_readdir();
extern err_t		ev_symlink();
extern err_t		ev_readlink();
extern err_t		ev_fsync();
extern void		ev_inactive();
extern err_t		ev_fid();
extern void		ev_rwlock();
extern void		ev_rwunlock();
extern err_t		ev_seek();
extern int		ev_cmp();
extern err_t		ev_frlock();
extern err_t		ev_space();
extern err_t		ev_realvp();

/*			Function Declarations (Continued)
**			=================================
**
**	These are all of the kernel (non-events) functions which we
**	use.
*/

extern struct seg	*as_segat();	/* Find the segment	*/
					/* containing a 	*/
					/* particular virtual	*/
					/* address for a	*/
					/* particular process.	*/
extern struct seg	*amtoseg();	/* Find the segment 	*/
					/* which refers to a	*/
					/* particular anon_map 	*/
					/* for a process.	*/
extern struct anon_map	*as_shmlookup();/* Find the anon_map 	*/
					/* for the shared memory*/
					/* segment containing	*/
					/* a particular virtual	*/
					/* address in this 	*/
					/* address space.	*/
extern int		ttimeout();	/* Call a kernel	*/
					/* function after a	*/
					/* specified time	*/
					/* interval in ticks.	*/
extern int		untimeout();	/* Cancel a timer set	*/
					/* with the timeout	*/
					/* function.		*/
extern int		reglock();	/* Lock a region.	*/
extern int		regrele();	/* Unlock a region.	*/
extern void		freereg();	/* Free a region.	*/
extern int		getudev();	/* Get an unused major	*/
					/* device code.		*/
extern int		fixuserpsw();	/* Fix a psw to be	*/
					/* valid for running in	*/
					/* user mode.		*/
#endif	/* _KERNEL	*/

#endif	/* _SYS_EVSYS_H */
   0707010000597a000081240000000200000002000000012719347c0000231c000000230000000c00000000000000000000001c00000000usr/include/sys/evsyscall.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EVSYSCALL_H
#define _SYS_EVSYSCALL_H

#ident	"@(#)/usr/include/sys/evsyscall.h.sl 1.1 4.0 10/15/90 48888 AT&T-SF"
/*			File Contents
**			=============
**
**	This file contains the data concerned with the evsys system
**	call.  This system call is the interface between user mode and
**	the kernel.  The only other events system call is evtrapret for
**	returning from event trap handlers.  Of course, since events
**	are implemented as a VFS, lots of other system calls (open,
**	close, etc.) also work on event queues.  Users are not expected
**	to do invoked the evsys system call directly but rather to
**	invoke the library routines such as evpost, evpoll, etc. which,
**	in turn, do the system call.  For this reason, this header file
**	is not intended to be included in user's programs.
*/


/*			Required Header Files
**			=====================
**
**	The following header files must be includes before including
**	this file.
**
**		REQUIRES	sys/types.h
**		REQUIRES	sys/signal.h
**		REQUIRES	sys/evecb.h
**		REQUIRES	sys/hrtcntl.h
**		REQUIRES	sys/priocntl.h
**		REQUIRES	sys/procset.h
**		REQUIRES	sys/events.h
*/

/*			The evsys System Call
**			=====================
**
**	The evsys system call is used to obtain a direct entry into
**	the events code without going through the VFS interface.  This
**	is necessary in some cases because no file descriptor is
**	required with certain events function calls (e.g., evcntl).
**	Without a file descriptor referring to an event queue (file),
**	it is impossible to go through the VFS mechanism.  We always
**	use evsys rather than an existing system call such as ioctl
**	so that we always get into the events code, even for errors.
**	This enables us to give more specific error messages for some
**	cases.  In addition, extension of events to work over RFS will
**	require that the ioctl interface not be used.
**	The following is the list of functions which are implemented
**	through the evsys interface.  The comment with each command
**	indicates the value of the variable third argument to the
**	function.  This argument appears in the evsa_arg member of the
**	evsys_args_t structure defined at the end of this file.
*/

typedef enum evscmds {

	EVS_EVPOST,	/* An evpost function.			*/
			/* evsa_arg = (evsys_post_t *).		*/
	EVS_EVPOLL,	/* An evpoll function.			*/
			/* evsa_arg = (evsys_poll_t *).		*/
	EVS_EVPOLLMORE,	/* An evpollmore function.		*/
			/* evsa_arg = (evsys_pollmore_t *).	*/
	EVS_EVTRAP,	/* An evtrap function.			*/
			/* evsa_arg = (evsys_trap_t *).		*/
	EVS_EVTRAPCAN,	/* An evtrapcancel function.		*/
			/* evsa_arg = (evsys_trapcancel_t *).	*/
	EVS_EVCNTL,	/* An evcntl function.			*/
			/* evsa_arg = (evsys_cntl_t *).		*/
	EVS_EVQCNTL,	/* An evqcntl function.			*/
			/* evsa_arg = (evsys_qcntl_t *).	*/
	EVS_EVEXIT,	/* An evexit with eqid = EQ_NOQUEUE.	*/
			/* evsa_arg = (evsys_exit_t *).		*/
	EVS_EVSIG	/* An evsig with eqid = EQ_NOQUEUE.	*/
			/* evsa_arg = (evsys_sig_t *).		*/
} evscmds_t;

/*			The evsys System Call (Continued)
**			=================================
**
**	The following structure describes the arguments to the evsys
**	system call.
**
**	The field evsa_ver below should really be type evver_t.
**	However, this type is a short and the following structure
**	describes arguments to a system call which, like all function
**	arguments, are passed as int's.
*/

typedef struct evsys_args {
	evscmds_t	evsa_cmd;	/* One of the EVS_XXXX	*/
					/* commands listed	*/
					/* above.		*/
	int		evsa_ver;	/* A version number	*/
					/* like EV_VERSION.	*/
	_VOID		*evsa_arg;	/* The actual argument.	*/
					/* A pointer to one of	*/
					/* the structures	*/
					/* defined below.	*/
} evsys_args_t;

/*			The evpost Interface
**			====================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for an evpost function.
*/

typedef struct evsys_post {
	event_t	*evs_post_elp;		/* Pointer to array of	*/
					/* event structures to	*/
					/* post.		*/
	int	evs_post_els;		/* Nbr of structures in	*/
					/* list.		*/
	int	evs_post_flags;		/* Flags passed with	*/
					/* evpost.		*/
} evsys_post_t;

/*			The evpoll Interface
**			====================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for an evpoll function.
*/

typedef struct evsys_poll {
	evpollcmds_t	evs_poll_cmd;	/* The poll cmd.  One	*/
					/* of the EC_XXXX 	*/
					/* commands defined in	*/
					/* events.h.		*/
	event_t		*evs_poll_elp;	/* Ptr to array of	*/
					/* events to poll for.	*/
	int		evs_poll_els;	/* Nbr of events in the	*/
					/* array.		*/

	hrtime_t	*evs_poll_top;	/* Ptr to the hrtime_t	*/
					/* structure giving the	*/
					/* timeout for the poll	*/
					/* or NULL (immediate	*/
					/* return) or -1 (wait	*/
					/* forever).		*/
} evsys_poll_t;

/*			The evpollmore Interface
**			========================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for the evpollmore function.
*/

typedef struct evsys_pollmore {
	event_t		*evs_pollmore_elp;
					/* Ptr to array of	*/
					/* events to poll for.	*/

	int		evs_pollmore_els;
					/* Nbr of events in the	*/
					/* array.		*/
} evsys_pollmore_t;

/*			The evtrap Interface
**			====================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for the evtrap function.
*/

typedef struct evsys_trap {
	evpollcmds_t	evs_trap_cmd;	/* The trap cmd.  One	*/
					/* of the EC_XXX 	*/
					/* commands defined in	*/
					/* events.h		*/
	event_t		*evs_trap_elp;	/* Ptr to array of	*/
					/* events to trap for.	*/
	int		evs_trap_els;	/* Nbr of events in the	*/
					/* array.		*/
	long		evs_trap_tid;	/* The trap identifier.	*/

	void		(*evs_trap_lfunc)();
					/* The library routine	*/
					/* to call a user's 	*/
					/* trap handler.	*/

	void		(*evs_trap_ufunc)();
					/* The user's trap	*/
					/* handler to call.	*/

	evta_t	*evs_trap_tap;	/* The optional trap	*/
					/* argument.		*/
} evsys_trap_t;

/*			The evtrapcancel Interface
**			==========================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for the evtrapcancel function.
*/

typedef struct evsys_trapcan {
	long		*evs_trapcan_tidp;
					/* Ptr to the array of	*/
					/* trap identifiers	*/
					/* which are to be	*/
					/* cancelled.		*/
	int		evs_trapcan_tids;
					/* Size of the array	*/
					/* evs_trapcan_tidp.	*/
} evsys_trapcan_t;

/*			The evcntl Interface
**			====================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for the evcntl function.
*/

typedef struct evsys_cntl {
	evcntlcmds_t	evs_cntl_cmd;	/* The command argument.*/
	long		evs_cntl_arg1;	/* First argument.	*/
	long		evs_cntl_arg2;	/* Second argument.	*/
} evsys_cntl_t;





/*			The evqcntl Interface
**			=====================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for the evqcntl function.
*/

typedef struct evsys_qcntl {
	int		evs_qcntl_eqd;	/* The event queue	*/
					/* descriptor (file	*/
					/* descriptor) for the	*/
					/* queue to access.	*/
	evqcntlcmds_t	evs_qcntl_cmd;	/* The value of "cmd"	*/
					/* from the evqcntl	*/
					/* call.  Will be one	*/
					/* of EC_XXXX from	*/
					/* events.h.		*/
	long		evs_qcntl_arg;	/* The value of "arg"	*/
					/* from the evqcntl	*/
					/* call.		*/
} evsys_qcntl_t;

/*			The evexit Interface
**			====================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for the evexit function.
*/

typedef struct evsys_exit {
	procset_t	*evs_exit_psp;	/* Ptr to the process	*/
					/* set structure which	*/
					/* defines the set of	*/
					/* processes which are	*/
					/* to be operated on.	*/
	hostid_t	evs_exit_hostid;/* The id of the host	*/
					/* system to which the	*/
					/* process set applies.	*/

	ecb_t	*evs_exit_ecbp;	/* Ptr to the ecb for	*/
					/* the event to be	*/
					/* posted.		*/
} evsys_exit_t;





/*			The evsig Interface
**			===================
**
**	The following structure is pointed to by "arg" on the evsys
**	system call for the evsig function.
*/

typedef struct evsys_sig {
	sigset_t	*evs_sig_setp;	/* Ptr to the set of	*/
					/* signals to which 	*/
					/* this call applies.	*/

	ecb_t	*evs_sig_ecbp;		/* Ptr to the ecb for	*/
					/* the event to be 	*/
					/* posted.		*/
	evsiginfo_t	*evs_sig_silp;	/* Ptr to list of	*/
					/* structures to use 	*/
					/* for returning the	*/
					/* old status of the	*/
					/* signals.		*/
	int		evs_sig_sils;	/* Nbr of elements in	*/
					/* the evs_sig_silp	*/
					/* list.		*/
} evsys_sig_t;

#endif	/* _SYS_EVSYSCALL_H */
0707010000597b000081240000000200000002000000012719347c00000d8a000000230000000c00000000000000000000001700000000usr/include/sys/exec.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_EXEC_H
#define _SYS_EXEC_H

#ident	"@(#)/usr/include/sys/exec.h.sl 1.1 4.0 10/15/90 6980 AT&T-SF"

#include <sys/types.h>
#include <sys/vnode.h>
#include <sys/cred.h>
#include <sys/resource.h>
#include <sys/proc.h>


#define getexmag(x)   (x[1] << 8) + x[0]


/*
 * User argument structure for stack image management
 */

struct uarg {
	caddr_t estkstart;
	int estksize;
	u_int estkhflag;
	int stringsize;
	int argsize;
	int envsize;
	int argc;
	int envc;
	int prefixc;	/* intp argument prefix invisible to psargs */
	int prefixsize;
	caddr_t *prefixp;
	int auxsize;
	addr_t stacklow;
	caddr_t stackend;
	char **argp;
	char **envp;
	char *fname;
	int traceinval;
	caddr_t auxaddr;
	caddr_t argaddr;
	int flags;
};

typedef struct execenv {
	caddr_t ex_brkbase;
	short   ex_magic;
	vnode_t *ex_vp;
} execenv_t; 

/* flags definition */

#define   RINTP   0x1 /* A run-time interpreter is active */
#define   EMULA   0x2 /* Invoking emulator */


struct execsw {
	short *exec_magic;
	int   (*exec_func)();
	int   (*exec_core)();
};

extern int nexectype;		/* number of elements in execsw */
extern struct execsw execsw[];

typedef struct exhdmap {
	struct exhdmap	*nextmap;
	off_t		curbase;
	off_t		curoff;
	int		cureoff;
	caddr_t		bndrycasep;
	long		bndrycasesz;
	struct fbuf	*fbufp;
	int		keepcnt;
} exhdmap_t;

typedef struct exhda {
	vnode_t	*vp;
	u_long	vnsize;
	exhdmap_t	*maplist;
	int state;
	int nomap;
} exhda_t;

#define EXHDA_HADERROR	1

#if defined(__STDC__)

extern int exhd_getmap(exhda_t *, off_t, int, int, char *);
extern void exhd_release(exhda_t *);
extern int remove_proc(struct uarg *);
extern int execmap(vnode_t *, caddr_t, size_t, size_t, off_t, int);
extern void setexecenv(struct execenv *);
extern int setregs(struct uarg *);
extern int core_seg(proc_t *, vnode_t *, off_t, caddr_t, size_t, rlim_t, cred_t
*);
extern int gexec(vnode_t **, struct uarg *, int, long *);
extern caddr_t execstk_addr(int, u_int *);
extern int execpermissions(struct vnode *, struct vattr *, exhda_t *, struct uarg *);

#else

extern int exhd_getmap();
extern void exechd_release();
extern int execmap();
extern int remove_proc();
extern void setexecenv();
extern int setregs();
extern int core_seg();
extern int gexec();
extern caddr_t execstk_addr();
extern int execpermissions();

#endif	/* __STDC__ */

/* flags for exhd_getmap(): */
#define	EXHD_NOALIGN	0
#define EXHD_4BALIGN	1	/* align on 4 byte boundary */
#define EXHD_KEEPMAP	2	/* keep for parallel use with other maps */
				/* if not set, map will be freed
				 * automatically on next getmap
				 */
#define EXHD_COPY	4	/* Copy to the provided address */

/* the following macro is a machine dependent encapsulation of
 * postfix processing to hide the stack direction from elf.c
 * thereby making the elf.c code machine independent.
 */
#ifdef i386
#define execpoststack(ARGS, ARRAYADDR, BYTESIZE)  \
	(copyout((caddr_t)(ARRAYADDR), (ARGS)->auxaddr, BYTESIZE) ? EFAULT : \
			(((ARGS)->auxaddr += (BYTESIZE)), 0))
#else
#define execpoststack(ARGS, ARRAYADDR, BYTESIZE)  \
	(copyout((caddr_t)(ARRAYADDR), (ARGS)->stackend, BYTESIZE) ? EFAULT \
		: (((ARGS)->stackend += (BYTESIZE)), 0))
#endif

#endif /* _SYS_EXEC_H */
  0707010000597c000081240000000200000002000000012719347c00000578000000230000000c00000000000000000000001800000000usr/include/sys/fault.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FAULT_H
#define _SYS_FAULT_H

#ident	"@(#)/usr/include/sys/fault.h.sl 1.1 4.0 10/15/90 46671 AT&T-SF"

/*
 * Fault numbers, analagous to signals.  These correspond to
 * hardware faults.  Setting the appropriate flags in a process's
 * set of traced faults via /proc causes the process to stop each
 * time one of the designated faults occurs so that a debugger can
 * take action.  See proc(4) for details.
 */

	/* fault enumeration must begin with 1 */
#define	FLTILL		1	/* Illegal instruction */
#define	FLTPRIV		2	/* Privileged instruction */
#define	FLTBPT		3	/* Breakpoint instruction */
#define	FLTTRACE	4	/* Trace trap (single-step) */
#define	FLTACCESS	5	/* Memory access (e.g., alignment) */
#define	FLTBOUNDS	6	/* Memory bounds (invalid address) */
#define	FLTIOVF		7	/* Integer overflow */
#define	FLTIZDIV	8	/* Integer zero divide */
#define	FLTFPE		9	/* Floating-point exception */
#define	FLTSTACK	10	/* Irrecoverable stack fault */
#define	FLTPAGE		11	/* Recoverable page fault (no associated sig) */

typedef struct {		/* fault set type */
	unsigned long	word[4];
} fltset_t;

#endif	/* _SYS_FAULT_H */
0707010000597d000081240000000200000002000000012719347c00000233000000230000000c00000000000000000000001700000000usr/include/sys/fblk.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FBLK_H
#define _SYS_FBLK_H

#ident	"@(#)/usr/include/sys/fblk.h.sl 1.1 4.0 10/15/90 27928 AT&T-SF"
/* WARNING!!!  This stub will be removed for release 4.0. Please 
*  be advised to change any source code using this header file */
#include <sys/fs/s5fblk.h>

#endif	/* _SYS_FBLK_H */
 0707010000597e000081240000000200000002000000012719347c0000044f000000230000000c00000000000000000000001700000000usr/include/sys/fbuf.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FBUF_H
#define _SYS_FBUF_H

#ident	"@(#)/usr/include/sys/fbuf.h.sl 1.1 4.0 10/15/90 2676 AT&T-SF"

/*
 * A struct fbuf is used to get a mapping to part of a file using the
 * segkmap facilities.  After you get a mapping, you can fbrelse() it
 * (giving a seg code to pass back to segmap_release), you can fbwrite()
 * it (causes a synchronous write back using the file mapping information),
 * or you can fbiwrite it (causing indirect synchronous write back to
 * the block number given without using the file mapping information).
 */

struct fbuf {
	addr_t	fb_addr;
	u_int	fb_count;
};

extern int fbread(/* vp, off, len, rw, fbpp */);
extern void fbzero(/* vp, off, len, fbpp */);
extern int fbwrite(/* fbp */);
extern int fbiwrite(/* fbp, vp, bn, bsize */);
extern void fbrelse(/* fbp, rw */);

#endif	/* _SYS_FBUF_H */
 0707010000597f000081240000000200000002000000012719347c0000135b000000230000000c00000000000000000000001800000000usr/include/sys/fcntl.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FCNTL_H
#define _SYS_FCNTL_H

#ident	"@(#)/usr/include/sys/fcntl.h.sl 1.1 4.0 10/15/90 48843 AT&T-SF"
#ifndef _SYS_TYPES_H
#include <sys/types.h>
#endif

/*
 * Flag values accessible to open(2) and fcntl(2)
 * (the first three can only be set by open).
 */
#define	O_RDONLY	0
#define	O_WRONLY	1
#define	O_RDWR		2
#if !defined(_POSIX_SOURCE)
#define	O_NDELAY	0x04	/* non-blocking I/O */
#endif /* !defined(_POSIX_SOURCE) */
#define	O_APPEND	0x08	/* append (writes guaranteed at the end) */
#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE)
#define	O_SYNC		0x10	/* synchronous write option */
#endif /* !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE */

/*
 * The following flag is added for asynchronous raw disk io feature 
 */
#define O_RAIOSIG	0x20	/* cause a signal for a completed RAIO request */ 

#define	O_NONBLOCK	0x80	/* non-blocking I/O (POSIX) */

/*
 * Flag values accessible only to open(2).
 */
#define	O_CREAT		0x100	/* open with file create (uses third open arg) */
#define	O_TRUNC		0x200	/* open with truncation */
#define	O_EXCL		0x400	/* exclusive open */
#define	O_NOCTTY	0x800	/* don't allocate controlling tty (POSIX) */

/* fcntl(2) requests */
#define	F_DUPFD		0	/* Duplicate fildes */
#define	F_GETFD		1	/* Get fildes flags */
#define	F_SETFD		2	/* Set fildes flags */
#define	F_GETFL		3	/* Get file flags */
#define	F_SETFL		4	/* Set file flags */

/*
 * Applications that read /dev/mem must be built like the kernel.  A
 * new symbol "_KMEMUSER" is defined for this purpose.
 */
#if defined(_KERNEL) || defined(_KMEMUSER)
#define	F_GETLK		14	/* Get file lock */
#define	F_O_GETLK	5	/* SVR3 Get file lock */

#else	/* user definition */

#if defined(_STYPES)	/* SVR3 definition */
#define	F_GETLK		5	/* Get file lock */
#else
#define	F_GETLK		14	/* Get file lock */
#endif	/* defined(_STYPES) */

#endif	/* defined(_KERNEL) */

#define	F_SETLK		6	/* Set file lock */
#define	F_SETLKW	7	/* Set file lock and wait */

#if !defined(_POSIX_SOURCE)
#define	F_CHKFL		8	/* Unused */

#define	F_ALLOCSP	10	/* Reserved */
#define	F_FREESP	11	/* Free file space */

#define F_RSETLK	20	/* Remote SETLK for NFS */
#define F_RGETLK	21	/* Remote GETLK for NFS */
#define F_RSETLKW	22	/* Remote SETLKW for NFS */

#define	F_GETOWN	23	/* Get owner (socket emulation) */
#define	F_SETOWN	24	/* Set owner (socket emulation) */
#endif /* !defined(_POSIX_SOURCE) */


#define F_CHSIZE    0x6000  /* XENIX chsize() system call */
#define F_RDCHK     0x6001  /* XENIX rdchk() system call */

/*
 * Fcntl(2) requests made from the XENIX locking(S) system call.  These fcntl()
 * requests are made only from the kernel.
 *
 * N.B.  The high nibble of the high byte is F_SETLK or F_SETLKW, and the low
 *       nibble of the high byte is F_UNLCK, F_WRLCK, or F_RDLCK.  However, *   no code actually relies on this.
 */

#define F_LK_UNLCK  0x6300  /* locking() LK_UNLCK request */
#define F_LK_LOCK   0x7200  /* locking() LK_LOCK request */
#define F_LK_NBLCK  0x6200  /* locking() LK_NBLCK request */
#define F_LK_RLCK   0x7100  /* locking() LK_RLCK request */
#define F_LK_NBRLCK 0x6100  /* locking() LK_NBRLCK request */

#define LK_CMDTYPE(x)   ((x >> 12) & 0x7) /* get high nibble of high byte */
#define LK_LCKTYPE(x)   ((x >> 8) & 0x7)  /* get low nibble of high byte */


/*
 * File segment locking set data type - information passed to system by user.
 */
#if defined(_KERNEL) || defined(_KMEMUSER)
	/* EFT definition */
typedef struct flock {
	short	l_type;
	short	l_whence;
	off_t	l_start;
	off_t	l_len;		/* len == 0 means until end of file */
        long	l_sysid;
        pid_t	l_pid;
	long	pad[4];		/* reserve area */
} flock_t;

typedef struct o_flock {
	short	l_type;
	short	l_whence;
	long	l_start;
	long	l_len;		/* len == 0 means until end of file */
        short   l_sysid;
        o_pid_t l_pid;
} o_flock_t;

#else		/* user level definition */

#if defined(_STYPES)
	/* SVR3 definition */
typedef struct flock {
	short	l_type;
	short	l_whence;
	off_t	l_start;
	off_t	l_len;		/* len == 0 means until end of file */
	short	l_sysid;
        o_pid_t	l_pid;
} flock_t;


#else

typedef struct flock {
	short	l_type;
	short	l_whence;
	off_t	l_start;
	off_t	l_len;		/* len == 0 means until end of file */
	long	l_sysid;
        pid_t	l_pid;
	long	pad[4];		/* reserve area */
} flock_t;

#endif	/* defined(_STYPES) */

#endif	/* defined(_KERNEL) */

/*
 * File segment locking types.
 */
#define	F_RDLCK	01	/* Read lock */
#define	F_WRLCK	02	/* Write lock */
#define	F_UNLCK	03	/* Remove lock(s) */

/*
 * POSIX constants 
 */

#define	O_ACCMODE	3	/* Mask for file access modes */
#define	FD_CLOEXEC	1	/* close on exec flag */

#endif	/* _SYS_FCNTL_H */
 07070100005980000081240000000200000002000000012719347c000020c3000000230000000c00000000000000000000001500000000usr/include/sys/fd.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FD_H
#define _SYS_FD_H

#ident	"@(#)/usr/include/sys/fd.h.sl 1.1 4.0 10/15/90 18780 AT&T-SF"

#define	FD0	0	/* major device number for floppy disk */

/*
 * the floppy disk minor device number is interpreted as follows:
 *     bits:
 *	 7  4 3 21 0
 * 	+----+-+--+-+
 * 	|fmt |s|pt|u|
 * 	+----+-+--+-+
 *     codes:
 *	u   - unit no. (0 or 1)
 *	pt  - partition no. (0 - 3)
 *	s   - single/double sided (1 = single)
 *	fmt - format code, no. of bytes per sector/ no. of sectors per trk.
 */

#define	PARTITION(x)	((getminor(x) & 0x06) >> 1)
#define UNIT(x)		(getminor(x) & 0x01)
#define	FRMT(x)		((getminor(x) & 0xf0) >> 4)
#define	SIDES(x)	((getminor(x) & 0x08) ? 1 : 2)

/*
 * Defines for controller access.
 */
#define	FDSTAT	0x3f4	/* I/O port addr of floppy controller status port */
#define	FDDATA	0x3f5	/* I/O port addr of floppy controller data port */

#define	FCBUSY	0x10	/* controller busy bit */
#define	IODIR	0x40	/* data reg I/O direction, 1 = read, 0 = write */
#define	IORDY	0x80	/* data register ready to xfer bit */

#define	FCRETRY	4000	/* this many ten microseconds equals 40ms. */

#define	CTIMOUT	0x02	/* Timed out waiting for IORDY in fdcmd */
#define	RTIMOUT	0x03	/* Timed out waiting for IORDY in fdresult*/
#define	NECERR	0x04	/* Controller wont go idle error flag */
#define	BADOPCODE	0x05	/* Invalid OPCODE */
#define	INB_ERR	0x06
#define	OUTB_ERR	0x07
#define	RESET_FAIL	0x08
#define	UNDEFINED	0x09

#define ONESIDE 0x08    /* indicates in minor dev that we want single sided */

#define NUMDRV  2           /* maximum number of drives supported */
#define NHDS    2           /* default number of heads */
#define NSECS   9           /* default number of sectors per track */
#define NCYLS   40          /* default number of cylinders */
#define SECSIZE 512         /* default sector size */
#define SECSHFT 9
#define SECMASK (SECSIZE-1)

#define FD          ('R'<<8)
#define FDSPARAM    (FD | 00)   /* set the drive paramaters */
#define FDGPARAM    (FD | 01)   /* get the drive paramaters */
#define FDFMTTRK    (FD | 02)   /* format a single track */

#define OPEN_EMAX   1       /* max number of retries during open processing */
#define FORM_EMAX   3       /* max number of retries during format */
#define TRYRESET    5       /* try a reset after this many errrors */
#define NORM_EMAX   10      /* normal max number of retries */

#define RUNTIM  3
#define WAITTIM 4
#define LOADTIM 10
#define MTIME   100	/* no. of clock ticks in one second */
#define ETIMOUT 50	/* no. of clock ticks in 1/2 second */
#define T25MS   3	/* no. of clock ticks in 25 milliseconds */
#define T500MS  50	/* no. of clock ticks in 500 milliseconds */
#define T50MS   5	/* no. of clock ticks in 50 milliseconds */
#define T750MS  75	/* no. of clock ticks in 750 milliseconds */

#define OPENED  0x01
#define OPENING 0x02
#define RECAL   0x04
#define CLOSING 0x08
#define EXCLUSV 0x10
#define RSTDOPN 0x20

#define WINTR   0x01
#define	WRESET	0x02

#define D_NTRK  40      /* 40 tracks - double density */
#define Q_NTRK  80      /* 80 tracks - quad density */


#define FDCSR1      0x03F7
#define DOOROPEN    0x80
#define FDCTRL      0x03F2
#define NORESET     0x04
#define ENABINT     0x08
#define ENABMOTOR   0x10

#define FD0BSY      0x01    /* drive is seeking */
#define FD1BSY      0x02
#define FD2BSY      0x04
#define FD3BSY      0x08
#define FCBSY       0x10    /* controller is busy */
#define NODMA       0x20    /* controller in non-DMA mode */

/*
 * Floppy controller commands
 */
#define RDCMD       0x26
#define SEEK        0x0F
#define FORMAT      0x0D
#define READID      0x0A
#define SENSE_INT   0x08
#define REZERO      0x07
#define WRCMD       0x05
#define SENSE_DRV   0x04        /* read status register 3 */
#define SPECIFY     0x03
#define	CONFIG		0x13
#define	VERSION		0x10

#define READDEL     0x0C
#define WRITEDEL    0x09
#define READTRACK   0x02
#define RAWCMD      0x7F	/* command is thru raw I/O ioctl */

#define INVALID     0x80        /* status register 0 */
#define ABNRMTERM   0x40
#define SEEKEND     0x20
#define EQCHK       0x10
#define NOTRDY      0x08

#define EOCYL       0x80        /* status register 1 */
#define CRCERR      0x20
#define OVRRUN      0x10
#define NODATA      0x04
#define MADR        0x01

#define FAULT       0x80        /* status register 3 */
#define WPROT       0x40
#define RDY         0x20
#define TWOSIDE     0x08

/* NEW_HARDWARE CMOS drive descriptions */
#define DRV_NONE    0x00
#define DRV_DBL     0x01
#define DRV_QUAD    0x02

	    /* encodings for the 'fdf_den' field in structure 'fdparam' */
#define DEN_MFM 0x40        /* double density disks */
#define DEN_FM  0x00        /* single density disks */

	    /* encodings for the 'fdf_bps' field in structure 'fdparam' */
#define BPS128  0           /* 128 bytes per sector */
#define BPS256  1           /* 256 bytes per sector */
#define BPS512  2           /* 512 bytes per sector */
#define BPS1024 3           /* 1024 bytes per sector */
#define MAXBPS  3           /* maximum value of the 'fdf_bps' field */

#define	FDNPART	3	/* number of partitions supported */
#define	FDMEMSIZE	(36*512)
/*
 * partition table for floppy disks
 * we support, 3 different partitions:
 * 	0 - the whole disk;
 *	1 - the first cylinder on the disk
 *	2 - the whole disk minus the first cylinder
 */
struct fdpartab {
	int	startcyl;	/* cylinder no. where partition starts */
	int	numcyls;	/* number of cylinders in partition */
};

#define	FDNSECT	10	/* no. of sector size/count types supported */
/*
 * sector table for floppy disks,
 * specifies number of bytes per sector and
 * number of sectors per track.
 */
struct fdsectab {
	unsigned short	fd_ssize;	/* number of bytes in a sector */
	unsigned short	fd_sshift;	/* shift to convert bytes to sectors */
	unsigned char	fd_nsect;	/* number of sectors per track */
	unsigned char	fd_drvs;	/* bitmask of drive types supporting */
	unsigned char	fd_gpln;	/* normal gap length */
	unsigned char	fd_gplf;	/* format gap length */
};

struct fdstate {
	char     fd_status;
	char     fd_maxerr;
	unsigned char  fd_drvtype;
	unsigned char  fd_trnsfr;
	unsigned char  fd_hst;
	unsigned char  fd_mst;
	unsigned char  fd_dstep;
	unsigned short fd_cylskp;
	unsigned short fd_ncyls;
	unsigned short fd_secsiz;
	unsigned short fd_secmsk;
	unsigned char  fd_secsft;
	unsigned char  fd_nsides;
	unsigned char  fd_nsects;
	unsigned char  fd_cylsiz;
	unsigned char  fd_curcyl;
	unsigned char  fd_lsterr;
	unsigned short fd_n512b;
	dev_t	       fd_device;
	struct   proc *fd_proc;
	unsigned char  fd_fmt;		/* auto format detection */
	unsigned char  fd_dskchg;	/* if == 0, format is up to date */
};

struct fdparam {        /* used by FDSPARAM and FDGPARAM commands */
	char    fdf_bps;    /* number of bytes per sector - encoded */
	char    fdf_spt;    /* number of sectors per track */
	char    fdf_gpln;   /* gap length for normal R/W operations */
	char    fdf_gplf;   /* gap length for format operations */
	char    fdf_dtl;    /* length of sector if 'fdf_bps' = 0 */
	char    fdf_fil;    /* fill byte to use while formatting */
	char    fdf_den;    /* FM or MFM encoding */
	char    fdf_nhd;    /* number of heads */
	short   fdf_ncyl;   /* number of cylinders */
};

struct fdformid {       /* used by FDFMTTRK command */
	char    fdf_track;
	char    fdf_head;
	char    fdf_sec;
	char    fdf_secsiz;
};

#define FIOC		('F'<<8)
#define	F_DTYP		(FIOC|60)	/* returns fd_drvtype */
#define F_FCR		(FIOC|61)	/* output to Floppy Control Register */
#define F_DOR		(FIOC|62)	/* output to Digital Output Register */
#define F_RAW		(FIOC|63)	/* general raw controller interface */

struct fdraw {			/* used by F_RAW command */
	char	fr_cmd[10];	/* user-supplied command bytes */
	short	fr_cnum;	/* number of command bytes */
	char	fr_result[10];	/* controller-supplied result bytes */
	short	fr_nbytes;	/* number to transfer if read/write command */
	char   *fr_addr;	/* where to transfer if read/write command */
};

struct  fdbufstruct {
	int         fbs_flags;
	caddr_t     fbs_addr;
	unsigned    int     fbs_size;
};

#endif	/* _SYS_FD_H */
 07070100005981000081240000000200000002000000012719347c0000095d000000230000000c00000000000000000000001800000000usr/include/sys/fdisk.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FDISK_H
#define _SYS_FDISK_H

#ident	"@(#)/usr/include/sys/fdisk.h.sl 1.1 4.0 10/15/90 40837 AT&T-SF"

#define BOOTSZ		446	/* size of boot code in master boot block */
#define FD_NUMPART	4	/* number of 'partitions' in fdisk table */
#define MBB_MAGIC	0xAA55	/* magic number for mboot.signature */
#define DEFAULT_INTLV	4	/* default interleave for testing tracks */
#define MINPSIZE	4	/* minimum number of cylinders in a partition */
#define TSTPAT		0xE5	/* test pattern for verifying disk */

/*
 * structure to hold the fdisk partition table
 */
struct ipart {
	unsigned char bootid;	/* bootable or not */
	unsigned char beghead;	/* beginning head, sector, cylinder */
	unsigned char begsect;	/* begcyl is a 10-bit number. High 2 bits */
	unsigned char begcyl;	/*     are in begsect. */
	unsigned char systid;	/* OS type */
	unsigned char endhead;	/* ending head, sector, cylinder */
	unsigned char endsect;	/* endcyl is a 10-bit number.  High 2 bits */
	unsigned char endcyl;	/*     are in endsect. */
	long    relsect;	/* first sector relative to start of disk */
	long    numsect;	/* number of sectors in partition */
};
/*
 * Values for bootid.
 */
#define NOTACTIVE	0
#define ACTIVE		128
/*
 * Values for systid.
 */
#define DOSOS12		1	/* DOS partition, 12-bit FAT */
#define PCIXOS		2	/* PC/IX partition */
#define DOSDATA		86	/* DOS data partition */
#define DOSOS16		4	/* DOS partition, 16-bit FAT */
#define EXTDOS		5	/* EXT-DOS partition */
#define OTHEROS		98	/* part. type for appl. (DB?) needs raw partition */
				/* ID was 0 but conflicted with DOS 3.3 fdisk    */
#define UNIXOS		99	/* UNIX V.x partition */
#define UNUSED		100	/* unassigned partition */
#define MAXDOS		65535L	/* max size (sectors) for DOS partition */
/*
 * structure to hold master boot block in physical sector 0 of the disk.
 * Note that partitions stuff can't be directly included in the structure
 * because of lameo '386 compiler alignment design.
 */

struct  mboot {     /* master boot block */
	char    bootinst[BOOTSZ];
	char    parts[FD_NUMPART * sizeof(struct ipart)];
	ushort   signature;
};

#endif	/* _SYS_FDISK_H */
   07070100005982000081240000000200000002000000012719347c00000b5b000000230000000c00000000000000000000001700000000usr/include/sys/file.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FILE_H
#define _SYS_FILE_H

#ident	"@(#)/usr/include/sys/file.h.sl 1.1 4.0 10/15/90 10023 AT&T-SF"
/*
 * One file structure is allocated for each open/creat/pipe call.
 * Main use is to hold the read/write pointer associated with
 * each open file.
 */
typedef struct file {
	struct file  *f_next;		/* pointer to next entry */
	struct file  *f_prev;		/* pointer to previous entry */
	ushort	f_flag;
	cnt_t	f_count;		/* reference count */
	struct vnode *f_vnode;		/* pointer to vnode structure */
	off_t	f_offset;		/* read/write character pointer */
	struct	cred *f_cred;		/* credentials of user who opened it */
	struct	aioreq *f_aiof;		/* aio file list forward link	*/
	struct	aioreq *f_aiob;		/* aio file list backward link	*/
	union {
		off_t f_off;
/* XENIX Support */
		struct	file *f_slnk;	/* XENIX semaphore queue */
/* End XENIX Support */
	} f_un;
} file_t;

#define f_offset	f_un.f_off	/* read/write character pointer */

/* flags */

#define	FOPEN		0xFFFFFFFF
#define	FREAD		0x01
#define	FWRITE		0x02
#define	FNDELAY		0x04
#define	FAPPEND		0x08
#define	FSYNC		0x10

/*
 * The new flag is added for raw disk async I/O feature.
 */
#define	FRAIOSIG	0x20	/* cause a signal for a completed RAIO request */ 

#define	FNONBLOCK	0x80

#define	FMASK		0xFF	/* should be disjoint from FASYNC */

/* open-only modes */

#define FCREAT      0x0100
#define FTRUNC      0x0200
#define FEXCL       0x0400
#define FNOCTTY     0x0800

/* Internal flag used by SVR4 async i/o feature */
#define FASYNC      0x1000

/* file descriptor flags */
#define FCLOSEXEC	001	/* close on exec */

/* miscellaneous defines */

#define NULLFP ((struct file *)0)

#ifndef L_SET
#define	L_SET	0	/* for lseek */
#endif /* L_SET */

/*
 * Count of number of entries in file list.
 */
extern unsigned int filecnt;

/*
 * Routines dealing with user per-open file flags and
 * user open files.  
 */

#if defined(__STDC__)
extern int getf(int, file_t **);
extern void closeall(int);
extern int closef(file_t *);
extern int ufalloc(int, int *);
extern int falloc(struct vnode *, int, file_t **, int *);
extern void finit(void);
extern void unfalloc(file_t *);
extern void setf(int, file_t *);
extern char getpof(int);
extern void setpof(int, char);
extern int filesearch(struct vnode *);
extern int fassign(struct vnode **, int, int*);

#else

extern int getf();
extern void closeall();
extern int closef();
extern int ufalloc();
extern int falloc();
extern void finit();
extern void unfalloc();
extern void setf();
extern char getpof();
extern void setpof();
extern int filesearch();
extern int fassign();

#endif	/* __STDC__ */

#endif	/* _SYS_FILE_H */
 07070100005983000081240000000200000002000000012719347c0000063b000000230000000c00000000000000000000001800000000usr/include/sys/filio.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FILIO_H
#define _SYS_FILIO_H

#ident	"@(#)/usr/include/sys/filio.h.sl 1.1 4.0 10/15/90 22592 AT&T-SF"

/*	@(#)filio.h 1.3 88/02/08 SMI; from UCB ioctl.h 7.1 6/4/86	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * General file ioctl definitions.
 */

#include <sys/ioccom.h>

#define	FIOCLEX		_IO('f', 1)		/* set exclusive use on fd */
#define	FIONCLEX	_IO('f', 2)		/* remove exclusive use */
/* another local */
#define	FIONREAD	_IOR('f', 127, int)	/* get # bytes to read */
#define	FIONBIO		_IOW('f', 126, int)	/* set/clear non-blocking i/o */
#define	FIOASYNC	_IOW('f', 125, int)	/* set/clear async i/o */
#define	FIOSETOWN	_IOW('f', 124, int)	/* set owner */
#define	FIOGETOWN	_IOR('f', 123, int)	/* get owner */

#endif	/* _SYS_FILIO_H */
 07070100005984000081240000000200000002000000012719347c0000023d000000230000000c00000000000000000000001900000000usr/include/sys/filsys.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FILSYS_H
#define _SYS_FILSYS_H

#ident	"@(#)/usr/include/sys/filsys.h.sl 1.1 4.0 10/15/90 63616 AT&T-SF"
/* WARNING!!!  This stub will be removed for release 4.0. Please 
*  be advised to change any source code using this header file */
#include <sys/fs/s5filsys.h>

#endif	/* _SYS_FILSYS_H */
   07070100005985000081240000000200000002000000012719347c000005c4000000230000000c00000000000000000000001800000000usr/include/sys/flock.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FLOCK_H
#define _SYS_FLOCK_H

#ident	"@(#)/usr/include/sys/flock.h.sl 1.1 4.0 10/15/90 27371 AT&T-SF"

#define	INOFLCK		1	/* Vnode is locked when reclock() is called. */
#define	SETFLCK		2	/* Set a file lock. */
#define	SLPFLCK		4	/* Wait if blocked. */
#define	RCMDLCK		8	/* RGETLK/RSETLK/RSETLKW specified */

#define IGN_PID		(-1)	/* ignore epid when cleaning locks */

/* file locking structure (connected to vnode) */

#define l_end 		l_len
#define MAXEND  	017777777777

typedef struct filock {
	struct	flock set;	/* contains type, start, and end */
	union	{
		int wakeflg;	/* for locks sleeping on this one */
		struct {
			long sysid;
			pid_t pid;
		} blk;			/* for sleeping locks only */
	}	stat;
#ifdef	u3b
	int	wakesem;
#endif
	struct	filock *prev;
	struct	filock *next;
} filock_t;

/* file and record locking configuration structure */
/* record use total may overflow */
struct flckinfo {
	long reccnt;	/* number of records currently in use */
	long rectot;	/* number of records used since system boot */
};

extern struct flckinfo	flckinfo;

#if defined(__STDC__)
int	reclock(struct vnode *, struct flock *, int, int, off_t);
#else
int	reclock();
#endif

#endif	/* _SYS_FLOCK_H */
07070100005986000081240000000200000002000000012719347c00000bf9000000230000000c00000000000000000000001500000000usr/include/sys/fp.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FP_H
#define _SYS_FP_H

#ident	"@(#)/usr/include/sys/fp.h.sl 1.1 4.0 10/15/90 8145 AT&T-SF"

/*
 * 80287/80387 floating point processor definitions
 */

/*
 * values that go into fp_kind
 */
#define FP_NO   0       /* no fp chip, no emulator (no fp support)      */
#define FP_SW   1       /* no fp chip, using software emulator          */
#define FP_HW   2       /* chip present bit                             */
#define FP_287  2       /* 80287 chip present                           */
#define FP_387  3       /* 80387 chip present                           */

/*
 * masks for 80387 control word
 */
#define FPINV   0x00000001      /* invalid operation                    */
#define FPDNO   0x00000002      /* denormalized operand                 */
#define FPZDIV  0x00000004      /* zero divide                          */
#define FPOVR   0x00000008      /* overflow                             */
#define FPUNR   0x00000010      /* underflow                            */
#define FPPRE   0x00000020      /* precision                            */
#define FPPC    0x00000300      /* precision control                    */
#define FPRC    0x00000C00      /* rounding control                     */
#define FPIC    0x00001000      /* infinity control                     */
#define WFPDE   0x00000080      /* data chain exception                 */

/*
 * precision, rounding, and infinity options in control word
 */
#define FPSIG24 0x00000000      /* 24-bit significand precision (short) */
#define FPSIG53 0x00000200      /* 53-bit significand precision (long)  */
#define FPSIG64 0x00000300      /* 64-bit significand precision (temp)  */
#define FPRTN   0x00000000      /* round to nearest or even             */
#define FPRD    0x00000400      /* round down                           */
#define FPRU    0x00000800      /* round up                             */
#define FPCHOP  0x00000C00      /* chop (truncate toward zero)          */
#define FPP     0x00000000      /* projective infinity                  */
#define FPA     0x00001000      /* affine infinity                      */
#define WFPB17  0x00020000      /* bit 17                               */
#define WFPB24  0x01000000      /* bit 24                               */

/*
 * masks for 80387 status word
 */
#define FPS_ES	0x00000080      /* error summary bit                    */

extern char fp_kind;            /* kind of fp support                   */
extern struct proc *fp_proc;    /* process that owns the fp unit        */

/*
 * values for fp_vers
 */
#define	FP_COFF		1
#define	FP_XOUT		2
/*  Since Elf or Coff Format Emulator behaves/works in the same way.
 */
#define FP_ELF		1

extern char fp_vers;		/* used to indicate how to map u-area	*/

#define EMUL_START	0x15

#endif	/* _SYS_FP_H */
   0707010000489b000041fd0000000200000002000000022719347c00000000000000230000000c00000000000000000000001300000000usr/include/sys/fs    07070100004bb4000081240000000200000002000000012719347c000014f0000000230000000c00000000000000000000001900000000usr/include/sys/fs/bfs.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_BFS_H
#define _FS_BFS_H

#ident	"@(#)/usr/include/sys/fs/bfs.h.sl 1.1 4.0 10/15/90 25798 AT&T-SF"

#include <sys/resource.h>

#define BFS_MAXFNLEN 14			/* Maximum file length */
#define BFS_MAXFNLENN (BFS_MAXFNLEN+1)  /* Used for NULL terminated copies */

struct bfsvattr {
	vtype_t		va_type;	/* vnode type (for create) */
	mode_t		va_mode;	/* file access mode */
	uid_t		va_uid;		/* owner user id */
	uid_t		va_gid;		/* owner group id */
	nlink_t		va_nlink;	/* number of references to file */
	time_t		va_atime;	/* time of last access */
	time_t		va_mtime;	/* time of last modification */
	time_t		va_ctime;	/* time file ``created'' */
	long		va_filler[4];	/* padding */
};

/*
 * The bfs_dirent is the "inode" of BFS.  Always on disk, it is pointed
 * to (by disk offset) by the vnode and is referenced every time an
 * operation is done on the vnode.  It must be referenced every time,
 * as things can move around very quickly
 */
struct bfs_dirent
{
	ushort  d_ino;				/* inode */
	daddr_t d_sblock;			/* Start block */
	daddr_t d_eblock;			/* End block */
	daddr_t d_eoffset;			/* EOF disk offset (absolute) */
	struct  bfsvattr d_fattr;		/* File attributes */
};


struct bfs_ldirs {
	ushort l_ino;
	char   l_name[BFS_MAXFNLEN];
};

/*
 * We keep a linked list of all referenced BFS vnodes.  bfs_inactive will remove
 * them from the list, and bfs_fillvnode will add to and search through the list
 */
struct bfs_core_vnode
{
	struct vnode *core_vnode;
	struct bfs_core_vnode *core_next;
};

/*
 * The BFS superbuf contains all private data about a given BFS filesystem.
 * It is pointed to by the data field of the vfs structure and is thus passed
 * to every vfsop and vnodeops even if indirectly
 */
struct bsuper
{
	off_t bsup_start;		/* The filesystem data start offset */
	off_t bsup_end;			/* The filesystem data end offset */
	long bsup_freeblocks;		/* # of freeblocks (for statfs) */
	long bsup_freedrents;		/* # of free dir entries (for statfs) */
	struct vnode *bsup_devnode;	/* The device special vnode */
	struct vnode *bsup_root;	/* Root vnode */
	off_t bsup_lastfile;		/* Last file directory offset */

	long  bsup_inomapsz;
	char *bsup_inomap;

	/* Linked vnode list */

	struct bfs_core_vnode *bsup_incore_vlist;	

	/*
	 * bsup_ioinprog is the count of the number of io operations is 
	 * in progress.  Compaction routines sleep on this being zero
	 */
	ushort bsup_ioinprog;
	struct vnode *bsup_writelock;	/* The file which is open for write */

	/* Booleans */

	unsigned char bsup_fslocked;	/* Fs is locked when compacting */
	unsigned char bsup_compacted;	/* Fs compacted, no removes done */
};

/* The disk superbuff */
struct bdsuper
{
	long  bdsup_bfsmagic;		/* Magic number */
	off_t bdsup_start;		/* Filesystem data start offset */
	off_t bdsup_end;		/* Filesystem data end offset */

	/*
	 * The next four words are used to promote sanity in compaction.  Used
	 * correctly, a crash at any point during compaction is recoverable
	 */
	daddr_t bdcp_fromblock;		/* "From" block of current transfer */
	daddr_t bdcp_toblock;		/* "To" block of current transfer */
	daddr_t bdcpb_fromblock;	/* Backup of "from" block */
	daddr_t bdcpb_toblock;		/* Backup of "to" block */
	long    bdsup_filler[121];	/* Padding */
};

/* Used to overlay the kernel struct fid */
struct bfs_fid_overlay
{
	ushort o_len;
	long o_offset;
};


#define BFS_MAGIC	0x1BADFACE
#define BFS_SUPEROFF	0
#define BFS_DIRSTART	(BFS_SUPEROFF + sizeof(struct bdsuper))
#define BFS_DEVNODE(vfsp) ((struct bsuper *)vfsp->vfs_data)->bsup_devnode
#define BFS_BSIZE	512
#define BFS_ULT		RLIM_INFINITY	/* file size limit not enforced */
#define BFS_YES		(char)1
#define BFS_NO		(char)0
#define CHUNKSIZE	4096
#define BIGFILE		500
#define SMALLFILE	10
#define BFSROOTINO	2
#define DIRBUFSIZE	1024

#define BFS_INOLOCK(bs, inode) { \
	while (bs->bsup_inomap[inode]) \
		sleep(&(bs->bsup_inomap[inode]), PINOD); \
	bs->bsup_inomap[inode] = 1; \
}

#define BFS_INOUNLOCK(bs, inode) { \
	ASSERT (bs->bsup_inomap[inode]); \
	bs->bsup_inomap[inode] = 0; \
	wakeprocs(&(bs->bsup_inomap[inode]), PRMPT); \
}


#define BFS_OFF2INO(offset) \
	((offset - BFS_DIRSTART) / sizeof(struct bfs_dirent)) + BFSROOTINO

#define BFS_INO2OFF(inode) \
	((inode - BFSROOTINO) * sizeof(struct bfs_dirent)) + BFS_DIRSTART

#define BFS_GETINODE(bvp, offset, buf, cr) \
	vn_rdwr(UIO_READ, bvp, (caddr_t)buf, sizeof(struct bfs_dirent), \
				offset, UIO_SYSSPACE, 0, 0, cr, 0)

#define BFS_PUTINODE(bvp, offset, buf, cr) \
	vn_rdwr(UIO_WRITE, bvp, (caddr_t)buf, sizeof(struct bfs_dirent), \
			offset, UIO_SYSSPACE, IO_SYNC, BFS_ULT, cr, (int *)0)

#define BFS_GETDIRLIST(bvp, offset, buf, len, cr) \
	vn_rdwr(UIO_READ, bvp, buf, len, offset, UIO_SYSSPACE, 0, 0, cr, 0)

#define CHECK_LOCK(bs) \
	if (bs->bsup_fslocked) \
		while (bs->bsup_fslocked) \
			sleep((caddr_t)&bs->bsup_fslocked, PINOD)


#define BFS_LOCK(bs) bs->bsup_fslocked = BFS_YES


#define BFS_IOBEGIN(bs) bs->bsup_ioinprog++

#define BFS_IOEND(bs) if (!(--bs->bsup_ioinprog)) \
			wakeprocs((caddr_t)&bs->bsup_ioinprog, PRMPT)

#endif	/* _FS_BFS_H */
0707010000489c000081240000000200000002000000012719347c0000030a000000230000000c00000000000000000000002100000000usr/include/sys/fs/bfs_compact.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_BFS_COMPACT_H
#define _FS_BFS_COMPACT_H

#ident	"@(#)/usr/include/sys/fs/bfs_compact.sl 1.1 4.0 10/15/90 7150 AT&T-SF"

#define BFS_CCT_READ(bvp, offset, len, buf,cr) \
	vn_rdwr(UIO_READ, bvp, (caddr_t)buf, len, offset, \
				UIO_SYSSPACE, 0, 0, cr, 0)

#define BFS_CCT_WRITE(bvp, offset, len, buf,cr) \
	vn_rdwr(UIO_WRITE, bvp, (caddr_t)buf, len, offset, \
				UIO_SYSSPACE, IO_SYNC, BFS_ULT, cr, (int *)0)

#define BFS_SANITYWSTART (BFS_SUPEROFF + (sizeof(long)*3))

#endif	/* _FS_BFS_COMPACT_H */
  0707010000489d000081240000000200000002000000012719347c00000759000000230000000c00000000000000000000001e00000000usr/include/sys/fs/fifonode.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_FIFONODE_H
#define _FS_FIFONODE_H

#ident	"@(#)/usr/include/sys/fs/fifonode.h.sl 1.1 4.0 10/15/90 46292 AT&T-SF"

/*
 * Each FIFOFS object is identified by a struct fifonode/vnode pair.
 */
struct fifonode {
	struct vnode	fn_vnode;	/* represents the fifo/pipe */
	struct vnode	*fn_mate;	/* the other end of a pipe */
	struct vnode	*fn_realvp;	/* node being shadowed by fifo */
	ushort		fn_ino;		/* node id for pipes */
	short		fn_wcnt;	/* number of writers */
	short		fn_rcnt;	/* number of readers */
	short		fn_open;	/* open count of node*/
	struct vnode	*fn_unique;	/* new vnode created by CONNLD */
	ushort		fn_flag;	/* flags as defined below */
	time_t		fn_atime;	/* creation times for pipe */
	time_t		fn_mtime;
	time_t		fn_ctime;
	struct fifonode	*fn_nextp;	/* next link in the linked list */
	struct fifonode	*fn_backp;	/* back link in linked list */
};

/*
 * Valid flags for fifonodes.
 */
#define ISPIPE		01	/* fifonode is that of a pipe */
#define FIFOLOCK	02	/* fifonode is locked */
#define FIFOSEND        04	/* file descriptor at stream head of pipe */
#define FIFOWRITE      010	/* process is blocked waiting to write */
#define FIFOWANT       020	/* a process wants to access the fifonode */
#define FIFOREAD       040	/* process is blocked waiting to read */
#define FIFOPASS      0100	/* CONNLD passed a new vnode in fn_unique */

/* XENIX Support */
extern int fifo_rdchk();
/* End XENIX Support */

/*
 * Macros to convert a vnode to a fifnode, and vice versa.
 */
#define VTOF(vp) ((struct fifonode *)((vp)->v_data))
#define FTOV(fp) (&(fp)->fn_vnode)

#endif	/* _FS_FIFONODE_H */
   0707010000489e000081240000000200000002000000012719347c00000634000000230000000c00000000000000000000001e00000000usr/include/sys/fs/namenode.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_NAMENODE_H
#define _FS_NAMENODE_H

#ident	"@(#)/usr/include/sys/fs/namenode.h.sl 1.1 4.0 10/15/90 61803 AT&T-SF"

/*
 * This structure is used to pass a file descriptor from user
 * level to the kernel. It is first used by fattach() and then
 * be NAMEFS.
 */
struct namefd {
	int fd;
};

/*
 * Each NAMEFS object is identified by a struct namenode/vnode pair.
 */
struct namenode {
	struct vnode    nm_vnode;	/* represents mounted file desc. */
	ushort		nm_flag;	/* flags defined below */
	struct vattr    nm_vattr;	/* attributes of mounted file desc. */
	struct vnode	*nm_filevp;	/* file desc. prior to mounting */
	struct file	*nm_filep;  /* file pointer of nm_filevp */
	struct vnode	*nm_mountpt;	/* mount point prior to mounting */
	struct namenode *nm_nextp;	/* next link in the linked list */
	struct namenode *nm_backp;	/* back link in linked list */
};

/*
 * Valid flags for namenodes.
 */
#define NMLOCK        01	/* the namenode is locked */
#define NMWANT        02	/* a process wants the namenode */


/*
 * Macros to convert a vnode to a namenode, and vice versa.
 */
#define VTONM(vp) ((struct namenode *)((vp)->v_data))
#define NMTOV(nm) (&(nm)->nm_vnode)

extern struct namenode *namefind();
extern struct namenode *namealloc;
extern struct vnodeops nm_vnodeops;

#endif	/* _FS_NAMENODE_H */
0707010000489f000081240000000200000002000000012719347c00000957000000230000000c00000000000000000000001d00000000usr/include/sys/fs/rf_acct.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FS_RF_ACCT_H
#define _SYS_FS_RF_ACCT_H

#ident	"@(#)/usr/include/sys/fs/rf_acct.h.sl 1.1 4.0 10/15/90 20472 AT&T-SF"

#include <sys/types.h>
#include <sys/sysinfo.h>

/*
 * Accounting structure for RFS client caching.
 */
typedef struct rfc_info {
	ulong rfci_pmread;	/* read cache miss pages */
	ulong rfci_pmwrite;	/* write cache miss pages */
	ulong rfci_ptread;	/* read pages sought in cache */
	ulong rfci_ptwrite;	/* write pages sought in cache */
	ulong rfci_pabort;	/* pages aborted from cache */
	ulong rfci_snd_dis;	/* cache disable messages sent */
	ulong rfci_rcv_dis;	/* cache disable messages received */
	ulong rfci_snd_msg;	/* total messages sent */
	ulong rfci_rcv_msg;	/* total messages received */
	ulong rfci_vc_hit;	/* vattr cache hits */
	ulong rfci_vc_miss;	/* vattr cache misses */
	ulong rfci_ac_hit;	/* access cache hits */
	ulong rfci_ac_miss;	/* access cache misses */
	ulong rfci_dis_data;	/* on server, messages incurred for files
				 * with caching temporarily disabled
				 * in resources mounted with caching */
} rfc_info_t;

typedef struct rf_srv_info {
			/* ELEMENT FOR sar -Du */
	time_t	rfsi_serve;	/* ticks in rfs server since boot */
			/* ELEMENTS FOR sar -S */
	ulong	rfsi_nservers;	/* sum of all servers since boot */
	ulong	rfsi_srv_que;	/* sum of server queue length since boot */
	ulong	rfsi_srv_occ;	/* seconds server queue found occupied */
	ulong	rfsi_rcv_que;	/* sum of server work list length since boot */
	ulong	rfsi_rcv_occ;	/* seconds server work list found occupied */
} rf_srv_info_t;

#if defined(_KERNEL)

extern rfc_info_t	rfc_info;
extern fsinfo_t		rfcl_fsinfo;
extern fsinfo_t		rfsr_fsinfo;
extern rf_srv_info_t	rf_srv_info;

extern time_t		*rfsi_servep;	/* SVID compliance hack for sar(1) */

extern	int minserve;			/* tunable: server low water mark */
extern	int maxserve;			/* tunable: server high water mark */
extern	int rf_nservers;		/* total servers in system */
extern	int n_idleserver;		/* idle servers in system */
extern	int rf_n_sr_msgs;		/* rcvds in server work list */

extern void rf_clock();

#endif

#endif /* _SYS_FS_RF_ACCT_H */
 070701000048a0000081240000000200000002000000012719347c0000098d000000230000000c00000000000000000000001c00000000usr/include/sys/fs/rf_vfs.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FS_RF_VFS_H
#define _SYS_FS_RF_VFS_H

#ident	"@(#)/usr/include/sys/fs/rf_vfs.h.sl 1.1 4.0 10/15/90 36742 AT&T-SF"

#include <sys/list.h>
#include <sys/types.h>
#include <sys/vnode.h>
#include <sys/vfs.h>

/*
 * RFS-specific part of VFS.
 */
typedef struct rf_vfs {
	struct rf_vfs	*rfvfs_prev;
	struct rf_vfs	*rfvfs_next;
	vfs_t		*rfvfs_vfsp;	/* to vfs for resource */
	vnode_t		*rfvfs_rootvp;	/* root vnode when mntproc NULL */
	struct proc	*rfvfs_mntproc;	/* process mounting when rootvp NULL */
	int		rfvfs_refcnt;	/* n sndds active in resource */
	ushort		rfvfs_flags;	/* flags, below */
	long		rfvfs_mntid;	/* "index" from static table days */
	ls_elt_t	rfvfs_sdhash;	/* to hash chains for free sndds */
	char		rfvfs_name[MAXDNAME + 1];
					/* resource name */
} rf_vfs_t;
/*
 * flags in rf_vfs
 */
#define MFREE           0x0
#define MFUMOUNT        0x40
#define MLINKDOWN       0x80
#define MCACHE          0x100

/*
 * list header for RFS dependent VFSs
 */
typedef struct rf_head {
	rf_vfs_t  *rfh_prev;
	rf_vfs_t  *rfh_next;
} rf_head_t;
extern rf_head_t       rf_head;

/*
 * for rfs mounts, mount system call gets a pointer to one
 * of these as its "dataptr" arg
 */
typedef struct rf_mountdata {
	ushort  rfm_flags;       /* RFS-specific flags */
	rf_token_t rfm_token;
} rf_mountdata_t;
/*
 * flags in rf_mountdata_t
 */
#define MS_CACHE	0x8

/*
 * generic mount flags of interest
 */
#define MS_FLAGS_TO_RFS(flags)  ((flags) & MS_RDONLY)

/*
 * Give a pointer to an rf_vfs structure, yield ptr to corresponding VFS
 */
#define RFTOVF(rf_vfsp)   ((vfs_t *)((rf_vfsp)->rfvfs_vfsp))
/*
 * Given a pointer to a VFS, yield ptr to corresponding rf_vfs structure
 */
#define VFTORF(vfsp)    ((rf_vfs_t *)((vfsp)->vfs_data))
/* Is this an rf_vfs vnode pointer? */
#define ISRFSVP(vp)      ((vp)->v_op == &rf_vnodeops)
/* Is this a rf_vfst vfs pointer? */
#define ISRFSVFSP(vfsp)   ((vfsp)->vfs_op == &rf_vfsops)

#if defined(_KERNEL)

extern struct vfsops rf_vfsops;
extern struct vnodeops rf_vnodeops;
extern struct vnodeops *rf_vnopsp;

extern int rfs_type;

extern rf_vfs_t *findrfvfs();
extern int	rf_vp_preSVR4();

#endif

#endif /* _SYS_FS_RF_VFS_H */
   070701000048a1000081240000000200000002000000012719347c00000235000000230000000c00000000000000000000001b00000000usr/include/sys/fs/s5dir.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_S5DIR_H
#define _FS_S5DIR_H

#ident	"@(#)/usr/include/sys/fs/s5dir.h.sl 1.1 4.0 10/15/90 42910 AT&T-SF"
#ifndef	DIRSIZ
#define	DIRSIZ	14
#endif
struct	direct
{
	o_ino_t	d_ino;		/* s5 inode type */
	char	d_name[DIRSIZ];
};

#define	SDSIZ	(sizeof(struct direct))

#endif	/* _FS_S5DIR_H */
   070701000048a2000081240000000200000002000000012719347c000001d7000000230000000c00000000000000000000001c00000000usr/include/sys/fs/s5fblk.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_S5FBLK_H
#define _FS_S5FBLK_H

#ident	"@(#)/usr/include/sys/fs/s5fblk.h.sl 1.1 4.0 10/15/90 28247 AT&T-SF"
struct	fblk
{
	int	df_nfree;
	daddr_t	df_free[NICFREE];
};

#endif	/* _FS_S5FBLK_H */
 070701000048a3000081240000000200000002000000012719347c000007ac000000230000000c00000000000000000000001e00000000usr/include/sys/fs/s5filsys.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_S5FILSYS_H
#define _FS_S5FILSYS_H

#ident	"@(#)/usr/include/sys/fs/s5filsys.h.sl 1.1 4.0 10/15/90 44766 AT&T-SF"
/*
 * Structure of the super-block.
 */

struct	filsys
{
	u_short	s_isize;	/* size in blocks of i-list */
	daddr_t	s_fsize;	/* size in blocks of entire volume */
	short	s_nfree;	/* number of addresses in s_free */
	daddr_t	s_free[NICFREE];/* free block list */
		/* S5 inode definition cannot change for EFT */
	short	s_ninode;	/* number of i-nodes in s_inode */
	o_ino_t	s_inode[NICINOD];/* free i-node list */
	char	s_flock;	/* lock during free list manipulation */
	char	s_ilock;	/* lock during i-list manipulation */
	char  	s_fmod; 	/* super block modified flag */
	char	s_ronly;	/* mounted read-only flag */
	time_t	s_time; 	/* last super block update */
	short	s_dinfo[4];	/* device information */
	daddr_t	s_tfree;	/* total free blocks*/
	o_ino_t	s_tinode;	/* total free inodes */
	char	s_fname[6];	/* file system name */
	char	s_fpack[6];	/* file system pack name */
	long	s_fill[12];	/* adjust to make sizeof filsys */
	long	s_state;	/* file system state */
	long	s_magic;	/* magic number to indicate new file system */
	long	s_type;		/* type of new file system */
} ;

#define FsMAGIC	0xfd187e20	/* s_magic */

#define Fs1b	1	/* 512-byte blocks */
#define Fs2b	2	/* 1024-byte blocks */
#define Fs4b	3	/* 2048-byte blocks */

#define	FsOKAY	0x7c269d38	/* s_state: clean */
#define	FsACTIVE	0x5e72d81a	/* s_state: active */
#define	FsBAD	0xcb096f43	/* s_state: bad root */
#define FsBADBLK	0xbadbc14b	/* s_state: bad block corrupted it */

#define getfs(vfsp)	((struct filsys *)((struct s5vfs *)vfsp->vfs_data)->vfs_bufp->b_un.b_addr)

#endif	/* _FS_S5FILSYS_H */
070701000048a4000081240000000200000002000000012719347c00000457000000230000000c00000000000000000000001b00000000usr/include/sys/fs/s5ino.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_S5INO_H
#define _FS_S5INO_H

#ident	"@(#)/usr/include/sys/fs/s5ino.h.sl 1.1 4.0 10/15/90 12087 AT&T-SF"
/*
 * Inode structure as it appears on a disk block.  Of the 40 address
 * bytes, 39 are used as disk addresses (13 addresses of 3 bytes each)
 * and the 40th is used as a file generation number.
 */
struct	dinode {
	o_mode_t	di_mode;	/* mode and type of file */
	o_nlink_t	di_nlink;    	/* number of links to file */
	o_uid_t		di_uid;      	/* owner's user id */
	o_gid_t		di_gid;      	/* owner's group id */
	off_t		di_size;     	/* number of bytes in file */
	char  		di_addr[39];	/* disk block addresses */
	unsigned char	di_gen;		/* file generation number */
	time_t		di_atime;   	/* time last accessed */
	time_t		di_mtime;   	/* time last modified */
	time_t		di_ctime;   	/* time created */
};

#endif	/* _FS_S5INO_H */
 070701000048a5000081240000000200000002000000012719347c00001a8c000000230000000c00000000000000000000001d00000000usr/include/sys/fs/s5inode.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_S5INODE_H
#define _FS_S5INODE_H

#ident	"@(#)/usr/include/sys/fs/s5inode.h.sl 1.1 4.0 10/15/90 636 AT&T-SF"

#include <sys/proc.h>	/* XXX -- needed for user-context kludge in ILOCK */
#include <sys/disp.h>	/* XXX */

#define	NADDR	13
#define	NSADDR	(NADDR*sizeof(daddr_t)/sizeof(short))

struct inode {
	struct	inode *i_forw;	/* inode hash chain */
	struct	inode *i_back;	/* " */
	struct	inode *av_forw;	/* freelist chain */
	struct	inode *av_back;	/* " */
	u_short	i_flag;		/* flags */
	o_ino_t	i_number;	/* inode number */
	dev_t	i_dev;		/* device where inode resides */
	o_mode_t i_mode;	/* file mode and type */
	o_uid_t	i_uid;		/* owner */
	o_gid_t	i_gid;		/* group */
	o_nlink_t i_nlink;	/* number of links */
	off_t	i_size;		/* size in bytes */
	time_t	i_atime;	/* last access time */
	time_t	i_mtime;	/* last modification time */
	time_t	i_ctime;	/* last "inode change" time */
	daddr_t	i_addr[NADDR];	/* block address list */
	short	i_nilocks;	/* XXX -- count of recursive ilocks */
	short	i_owner;	/* XXX -- proc slot of ilock owner */
	daddr_t	i_nextr;	/* next byte read offset (read-ahead) */
	u_char 	i_gen;		/* generation number */
	long    i_mapcnt;       /* number of mappings of pages */
	u_long	i_vcode;	/* version code attribute */
	struct vnode i_vnode;	/* Contains an instance of a vnode */
	int	*i_map;		/* block list for the corresponding file */
	dev_t	i_rdev;		/* rdev field for block/char specials */
};

#define	i_oldrdev	i_addr[0]
#define i_bcflag	i_addr[1]	/* block/char special flag occupies
					** bytes 3-5 in di_addr
					*/
#define NDEVFORMAT	0x1	/* device number stored in new area */
#define i_major		i_addr[2] /* major component occupies bytes 6-8 in di_addr */
#define i_minor		i_addr[3] /* minor component occupies bytes 9-11 in di_addr */

typedef struct inode inode_t;

extern struct inode *inode;
extern long int ninode;

struct	ifreelist {	/* must match struct inode */
	struct inode	*pad[2];
	struct inode	*av_forw;
	struct inode	*av_back;
};

extern struct ifreelist ifreelist;

/* Flags */

#define	ILOCKED	0x0001		/* inode is locked */
#define	IUPD	0x0002		/* file has been modified */
#define	IACC	0x0004		/* inode access time to be updated */
#define	IWANT	0x0010		/* some process waiting on lock */
#define	ICHG	0x0040		/* inode has been changed */
#define	ISYN	0x0080		/* do synchronous write for iupdat */
#define	IMOD	0x0100		/* inode times have been modified */
#define	INOACC	0x0200		/* no access time update in getpage */
#define	ISYNC	0x0400		/* do all block allocation synchronously */
#define	IMODTIME 0x0800		/* mod time already set */
#define	IRWLOCKED	0x1000		/* inode is rwlocked */
#define	IINACTIVE	0x2000		/* inode is inactive */

/*
 * File types.
 */

#define	IFMT	0xF000		/* type of file */
#define		IFIFO	0x1000	/* fifo special */
#define		IFCHR	0x2000	/* character special */
#define		IFDIR	0x4000	/* directory */
#define		IFNAM	0x5000	/* XENIX special named file */
#define		IFBLK	0x6000	/* block special */
#define		IFREG	0x8000	/* regular */
#define		IFLNK	0xA000	/* symbolic link */

/*
 * File modes.
 */
#define	ISUID	VSUID		/* set user id on execution */
#define	ISGID	VSGID		/* set group id on execution */
#define ISVTX	VSVTX		/* save swapped text even after use */

/*
 * Permissions.
 */
#define	IREAD		VREAD	/* read permission */
#define	IWRITE		VWRITE	/* write permission */
#define	IEXEC		VEXEC	/* execute permission */

#ifdef _KERNEL

extern int iget(), ialloc();
extern void iinactive();

extern int bmap(), bmapalloc();

/*
 * inode-to-vnode conversion.
 */
#define	ITOV(ip)	((struct vnode *)&(ip)->i_vnode)
#define VTOI(vp)	((struct inode *)(vp)->v_data)

#define ESAME	(-1)		/* Special KLUDGE error for rename */

#define	S5_HOLE	(-1)		/* Value used when no block allocated */

enum de_op	{ DE_CREATE, DE_MKDIR, DE_LINK, DE_RENAME }; /* direnter ops */
enum dr_op	{ DR_REMOVE, DR_RMDIR, DR_RENAME }; /* dirremove ops */

/*
 * This overlays the fid structure (see vfs.h).
 */
struct ufid {
	u_short	ufid_len;
	o_ino_t	ufid_ino;
	long	ufid_gen;
};

/*
 * S5 VFS private data.
 */
struct s5vfs {
	struct vnode	*vfs_root;	/* root vnode */
	struct buf	*vfs_bufp;	/* buffer containing superblock */
	struct vnode	*vfs_devvp;	/* block device vnode */
	long		vfs_nindir;	/* bsize/sizeof(daddr_t) */
	long		vfs_inopb;	/* bsize/sizeof(dinode) */
	long		vfs_bmask;	/* bsize-1 */
	long		vfs_nmask;	/* nindir-1 */
	long		vfs_ltop;	/* ltop or ptol shift constant */
	long		vfs_bshift;	/* log2(bsize) */
	long		vfs_nshift;	/* log2(nindir) */
	long		vfs_inoshift;	/* log2(inopb) */
};

#define S5VFS(vfsp) ((struct s5vfs *)((vfsp)->vfs_data))

/*
 * Lock and unlock inodes.
 *
 * XXX -- Uses process context.  Rewrite to remove this.
 */
#define	IRWLOCK(ip) { \
	while ((ip)->i_flag & IRWLOCKED) { \
		(ip)->i_flag |= IWANT; \
		(void) sleep((caddr_t)(ip), PINOD); \
	} \
	(ip)->i_flag |= IRWLOCKED; \
	if ((ip)->i_vnode.v_flag & VISSWAP) { \
		curproc->p_swlocks++; \
		curproc->p_flag |= SSWLOCKS; \
	} \
}

#define	IRWUNLOCK(ip) { \
	ASSERT((ip)->i_flag & IRWLOCKED); \
	if ((ip)->i_vnode.v_flag & VISSWAP) { \
		if (--curproc->p_swlocks == 0) \
			curproc->p_flag &= ~SSWLOCKS; \
	} \
	(ip)->i_flag &= ~IRWLOCKED; \
	if ((ip)->i_flag & IWANT) { \
		(ip)->i_flag &= ~IWANT; \
		wakeprocs((caddr_t)(ip), PRMPT); \
	} \
}

#define	ILOCK(ip) { \
	while (((ip)->i_flag & ILOCKED) && (ip)->i_owner != curproc->p_slot) { \
		(ip)->i_flag |= IWANT; \
		(void) sleep((caddr_t)(ip), PINOD); \
	} \
	(ip)->i_owner = curproc->p_slot; \
	(ip)->i_nilocks++; \
	(ip)->i_flag |= ILOCKED; \
	if ((ip)->i_vnode.v_flag & VISSWAP) { \
		curproc->p_swlocks++; \
		curproc->p_flag |= SSWLOCKS; \
	} \
}

#define	IUNLOCK(ip) { \
	ASSERT((ip)->i_flag & ILOCKED); \
	--(ip)->i_nilocks; \
	ASSERT((ip)->i_nilocks >= 0); \
	if ((ip)->i_vnode.v_flag & VISSWAP) { \
		if (--curproc->p_swlocks == 0) \
			curproc->p_flag &= ~SSWLOCKS; \
	} \
	if ((ip)->i_nilocks == 0) { \
		(ip)->i_flag &= ~ILOCKED; \
		if ((ip)->i_flag & IWANT) { \
			(ip)->i_flag &= ~IWANT; \
			wakeprocs((caddr_t)(ip), PRMPT); \
		} \
	} \
}

#define ITIMES(ip) { \
	if ((ip)->i_flag & (IUPD|IACC|ICHG)) { \
		(ip)->i_flag |= IMOD; \
		if ((ip)->i_flag & IACC) \
			(ip)->i_atime = hrestime.tv_sec; \
		if ((ip)->i_flag & IUPD) {\
			(ip)->i_mtime = hrestime.tv_sec; \
			(ip)->i_flag |= IMODTIME; \
		} \
		if ((ip)->i_flag & ICHG) \
			(ip)->i_ctime = hrestime.tv_sec; \
		(ip)->i_flag &= ~(IACC|IUPD|ICHG); \
	} \
}

#endif

#ifndef NADDR
#define NADDR 13
#endif

#endif	/* _FS_S5INODE_H */
070701000048a6000081240000000200000002000000012719347c0000030b000000230000000c00000000000000000000001e00000000usr/include/sys/fs/s5macros.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_S5MACROS_H
#define _FS_S5MACROS_H

#ident	"@(#)/usr/include/sys/fs/s5macros.h.sl 1.1 4.0 10/15/90 42228 AT&T-SF"

#define FsLTOP(fs, b)	((b) << (fs)->vfs_ltop)
#define FsPTOL(fs, b)	((b) >> (fs)->vfs_ltop)
#define FsITOD(fs, x)	(daddr_t)(((unsigned)(x)+(2*(fs)->vfs_inopb-1)) >> (fs)->vfs_inoshift)
#define FsITOO(fs, x)	(daddr_t)(((unsigned)(x)+(2*(fs)->vfs_inopb-1)) & ((fs)->vfs_inopb-1))
#define FsINOS(fs, x)	((((x) >> (fs)->vfs_inoshift) << (fs)->vfs_inoshift) + 1)

#endif	/* _FS_S5MACROS_H */
 070701000048a7000081240000000200000002000000012719347c00000371000000230000000c00000000000000000000001d00000000usr/include/sys/fs/s5param.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_S5PARAM_H
#define _FS_S5PARAM_H

#ident	"@(#)/usr/include/sys/fs/s5param.h.sl 1.1 4.0 10/15/90 37415 AT&T-SF"

/*
 * Filesystem parameters.
 */
#define	SUPERB	((daddr_t)1)	/* block number of the super block */
#define	DIRSIZ	14		/* max characters per directory */
#define	NICINOD	100		/* number of superblock inodes */
#define	NICFREE	50		/* number of superblock free blocks */
#define	S5ROOTINO	2	/* i-number of all roots */
#define NDPC		4		/* number of blocks/click */
#define Fs2BLK		0x8000		/* large block flag in bsize */

#define SUPERBOFF	512	/* superblock offset */

#endif	/* _FS_S5PARAM_H */
   070701000048a8000081240000000200000002000000012719347c000011e3000000230000000c00000000000000000000001b00000000usr/include/sys/fs/snode.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_SNODE_H
#define _FS_SNODE_H

#ident	"@(#)/usr/include/sys/fs/snode.h.sl 1.1 4.0 10/15/90 34683 AT&T-SF"
/*
 * The snode represents a special file in any filesystem.  There is
 * one snode for each active special file.  Filesystems that support
 * special files use specvp(vp, dev, type, cr) to convert a normal
 * vnode to a special vnode in the ops lookup() and create().
 *
 * To handle having multiple snodes that represent the same
 * underlying device vnode without cache aliasing problems,
 * the s_commonvp is used to point to the "common" vnode used for
 * caching data.  If an snode is created internally by the kernel,
 * then the s_realvp field is NULL and s_commonvp points to s_vnode.
 * The other snodes which are created as a result of a lookup of a
 * device in a file system have s_realvp pointing to the vp which
 * represents the device in the file system while the s_commonvp points
 * into the "common" vnode for the device in another snode.
 */

struct snode {
	struct	snode *s_next;		/* must be first */
	struct	vnode s_vnode;		/* vnode associated with this snode */
	struct	vnode *s_realvp;	/* vnode for the fs entry (if any) */
	struct	vnode *s_commonvp;	/* common device vnode */
	ushort	s_flag;			/* flags, see below */
	dev_t	s_dev;			/* device the snode represents */
	dev_t	s_fsid;			/* file system identifier */
	daddr_t	s_nextr;		/* next byte read offset (read-ahead) */
	long	s_size;			/* block device size in bytes */
	time_t  s_atime;		/* time of last access */
	time_t  s_mtime;		/* time of last modification */
	time_t  s_ctime;		/* time of last attributes change */
	int	s_count;		/* count of opened references */
        long    s_mapcnt;               /* count of mappings of pages */
	long	s_pad1;			/* reserved for security */
	long	s_pad2;			/* reserved for security */
	long	s_pad3;			/* reserved for security */
	struct proc *s_powns;		/* XXX vm debugging */
};

/* flags */
#define SLOCKED		0x01		/* snode is locked */
#define SUPD		0x02		/* update device access time */
#define SACC		0x04		/* update device modification time */
#define SWANT		0x10		/* some process waiting on lock */
#define SCHG		0x40		/* update device change time */

/*
 * Convert between vnode and snode
 */
#define	VTOS(vp)	((struct snode *)((vp)->v_data))
#define	STOV(sp)	(&(sp)->s_vnode)

extern struct proc *curproc;		/* XXX vm debugging */
/*
 * Lock and unlock snodes.
 */
#define SNLOCK(sp) { \
	while ((sp)->s_flag & SLOCKED) { \
		(sp)->s_flag |= SWANT; \
		(void) sleep((caddr_t)(sp), PINOD); \
	} \
	(sp)->s_flag |= SLOCKED; \
	if (((sp)->s_vnode.v_flag & VISSWAP) != 0) { \
		curproc->p_swlocks++; \
		curproc->p_flag |= SSWLOCKS; \
	} \
	(sp)->s_powns = curproc; \
}

#define SNUNLOCK(sp) { \
	(sp)->s_flag &= ~SLOCKED; \
	if (((sp)->s_vnode.v_flag & VISSWAP) != 0) \
		if (--curproc->p_swlocks == 0) \
			curproc->p_flag &= ~SSWLOCKS; \
	if ((sp)->s_flag & SWANT) { \
		(sp)->s_flag &= ~SWANT; \
		wakeprocs((caddr_t)(sp), PRMPT); \
	} \
	(sp)->s_powns = NULL; \
}

/*
 * Construct a spec vnode for a given device that shadows a particular
 * "real" vnode.
 */
extern struct vnode *specvp();

/*
 * Construct a spec vnode for a given device that shadows nothing.
 */
extern struct vnode *makespecvp();

/*
 * Find any other spec vnode that refers to the same device as another vnode.
 */
extern struct vnode *other_specvp();

/*
 * Convert a device vnode pointer into a common device vnode pointer.
 */
extern struct vnode *common_specvp();

/*
 * Wait for access to a file, or signal other processes waiting for access.
 */
extern int openwait();
extern int openprivwait();
extern int setprivwait();
extern void privsig();

/* XENIX Support */
extern int spec_rdchk();
/* End XENIX Support */

/*
 * If driver does not have a size routine (e.g. old drivers), the size of the
 * device is assumed to be infinite.
 */
#define UNKNOWN_SIZE 	0x7fffffff

/*
 * Snode lookup stuff.
 * These routines maintain a table of snodes hashed by dev so
 * that the snode for an dev can be found if it already exists.
 * NOTE: STABLESIZE must be a power of 2 for STABLEHASH to work!
 */

#define	STABLESIZE	16
#define	STABLEHASH(dev)	((getmajor(dev) + getminor(dev)) & (STABLESIZE - 1))
extern struct snode *stable[];

extern struct vnodeops spec_vnodeops;

#endif	/* _FS_SNODE_H */
 070701000048a9000081240000000200000002000000012719347c0000469e000000230000000c00000000000000000000001c00000000usr/include/sys/fs/ufs_fs.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FS_UFS_FS_H
#define _SYS_FS_UFS_FS_H

#ident	"@(#)/usr/include/sys/fs/ufs_fs.h.sl 1.1 4.0 10/15/90 1720 AT&T-SF"
/*
 * Each disk drive contains some number of file systems.
 * A file system consists of a number of cylinder groups.
 * Each cylinder group has inodes and data.
 *
 * A file system is described by its super-block, which in turn
 * describes the cylinder groups.  The super-block is critical
 * data and is replicated in each cylinder group to protect against
 * catastrophic loss.  This is done at mkfs time and the critical
 * super-block data does not change, so the copies need not be
 * referenced further unless disaster strikes.
 *
 * For file system fs, the offsets of the various blocks of interest
 * are given in the super block as:
 *      [fs->fs_sblkno]         Super-block
 *      [fs->fs_cblkno]         Cylinder group block
 *      [fs->fs_iblkno]         Inode blocks
 *      [fs->fs_dblkno]         Data blocks
 * The beginning of cylinder group cg in fs, is given by
 * the ``cgbase(fs, cg)'' macro.
 *
 * The first boot and super blocks are given in absolute disk addresses.
 */
#define BBSIZE          8192
#define SBSIZE          8192
#define BBLOCK          ((daddr_t)(0))
#define SBLOCK          ((daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))

/*
 * Addresses stored in inodes are capable of addressing fragments
 * of `blocks'. File system blocks of at most size MAXBSIZE can 
 * be optionally broken into 2, 4, or 8 pieces, each of which is
 * addressible; these pieces may be DEV_BSIZE, or some multiple of
 * a DEV_BSIZE unit.
 *
 * Large files consist of exclusively large data blocks.  To avoid
 * undue wasted disk space, the last data block of a small file may be
 * allocated as only as many fragments of a large block as are
 * necessary.  The file system format retains only a single pointer
 * to such a fragment, which is a piece of a single large block that
 * has been divided.  The size of such a fragment is determinable from
 * information in the inode, using the ``blksize(fs, ip, lbn)'' macro.
 *
 * The file system records space availability at the fragment level;
 * to determine block availability, aligned fragments are examined.
 *
 * The root inode is the root of the file system.
 * Inode 0 can't be used for normal purposes and
 * historically bad blocks were linked to inode 1,
 * thus the root inode is 2. (inode 1 is no longer used for
 * this purpose, however numerous dump tapes make this
 * assumption, so we are stuck with it)
 * The lost+found directory is given the next available
 * inode when it is created by ``mkfs''.
 */
#define UFSROOTINO      ((ino_t)2)      /* i number of all roots */
#define LOSTFOUNDINO    (UFSROOTINO + 1)

/*
 * Cylinder group related limits.
 *
 * For each cylinder we keep track of the availability of blocks at different
 * rotational positions, so that we can lay out the data to be picked
 * up with minimum rotational latency.  NRPOS is the number of rotational
 * positions which we distinguish.  With NRPOS 8 the resolution of our
 * summary information is 2ms for a typical 3600 rpm drive.
 */
#define NRPOS           8       /* number distinct rotational positions */

/*
 * MAXIPG bounds the number of inodes per cylinder group, and
 * is needed only to keep the structure simpler by having the
 * only a single variable size element (the free bit map).
 *
 * N.B.: MAXIPG must be a multiple of INOPB(fs).
 */
#define MAXIPG          2048    /* max number inodes/cyl group */

/*
 * MINBSIZE is the smallest allowable block size.
 * In order to insure that it is possible to create files of size
 * 2^32 with only two levels of indirection, MINBSIZE is set to 4096.
 * MINBSIZE must be big enough to hold a cylinder group block,
 * thus changes to (struct cg) must keep its size within MINBSIZE.
 * MAXCPG is limited only to dimension an array in (struct cg);
 * it can be made larger as long as that structures size remains
 * within the bounds dictated by MINBSIZE.
 * Note that super blocks are always of size SBSIZE,
 * and that both SBSIZE and MAXBSIZE must be >= MINBSIZE.
 */
#define MINBSIZE        4096
#define MAXCPG          32      /* maximum fs_cpg */

/*
 * The path name on which the file system is mounted is maintained
 * in fs_fsmnt. MAXMNTLEN defines the amount of space allocated in 
 * the super block for this name.
 * The limit on the amount of summary information per file system
 * is defined by MAXCSBUFS. It is currently parameterized for a
 * maximum of two million cylinders.
 */
#define MAXMNTLEN 512
#define MAXCSBUFS 32

/*
 * Per cylinder group information; summarized in blocks allocated
 * from first cylinder group data blocks.  These blocks have to be
 * read in from fs_csaddr (size fs_cssize) in addition to the
 * super block.
 *
 * N.B. sizeof (struct csum) must be a power of two in order for
 * the ``fs_cs'' macro to work (see below).
 */
struct csum {
        long    cs_ndir;        /* number of directories */
        long    cs_nbfree;      /* number of free blocks */
        long    cs_nifree;      /* number of free inodes */
        long    cs_nffree;      /* number of free frags */
};

/*
 * Super block for a file system.
 */
#define FS_MAGIC        0x011954
#define FSACTIVE    0x5e72d81a  /* fs_state: mounted */
#define FSOKAY      0x7c269d38  /* fs_state: clean */
#define FSBAD       0xcb096f43  /* fs_state: bad root */
struct  fs {
        struct  fs *fs_link;            /* linked list of file systems */
        struct  fs *fs_rlink;           /*     used for incore super blocks */
        daddr_t fs_sblkno;              /* addr of super-block in filesys */
        daddr_t fs_cblkno;              /* offset of cyl-block in filesys */
        daddr_t fs_iblkno;              /* offset of inode-blocks in filesys */
        daddr_t fs_dblkno;              /* offset of first data after cg */
        long    fs_cgoffset;            /* cylinder group offset in cylinder */
        long    fs_cgmask;              /* used to calc mod fs_ntrak */
        time_t  fs_time;                /* last time written */
        long    fs_size;                /* number of blocks in fs */
        long    fs_dsize;               /* number of data blocks in fs */
        long    fs_ncg;                 /* number of cylinder groups */
        long    fs_bsize;               /* size of basic blocks in fs */
        long    fs_fsize;               /* size of frag blocks in fs */
        long    fs_frag;                /* number of frags in a block in fs */
/* these are configuration parameters */
        long    fs_minfree;             /* minimum percentage of free blocks */
        long    fs_rotdelay;            /* num of ms for optimal next block */
        long    fs_rps;                 /* disk revolutions per second */
/* these fields can be computed from the others */
        long    fs_bmask;               /* ``blkoff'' calc of blk offsets */
        long    fs_fmask;               /* ``fragoff'' calc of frag offsets */
        long    fs_bshift;              /* ``lblkno'' calc of logical blkno */
        long    fs_fshift;              /* ``numfrags'' calc number of frags */
/* these are configuration parameters */
        long    fs_maxcontig;           /* max number of contiguous blks */
        long    fs_maxbpg;              /* max number of blks per cyl group */
/* these fields can be computed from the others */
        long    fs_fragshift;           /* block to frag shift */
        long    fs_fsbtodb;             /* fsbtodb and dbtofsb shift constant */
        long    fs_sbsize;              /* actual size of super block */
        long    fs_csmask;              /* csum block offset */
        long    fs_csshift;             /* csum block number */
        long    fs_nindir;              /* value of NINDIR */
        long    fs_inopb;               /* value of INOPB */
        long    fs_nspf;                /* value of NSPF */
        long    fs_optim;               /* optimization preference, see below */
   long    fs_state;       /* fiel system state */
		   long    fs_sparecon[2];         /* reserved for future constants */

/* a unique id for this filesystem (currently unused and unmaintained) */
        long    fs_id[2];               /* file system id */
/* sizes determined by number of cylinder groups and their sizes */
        daddr_t fs_csaddr;              /* blk addr of cyl grp summary area */
        long    fs_cssize;              /* size of cyl grp summary area */
        long    fs_cgsize;              /* cylinder group size */
/* these fields should be derived from the hardware */
        long    fs_ntrak;               /* tracks per cylinder */
        long    fs_nsect;               /* sectors per track */
        long    fs_spc;                 /* sectors per cylinder */
/* this comes from the disk driver partitioning */
        long    fs_ncyl;                /* cylinders in file system */
/* these fields can be computed from the others */
        long    fs_cpg;                 /* cylinders per group */
        long    fs_ipg;                 /* inodes per group */
        long    fs_fpg;                 /* blocks per group * fs_frag */
/* this data must be re-computed after crashes */
        struct  csum fs_cstotal;        /* cylinder summary information */
/* these fields are cleared at mount time */
        char    fs_fmod;                /* super block modified flag */
        char    fs_clean;               /* file system is clean flag */
        char    fs_ronly;               /* mounted read-only flag */
        char    fs_flags;               /* currently unused flag */
        char    fs_fsmnt[MAXMNTLEN];    /* name mounted on */
/* these fields retain the current block allocation info */
        long    fs_cgrotor;             /* last cg searched */
        struct  csum *fs_csp[MAXCSBUFS];/* list of fs_cs info buffers */
        long    fs_cpc;                 /* cyl per cycle in postbl */
        short   fs_postbl[MAXCPG][NRPOS];/* head of blocks for each rotation */
        long    fs_magic;               /* magic number */
        u_char  fs_rotbl[1];            /* list of blocks for each rotation */
/* actually longer */
};

/*
 * Preference for optimization.
 */
#define FS_OPTTIME      0       /* minimize allocation time */
#define FS_OPTSPACE     1       /* minimize disk fragmentation */

/*
 * Convert cylinder group to base address of its global summary info.
 *
 * N.B. This macro assumes that sizeof (struct csum) is a power of two.
 */
#define fs_cs(fs, indx) \
        fs_csp[(indx) >> (fs)->fs_csshift][(indx) & ~(fs)->fs_csmask]

/*
 * MAXBPC bounds the size of the rotational layout tables and
 * is limited by the fact that the super block is of size SBSIZE.
 * The size of these tables is INVERSELY proportional to the block
 * size of the file system. It is aggravated by sector sizes that
 * are not powers of two, as this increases the number of cylinders
 * included before the rotational pattern repeats (fs_cpc).
 * Its size is derived from the number of bytes remaining in (struct fs)
 */
#define MAXBPC  (SBSIZE - sizeof (struct fs))

/*
 * Cylinder group block for a file system.
 */
#define CG_MAGIC        0x090255
struct  cg {
        struct  cg *cg_link;            /* linked list of cyl groups */
        struct  cg *cg_rlink;           /*     used for incore cyl groups */
        time_t  cg_time;                /* time last written */
        long    cg_cgx;                 /* we are the cgx'th cylinder group */
        short   cg_ncyl;                /* number of cyl's this cg */
        short   cg_niblk;               /* number of inode blocks this cg */
        long    cg_ndblk;               /* number of data blocks this cg */
        struct  csum cg_cs;             /* cylinder summary information */
        long    cg_rotor;               /* position of last used block */
        long    cg_frotor;              /* position of last used frag */
        long    cg_irotor;              /* position of last used inode */
        long    cg_frsum[MAXFRAG];      /* counts of available frags */
        long    cg_btot[MAXCPG];        /* block totals per cylinder */
        short   cg_b[MAXCPG][NRPOS];    /* positions of free blocks */
        char    cg_iused[MAXIPG/NBBY];  /* used inode map */
        long    cg_magic;               /* magic number */
        u_char  cg_free[1];             /* free block map */
/* actually longer */
};

/*
 * MAXBPG bounds the number of blocks of data per cylinder group,
 * and is limited by the fact that cylinder groups are at most one block.
 * Its size is derived from the size of blocks and the (struct cg) size,
 * by the number of remaining bits.
 */
#define MAXBPG(fs) \
        (fragstoblks((fs), (NBBY * ((fs)->fs_bsize - (sizeof (struct cg))))))

/*
 * Turn file system block numbers into disk block addresses.
 * This maps file system blocks to device size blocks.
 */
#define fsbtodb(fs, b)  ((b) << (fs)->fs_fsbtodb)
#define dbtofsb(fs, b)  ((b) >> (fs)->fs_fsbtodb)

/*
 * Cylinder group macros to locate things in cylinder groups.
 * They calc file system addresses of cylinder group data structures.
 */
#define cgbase(fs, c)   ((daddr_t)((fs)->fs_fpg * (c)))
#define cgstart(fs, c) \
        (cgbase(fs, c) + (fs)->fs_cgoffset * ((c) & ~((fs)->fs_cgmask)))
#define cgsblock(fs, c) (cgstart(fs, c) + (fs)->fs_sblkno)      /* super blk */
#define cgtod(fs, c)    (cgstart(fs, c) + (fs)->fs_cblkno)      /* cg block */
#define cgimin(fs, c)   (cgstart(fs, c) + (fs)->fs_iblkno)      /* inode blk */
#define cgdmin(fs, c)   (cgstart(fs, c) + (fs)->fs_dblkno)      /* 1st data */

/*
 * Macros for handling inode numbers:
 *     inode number to file system block offset.
 *     inode number to cylinder group number.
 *     inode number to file system block address.
 */
#define itoo(fs, x)     ((x) % (u_long)INOPB(fs))
#define itog(fs, x)     ((x) / (u_long)(fs)->fs_ipg)
#define itod(fs, x) \
        ((daddr_t)(cgimin(fs, itog(fs, x)) + \
        (blkstofrags((fs), (((x) % (u_long)(fs)->fs_ipg) / (u_long)INOPB(fs))))))

/*
 * Give cylinder group number for a file system block.
 * Give cylinder group block number for a file system block.
 */
#define dtog(fs, d)     ((d) / (fs)->fs_fpg)
#define dtogd(fs, d)    ((d) % (fs)->fs_fpg)

/*
 * Extract the bits for a block from a map.
 * Compute the cylinder and rotational position of a cyl block addr.
 */
#define blkmap(fs, map, loc) \
    (((map)[(loc) / NBBY] >> ((loc) % NBBY)) & (0xff >> (NBBY - (fs)->fs_frag)))
#define cbtocylno(fs, bno) \
    ((bno) * NSPF(fs) / (fs)->fs_spc)
#define cbtorpos(fs, bno) \
    ((bno) * NSPF(fs) % (fs)->fs_spc % (fs)->fs_nsect * NRPOS / (fs)->fs_nsect)

/*
 * The following macros optimize certain frequently calculated
 * quantities by using shifts and masks in place of divisions
 * modulos and multiplications.
 */
#define blkoff(fs, loc)         /* calculates (loc % fs->fs_bsize) */ \
        ((loc) & ~(fs)->fs_bmask)
#define fragoff(fs, loc)        /* calculates (loc % fs->fs_fsize) */ \
        ((loc) & ~(fs)->fs_fmask)
#define lblkno(fs, loc)         /* calculates (loc / fs->fs_bsize) */ \
        ((loc) >> (fs)->fs_bshift)
#define numfrags(fs, loc)       /* calculates (loc / fs->fs_fsize) */ \
        ((loc) >> (fs)->fs_fshift)
#define blkroundup(fs, size)    /* calculates roundup(size, fs->fs_bsize) */ \
        (((size) + (fs)->fs_bsize - 1) & (fs)->fs_bmask)
#define fragroundup(fs, size)   /* calculates roundup(size, fs->fs_fsize) */ \
        (((size) + (fs)->fs_fsize - 1) & (fs)->fs_fmask)
#define fragstoblks(fs, frags)  /* calculates (frags / fs->fs_frag) */ \
        ((frags) >> (fs)->fs_fragshift)
#define blkstofrags(fs, blks)   /* calculates (blks * fs->fs_frag) */ \
        ((blks) << (fs)->fs_fragshift)
#define fragnum(fs, fsb)        /* calculates (fsb % fs->fs_frag) */ \
        ((fsb) & ((fs)->fs_frag - 1))
#define blknum(fs, fsb)         /* calculates rounddown(fsb, fs->fs_frag) */ \
        ((fsb) &~ ((fs)->fs_frag - 1))

/*
 * Determine the number of available frags given a
 * percentage to hold in reserve
 */
#define freespace(fs, percentreserved) \
        (blkstofrags((fs), (fs)->fs_cstotal.cs_nbfree) + \
        (fs)->fs_cstotal.cs_nffree - ((fs)->fs_dsize * (percentreserved) / 100))

/*
 * Determining the size of a file block in the file system.
 */
#define blksize(fs, ip, lbn) \
        (((lbn) >= NDADDR || (ip)->i_size >= ((lbn) + 1) << (fs)->fs_bshift) \
            ? (fs)->fs_bsize \
            : (fragroundup(fs, blkoff(fs, (ip)->i_size))))
#define dblksize(fs, dip, lbn) \
        (((lbn) >= NDADDR || (dip)->di_size >= ((lbn) + 1) << (fs)->fs_bshift) \
            ? (fs)->fs_bsize \
            : (fragroundup(fs, blkoff(fs, (dip)->di_size))))

/*
 * Number of disk sectors per block; assumes DEV_BSIZE byte sector size.
 */
#define NSPB(fs)        ((fs)->fs_nspf << (fs)->fs_fragshift)
#define NSPF(fs)        ((fs)->fs_nspf)

/*
 * INOPB is the number of inodes in a secondary storage block.
 */
#define INOPB(fs)       ((fs)->fs_inopb)
#define INOPF(fs)       ((fs)->fs_inopb >> (fs)->fs_fragshift)

/*
 * NINDIR is the number of indirects in a file system block.
 */
#define NINDIR(fs)      ((fs)->fs_nindir)

/* casts to keep lint happy */
#define insque(q,p)     _insque((caddr_t)q,(caddr_t)p)
#define remque(q)       _remque((caddr_t)q)

/*
 * bit map related macros
 */
#define setbit(a,i)     ((a)[(i)/NBBY] |= 1<<((i)%NBBY))
#define clrbit(a,i)     ((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
#define isset(a,i)      ((a)[(i)/NBBY] & (1<<((i)%NBBY)))
#define isclr(a,i)      (((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)

#define getfs(vfsp) ((struct fs *)((struct ufsvfs *)vfsp->vfs_data)->vfs_bufp->b_un.b_addr)

#endif /* _SYS_FS_UFS_FS_H */
  070701000048aa000081240000000200000002000000012719347c00000b59000000230000000c00000000000000000000001f00000000usr/include/sys/fs/ufs_fsdir.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FS_UFS_FSDIR_H
#define _SYS_FS_UFS_FSDIR_H

#ident	"@(#)/usr/include/sys/fs/ufs_fsdir.h.sl 1.1 4.0 10/15/90 52243 AT&T-SF"
/*
 * A directory consists of some number of blocks of DIRBLKSIZ
 * bytes, where DIRBLKSIZ is chosen such that it can be transferred
 * to disk in a single atomic operation (e.g. 512 bytes on most machines).
 *
 * Each DIRBLKSIZ byte block contains some number of directory entry
 * structures, which are of variable length.  Each directory entry has
 * a struct direct at the front of it, containing its inode number,
 * the length of the entry, and the length of the name contained in
 * the entry.  These are followed by the name padded to a 4 byte boundary
 * with null bytes.  All names are guaranteed null terminated.
 * The maximum length of a name in a directory is MAXNAMLEN.
 *
 * The macro DIRSIZ(dp) gives the amount of space required to represent
 * a directory entry.  Free space in a directory is represented by
 * entries which have dp->d_reclen > DIRSIZ(dp).  All DIRBLKSIZ bytes
 * in a directory block are claimed by the directory entries.  This
 * usually results in the last entry in a directory having a large
 * dp->d_reclen.  When entries are deleted from a directory, the
 * space is returned to the previous entry in the same directory
 * block by increasing its dp->d_reclen.  If the first entry of
 * a directory block is free, then its dp->d_ino is set to 0.
 * Entries other than the first in a directory do not normally have
 * dp->d_ino set to 0.
 */
#define DIRBLKSIZ	DEV_BSIZE
#define	MAXNAMLEN	255

struct	direct {
	u_long	d_ino;			/* inode number of entry */
	u_short	d_reclen;		/* length of this record */
	u_short	d_namlen;		/* length of string in d_name */
	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
};

/*
 * The DIRSIZ macro gives the minimum record length which will hold
 * the directory entry.  This requires the amount of space in struct direct
 * without the d_name field, plus enough space for the name with a terminating
 * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
 */
#undef DIRSIZ
#define DIRSIZ(dp) \
    ((sizeof (struct direct) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))

#ifdef _KERNEL
/*
 * Template for manipulating directories.
 * Should use struct direct's, but the name field
 * is MAXNAMLEN - 1, and this just won't do.
 */
struct dirtemplate {
	u_long	dot_ino;
	short	dot_reclen;
	short	dot_namlen;
	char	dot_name[4];		/* must be multiple of 4 */
	u_long	dotdot_ino;
	short	dotdot_reclen;
	short	dotdot_namlen;
	char	dotdot_name[4];		/* ditto */
};
#endif

#endif /* _SYS_FS_UFS_FSDIR_H */
   070701000048ab000081240000000200000002000000012719347c00002a2f000000230000000c00000000000000000000001f00000000usr/include/sys/fs/ufs_inode.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/fs/ufs_inode.h.sl 1.1 4.0 10/15/90 16886 AT&T-SF"

#ifndef _SYS_FS_UFS_INODE_H
#define _SYS_FS_UFS_INODE_H



/*
 * The I node is the focus of all local file activity in UNIX.
 * There is a unique inode allocated for each active file,
 * each current directory, each mounted-on file, each mapping,
 * and the root.  An inode is `named' by its dev/inumber pair.
 * Data in icommon is read in from permanent inode on volume.
 */

#define EFT_MAGIC 0x90909090	/* magic cookie for EFT */
#define	NDADDR	12		/* direct addresses in inode */
#define	NIADDR	3		/* indirect addresses in inode */

struct inode {
	struct	inode *i_chain[2];	/* must be first */
	struct	vnode i_vnode;	/* vnode associated with this inode */
	struct	vnode *i_devvp;	/* vnode for block I/O */
	u_short	i_flag;
	dev_t	i_dev;		/* device where inode resides */
	ino_t	i_number;	/* i number, 1-to-1 with device address */
	off_t	i_diroff;	/* offset in dir, where we found last entry */
	struct	fs *i_fs;	/* file sys associated with this inode */
	struct	dquot *i_dquot;	/* quota structure controlling this file */
	short	i_owner;	/* proc index of process locking inode */
	short	i_count;	/* number of inode locks for i_owner */
	daddr_t	i_nextr;	/* next byte read offset (read-ahead) */
	struct inode  *i_freef;	/* free list forward */
	struct inode **i_freeb;	/* free list back */
	ulong	i_vcode;	/* version code attribute */
	long	i_mapcnt;	/* mappings to file pages */
	int	*i_map;		/* block list for the corresponding file */
	struct 	icommon {
		o_mode_t ic_smode;	/*  0: mode and type of file */
		short	ic_nlink;	/*  2: number of links to file */
		o_uid_t	ic_suid;		/*  4: owner's user id */
		o_gid_t	ic_sgid;		/*  6: owner's group id */
		quad	ic_size;	/*  8: number of bytes in file */
#ifdef _KERNEL
		struct timeval ic_atime;/* 16: time last accessed */
		struct timeval ic_mtime;/* 24: time last modified */
		struct timeval ic_ctime;/* 32: last time inode changed */
#else
		time_t	ic_atime;	/* 16: time last accessed */
		long	ic_atspare;
		time_t	ic_mtime;	/* 24: time last modified */
		long	ic_mtspare;
		time_t	ic_ctime;	/* 32: last time inode changed */
		long	ic_ctspare;
#endif
		daddr_t	ic_db[NDADDR];	/* 40: disk block addresses */
		daddr_t	ic_ib[NIADDR];	/* 88: indirect blocks */
		long	ic_flags;	/* 100: status, currently unused */
		long	ic_blocks;	/* 104: blocks actually held */
		long	ic_gen;		/* 108: generation number */
		mode_t	ic_mode;	/* 112: EFT version of mode*/
		uid_t	ic_uid;		/* 116: EFT version of uid */
		gid_t	ic_gid;		/* 120: EFT version of gid */
		ulong	ic_eftflag;	/* 124: indicate EFT version*/

	} i_ic;
};

struct dinode {
	union {
		struct	icommon di_icom;
		char	di_size[128];
	} di_un;
};
#define i_mode		i_ic.ic_mode
#define	i_nlink		i_ic.ic_nlink
#define i_uid		i_ic.ic_uid
#define i_gid		i_ic.ic_gid
#define i_smode		i_ic.ic_smode
#define i_suid		i_ic.ic_suid
#define i_sgid		i_ic.ic_sgid
#define i_eftflag	i_ic.ic_eftflag

/* ugh! -- must be fixed */
#if defined(vax) || defined(i386)
#define	i_size		i_ic.ic_size.val[0]
#endif
#if defined(mc68000) || defined(sparc) || defined(u3b2) || defined(u3b15)
#define	i_size		i_ic.ic_size.val[1]
#endif
#define	i_db		i_ic.ic_db
#define	i_ib		i_ic.ic_ib

#define	i_atime		i_ic.ic_atime
#define	i_mtime		i_ic.ic_mtime
#define	i_ctime		i_ic.ic_ctime

#define i_blocks	i_ic.ic_blocks
#define	i_oldrdev	i_ic.ic_db[0]
#define	i_rdev		i_ic.ic_db[1]
#define	i_gen		i_ic.ic_gen
#define	i_forw		i_chain[0]
#define	i_back		i_chain[1]

#define di_ic		di_un.di_icom
#define	di_mode		di_ic.ic_mode
#define	di_nlink	di_ic.ic_nlink
#define	di_uid		di_ic.ic_uid
#define	di_gid		di_ic.ic_gid
#define di_smode	di_ic.ic_smode
#define di_suid		di_ic.ic_suid
#define di_sgid		di_ic.ic_sgid
#define di_eftflag	di_ic.ic_eftflag

#if defined(vax) || defined(i386)
#define	di_size		di_ic.ic_size.val[0]
#endif
#if defined(mc68000) || defined(sparc) || defined(u3b2) || defined(u3b15)
#define	di_size		di_ic.ic_size.val[1]
#endif
#define	di_db		di_ic.ic_db
#define	di_ib		di_ic.ic_ib

#define	di_atime	di_ic.ic_atime
#define	di_mtime	di_ic.ic_mtime
#define	di_ctime	di_ic.ic_ctime

#define	di_oldrdev	di_ic.ic_db[0]
#define	di_rdev		di_ic.ic_db[1]
#define	di_blocks	di_ic.ic_blocks
#define	di_gen		di_ic.ic_gen

/* flags */
#define	ILOCKED		0x001		/* inode is locked */
#define	IUPD		0x002		/* file has been modified */
#define	IACC		0x004		/* inode access time to be updated */
#define	IMOD		0x008		/* inode has been modified */
#define	IWANT		0x010		/* some process waiting on lock */
#define	ISYNC		0x020		/* do all allocation synchronously */
#define	ICHG		0x040		/* inode has been changed */
#define	ILWAIT		0x080		/* someone waiting on file lock */
#define	IREF		0x100		/* inode is being referenced */
#define	INOACC		0x200		/* no access time update in getpage */
#define	IMODTIME	0x400		/* mod time already set */
#define	IINACTIVE	0x800		/* inode is inactive */
#define	IRWLOCKED	0x1000		/* inode is rwlocked */

/* modes */
#define	IFMT		0170000		/* type of file */
#define	IFIFO		0010000		/* named pipe (fifo) */
#define	IFCHR		0020000		/* character special */
#define	IFDIR		0040000		/* directory */
#define	IFBLK		0060000		/* block special */
#define	IFREG		0100000		/* regular */
#define	IFLNK		0120000		/* symbolic link */
#define	IFSOCK		0140000		/* socket */

#define	ISUID		04000		/* set user id on execution */
#define	ISGID		02000		/* set group id on execution */
#define	ISVTX		01000		/* save swapped text even after use */
#define	IREAD		0400		/* read, write, execute permissions */
#define	IWRITE		0200
#define	IEXEC		0100


#ifdef _KERNEL
struct inode *ufs_inode;		/* the inode table itself */
struct inode *inodeNINODE;		/* the end of the inode table */
extern int ufs_ninode;			/* number of slots in the table */

extern struct vnodeops ufs_vnodeops;	/* vnode operations for ufs */

extern ino_t dirpref();
extern daddr_t blkpref();

/*
 * A struct fbuf is used to get a mapping to part of a file using the
 * segkmap facilities.  After you get a mapping, you can fbrelse() it
 * (giving a seg code to pass back to segmap_release), you can fbwrite()
 * it (causes a synchronous write back using inode mapping information),
 * or you can fbiwrite it (causing indirect synchronous write back to
 * the block number given without using inode mapping information).
 */

struct fbuf {
	addr_t	fb_addr;
	u_int	fb_count;
};

extern int fbread(/* vp, off, len, rw, fbpp */);
extern void fbzero(/* vp, off, len, fbpp */);
extern int fbwrite(/* fb */);
extern int fbiwrite(/* fb, ip, bn */);
extern void fbrelse(/* fb, rw */);

/*
 * Convert between inode pointers and vnode pointers
 */
#define VTOI(VP)	((struct inode *)(VP)->v_data)
#define ITOV(IP)	((struct vnode *)&(IP)->i_vnode)

#ifdef notneeded
Look at sys/mode.h and os/vnode.c
/*
 * Convert between vnode types and inode formats
 */
extern enum vtype	iftovt_tab[];
extern int		vttoif_tab[];
#define IFTOVT(M)	(iftovt_tab[((M) & IFMT) >> 13])
#define VTTOIF(T)	(vttoif_tab[(int)(T)])

#define MAKEIMODE(T, M)	(VTTOIF(T) | (M))
#endif

/*
 * Lock and unlock inodes.
 */
#define	IRWLOCK(ip) { \
	while ((ip)->i_flag & IRWLOCKED) { \
		(ip)->i_flag |= IWANT; \
		(void) sleep((caddr_t)(ip), PINOD); \
	} \
	(ip)->i_flag |= IRWLOCKED; \
	if (((ip)->i_vnode.v_flag & VISSWAP) != 0){ \
		curproc->p_swlocks++;	\
		curproc->p_flag |= SSWLOCKS;\
	} \
}

#define	IRWUNLOCK(ip) { \
	ASSERT((ip)->i_flag & IRWLOCKED); \
	if (((ip)->i_vnode.v_flag & VISSWAP) != 0) \
		if (--curproc->p_swlocks == 0)  \
			curproc->p_flag &= ~SSWLOCKS; \
	(ip)->i_flag &= ~IRWLOCKED; \
	if ((ip)->i_flag & IWANT) { \
		(ip)->i_flag &= ~IWANT; \
		wakeprocs((caddr_t)(ip), PRMPT); \
	} \
}

#define	ILOCK(ip) { \
	while (((ip)->i_flag & ILOCKED) && \
	    (ip)->i_owner != curproc->p_slot) { \
		(ip)->i_flag |= IWANT; \
		(void) sleep((caddr_t)(ip), PINOD); \
	} \
	(ip)->i_owner = curproc->p_slot; \
	(ip)->i_count++; \
	(ip)->i_flag |= ILOCKED; \
	if (((ip)->i_vnode.v_flag & VISSWAP) != 0){ \
		curproc->p_swlocks++;	\
		curproc->p_flag |= SSWLOCKS;\
	} \
}

#define	IUNLOCK(ip) { \
	if (--(ip)->i_count < 0) \
		panic("IUNLOCK"); \
	if (((ip)->i_vnode.v_flag & VISSWAP) != 0) \
		if (--curproc->p_swlocks == 0)  \
			curproc->p_flag &= ~SSWLOCKS; \
	if ((ip)->i_count == 0) { \
		(ip)->i_flag &= ~ILOCKED; \
		if ((ip)->i_flag & IWANT) { \
			(ip)->i_flag &= ~IWANT; \
			wakeprocs((caddr_t)(ip), PRMPT); \
		} \
	} \
}

#define IUPDAT(ip, waitfor) { \
	if (ip->i_flag & (IUPD|IACC|ICHG|IMOD)) \
		ufs_iupdat(ip, waitfor); \
}

/*
 * Mark an inode with the current (unique) timestamp.
 */
struct timeval iuniqtime;

#define IMARK(ip) { \
	if (hrestime.tv_sec > iuniqtime.tv_sec || \
		hrestime.tv_nsec/1000 > iuniqtime.tv_usec) { \
		iuniqtime.tv_sec = hrestime.tv_sec; \
		iuniqtime.tv_usec = hrestime.tv_nsec/1000; \
	} else { \
		iuniqtime.tv_usec++; \
	} \
	if ((ip)->i_flag & IACC) \
		(ip)->i_atime = iuniqtime; \
	if ((ip)->i_flag & IUPD) { \
		(ip)->i_mtime = iuniqtime; \
		(ip)->i_flag |= IMODTIME; \
	} \
	if ((ip)->i_flag & ICHG) { \
		ip->i_diroff = 0; \
		(ip)->i_ctime = iuniqtime; \
	} \
}

#define ITIMES(ip) { \
	if ((ip)->i_flag & (IUPD|IACC|ICHG)) { \
		(ip)->i_flag |= IMOD; \
		IMARK(ip); \
		(ip)->i_flag &= ~(IACC|IUPD|ICHG); \
	} \
}

/*
 * Allocate the specified block in the inode
 * and make sure any in-core pages are initialized.
 */
#define	BMAPALLOC(ip, lbn, size) \
	ufs_bmap((ip), (lbn), (daddr_t *)NULL, (daddr_t *)NULL, (size), S_WRITE, 0)

#define ESAME	(-1)		/* trying to rename linked files (special) */

/*
 * Check that file is owned by current user or user is su.
 */
#define OWNER(CR, IP)	(((CR)->cr_uid == (IP)->i_uid)? 0: (suser(CR)? 0: EPERM))

#define	UFS_HOLE	(daddr_t)-1	/* value used when no block allocated */

/*
 * enums
 */
enum de_op	{ DE_CREATE, DE_MKDIR, DE_LINK, DE_RENAME };	/* direnter ops */
enum dr_op	{ DR_REMOVE, DR_RMDIR, DR_RENAME };	/* dirremove ops */

/*
 * This overlays the fid structure (see vfs.h)
 */
struct ufid {
	u_short	ufid_len;
	ino_t	ufid_ino;
	long	ufid_gen;
};

/*
 * UFS VFS private data.
 */
struct ufsvfs {
	struct vnode	*vfs_root;	/* root vnode */
	struct buf	*vfs_bufp;	/* buffer containing superblock */
	struct vnode	*vfs_devvp;	/* block device vnode */
	struct inode	*vfs_qinod;	/* QUOTA: pointer to quota file */
	u_short		vfs_qflags;	/* QUOTA: filesystem flags */
	u_long		vfs_btimelimit;	/* QUOTA: block time limit */
	u_long		vfs_ftimelimit;	/* QUOTA: file time limit */
};

#endif

#endif /* _SYS_FS_UFS_INODE_H */
 070701000048ac000081240000000200000002000000012719347c00001401000000230000000c00000000000000000000001f00000000usr/include/sys/fs/ufs_quota.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FS_UFS_QUOTA_H
#define _SYS_FS_UFS_QUOTA_H

#ident	"@(#)/usr/include/sys/fs/ufs_quota.h.sl 1.1 4.0 10/15/90 40451 AT&T-SF"

/*
 * The following constants define the default amount of time given a user
 * before the soft limits are treated as hard limits (usually resulting
 * in an allocation failure). These may be  modified by the quotactl
 * system call with the Q_SETQLIM or Q_SETQUOTA commands.
 */

#define DQ_FTIMELIMIT   (7 * 24*60*60)          /* 1 week */
#define DQ_BTIMELIMIT   (7 * 24*60*60)          /* 1 week */

/*
 * The dqblk structure defines the format of the disk quota file
 * (as it appears on disk) - the file is an array of these structures
 * indexed by user number.  The setquota sys call establishes the inode
 * for each quota file (a pointer is retained in the mount structure).
 */

struct  dqblk {
        u_long  dqb_bhardlimit; /* absolute limit on disk blks alloc */
        u_long  dqb_bsoftlimit; /* preferred limit on disk blks */
        u_long  dqb_curblocks;  /* current block count */
        u_long  dqb_fhardlimit; /* maximum # allocated files + 1 */
        u_long  dqb_fsoftlimit; /* preferred file limit */
        u_long  dqb_curfiles;   /* current # allocated files */
        u_long  dqb_btimelimit; /* time limit for excessive disk use */
        u_long  dqb_ftimelimit; /* time limit for excessive files */
};

#define dqoff(UID)      ((off_t)((UID) * sizeof(struct dqblk)))

/*
 * The dquot structure records disk usage for a user on a filesystem.
 * There is one allocated for each quota that exists on any filesystem
 * for the current user. A cache is kept of recently used entries.
 * Active inodes have a pointer to the dquot associated with them.
 */
struct  dquot {
        struct  dquot *dq_forw, *dq_back;/* hash list, MUST be first entry */
        struct  dquot *dq_freef, *dq_freeb; /* free list */
        short   dq_flags;
#define DQ_LOCKED       0x01            /* locked for I/O */
#define DQ_WANT         0x02            /* wanted */
#define DQ_MOD          0x04            /* this quota modified since read */
#define DQ_BLKS         0x10            /* has been warned about blk limit */
#define DQ_FILES        0x20            /* has been warned about file limit */
        short   dq_cnt;                 /* count of active references */
        uid_t   dq_uid;                 /* user this applies to */
        struct ufsvfs *dq_ufsvfsp;            /* filesystem this relates to */
        struct dqblk dq_dqb;            /* actual usage & quotas */
};

#define dq_bhardlimit   dq_dqb.dqb_bhardlimit
#define dq_bsoftlimit   dq_dqb.dqb_bsoftlimit
#define dq_curblocks    dq_dqb.dqb_curblocks
#define dq_fhardlimit   dq_dqb.dqb_fhardlimit
#define dq_fsoftlimit   dq_dqb.dqb_fsoftlimit
#define dq_curfiles     dq_dqb.dqb_curfiles
#define dq_btimelimit   dq_dqb.dqb_btimelimit
#define dq_ftimelimit   dq_dqb.dqb_ftimelimit

/*
 * flags for m_qflags in mount struct
 */
#define MQ_ENABLED      0x01            /* quotas are enabled */

#if defined(_KERNEL) && defined(QUOTA)
struct  dquot *dquot, *dquotNDQUOT;
extern int      ndquot;

extern void qtinit();                   /* initialize quota system */
extern struct dquot *getinoquota();     /* establish quota for an inode */
extern int chkdq();                     /* check disk block usage */
extern int chkiq();                     /* check inode usage */
extern void dqrele();                   /* release dquot */
extern int closedq();                   /* close quotas */

extern int getdiskquota();              /* get dquot for uid on filesystem */
extern void dqput();                    /* release locked dquot */
extern void dqupdate();                 /* update dquot on disk */

#define DQLOCK(dqp) { \
        while ((dqp)->dq_flags & DQ_LOCKED) { \
                (dqp)->dq_flags |= DQ_WANT; \
                (void) sleep((caddr_t)(dqp), PINOD+1); \
        } \
        (dqp)->dq_flags |= DQ_LOCKED; \
}

#define DQUNLOCK(dqp) { \
        (dqp)->dq_flags &= ~DQ_LOCKED; \
        if ((dqp)->dq_flags & DQ_WANT) { \
                (dqp)->dq_flags &= ~DQ_WANT; \
				wakeprocs((caddr_t)(dqp), PRMPT); \
        } \
}
#endif

/*
 * Definitions for the 'quotactl' system call.
 */
#define Q_QUOTAON       1       /* turn quotas on */
#define Q_QUOTAOFF      2       /* turn quotas off */
#define Q_SETQUOTA      3       /* set disk limits & usage */
#define Q_GETQUOTA      4       /* get disk limits & usage */
#define Q_SETQLIM       5       /* set disk limits only */
#define Q_SYNC          6       /* update disk copy of quota usages */
#define Q_ALLSYNC       7       /* update disk copy of quota usages for all fs*/

struct quotctl {
        int     op;
        uid_t   uid;
        caddr_t addr;
};
#define Q_QUOTACTL	0x00030189	/* ioctl command for quotactl */
#endif /* _SYS_FS_UFS_QUOTA_H */
   070701000048ad000081240000000200000002000000012719347c00000f28000000230000000c00000000000000000000001e00000000usr/include/sys/fs/xnamnode.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _FS_XNAMNODE_H
#define _FS_XNAMNODE_H

#ident	"@(#)/usr/include/sys/fs/xnamnode.h.sl 1.1 4.0 10/15/90 56520 AT&T-SF"
/*
 * The xnamnode represents a special XENIX file in any filesystem.  There is
 * one xnamnode for each active special XENIX file.  Filesystems that support
 * special files use xnamvp(vp, dev, type, cr) to convert a normal
 * vnode to a special vnode in the ops lookup() and create().
 *
 */

struct xsem {			/* XENIX semaphore */
	short  x_scount;	/* current semaphore count */
	short  x_eflag;		/* err flg */
	struct file *x_headw;	/* first waiter */
	struct file *x_tailw;	/* last waiter */
};

struct xsd {               /* XENIX shared data */
	union {
		struct xsd *x_chain; /* next available shared data structure */
		struct anon_map *xamp;  /* Pointer to shared data segment */
	} x_sun;
	unsigned x_len;	     /* limit of segment (seg size - 1) */
	short    x_snum;         /* serial # for sdgetv, sdwaitv */
	short    x_flags;        /* LOCKED, etc. */
}; 


struct xnamnode {
	struct	xnamnode *x_next;		/* must be first */
	struct	vnode x_vnode;		/* vnode associated with this xnamnode */
	struct	vnode *x_realvp;	/* vnode for the fs entry (if any) */
	ushort	x_flag;			/* flags, see below */
	dev_t	x_dev;			/* device the xnamnode represents */
	dev_t	x_fsid;			/* file system identifier */
	daddr_t	x_nextr;		/* next byte read offset (read-ahead) */
	long	x_size;			/* block device size in bytes */
	time_t  x_atime;		/* time of last access */
	time_t  x_mtime;		/* time of last modification */
	time_t  x_ctime;		/* time of last attributes change */
	int	x_count;		/* count of opened references */
	mode_t	x_mode;			/* file mode and type */
	uid_t	x_uid;			/* owner */
	gid_t	x_gid;			/* group */
	union x_u {
		struct  xsem *xsem;	/* ptr to XENIX semaphores */
		struct  xsd *xsd;	/* ptr to XENIX semaphores */
	} x_un;
	struct proc *x_powns;		/* XXX vm debugging */
};

#define x_sem	x_un.xsem	/* for v_type==VXNAM && v_rdev==XNAM_SEM */
#define x_sd	x_un.xsd	/* for v_type==VXNAM && v_rdev==XNAM_SD */

/* flags */
#define XNAMLOCKED		0x01		/* xnamnode is locked */
#define XNAMUPD		0x02		/* update device access time */
#define XNAMACC		0x04		/* update device modification time */
#define XNAMWANT		0x10		/* some process waiting on lock */
#define XNAMCHG		0x40		/* update device change time */

/* XENIX semaphore sub-types */
#define	XNAM_SEM		0x01
#define	XNAM_SD			0x02

/*
 * Convert between vnode and xnamnode
 */
#define	VTOXNAM(vp)	((struct xnamnode *)((vp)->v_data))
#define	XNAMTOV(xp)	(&(xp)->x_vnode)

extern struct proc *curproc;	/* XXX vm debugging */
/*
 * Lock and unlock xnamnodes.
 */
#define XNAMNLOCK(xp) { \
	while ((xp)->x_flag & XNAMLOCKED) { \
		(xp)->x_flag |= XNAMWANT; \
		(void) sleep((caddr_t)(xp), PINOD); \
	} \
	(xp)->x_flag |= XNAMLOCKED; \
	if (((xp)->x_vnode.v_flag & VISSWAP) != 0) { \
		curproc->p_swlocks++; \
		curproc->p_flag |= SSWLOCKS; \
	} \
	(xp)->x_powns = curproc; \
}

#define XNAMNUNLOCK(xp) { \
	(xp)->x_flag &= ~XNAMLOCKED; \
	if (((xp)->x_vnode.v_flag & VISSWAP) != 0) \
		if (--curproc->p_swlocks == 0) \
			curproc->p_flag &= ~SSWLOCKS; \
	if ((xp)->x_flag & XNAMWANT) { \
		(xp)->x_flag &= ~XNAMWANT; \
		wakeprocs((caddr_t)(xp), PRMPT); \
	} \
	(xp)->x_powns = NULL; \
}

/*
 * Construct an xnam vnode for a given device that shadows a particular
 * "real" vnode.
 */
extern struct vnode *xnamvp();


/*
 * Xnamnode lookup stuff.
 * These routines maintain a table of xnamnodes.
 */

#define	XNAMTABLESIZE	2
extern struct xnamnode *xnamtable[];

extern struct vnodeops xnam_vnodeops;

#endif	/* _FS_XNAMNODE_H */
07070100005987000081240000000200000002000000012719347c00000570000000230000000c00000000000000000000001a00000000usr/include/sys/fsiboot.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FSIBOOT_H
#define _SYS_FSIBOOT_H

#ident	"@(#)/usr/include/sys/fsiboot.h.sl 1.1 4.0 10/15/90 33863 AT&T-SF"
#define FFSO	18	/* File system offset on floppy disk */
#define LBOOT "mUNIX"   /* The configuration program (Operating system) */
#define UNIX "unix"     /* The default AUTOBOOT program */
#define DGMON "dgmon"   	/* If either of these are being AUTOBOOTED, */
#define FILLEDT "filledt"	/* don't check for reconfig */
#define SYSTEM "system"   /* Used to compare dates */
#define AUBOOT "auto boot" 	/* auto boot after root fail to remount */
#define HMAJOR 1
#define TRUE (char)1
#define FALSE (char)0
#define FMAJOR 2
#define BSIZE 512
#define SECTSIZE 512
#define FASTBOOT "fast boot"
#define MYVTOC ((struct vtoc *) (BOOTADDR + BSIZE))
#define MYPDINFO ((struct pdinfo *)(BOOTADDR + 2 * BSIZE))
#define	restart() { RST=1; for (;;) ; }
#define MAGICMODE "magic mode"

#define S3BC_TCDRV	0x10	/* EDT name[] is a TC driver; board code is the
 				 * major number of this TC.
 				 */
#define EDT_START	P_EDT	/* origin of EDT */

struct badblock {
	long bad;
	long good;
};


#endif	/* _SYS_FSIBOOT_H */
07070100005988000081240000000200000002000000012719347c00000304000000230000000c00000000000000000000001700000000usr/include/sys/fsid.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FSID_H
#define _SYS_FSID_H

#ident	"@(#)/usr/include/sys/fsid.h.sl 1.1 4.0 10/15/90 22972 AT&T-SF"

/* Fstyp names for use in fsinfo structure. These names */
/* must be constant across releases and will be used by a */
/* user level routine to map fstyp to fstyp index as used */
/* ip->i_fstyp. This is necessary for programs like mount. */

#define S51K	"S51K"
#define PROC	"PROC"
#define DUFST	"DUFST"
#define NFS		"NFS"
#define S52K	"S52K"
#define XENIX	"XENIX"

#endif	/* _SYS_FSID_H */
07070100005989000081240000000200000002000000012719347c000002fe000000230000000c00000000000000000000001800000000usr/include/sys/fstyp.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_FSTYP_H
#define _SYS_FSTYP_H

#ident	"@(#)/usr/include/sys/fstyp.h.sl 1.1 4.0 10/15/90 42053 AT&T-SF"

#define FSTYPSZ		16	/* max size of fs identifier */

/*
 * Opcodes for the sysfs() system call.
 */
#define GETFSIND	1	/* translate fs identifier to fstype index */
#define GETFSTYP	2	/* translate fstype index to fs identifier */
#define GETNFSTYP	3	/* return the number of fstypes */

#if defined(__STDC__) && !defined(_KERNEL)
int sysfs(int, ...);
#endif

#endif	/* _SYS_FSTYP_H */
  0707010000598a000081240000000200000002000000012719347c000007a3000000230000000c00000000000000000000001900000000usr/include/sys/gdpstr.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_GDPSTR_H
#define _SYS_GDPSTR_H

#ident	"@(#)/usr/include/sys/gdpstr.h.sl 1.1 4.0 10/15/90 50057 AT&T-SF"
/*  
 *	commands for virtual circuits set up 
 */

#define PM_DATA		0
#define	PM_LISTEN	1
#define	PM_CONNECT	2
#define	PM_ACCEPT	3
#define	PM_DISCONNECT	4

/*  
 *	reason for disconnect
 */

#define	VC_REJECT	1	/* reject a conection request */
#define	VC_CLOSE	2	/* closed by the other end */
#define	VC_CONNFAIL	3	/* fail to contact remote side */
#define	VC_LINKDOWN	4	/* link down */
#define VC_NORMAL	6	/* normal disconnect link not needed */

/*  
 *	messages passed from the upper modules  
 *	to the protocol module 
 */

/*  connection request */

struct	pm_connect {
	naddr_t	dstnadr;	/* destination network address */
	ushort	dstmdev;	/* destination minor device number */
	ushort	nretry;		/* number of retries for set up */
	ushort	interval;	/* time interval between retries */
};


/*  accept the connection request */

struct	pm_accept {
	naddr_t	dstnadr;	/* destination network address */
	ushort	dstmdev;	/* destination minor device number */
	ushort	respmdev;	/* responding minor device number */
};


/*  reject the connection request or 
    disconnect a virtual circuit */

struct	pm_disconnect {
	naddr_t	dstnadr;	/* destination network address */
	ushort	dstmdev;	/* destination minor device number */
	short	reason;		/* reason for disconnect */
};


/*  
 *	messages returned from the protocol module
 *	to the upper modules  
 */

struct	resp_msg {
	short	cmd;		/* command */
	short	reason;		/* reason for disconnect */
	naddr_t	srcnadr;	/* source network address */
	ushort	srcmdev;	/* source minor device number */
};

#endif	/* _SYS_GDPSTR_H */
 0707010000598b000081240000000200000002000000012719347c00000248000000230000000c00000000000000000000001900000000usr/include/sys/genvid.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/genvid.h.sl 1.1 4.0 10/15/90 15762 AT&T-SF"

typedef struct gvid {
	unsigned long gvid_num;
	dev_t *gvid_buf;
	major_t gvid_maj;
} gvid_t;

#define	GVID_SET	1
#define	GVID_ACCESS	2

#define	GVIOC	('G'<<8|'v')
#define	GVID_SETTABLE	((GVIOC << 16)|1)
#define	GVID_GETTABLE	((GVIOC << 16)|2)
0707010000598c000081240000000200000002000000012719347c000007a2000000230000000c00000000000000000000001b00000000usr/include/sys/getpages.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_GETPAGES_H
#define _SYS_GETPAGES_H

#ident	"@(#)/usr/include/sys/getpages.h.sl 1.1 4.0 10/15/90 52497 AT&T-SF"

/*	The following list is used to keep track of regions locked
**	by getpages.
*/

typedef struct {
	reg_t	*gpr_rgptr;	/* Pointer to the region.	*/
	int	gpr_count;	/* Number of pages from this	*/
				/* region in spglist and 	*/
				/* fpglist.			*/
} gprgl_t;

extern gprgl_t	gprglst[];
extern int	gprgndx;


/*	The following structure is used to maintain a list of
 *	pages to be stolen by getpages.
 */

typedef struct {
	pte_t	*gp_ptptr;	/* Ptr to page table entry.	*/
	gprgl_t	*gp_rlptr;	/* Ptr to region list entry.	*/
} pglst_t;

/*	The following define sets the maximum size chunk which
 *	getpages can swap out at once.  The tuneable parameter
 *	tune.t_maxsc can never be made larger than this value.
 */

#define MAXSPGLST	100

/*	The following list is used to accumulate pages which we
**	wish to steal but which must be written to swap first.
*/

extern pglst_t	spglst[];
extern int	spglndx;

/*	The following list is used to accumulate pages which we
**	wish to steal and which have a current copy on swap or
**	a file and thus do not require any I/O to be done before
**	they can be stolen.  The reason for accummulating them
**	in a list instead of free each page as it is found is
**	to reduce the number of ATB purges required.
*/

#define	MAXFPGLST	100

extern pglst_t	fpglst[];
extern int	fpglndx;


/*	The following word is used to lock the getpages tables
**	described above so that vhand and sched can't both
**	use them at the same time.
*/

extern int	pglstlock;
extern int	pglstlk();
extern int	pglstunlk();

#endif	/* _SYS_GETPAGES_H */
  0707010000598d000081240000000200000002000000012719347c0000156b000000230000000c00000000000000000000001500000000usr/include/sys/hd.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_HD_H
#define _SYS_HD_H

#ident	"@(#)/usr/include/sys/hd.h.sl 1.1 4.0 10/15/90 7077 AT&T-SF"

/*
 * PC AT Hard disk controller definitions.
 */


#define	HD0	0x1f0	/* base for hard controller I/O port addresses */
#define	FDR	0x3f6	/* I/O port address for fixed disk register */

/*
 * Bit 3 of the fixed disk register must be set to 1 to access heads
 * 8 - 15 of a hard disk.
 */
#define	HD_EXTRAHDS	0x08	/* set into FDR to access high disk heads */
#define	HD_NOEXTRAHDS	0x00	/* set into FDR if no high disk heads */

/*
 * port offsets from base above.
 */
#define	HD_DATA		0x00	/* data register */
#define	HD_ERROR	0x01	/* error register/write precomp */
#define	HD_PRECOMP	0x01	/* error register/write precomp */
#define	HD_NSECT	0x02	/* sector count */
#define	HD_SECT		0x03	/* sector number */
#define	HD_LCYL		0x04	/* cylinder low byte */
#define	HD_HCYL		0x05	/* cylinder high byte */
#define	HD_DRV		0x06	/* drive/head register */
#define	HD_STATUS	0x07	/* status/command register */
#define	HD_CMD		0x07	/* status/command register */

/*
 * Status bits
 */
#define	BUSY		0x80	/* controller busy */
#define	READY		0x40	/* drive ready */
#define	WRFAULT		0x20	/* write fault */
#define	SEEKDONE	0x10	/* seek operation complete */
#define	DATARQ		0x08	/* data request */
#define	ECC		0x04	/* ECC correction applied */
#define	INDEX		0x02	/* disk revolution index */
#define ERROR		0x01	/* error flag */

/*
 * Drive selectors
 */
#define	HD_DHFIXED	0xa0	/* bits always set in drive/head reg. */
#define	HD_DRIVE0	0x00	/* or into HD_DHFIXED to select drive 0 */
#define	HD_DRIVE1	0x10	/* or into HD_DHFIXED to select drive 1 */

/*
 * Hard disk commands. 
 */
#define	HD_RESTORE	0x10	/* restore cmd, bottom 4 bits set step rate */
#define	HD_SEEK		0x70	/* seek cmd, bottom 4 bits set step rate */
#define	HD_RDSEC	0x20	/* read sector cmd, bottom 2 bits set ECC and
					retry modes */
#define	HD_WRSEC	0x30	/* write sector cmd, bottom 2 bits set ECC and
					retry modes */
#define	HD_FORMAT	0x50	/* format track command */
#define	HD_RDVER	0x40	/* read verify cmd, bot. bit sets retry mode */
#define	HD_DIAG		0x90	/* diagnose command */
#define	HD_SETPARAM	0x91	/* set parameters command */

#define	HDTIMOUT	25000	/* how many 10usecs in a 1/4 sec.*/

#define NUMDRV  2	/* maximum number of drives */
#define SECSIZE 512	/* default sector size */
#define SECSHFT 9
#define SECMASK (SECSIZE-1)
#define cylin   av_back

/* Values of hd_state */
#define HD_OPEN		0x01	/* drive is open */
#define HD_OPENING	0x02	/* drive is being opened */
#define HD_DO_RST	0x04	/* hardware restore command should be issued */
#define HD_DO_FMT	0x08	/* track is being formatted */
#define HD_VTOC_OK	0x10	/* VTOC (pdinfo, vtoc, alts table) OK */
#define HD_FMT_RST	0x20	/* restore needs to happen before format */
#define HD_BADBLK	0x40	/* bad block is being remapped */
#define HD_BBH_VFY	0x0080	/* potential bad block is being verified */
#define HD_BBH_MAP	0x0100	/* bad block is being assigned an alt.  */
#define HD_DO_VFY	0x0200	/* Sector(s) being verified.            */
#define HD_BADTRK	0x0400	/* bad block is in alt trk area being remapped */
#define HD_DO_CNTLCHK   0x0800  /* DPT HA controller check */

/*
 * the hard disk minor device number is interpreted as follows:
 *     bits:
 *	 7 5 4 3  0
 * 	+---+-+----+
 * 	|   |u|part|
 * 	+---+-+--+-+
 *     codes:
 *	u     - unit no. (0 or 1)
 *	part  - partition no. (0 - 15)
 */
#define PARTITION(x)	(getminor(x) & 0x0F)
#define UNIT(x)		((getminor(x) >> 4) & 0x01)
#define BASEDEV(x)	(dev_t)((x) & ~0x0F)

/*
 * Logical blocks to physical blocks
 */
#define lbtopb(lb) (((lb) << BSHIFT) >> SECSHFT)
#define pbtolb(pb) (((pb) << SECSHFT) >> BSHIFT)

/*
 * controller interface templates
 */
struct AT_cmd {
	unsigned char nhd_precomp;	/* write precomp */
        unsigned char nhd_nsect; /* decremented during operation - 0 == 256 */
	unsigned char nhd_sect;                   /* starting sector number */
	unsigned int  nhd_cyl;                      /* up to 1024 cylinders */
	/*
	 * must have
	 *	bit	7	1
	 *	bit	6	0
	 *	bit	5	1
	 *	bit	4	drive number
	 *	bits  3-0	head number
	 */
	unsigned char nhd_drv;
	unsigned char nhd_cmd;
};

/*
 * r3, r2, r1, r0 is stepping rate:
 *	0		 .35 micro-seconds
 *	1		 .5	milli-seconds
 *	2		1.0	milli-seconds
 *	2		1.0	milli-seconds
 *	.
 *	.
 *	.
 *	15		7.5	milli-seconds
 */

/*
 * bit	definition		value
 *			0			1
 * L	data mode	data only		data plus 4 byte ECC
 * T	retry mode	retries enabled		retries disabled
 */

/*
 * operational mode
 */
#define	DAM_NOT_FOUND	0x01	/* Data Address Mark not found   */
#define	TR000_ERR	0x02	/* Track 0 not found             */
#define	ABORTED		0x04	/* Command Aborted               */
#define	ID_NOT_FOUND	0x10	/* Sector ID not found           */
#define	ECC_ERR		0x40	/* Uncorrectable data read error */
#define	BAD_BLK		0x80	/* Bad block flag detected       */

#define HDPDLOC		29	/* Sector number on disk where pdinfo is */

/* New ioctls to be used for the purpose of testing BBH */
#define HIOC	('H'<<8)
#define GETALTTBL	(HIOC | 1)	/* get alt_table from kernel memory */
#define FMTBAD		(HIOC | 2)	/* format tracks as bad             */

#endif	/* _SYS_HD_H */
 0707010000598e000081240000000200000002000000012719347c00000992000000230000000c00000000000000000000001900000000usr/include/sys/hetero.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_HETERO_H
#define _SYS_HETERO_H

#ident	"@(#)/usr/include/sys/hetero.h.sl 1.1 4.0 10/15/90 11257 AT&T-SF"

/*
 *	Define machine attributes for heterogeneity.
 *
 *	Also define macros for determining the resultant size of a
 *	conversion.
 *
 *	Machine attribute consists of three components -
 *	byte ordering, alignment, and data unit size.
 *	The machine attributes are defined in a byte (8 bits),
 *	the lower 2 bits are used to define the byte ordering,
 *	the middle 3 bits are used to define the alignment,
 *	the higher 3 bits are used to define the data unit size.
 *
 *
 *	BYTE_ORDER	0x01	3B, IBM byte ordering
 *			0x02	VAX byte ordering
 *	ALIGNMENT	0x04	word aligned (4 bytes boundary)
 *			0x08	half-word aligned (2 bytes boundary)
 *			0x0c	byte aligned
 *	UNIT_SIZE	0x20	4 bytes integer, 2 bytes short, 4 bytes pointer
 *			0x40	2 bytes integer, 2 bytes short, 2 bytes pointer
 */


/*
 *	Define masks for machine attributes
 */

#define BYTE_MASK	0x03
#define ALIGN_MASK	0x1c
#define UNIT_MASK	0xe0


/*
 *	Define what need to be converted - header or data parts
 */

#define ALL_CONV	0	/* convert both header and data parts */
#define DATA_CONV	1	/* convert data part */
#define NO_CONV		2	/* no conversion needed */



#ifdef u3b2
/*
 *	Define machine attributes for 3B
 */

#define BYTE_ORDER	0x01
#define ALIGNMENT	0x04
#define UNIT_SIZE	0x20
#endif

#ifdef i286
/*
 *	Define machine attributes for Intel 286
 */

#define BYTE_ORDER	0x02
#define ALIGNMENT	0x08
#define UNIT_SIZE	0x40
#endif

#ifdef i386
/*
 *	Define machine attributes for Intel 386
 */

#define BYTE_ORDER	0x02
#define ALIGNMENT	0x04
#define UNIT_SIZE	0x20
#endif


#define MACHTYPE	(BYTE_ORDER | ALIGNMENT | UNIT_SIZE)


/*
 *	Define macros for determining the size in bytes of the result of a
 * 	conversion.
 *
 */

/* 	A c0 conversion produces a buffer aligned on long boundary both at
 *	the beginning and at the end, containing a long for the character
 *	string length (including a NULL) and the character string itself
 *	(including a NULL).
 */

#define C0SIZE(stringlen) (stringlen) + 2 * (sizeof(long) - 1) + \
	    sizeof(long) + sizeof(char)

#endif		/* _SYS_HETERO_H */
  0707010000598f000081240000000200000002000000012719347c000011b5000000230000000c00000000000000000000001a00000000usr/include/sys/hrtcntl.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_HRTCNTL_H
#define _SYS_HRTCNTL_H

#ident	"@(#)/usr/include/sys/hrtcntl.h.sl 1.1 4.0 10/15/90 63129 AT&T-SF"

/* 
 * The following are the possible commands for the hrtcntl,
 * hrtalarm, and hrtsleep system calls.
 */

typedef	enum	hrtcmds {

		/*   hrtcntl	commands   */
	HRT_GETRES,		/* Get the resolution of a clock.      */
	HRT_TOFD,		/* Get the value of time since	       */
				/* 00:00:00 GMT, January 1, 1970       */
	HRT_STARTIT,		/* Start timing an activity */
	HRT_GETIT,		/* Return the interval time elapsed    */
				/* since the corresponding HRT_STARTIT **
				** command has been issued.	       */
		/*   hrtalarm   commands   */
	HRT_ALARM,		/* Start a timer and post an alarm     **
				** event after the time interval has   **
				** elapsed.			       */
	HRT_RALARM,		/* Post an alarm repeatedly after      **
				** every time interval. 	       */
	HRT_TODALARM,	        /* Similar to HRT_ALARM except that    **
				** the time at which the alarm is to   **
				** posted is specified by an absolute  **
				** time.			       */
	HRT_INT_RPT,		/* Start a repeating alarm some time   **
				** in the future. 		       */
	HRT_TOD_RPT,		/* Similar to HRT_INT_RPT except that  **
				** the time of day when the alarm      **
				** should begin is specified.          */
	HRT_PENDING,		/* Determine the time remaining until  **
				** a pending alarm fires.	       */
		/*   hrtsleep   commands  */
	HRT_INTSLP,		/* Put the process to sleep for an     **
				** interval.			       */
	HRT_TODSLP,		/* Put the process to sleep until      **
				** a specified time of day.            */
		/*   The following fields will be used
		 *   to implement BSD timers
		 */
	HRT_BSD,
	HRT_BSD_PEND,
	HRT_RBSD,
	HRT_BSD_REP,
	HRT_BSD_CANCEL
} hrtcmds_t;

/*
 *	Definitions for commonly used resolutions.
 */

#define	SEC		1
#define	MILLISEC	1000
#define MICROSEC	1000000
#define NANOSEC		1000000000

/*
 * Scaling factor used to save
 * fractional remainder.
 */
#define SCALE		1000000

/*
 *	Definitions for specifying rounding mode.
 */

#define HRT_TRUNC	0	/* Round results down.	*/
#define HRT_RND		1	/* Round results (rnd up if fractional	*/
				/*   part >= .5 otherwise round down).	*/
#define	HRT_RNDUP	2	/* Always round results up.	*/

/*
 *	Definition for the type of internal buffer used with the
 *	HRT_STARTIT and HRT_GETIT commands.
 */

typedef	struct interval {
	unsigned long	i_word1;
	unsigned long	i_word2;
	int		i_clock;
} interval_t;

/*
 *	Structure used to represent a high-resolution time-of-day
 *	or interval.
 */

typedef struct hrtime {
	ulong	hrt_secs;	/* Seconds.				*/
	long	hrt_rem;	/* A value less than a second.		*/
	ulong	hrt_res;	/* The resolution of hrt_rem.		*/
} hrtime_t;

/*
 * Data returned by hrtcancel if the ECBF_POSTCAN flag is set.
 */

typedef	struct evd_hrt {
	hrtime_t  hrte_time;	/* The time when the alarm		*/
				/* would next have fired. A		*/
				/* time-of-day or an interval depending */
				/* on the type of the alarm.		*/
} evd_hrt_t;



/*
 *	The structure used for the hrtalarm and hrtsleep system calls.
 */

typedef struct hrtcmd {
	int		hrtc_cmd;	/* A timer command.		*/
	int		hrtc_clk;	/* Which clock to use.		*/	
	hrtime_t	hrtc_int;	/* A time interval.		*/
	hrtime_t	hrtc_tod;	/* A time of day.		*/
	int		hrtc_flags;	/* Various flags. 		*/
	int		hrtc_error;	/* An error code		*/
					/* (see eys/errno.h).		*/
	ecb_t		hrtc_ecb;	/* An event control block.	*/
} hrtcmd_t;

/*
 * Flags for the hrtc_flags field.
 */

#define	HRTF_DONE	0x0001	/* The requested alarm has been set.	*/
#define	HRTF_ERROR	0x0002	/* An error has been encountered.	*/

/*
 * Multiple clocks
 */

#define CLK_STD		0x0001	/* The standard real-time clock.	*/
#define CLK_USERVIRT	0x0002	/* A clock measuring user process	*/
				/* virtual time.			*/
#define CLK_PROCVIRT	0x0004	/* A clock measuring a process' virtual */
				/* time.				*/

/*			Function Prototypes
**			===================
**
**	The following are prototypes for the library functions which
**	users call. 
*/

#if defined(__STDC__) && !defined(_KERNEL)
int   hrtcntl(int, int, interval_t *, hrtime_t *);
int   hrtalarm(hrtcmd_t *, int);
int   hrtsleep(hrtcmd_t *);
int   hrtcancel(const long *, int);
#endif

#endif	/* _SYS_HRTCNTL_H */
   07070100005990000081240000000200000002000000012719347c0000077f000000230000000c00000000000000000000001900000000usr/include/sys/hrtsys.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_HRTSYS_H
#define _SYS_HRTSYS_H

#ident	"@(#)/usr/include/sys/hrtsys.h.sl 1.1 4.0 10/15/90 48671 AT&T-SF"
/*
 *	Kernel structure for keeping track of sleep and alarm requests.
 */


typedef struct timer {
	struct proc	*hrt_proc;	/* Ptr to proc table entry.	*/
	int		hrt_clk;	/* Which clock to use		*/
	unsigned long	hrt_time;	/* Remaining time to alarm in	*/
					/* HZ.				*/
	unsigned long	hrt_int;	/* Base interval for repeating	*/
					/* alarms.			*/
	unsigned long	hrt_rem;	/* Value of remainder for	*/
					/* repeat alarm.		*/
	unsigned long	hrt_crem;	/* Cummulative remainder for	*/
					/* repeating alarm.		*/
	unsigned long	hrt_res;	/* User specified resolution.	*/
	ushort		hrt_cmd;	/* The user specified command.	*/
	struct vnode	*hrt_vp;	/* Ptr to vnode for event queue	*/
					/* to post to.			*/
	ecb_t	hrt_ecb;		/* User specified event control */
					/* block.			*/
	int	(*hrt_fn)();		/* function to call		*/	
	struct timer	*hrt_next;	/* Next on list.		*/
	struct timer	*hrt_prev;	/* Previous on list.		*/
} timer_t;

extern timer_t	hrtimes[];
extern int	hrtimes_size;
extern timer_t	hrt_active;
extern timer_t	hrt_avail;

extern timer_t	*hrt_alloc();
extern void	hrt_free();

extern void	hrtinit();
extern void	itinit();

extern long	hrt_convert();

extern	void	hrt_timeout();
extern	void	hrt_enqueue();
extern	void	hrt_dequeue();

extern	void	itimer_timeout();
extern	void	itimer_enqueue();
extern	void	itimer_dequeue();

extern timer_t	itimes[];
extern int	itimes_size;
extern timer_t	it_avail;

#ifdef _KERNEL

extern int	hrt_cancel_proc();
extern void	hrt_gettofd();

#endif /* _KERNEL */

#endif	/* _SYS_HRTSYS_H */
 07070100005991000081240000000200000002000000012719347c000030a0000000230000000c00000000000000000000001900000000usr/include/sys/i8237A.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*      Copyright (c) 1989, 1990 AT&T   */
/*           All Rights Reserved        */

/*      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T     */
/*      The copyright notice above does not evidence any        */
/*      actual or intended publication of such source code.     */

#ident	"@(#)/usr/include/sys/i8237A.h.sl 1.1 4.0 10/15/90 24241 AT&T-SF"

#ifndef _SYS_I8237A_H
#define	_SYS_I8237A_H

#define D37A_MAX_CHAN   8
#define D37A_DFR_ALIGN  0xf
#define D37A_MIN_CHAN   0x0

/*
 * Defines for PC AT DMA controllers.
 * The PC AT has two intel 8237A-5 dma controllers with page registers
 * for each channel, allowing access to the entire 16M address space.
 */

#define DMACH0PG        0x87    /* port address for dma chan. 0 page reg. */
#define DMACH1PG        0x83    /* port address for dma chan. 1 page reg. */
#define DMACH2PG        0x81    /* port address for dma chan. 2 page reg. */
#define DMACH3PG        0x82    /* port address for dma chan. 3 page reg. */
#define DMACH4PG        0x00    /* dummy address for dma chan. 4 page reg. */
#define DMACH5PG        0x8b    /* port address for dma chan. 5 page reg. */
#define DMACH6PG        0x89    /* port address for dma chan. 6 page reg. */
#define DMACH7PG        0x8a    /* port address for dma chan. 7 page reg. */

/*
 * The EISA has a high page address register giving access to the
 *      full 32-bit address space
 */

#define DMACH0HPG       0x487   /* port address for dma chan. 0 high page reg */
#define DMACH1HPG       0x483   /* port address for dma chan. 1 high page reg */
#define DMACH2HPG       0x481   /* port address for dma chan. 2 high page reg */
#define DMACH3HPG       0x482   /* port address for dma chan. 3 high page reg */
#define DMACH4HPG       0x000   /* dumy address for dma chan. 4 high page reg */
#define DMACH5HPG       0x48b   /* port address for dma chan. 5 high page reg */
#define DMACH6HPG       0x489   /* port address for dma chan. 6 high page reg */
#define DMACH7HPG       0x48a   /* port address for dma chan. 7 high page reg */

/*
 * I/O port addresses for controller 1 programming.
 */
#define DMA1BCA0        0x00    /* chan. 0 base and current address */
#define DMA1BCWC0       0x01    /* chan. 0 base and current word count */
#define DMA1BCA1        0x02    /* chan. 1 base and current address */
#define DMA1BCWC1       0x03    /* chan. 1 base and current word count */
#define DMA1BCA2        0x04    /* chan. 2 base and current address */
#define DMA1BCWC2       0x05    /* chan. 2 base and current word count */
#define DMA1BCA3        0x06    /* chan. 3 base and current address */
#define DMA1BCWC3       0x07    /* chan. 3 base and current word count */
#define DMA1RSWWCR      0x08    /* read status reg/write command reg */
#define DMA1WRR         0x09    /* write request register */
#define DMA1WSMR        0x0a    /* write single mask register bit */
#define DMA1WMR         0x0b    /* write mode register */
#define DMA1CBPFF       0x0c    /* clear byte pointer flip flop */
#define DMA1RTRWMC      0x0d    /* read temp reg/write master clear */
#define DMA1CMR         0x0e    /* clear mask register */
#define DMA1WAMRB       0x0f    /* write all mask register bits */

/*
 * I/O port addresses for controller 2 programming.
 */
#define DMA2BCA0        0xc0    /* chan. 0 base and current address */
#define DMA2BCWC0       0xc2    /* chan. 0 base and current word count */
#define DMA2BCA1        0xc4    /* chan. 1 base and current address */
#define DMA2BCWC1       0xc6    /* chan. 1 base and current word count */
#define DMA2BCA2        0xc8    /* chan. 2 base and current address */
#define DMA2BCWC2       0xca    /* chan. 2 base and current word count */
#define DMA2BCA3        0xcc    /* chan. 3 base and current address */
#define DMA2BCWC3       0xce    /* chan. 3 base and current word count */
#define DMA2RSWWCR      0xd0    /* read status reg/write command reg */
#define DMA2WRR         0xd2    /* write request register */
#define DMA2WSMR        0xd4    /* write single mask register bit */
#define DMA2WMR         0xd6    /* write mode register */
#define DMA2CBPFF       0xd8    /* clear byte pointer flip flop */
#define DMA2RTRWMC      0xda    /* read temp reg/write master clear */
#define DMA2CMR         0xdc    /* clear mask register */
#define DMA2WAMRB       0xde    /* write all mask register bits */

/*
 * defines for XENIX compatibility
 */

/*
 * Intel 8237 DMA Controller.
 */

/*
 * DMA I/O Port Assignments.
 */
/* 8 bit channel specific registers on controller 1 */
#define DMA_0ADR        0x00    /* Channel  address register */
#define DMA_0WCNT       0x01    /* Channel  word count */
#define DMA_1ADR        0x02    /* Channel  address register */
#define DMA_1WCNT       0x03    /* Channel  word count */
#define DMA_2ADR        0x04    /* Channel  address register */
#define DMA_2WCNT       0x05    /* Channel  word count */
#define DMA_3ADR        0x06    /* Channel  address register */
#define DMA_3WCNT       0x07    /* Channel  word count */

#define DMACH0CCH       0x401   /* chan. 0 base and current count high */
#define DMACH1CCH       0x403   /* chan. 1 base and current count high */
#define DMACH2CCH       0x405   /* chan. 2 base and current count high */
#define DMACH3CCH       0x407   /* chan. 3 base and current count high */


/* 16 bit channel specific registers on controller 1.
 * Chip A0 connected to bus A1, etc. so even address 
 * increments generated by this controller.  Hence, 
 * 16 bit dma, and only even i/o addresses. Channel 4
 * used to cascade controllers.
 */
#define DMA_4ADR        0xC0    /* (RESERVED) Channel  address register */
#define DMA_4WCNT       0xC2    /* (RESERVED) Channel  word count */
#define DMA_5ADR        0xC4    /* Channel  address register */
#define DMA_5WCNT       0xC6    /* Channel  word count */
#define DMA_6ADR        0xC8    /* Channel  address register */
#define DMA_6WCNT       0xCA    /* Channel  word count */
#define DMA_7ADR        0xCC    /* Channel  address register */
#define DMA_7WCNT       0xCE    /* Channel  word count */

#define DMACH4CCH       0x000   /* dummy chan. 0 base and current count high */
#define DMACH5CCH       0x4c6   /* chan. 1 base and current count high */
#define DMACH6CCH       0x4ca   /* chan. 2 base and current count high */
#define DMACH7CCH       0x4ce   /* chan. 3 base and current count high */

/* DMA controller 1, 8 bit channels */
#define CTL1_CMD        0x08    /* Command reg */
#define CTL1_REQ        0x09    /* request reg */
#define CTL1_STAT       0x08    /* Status reg */
#define CTL1_MASK       0x0A    /* Mask set/reset register */
#define CTL1_MODE       0x0B    /* Mode reg */
#define CTL1_CLFF       0x0C    /* Clear byte pointer first/last flip-flop */
#define CTL1_ALLMASK    0x0F    /* Mask all registers */

#define EISA_DMAIS      0x40a   /* interrupt status regiser */
#define CTL1_SCM        0x40a   /* set chain mode */
#define CTL1_EWM        0x40b   /* extended write mode */

/* DMA controller 2, 16 bit channels */
#define CTL2_CMD        0xD0    /* Command reg */
#define CTL2_REQ        0xD2    /* request reg */
#define CTL2_STAT       0xD0    /* Status reg */
#define CTL2_MASK       0xD4    /* Mask set/reset register */
#define CTL2_MODE       0xD6    /* Mode reg */
#define CTL2_CLFF       0xD8    /* Clear byte pointer first/last flip-flop */
#define CTL2_ALLMASK    0xDE    /* Mask all registers */

#define CTL2_SCM        0x40a   /* set chain mode */
#define CTL2_EWM        0x40b   /* extended write mode */

/* 8 bit channels */
#define DMA_0XADR       0x87    /* Channel 0 address extension reg */
#define DMA_1XADR       0x83    /* Channel 1 address extension reg */
#define DMA_2XADR       0x81    /* Channel 2 address extension reg */
#define DMA_3XADR       0x82    /* Channel 3 address extension reg */

/* 16 bit channels */
#define DMA_5XADR       0x8B    /* Channel 5 address extension reg */
#define DMA_6XADR       0x89    /* Channel 6 address extension reg */
#define DMA_7XADR       0x8A    /* Channel 7 address extension reg */


#define DMA_MSK         0x0A    /* Mask, enable disk, disable others */
#define DMA_CLEAR       0x1A    /* Master clear */
#define IOCR            0x56    /* IO controller */

/*
 * DMA Channels. d_chan field of dmareq.
 */

#define NCHANS          8

/* 8 bit channels */
#define DMA_CH0         0       /* Channel 0 */
#define DMA_CH1         1       /* Channel 1 */
#define DMA_CH2         2       /* Channel 2 */
#define DMA_CH3         3       /* Channel 3 */
/* 16 bit channels */
#define DMA_CH4         4       /* Channel 4 */
#define DMA_CH5         5       /* Channel 5 */
#define DMA_CH6         6       /* Channel 6 */
#define DMA_CH7         7       /* Channel 7 */

/*
 * DMA Masks.
 */
#define DMA_SETMSK      4       /* Set mask bit */
#define DMA_CLRMSK      0       /* Clear mask bit */
#define DMA_RD          1
#define DMA_WR          2
#define DMA_VR          0

/* from memory to device */
#define DMA_Wrmode      0x48    /* single, read, increment, no auto-init */
/* from device to memory */
#define DMA_Rdmode      0x44    /* single, write, increment, no auto-init */
#define DMA_Nomode      0x0C    /* illegal mode */

#define DMAPRI  PRIBIO

/* dma_alloc modes */
#define DMA_BLOCK       0       /* blocking task time allocation */
#define DMA_NBLOCK      1       /* non-blocking task time allocation */

#define EISA_DMA_8      0       /* 8-bit data path */
#define EISA_DMA_16     1       /* 16-bit data path, word count */
#define EISA_DMA_32     2       /* 32-bit data path */
#define EISA_DMA_16B    3       /* 16-bit data path, byte count */

#define EISA_ENCM       4       /* enable chaining mode */
#define EISA_CMOK       8       /* chaining mode completed (OK) */


/*
Channel Address Array - make's life much easier
*/
struct d37A_chan_reg_addr {
        unsigned char   addr_reg;       /* target address register */
        unsigned char   cnt_reg;        /* count register */
        unsigned char   page_reg;       /* page register */
        unsigned char   ff_reg;         /* first-last flipflop */
        unsigned char   cmd_reg;        /* command register */
        unsigned char   mode_reg;       /* mode register */
        unsigned char   mask_reg;       /* mask register */
        unsigned char   stat_reg;       /* status register */
        unsigned char   reqt_reg;       /* request register */
        unsigned short  hpage_reg;      /* high page register */
        unsigned short  hcnt_reg;       /* high count register */
        unsigned short  xmode_reg;      /* extended mode register */
        unsigned short  scm_reg;        /* set chaining mode register */
};

/*
macro to initialize array of d37A_chan_reg_addr structures
*/
#define D37A_BASE_REGS_VALUES \
        {DMA_0ADR, DMA_0WCNT, DMACH0PG, CTL1_CLFF, \
        CTL1_CMD, CTL1_MODE, CTL1_MASK, CTL1_STAT, CTL1_REQ, \
        DMACH0HPG, DMACH0CCH, CTL1_EWM, CTL1_SCM}, \
        {DMA_1ADR, DMA_1WCNT, DMACH1PG,  CTL1_CLFF, \
        CTL1_CMD, CTL1_MODE, CTL1_MASK, CTL1_STAT, CTL1_REQ, \
        DMACH1HPG, DMACH1CCH, CTL1_EWM, CTL1_SCM}, \
        {DMA_2ADR, DMA_2WCNT, DMACH2PG,  CTL1_CLFF, \
        CTL1_CMD, CTL1_MODE, CTL1_MASK, CTL1_STAT, CTL1_REQ, \
        DMACH2HPG, DMACH2CCH, CTL1_EWM, CTL1_SCM}, \
        {DMA_3ADR, DMA_3WCNT, DMACH3PG,  CTL1_CLFF, \
        CTL1_CMD, CTL1_MODE, CTL1_MASK, CTL1_STAT, CTL1_REQ, \
        DMACH3HPG, DMACH3CCH, CTL1_EWM, CTL1_SCM}, \
        {DMA_4ADR, DMA_4WCNT, DMACH4PG,  CTL2_CLFF, \
        CTL2_CMD, CTL2_MODE, CTL2_MASK, CTL2_STAT, CTL2_REQ, \
        DMACH4HPG, DMACH4CCH, CTL2_EWM, CTL2_SCM}, \
        {DMA_5ADR, DMA_5WCNT, DMACH5PG,  CTL2_CLFF, \
        CTL2_CMD, CTL2_MODE, CTL2_MASK, CTL2_STAT, CTL2_REQ, \
        DMACH5HPG, DMACH5CCH, CTL2_EWM, CTL2_SCM}, \
        {DMA_6ADR, DMA_6WCNT, DMACH6PG,  CTL2_CLFF, \
        CTL2_CMD, CTL2_MODE, CTL2_MASK, CTL2_STAT, CTL2_REQ, \
        DMACH6HPG, DMACH6CCH, CTL2_EWM, CTL2_SCM}, \
        {DMA_7ADR, DMA_7WCNT, DMACH7PG,  CTL2_CLFF, \
        CTL2_CMD, CTL2_MODE, CTL2_MASK, CTL2_STAT, CTL2_REQ, \
        DMACH7HPG, DMACH7CCH, CTL2_EWM, CTL2_SCM}

#endif
07070100005992000081240000000200000002000000012719347c000004d5000000230000000c00000000000000000000001800000000usr/include/sys/idtab.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_IDTAB_H
#define _SYS_IDTAB_H

#ident	"@(#)/usr/include/sys/idtab.h.sl 1.1 4.0 10/15/90 57764 AT&T-SF"
/*
 *
 *    defines for uid/gid translation.
 *
 */
#define MAXSNAME	20
#define CFREE		0
#define CINUSE		1
#define CINTER		2
#define GLOBAL_CH	'.'	/* name of the "global" table	*/
#define UID_DEV		0	/* minor device number for uid device	*/
#define	GID_DEV		1	/* minor device number for gid device	*/
#define UID_MAP		UID_DEV
#define GID_MAP		GID_DEV

struct idtab	{
	uid_t		i_rem;
	uid_t		i_loc;
};
#define i_defval i_rem
#define i_tblsiz i_loc

struct idhead {
	uid_t		i_default;
	uid_t		i_size;
	unsigned long	i_cend;
	unsigned long	i_next;
	unsigned long	i_tries;
	unsigned long	i_hits;
};
#define HEADSIZE \
    ((sizeof(struct idhead) + sizeof(struct idtab) -1) / sizeof(struct idtab))
#ifdef _KERNEL
extern char	rfheap[];
extern int	rfsize;

#define	gluid(a,b)	glid(UID_DEV,a,b)
#define glgid(a,b)	glid(GID_DEV,a,b)
#endif

#endif	/* _SYS_IDTAB_H */
   07070100005993000081240000000200000002000000012719347c00002be1000000230000000c00000000000000000000001700000000usr/include/sys/immu.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_IMMU_H
#define _SYS_IMMU_H

#ident	"@(#)/usr/include/sys/immu.h.sl 1.1 4.0 10/15/90 57967 AT&T-SF"

/*
 * Page Table Entry Definitions
 */

typedef union pte {    /*  page table entry  */

/*                                                 */
/*                        DEBUG                    */
/*                        only                     */
/*  +---------------------+---+---+-+-+---+-+-+-+  */
/*  |        pfn          |tag|   |m|r|   |u|r|p|  */
/*  +---------------------+---+---+-+-+---+-+-+-+  */
/*            20            3   2  1 1  2  1 1 1   */
/*                                                 */
	struct {
		uint pg_v	:  1,	/* Page is valid, i.e. present */
		     pg_rw	:  1,	/* read/write */
		     pg_us	:  1,	/* user/supervisor */
		     		:  2,	/* Reserved by hardware.	*/
		     pg_ref	:  1,	/* Page has been referenced */
		     pg_mod	:  1,	/* Page has been modified */
				:  2,	/* Reserved by hardware.	*/
		     pg_tag	:  3,	/* Unused software bits.	*/
		     pg_pfn	: 20;	/* Physical page frame number	*/
	} pgm;
	uint	pg_pte;		/* Full page table entry	*/
} pte_t;

/*
 *	Page Table
 */

#define NPGPT		1024	/* Nbr of pages per page table (seg). */

typedef struct ptbl {
	int page[NPGPT];
} ptbl_t;

/* Page table entry dependent constants */

#define	NBPP		4096		/* Number of bytes per page */
#define	NBPPT		4096		/* Number of bytes per page table */
#define	BPTSHFT		12 		/* LOG2(NBPPT) if exact */
#define	NPTPP		1		/* Nbr of page tables per page.	*/
#define	NPTPPSHFT	0		/* Shift for NPTPP. */

/* Following added because svid says ulimit works in 512 byte units. so we must
  have something independent of the blocksize of the file system implementation
 */
#define NUPP		8		/* Number ulimit blocks per page    */
#define UPPSHFT		3		/* Shift for ulimit blocks per page */

#define PNUMSHFT	12		/* Shift for page number from addr. */
#define PNUMMASK	0x3FF		/* Mask for index in page table */
#define POFFMASK        0xFFF		/* Mask for offset into page. */
#define	PTOFFMASK	0x3FF		/* Mask for offset into page table/dir*/
#define	PNDXMASK	PTOFFMASK	/* Mask for offset into kptbl.*/
#define PGFNMASK	0xFFFFF		/* Mask page frame nbr after shift. */
#define PTNUMSHFT	22		/* Shift for page table num from addr */
#define PTSIZE		4096		/* Page table size in bytes */
#define	PTMASK		(PTSIZE - 1)	/* Mask for page table size */
#define VPTSIZE		(1<<PTNUMSHFT)	/* Virtual bytes described by	*/
					/* a page table.		*/

/* Page descriptor (table) entry field masks */

#define PT_ADDR		0xFFC00000	/* physical page table address */
#define PG_ADDR		0xFFFFF000	/* physical page address */
#ifdef DEBUG
#define PG_LOCKCNT	0x00000E00	/* mapping SOFTLOCK count (software) */
#endif
#define PG_M		0x00000040	/* modify bit */
#define PG_REF		0x00000020	/* reference bit */
#define	PG_US		0x00000004	/* 0=supervisor, 1=user */
#define	PG_RW		0x00000002	/* 0=read-only, 1=read/write */
#define PG_V		0x00000001	/* page valid bit */
#define PG_P		PG_V		/* for source compatibility */
#define PTE_RW		(PG_RW|PG_US)
#define PTE_PROTMASK	PTE_RW

#define O_PG_LOCK	0x00000800	/* OBSOLETE; for binary compatibility */
#define PG_LOCK		0		/* OBSOLETE; for source compatibility */

#define XMEM_BIT	0x80000000	/* bit to indicate 2GB extra mem */

/* The page number within a section. */

#define ptnum(X)	((uint)(X) >> PTNUMSHFT)

#define pgndx(x)	(((x) >> PNUMSHFT) & PNDXMASK)

/* Round up page table address */

#define ptround(p)	((int *) (((uint)(p) + PTSIZE-1) & ~(PTSIZE-1)))

/* Round down page table address */

#define pttrunc(p)	((int *) ((uint)(p) & ~(PTSIZE-1)))
#define ptalign(p)	pttrunc(p)

#define pnum(X)  	(((uint)(X) >> PNUMSHFT) & PTOFFMASK) 
#define pfnum(X)	(((uint)(X) >> PNUMSHFT) & PGFNMASK)
#define PFNUM(X)	pfnum(X)

/* Following added because svid says ulimit works in 512 byte units, so we must
   have something independent of the blocksize of the file system implementation

	Ulimit blocks (512 bytes each) and pages.
 */

#define utop(UU)	(((UU) + NUPP -1) >> UPPSHFT)

/* Page tables (1024 entries == 4k bytes) to pages. */

#define	pttopgs(x)	(((x) + NPTPP - 1) >> NPTPPSHFT)
#define	pttob(x)	((x) << BPTSHFT)
#define	btopt(x)	(((x) + NBPPT - 1) >> BPTSHFT)

/* Form page table entry from modes and page frame number */

#define	mkpte(mode,pfn)	(mode | ((uint)(pfn) << PNUMSHFT))

/*	The following macros are used to set/check the value
 *	of the bits in a page descriptor (table) entry 
 *
 *	Atomic instruction is available to clear the present bit,
 *	other bits are set or cleared in a word operation.
 */

#define PG_ISVALID(pte) 	((pte)->pgm.pg_v)
#define PG_SETVALID(pte)	((pte)->pg_pte |= PG_V)
#define PG_CLRVALID(pte)	((pte)->pg_pte &= ~PG_V)

#define PG_SETMOD(pte)   	((pte)->pg_pte |= PG_M)	
#define PG_CLRMOD(pte)   	((pte)->pg_pte &= ~PG_M)	

#define PG_SETREF(pte)    	((pte)->pg_pte |= PG_REF)
#define PG_CLRREF(pte)    	((pte)->pg_pte &= ~PG_REF)

#define PG_ISWRITEABLE(pte)	((pte)->pgm.pg_rw)
#define PG_CLRW(pte)		((pte)->pg_pte &= ~(PG_RW))

#define PG_SETPROT(pte,b)	((pte)->pg_pte |= b)	/* Set r/w access */
#define PG_CLRPROT(pte)		((pte)->pg_pte &= ~(PTE_PROTMASK))

#ifdef DEBUG

/*
 * Macros to keep track of SOFTLOCKs on a mapping.
 */

#define PG_ISLOCKED(pte)	((pte)->pgm.pg_tag)
#define PG_SETLOCK(pte)		{ \
	if ((pte)->pgm.pg_tag == 7) \
		cmn_err(CE_PANIC, "Too many SOFTLOCKs on mapping !\n"); \
	++(pte)->pgm.pg_tag; \
}
#define PG_CLRLOCK(pte)	{ \
	if ((pte)->pgm.pg_tag == 0) \
		cmn_err(CE_PANIC, "SOFTUNLOCK on an unlocked mapping !\n"); \
	--(pte)->pgm.pg_tag; \
}

#else

#define PG_ISLOCKED(pte)
#define PG_SETLOCK(pte)
#define PG_CLRLOCK(pte)

#endif

#define SOFFMASK	0x3FFFFF	/* Mask for page table alignment */
#define SGENDMASK	0x3FFFFC	/* Mask for page table end alignment */

/*  access modes  */

#define KNONE  (unsigned char)  0x00
#define KEO    (unsigned char)  0x40	/* KRO on WE32000	*/
#define KRE    (unsigned char)  0x80
#define KRWE   (unsigned char)  0xC0	/* KRW on WE32000	*/

#define UNONE  (unsigned char)  0x00
#define UEO    (unsigned char)  0x01	/* URO on WE32000	*/
#define URE    (unsigned char)  0x02
#define URWE   (unsigned char)  0x03	/* URW on WE32000	*/

#define UACCESS (unsigned char) 0x03
#define KACCESS (unsigned char) 0xC0

#define SEG_RO	(KRWE|URE)
#define SEG_RW	(KRWE|URWE)


#define PAGNUM(x)   (((uint)(x) >> PNUMSHFT) & PNUMMASK)
#define PAGOFF(x)   (((uint)(x)) & POFFMASK)


/*	The following variables describe the memory managed by
**	the kernel.  This includes all memory above the kernel
**	itself.
*/

extern int	syssegs[];	/* Start of the system segment	*/
				/* from which kernel space is	*/
				/* allocated.  The actual value	*/
				/* is defined in the vuifile.	*/
extern pte_t	*kptbl;		/* Kernel page table.  Used to	*/
				/* map sysseg.			*/
extern pte_t	*usertable;	/* Common page table.  Used to	*/
				/* map the current ublock.	*/
extern int	maxmem;		/* Maximum available free	*/
				/* memory.			*/
extern int	freemem;	/* Current free memory.		*/
extern int	availrmem;	/* Available resident (not	*/
				/* swapable) memory in pages.	*/
extern int	availsmem;	/* Available swapable memory in	*/
				/* pages.			*/

/*	Conversion macros
*/

/*	Get page number from system virtual address.  */


/*	Between kernel virtual address and physical page frame number.
*/

#define svtop(vaddr)	((((unsigned long) (vaddr) >= KVXBASE) ? \
			((vaddr) - KVXBASE) + X_MEMBIT : (vaddr) - KVBASE) \
			>> PNUMSHFT)

/*	Get system virtual address from page number.  */

#define ptosv(pfn)   (phystokv((pfn) << PNUMSHFT))


/*	These macros are used to map between kernel virtual
**      and physical address.
*/

extern paddr_t	svirtophys(/* va */);

#define phystokv(paddr) xphystokv(paddr)
 
/*	The xphystokv() macro works for all physical addresses
**	which correspond to main (RAM) memory.  This differs from
**	phystokv() in that it can handle the Olivetti's extra 384K.
**	Normally, this isn't an issue, since this 384K is used for
**	kernel text.
*/

#define xphystokv(paddr) (((unsigned long)(paddr) & XMEM_BIT) ? \
		(paddr) + (KVXBASE - XMEM_BIT) : (paddr) + KVBASE)

/*	Between kernel virtual address and physical page frame number.
*/

#define phystopfn(paddr)	((u_int)(paddr) >> PNUMSHFT)
#define pfntophys(pfn)  	((pfn) << PNUMSHFT)
#define kvtopfn(vaddr) 		(kvtophys(vaddr) >> PNUMSHFT)
#define pfntokv(pfn)   		(phystokv ((pfn) << PNUMSHFT))

/*	Between kernel virtual addresses and the kernel page
**	table.
*/

#define	kvtokptbl(x)	(&kptbl[pgndx((uint)(x) - (uint)syssegs)])

/*
 * pte_t *
 * vatopdte(v)
 * returns the page directory entry location of v.
 */

#define	vatopdte(v)	(&kpd0[ptnum(v)])

/*
 * pte_t *
 * vatopte(v, pdte)
 * returns the page table entry location of v.
 */

#define	vatopte(v, pdte) ((pte_t *)phystokv(ctob(pdte->pgm.pg_pfn)) + pnum(v))

/*
 * pte_t *
 * svtopte(v)
 * returns the pt entry location of v.
 *
 * This macro works only with paged virtual address.
 *
 */

#define svtopte(v) ((pte_t *)phystokv(ctob((uint)(vatopdte(v)->pgm.pg_pfn))) + pnum(v))

/*
 * svtopfn(v)
 */

#define svtopfn(v) (PAGNUM(svirtophys(v)))

/*	Page frame number to kernel pte.
*/

#define	pfntokptbl(p)	(kvtokptbl(pfntokv(p)))

/*	Convert segment:offset 8086 far pointer to address
*/

#define	ftop(x)	((((x) & 0xffff0000) >> 12) + ((x) & 0xffff))


/* flags used in ptmemall() call
*/

#define PHYSCONTIG 02
#define NOSLEEP    01


/*	Declarations for kernel variables
*/

#ifdef _KERNEL

extern pte_t	kpd0[];		/* Global system page directory */

#endif /* _KERNEL */


/*
 *  User address space offsets
 *
 *****************************  NOTE - NOTE  *********************************
 *
 *	 ANY CHANGES IN THE FOLLOWING DEFINES NEED TO BE REFLECTED IN
 *	    EITHER ml/misc.s, OR ml/ttrap.s, OR BOTH.
 */

#define UVBASE          ((unsigned)0x00000000L)     /* main store virtual address    */
#define UVSTACK         ((unsigned)0x7FFFFFFCL)     /* stack bottom virtual address  */
#define UVSHM           ((unsigned)0x80000000L)     /* Shared memory address         */
#define KVBASE          ((unsigned)0xC0000000L)     /* base of kernel memory map     */
#define KVXBASE         ((unsigned)0xC8000000L)     /* base for extended memory      */
#define KVSBASE         ((unsigned)0xD0000000L)     /* base for kernel text, data + bss */
#define UVUBLK          ((unsigned)0xE0000000L)     /* ublock virtual address        */

#define UVTEXT          UVBASE          /* beginning addrss of user text    */
#define UVEND		KVBASE		/* end of user virtual address range */
#define MINUVADR        UVTEXT          /* minimum user virtual address.    */
#define MAXUVADR        KVBASE          /* maximum user virtual address.    */
#define MINKVADR        KVBASE          /* minimum kernel virtual address.  */
#define MAXKVADR        UVUBLK          /* maximum kernel virtual address.  */

#define KADDR(v)        ((v) >= MINKVADR)

#define	SEL_RPL		0x03

#endif	/* _SYS_IMMU_H */
   07070100005994000081240000000200000002000000012719347c0000021b000000230000000c00000000000000000000001700000000usr/include/sys/info.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_INFO_H
#define _SYS_INFO_H

#ident	"@(#)/usr/include/sys/info.h.sl 1.1 4.0 10/15/90 24088 AT&T-SF"
/*
 *   Header that will contain system info. Version and release number. 
 *
 */

struct sysinfo {
	short release;
	short version;
};

#endif	/* _SYS_INFO_H */
 07070100005995000081240000000200000002000000012719347c00001769000000230000000c00000000000000000000001900000000usr/include/sys/inline.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_INLINE_H
#define _SYS_INLINE_H

#ident	"@(#)/usr/include/sys/inline.h.sl 1.1 4.0 10/15/90 38106 AT&T-SF"

#if !defined(lint)

asm	void flushtlb()	
{
	movl	%cr3, %eax
	movl	%eax, %cr3
}

asm	int _cr0()
{
	movl	%cr0, %eax
}

asm	int _cr2()
{
	movl	%cr2, %eax
}

asm	int _cr3()
{
	movl	%cr3, %eax
	andl	$0x7FFFFFFF, %eax
}

asm	void _wdr0(x)
{
%reg	x;
	movl    x, %db0
%ureg	x;
	movl    x, %db0
%con	x;
	movl	x,%eax	
	movl    %eax, %db0
%mem	x;
	movl	x,%eax
	movl    %eax, %db0
}

asm	void _wdr1(x)
{
%reg	x;
	movl    x, %db1
%ureg	x;
	movl    x, %db1
%con	x;
	movl	x,%eax
	movl    %eax, %db1
%mem	x;
	movl	x,%eax
	movl    %eax, %db1
}

asm	void _wdr2(x)
{
%reg	x;
	movl    x, %db2
%ureg	x;
	movl    x, %db2
%con	x;
	movl	x,%eax
	movl    %eax, %db2
%mem	x;
	movl	x,%eax
	movl    %eax, %db2
}

asm	void _wdr3(x)
{
%reg	x;
	movl    x, %db3
%ureg	x;
	movl    x, %db3
%con	x;
	movl	x,%eax
	movl    %eax, %db3
%mem	x;
	movl	x,%eax
	movl    %eax, %db3
}

asm	void _wdr6(x)
{
%reg	x;
	movl    x, %db6
%ureg	x;
	movl    x, %db6
%con	x;
	movl	x,%eax
	movl    %eax, %db6
%mem	x;
	movl	x,%eax
	movl    %eax, %db6
}

asm	void _wdr7(x)
{
%reg	x;
	movl    x, %db7
%ureg	x;
	movl    x, %db7
%con	x;
	movl	x,%eax
	movl    %eax, %db7
%mem	x;
	movl	x,%eax
	movl    %eax, %db7
}

asm	int _dr0()
{
	movl	%dr0, %eax
}

asm	int _dr1()
{
	movl	%dr1, %eax
}

asm	int _dr2()
{
	movl	%dr2, %eax
}

asm	int _dr3()
{
	movl	%dr3, %eax
}

asm	int _dr6()
{
	movl	%dr6, %eax
}

asm	int _dr7()
{
	movl	%dr7, %eax
}

asm	void loadtr(x)
{
%reg	x;
	movl    x,%eax
	ltr	%ax
%ureg	x;
	movl    x,%eax
	ltr	%ax
%con	x;
	movl	x,%eax
	ltr	%ax
%mem	x;
	movl	x,%eax
	ltr	%ax
}

asm     void outl(port,val)
{
%reg	port,val;
	movl	port, %edx
	movl	val, %eax
	outl	(%dx)
%reg	port; mem	val;
	movl	port, %edx
	movl    val, %eax
	outl	(%dx)
%mem	port; reg	val;
	movw	port, %dx
	movl	val, %eax
	outl	(%dx)
%mem	port,val;
	movw	port, %dx
	movl    val, %eax
	outl	(%dx)
}

asm	void outw(port,val)
{
%reg	port,val;
	movl	port, %edx
	movl	val, %eax
	data16
	outl	(%dx)
%reg	port; mem	val;
	movl	port, %edx
	movw	val, %ax
	data16
	outl	(%dx)
%mem	port; reg	val;
	movw	port, %dx
	movl	val, %eax
	data16
	outl	(%dx)
%mem	port,val;
	movw	port, %dx
	movw	val, %ax
	data16
	outl	(%dx)
}

asm	void outb(port,val)
{
%reg	port,val;
	movl	port, %edx
	movl	val, %eax
	outb	(%dx)
%reg	port; mem	val;
	movl	port, %edx
	movb	val, %al
	outb	(%dx)
%mem	port; reg	val;
	movw	port, %dx
	movl	val, %eax
	outb	(%dx)
%mem	port,val;
	movw	port, %dx
	movb	val, %al
	outb	(%dx)
}

asm     int inl(port)
{
%reg	port;
	movl	port, %edx
	inl	(%dx)
%mem	port;
	movw	port, %dx
	inl	(%dx)
}

asm	int inw(port)
{
%reg	port;
	subl    %eax, %eax
	movl	port, %edx
	data16
	inl	(%dx)
%mem	port;
	subl    %eax, %eax
	movw	port, %dx
	data16
	inl	(%dx)
}

asm	int inb(port)
{
%reg	port;
	subl    %eax, %eax
	movl	port, %edx
	inb	(%dx)
%mem	port;
	subl    %eax, %eax
	movw	port, %dx
	inb	(%dx)
}

asm     void intr_disable()
{
	pushfl
	cli
}

asm     void intr_restore()
{
	popfl
}

asm     void intr_enable()
{
	popfl
	sti
}

asm int struct_zero(addr, len)
{
%mem	addr; con	len;
	pushl	%edi
	pushl	addr
	movl	len, %ecx
	popl	%edi
	movl	$0, %eax
	rep
	sstob
	popl	%edi
%mem	addr; reg	len;
	pushl	%edi
	pushl	addr
	movl	len, %ecx
	popl	%edi
	movl	$0, %eax
	rep
	sstob
	popl	%edi
%mem	addr, len;
	pushl	%edi
	pushl	addr
	movl	len, %ecx
	popl	%edi
	movl	$0, %eax
	rep
	sstob
	popl	%edi
}

asm void copy_bytes(from, to, count)
{
%mem	from,to; con	count;
	pushl	%esi
	pushl	%edi
	pushl	from
	pushl	to
	movl	count, %ecx
	popl	%edi
	popl	%esi
	rep
	smovb
	popl	%edi
	popl	%esi
%mem	from,to; reg	count;
	pushl	%esi
	pushl	%edi
	pushl	from
	pushl	to
	movl	count, %ecx
	popl	%edi
	popl	%esi
	rep
	smovb
	popl	%edi
	popl	%esi
%mem	from,to,count;
	pushl	%esi
	pushl	%edi
	pushl	from
	pushl	to
	movl	count, %ecx
	popl	%edi
	popl	%esi
	rep
	smovb
	popl	%edi
	popl	%esi
}
#else	/* !defined(lint) */
/*
 *	Very fast byte-at-a-time copy, as opposed to bcopy, which is
 *	longword-at-a-time. For controler boards which can't handle 32 bit accesses.
*/
void copy_bytes(from, to, count)
register caddr_t from, to;
register int count;
{	*to = *from;
	while (--count)
		*(++to) = *(++from);
}

#if defined(__STDC__)

extern	void flushtlb(void);
extern	int _cr0(void);
extern	int _cr2(void);
extern	int _cr3(void);
extern	void _wdr0(ulong);
extern	void _wdr1(ulong);
extern	void _wdr2(ulong);
extern	void _wdr3(ulong);
extern	void _wdr6(ulong);
extern	void _wdr7(ulong);
extern	int _dr0(void);
extern	int _dr1(void);
extern	int _dr2(void);
extern	int _dr3(void);
extern	int _dr6(void);
extern	int _dr7(void);
extern	void loadtr(ulong);
extern  void outl(unsigned, ulong);
extern	void outw(unsigned,ulong);
extern	void outb(unsigned,ulong);
extern  int inl(unsigned);
extern	int inw(unsigned);
extern	int inb(unsigned);
extern  void intr_disable();
extern  void intr_restore();
extern  void intr_enable();
extern  int struct_zero(caddr_t, int);

#else	/* __STDC__ */

extern	void flushtlb();	
extern	int _cr0();
extern	int _cr2();
extern	int _cr3();
extern	void _wdr0();
extern	void _wdr1();
extern	void _wdr2();
extern	void _wdr3();
extern	void _wdr6();
extern	void _wdr7();
extern	int _dr0();
extern	int _dr1();
extern	int _dr2();
extern	int _dr3();
extern	int _dr6();
extern	int _dr7();
extern	void loadtr();
extern  void outl();
extern	void outw();
extern	void outb();
extern  int inl();
extern	int inw();
extern	int inb();
extern  void intr_disable();
extern  void intr_restore();
extern  void intr_enable();
extern  int struct_zero();

#endif	/* __STDC__ */

#endif	/* !defined(lint) */

#endif	/* _SYS_INLINE_H */

#ifdef	KPERF  /* This is for kernel performance tool */
asm	int
get_spl()
{
	movl	ipl, %eax
}
#endif	/* KPERF */
   07070100005996000081240000000200000002000000012719347c00000230000000230000000c00000000000000000000001600000000usr/include/sys/ino.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_INO_H
#define _SYS_INO_H

#ident	"@(#)/usr/include/sys/ino.h.sl 1.1 4.0 10/15/90 8550 AT&T-SF"
/*
 * WARNING.  This stub will be removed in System V Release 5.0.
 * Be advised to change any source code using this header file.
 */
#include <sys/fs/s5ino.h>

#endif	/* _SYS_INO_H */
07070100005997000081240000000200000002000000012719347c0000183e000000230000000c00000000000000000000001800000000usr/include/sys/inode.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */

#ident	"@(#)/usr/include/sys/inode.h.sl 1.1 4.0 10/15/90 52387 AT&T-SF"

#define FSPTR 1
/*
 *	The I node is the focus of all file activity in unix.
 *	There is a unique inode allocated for each active file,
 *	each current directory, each mounted-on file, text file,
 *	and the root. An inode is 'named' by its dev/inumber
 *	pair. (iget/iget.c) Data, from mode on, is read in from
 *	permanent inode on volume.
 */


struct iisem {              /* XENIX semaphore */
    short  i_scount;        /* current semaphore count */
    short  i_eflag;         /* err flg */
    struct file *i_headw;   /* first waiter */
    struct file *i_tailw;   /* last waiter */
};

struct iisd {               /* XENIX shared data */
    union {
	struct  region *i_region;  /* Pointer to the shared region */
	struct  iisd *i_chain;     /* next available shared data structure */
    } i_iun;
    unsigned i_len;	     /* limit of segment (seg size - 1) */
    short    i_snum;         /* serial # for sdgetv, sdwaitv */
    short    i_flags;        /* LOCKED, etc. */
};

typedef	struct	inode
{
	struct	inode	*i_forw;	/* inode hash chain */
	struct	inode	*i_back;	/* '' */
	struct	inode	*av_forw;	/* freelist chain */
	struct	inode	*av_back;	/* '' */
	int	*i_fsptr;	/* "typeless" pointer to fs dependent */
	long	i_number;	/* i number, 1-to-1 with dev address */
	ushort	i_ftype;	/* file type = IFDIR, IFREG, etc. */
	short	i_fstyp;	/* File system type */
	off_t	i_size;		/* size of file */
	ushort	i_uid;		/* owner */
	ushort	i_gid;		/* group of owner */
	ushort	i_flag;
	ushort	i_fill;
	cnt_t	i_count;	/* reference count */
	short	i_nlink;	/* directory entries */
	dev_t	i_rdev;		/* Raw device number */
	dev_t	i_dev;		/* device where inode resides */

	struct	mount	*i_mntdev;	/* ptr to mount dev inode resides on */
	union i_u {

		struct	mount	*i_mton;	/* pntr to mount table entry */
						/* that this inode is "mounted on" */
		struct stdata	*i_sp;  /* Associated stream.		*/
		struct iisem	*isem;	/* ptr to XENIX  semaphores */
		struct iisd	*isd;	/* ptr to XENIX shared data */
	} i_un;
#ifdef FSPTR
	struct fstypsw *i_fstypp;	/* pointer to file system */
					/* switch structure */
#endif
	long	*i_filocks;	/* pointer to filock (structure) list */
	struct	rcvd	*i_rcvd;	/* receive descriptor */
	unsigned long	i_vcode;	/* inode version code (RFS caching) */
	ushort	i_wcnt;			/* open for write count (RFS caching) */
} inode_t;

extern struct inode inode[];	/* The inode table itself */

struct	ifreelist
{	int	pad[2];		/* must match struct inode !*/
	struct inode	*av_forw;
	struct inode	*av_back;
} ;

extern struct ifreelist ifreelist;

#define	i_sptr	i_un.i_sp
#define	i_mnton	i_un.i_mton
#define	i_sem 	i_un.isem	/* for i_ftype==IFNAM && i_namtype==IFSEM */
#define	i_sd 	i_un.isd	/* for i_ftype==IFNAM && i_namtype==IFSHD */

/* for IFNAM type files, the subtype is encoded in i_rdev */
#define i_namtype i_rdev

/* flags */

#define	ILOCK	0x01		/* inode is locked */
#define	IUPD	0x02		/* file has been modified */
#define	IACC	0x04		/* inode access time to be updated */
#define	IMOUNT	0x08		/* inode is mounted on */
#define	IWANT	0x10		/* some process waiting on lock */
#define	ITEXT	0x20		/* inode is pure text prototype */
#define	ICHG	0x40		/* inode has been changed */
#define ISYN	0x80		/* do synchronous write for iupdate */
#define	IADV	0x100		/* advertised */
#define	IDOTDOT	0x200		/* object of remote mount */
#define	IRMOUNT	0x800		/* remotely mounted	*/
#define	IISROOT	0x1000		/* This is a root inode of an fs */
#define IWROTE	0x2000		/* write has happened since open */
#define IXLOCKED 0x4000		/* enforce file locks for XENIX compatibility */

/* file types */
/* WARNING: The following defines should NOT change!If more */
/* file types need to be added they should be added in the low */
/* bits */

#define	IFMT	0xf000		/* type of file */
#define		IFDIR	0x4000	/* directory */
#define		IFCHR	0x2000	/* character special */
#define		IFBLK	0x6000	/* block special */
#define		IFREG	0x8000	/* regular */
#define		IFMPC	0x3000	/* multiplexed char special */
#define		IFMPB	0x7000	/* multiplexed block special */
#define		IFIFO	0x1000	/* fifo special */
#define		IFNAM	0x5000	/* special named file - subtype in r_dev */

#define		IFSEM  1	/* XENIX semaphore subtype of IFNAM type file */
#define		IFSHD  2	/* XENIX shared data subtype of IFNAM */
				/*	type file */

/* file modes */
/* the System V Rel 2 chmod system call only knows about */
/* ISUID, ISGID, ISVTX */
/* Therefore, the bit positions of ISUID, ISGID, and ISVTX */
/* should not change */
#define	ISUID	0x800		/* set user id on execution */
#define	ISGID	0x400		/* set group id on execution */
#define ISVTX	0x200		/* save swapped text even after use */

/* access requests */
/* the System V Rel 2 chmod system call only knows about */
/* IREAD, IWRITE, IEXEC */
/* Therefore, the bit positions of IREAD, IWRITE, and IEXEC */
/* should not change */
#define	IREAD		0x100	/* read permission */
#define	IWRITE		0x080	/* write permission */
#define	IEXEC		0x040	/* execute permission */
#define	ICDEXEC		0x020	/* cd permission */
#define	IOBJEXEC	0x010	/* execute as an object file */
				/* i.e., 410, 411, 413 */
#define IMNDLCK		0x001	/* mandatory locking set */

#define	MODEMSK		0xfff	/* Nine permission bits - read/write/ */
				/* execute for user/group/others and */
				/* ISUID, ISGID, and ISVTX */	
				/* This is another way of saying: */
				/* (ISUID|ISGID|ISVTX| */
				/* (IREAD|IWRITE|IEXEC)| */
				/* ((IREAD|IWRITE|IEXEC)>>3)| */
				/* ((IREAD|IWRITE|IEXEC)>>6)) */
#define	PERMMSK		0x1ff	/* Nine permission bits: */
				/* ((IREAD|IWRITE|IEXEC)| */
				/* ((IREAD|IWRITE|IEXEC)>>3)| */
				/* ((IREAD|IWRITE|IEXEC)>>6)) */
  07070100005998000081240000000200000002000000012719347c0000085c000000230000000c00000000000000000000001800000000usr/include/sys/iobuf.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_IOBUF_H
#define _SYS_IOBUF_H

#ident	"@(#)/usr/include/sys/iobuf.h.sl 1.1 4.0 10/15/90 8286 AT&T-SF"
/*
 * Each IDFC controller has an iobuf, which contains private state data
 * and 2 list heads: the b_forw/b_back list, which is doubly linked
 * and has all the buffers currently associated with that major
 * device; and the d_actf/d_actl list, which is private to the
 * controller but in fact is always used for the head and tail
 * of the I/O queue for the device.
 * Various routines in bio.c look at b_forw/b_back
 * (notice they are the same as in the buf structure)
 * but the rest is private to each device controller.
 */
typedef struct iobuf
{
	int	b_flags;		/* see buf.h */
	struct	buf *b_forw;		/* first buffer for this dev */
	struct	buf *b_back;		/* last buffer for this dev */
	struct	buf *b_actf;		/* head of I/O queue (b_forw)*/
	struct 	buf *b_actl;		/* tail of I/O queue (b_back)*/
	o_dev_t	b_dev;			/* major+minor device name */
	char	b_active;		/* busy flag */
	char	b_errcnt;		/* error count (for recovery) */
	int	jrqsleep;		/* process sleep counter on jrq full */
	struct eblock	*io_erec;	/* error record */
	int	io_nreg;		/* number of registers to log on errors */
	paddr_t	io_addr;		/* local bus address */
	physadr	io_mba;			/* mba address */
	struct	iostat	*io_stp;	/* unit I/O statistics */
	clock_t	io_start;
	int	sgreq;			/* SYSGEN required flag */
	int	qcnt;			/* outstanding job request counter */
	int	io_s1;			/* space for drivers to leave things */
	int	io_s2;			/* space for drivers to leave things */
	dev_t	b_edev;			/* expanded device number */
} iobuf_t;

#define tabinit(dv,stat) {0,0,0,0,0,makedev(dv,0),0,00,0,0,0,0,0,stat,0,0,0,0,0}
#define NDEVREG	(sizeof(struct device)/sizeof(int))

#define	B_ONCE	01	/* flag for once only driver operations */
#define	B_TIME	04	/* for timeout use */

#endif	/* _SYS_IOBUF_H */
07070100005999000081240000000200000002000000012719347c0000085c000000230000000c00000000000000000000001900000000usr/include/sys/ioccom.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_IOCCOM_H
#define _SYS_IOCCOM_H

#ident	"@(#)/usr/include/sys/ioccom.h.sl 1.1 4.0 10/15/90 2776 AT&T-SF"

/*	@(#)ioccom.h 1.3 88/02/08 SMI; from UCB ioctl.h 7.1 6/4/86	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 255 bytes.
 */
#define	IOCPARM_MASK	0xff		/* parameters must be < 256 bytes */
#define	IOC_VOID	0x20000000	/* no parameters */
#define	IOC_OUT		0x40000000	/* copy out parameters */
#define	IOC_IN		0x80000000	/* copy in parameters */
#define	IOC_INOUT	(IOC_IN|IOC_OUT)
/* the 0x20000000 is so we can distinguish new ioctl's from old */
#define	_IO(x,y)	(IOC_VOID|(x<<8)|y)
#define	_IOR(x,y,t)	(IOC_OUT|((((int)sizeof(t))&IOCPARM_MASK)<<16)|(x<<8)|y)
#define	_IORN(x,y,t)	(IOC_OUT|(((t)&IOCPARM_MASK)<<16)|(x<<8)|y)
#define	_IOW(x,y,t)	(IOC_IN|((((int)sizeof(t))&IOCPARM_MASK)<<16)|(x<<8)|y)
#define	_IOWN(x,y,t)	(IOC_IN|(((t)&IOCPARM_MASK)<<16)|(x<<8)|y)
/* this should be _IORW, but stdio got there first */
#define	_IOWR(x,y,t)	(IOC_INOUT|((((int)sizeof(t))&IOCPARM_MASK)<<16)|(x<<8)|y)

#endif	/* _SYS_IOCCOM_H */
0707010000599a000081240000000200000002000000012719347c00000c76000000230000000c00000000000000000000001800000000usr/include/sys/ioctl.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_IOCTL_H
#define _SYS_IOCTL_H

#ident	"@(#)/usr/include/sys/ioctl.h.sl 1.1 4.0 10/15/90 48837 AT&T-SF"
/*
 *      There are some inherent problems in having a single file
 *      ioctl.h, with both System V and BSD flags. Introducing
 *  BSD flags into this file creates compilation problems
 *  with flags such as ECHO, NL1 etc., if termio.h and ioctl.h
 *      are included by the same file. Since these two files can
 *  be only included by System V applications, /usr/inclule/sys/ioctl.h
 *      will be System V mode and all the BSD flags will be turned off
 *      using #ifdef BSD_COMP. This file will also exist in
 *  /usr/ucbinclude/sys/ioctl.h for BSD applications but without the
 *      BSD flags turned off. System V appliactions can use ioctl.h without
 *      any changes, System V applications requiring BSD flags should
 *      -D BSD_COMP when compiling (and be warned about the common
 *      flags between System V and BSD) and BSD applications should
 *  use /usr/ucbinclude/sys/ioctl.h.
 *
 */

/*
 *	Ioctl commands
 */


/* BSD related defines */

#ifdef BSD_COMP

#include <sys/ttychars.h>
#include <sys/ttydev.h>
#include <sys/ttold.h>


#define	TANDEM		O_TANDEM
#define	CBREAK		O_CBREAK
#ifndef _SGTTY_H
#define	LCASE		O_LCASE
#define	ECHO		O_ECHO
#define	CRMOD		O_CRMOD
#define	RAW		O_RAW
#define	ODDP		O_ODDP
#define	EVENP		O_EVENP
#define	ANYP		O_ANYP
#define	NLDELAY		O_NLDELAY
#define		NL0		O_NL0
#define		NL1		O_NL1
#define		NL2		O_NL2
#define		NL3		O_NL3
#define	TBDELAY		O_TBDELAY
#define		TAB0		O_TAB0
#define		TAB1		O_TAB1
#define		TAB2		O_TAB2
#define	XTABS		O_XTABS
#define	CRDELAY		O_CRDELAY
#define		CR0		O_CR0
#define		CR1		O_CR1
#define		CR2		O_CR2
#define		CR3		O_CR3
#define	VTDELAY		O_VTDELAY
#define		FF0		O_FF0
#define		FF1		O_FF1
#define	BSDELAY		O_BSDELAY
#define		BS0		O_BS0
#define		BS1		O_BS1
#define 	ALLDELAY	O_ALLDELAY
#endif /* _SGTTY_H */
#define	CRTBS		O_CRTBS
#define	PRTERA		O_PRTERA
#define	CRTERA		O_CRTERA
#define	TILDE		O_TILDE
#define	MDMBUF		O_MDMBUF
#define	LITOUT		O_LITOUT
#define	TOSTOP		O_TOSTOP
#define	FLUSHO		O_FLUSHO
#define	NOHANG		O_NOHANG
#define	L001000		O_L001000
#define	CRTKIL		O_CRTKIL
#define	PASS8		O_PASS8
#define	CTLECH		O_CTLECH
#define	PENDIN		O_PENDIN
#define	DECCTQ		O_DECCTQ
#define	NOFLSH		O_NOFLSH

#include <sys/filio.h>
#include <sys/sockio.h>

#endif /* BSD_COMP */


/*
**	Union for use by all device handler ioctl routines.
*/
union ioctl_arg {
	struct termio	*stparg;	/* ptr to termio struct */
	struct Generic	*sparg;		/* ptr to generic struct */
	char		*cparg;		/* ptr to character */
	char		carg;		/* character */
	int		*iparg;		/* ptr to integer */
	int		iarg;		/* integer */
	long            *lparg;         /* ptr to long */
	long            larg;           /* long */
};

/*
 * Commands needed for XENIX ioctl() compatibility
 */

#define	TIOC	('T'<<8)
#define	TCFLSH	(TIOC|7)

#endif	/* _SYS_IOCTL_H */
  0707010000599b000081240000000200000002000000012719347c00000cda000000230000000c00000000000000000000001600000000usr/include/sys/ipc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_IPC_H
#define _SYS_IPC_H

#ident	"@(#)/usr/include/sys/ipc.h.sl 1.1 4.0 10/15/90 10395 AT&T-SF"
/* Common IPC Access Structure */

/* The kernel supports both the SVR3 ipc_perm and expanded ipc_perm
** structures simultaneously.
*/

/* Applications that read /dev/mem must be built like the kernel. A new
** symbol "_KMEMUSER" is defined for this purpose.
*/

#if defined(_KERNEL) || defined(_KMEMUSER)
/* SVR3 ipc_perm structure */
struct o_ipc_perm {
	o_uid_t	uid;	/* owner's user id */
	o_gid_t	gid;	/* owner's group id */
	o_uid_t	cuid;	/* creator's user id */
	o_gid_t	cgid;	/* creator's group id */
	o_mode_t mode;	/* access modes */
	ushort	seq;	/* slot usage sequence number */
	key_t	key;	/* key */
};
/* expanded ipc_perm structure */
struct ipc_perm {
	uid_t	uid;	/* owner's user id */
	gid_t	gid;	/* owner's group id */
	uid_t	cuid;	/* creator's user id */
	gid_t	cgid;	/* creator's group id */
	mode_t	mode;	/* access modes */
	ulong	seq;	/* slot usage sequence number */
	key_t	key;	/* key */
	long	pad[4]; /* reserve area */
};
#else	/* user definition */

struct ipc_perm {
#if !defined(_STYPES)
/* maps to kernel ipc_perm structure */
	uid_t	uid;	/* owner's user id */
	gid_t	gid;	/* owner's group id */
	uid_t	cuid;	/* creator's user id */
	gid_t	cgid;	/* creator's group id */
	mode_t	mode;	/* access modes */
	ulong	seq;	/* slot usage sequence number */
	key_t	key;	/* key */
	long	pad[4];	/* reserve area */
#else
	o_uid_t	uid;	/* owner's user id */
	o_gid_t	gid;	/* owner's group id */
	o_uid_t	cuid;	/* creator's user id */
	o_gid_t	cgid;	/* creator's group id */
	o_mode_t mode;	/* access modes */
	ushort	seq;	/* slot usage sequence number */
	key_t	key;	/* key */
#endif	/* !defined(_STYPES) */
};
#endif	/* defined(_KERNEL) */

/* Common IPC Definitions. */
/* Mode bits. */
#define	IPC_ALLOC	0100000		/* entry currently allocated */
#define	IPC_CREAT	0001000		/* create entry if key doesn't exist */
#define	IPC_EXCL	0002000		/* fail if key exists */
#define	IPC_NOWAIT	0004000		/* error if request must wait */

/* Keys. */
#define	IPC_PRIVATE	(key_t)0	/* private key */

/* Control Commands. */

#if defined(_KERNEL) || defined(_KMEMUSER)
/* Command values for EFT definition */
#define IPC_RMID	10	/* remove identifier */
#define	IPC_SET		11	/* set options */
#define	IPC_STAT	12	/* get options */

	/* For compatibility */
#define	IPC_O_RMID	0	/* remove identifier */
#define	IPC_O_SET	1	/* set options */
#define	IPC_O_STAT	2	/* get options */

#else	/* user definition */

#if !defined(_STYPES)

	/* EFT definition */
#define	IPC_RMID	10	/* remove identifier */
#define	IPC_SET		11	/* set options */
#define	IPC_STAT	12	/* get options */
#else	/* compatibility mode - NON EFT  definition */
#define	IPC_RMID	0	/* remove identifier */
#define	IPC_SET		1	/* set options */
#define	IPC_STAT	2	/* get options */

#endif	/* !defined(_STYPES) */
#endif	/* defined(_KERNEL) */

#if defined(__STDC__) && !defined(_KERNEL)
key_t ftok(const char *, int);
#endif

#endif	/* _SYS_IPC_H */
  0707010000599c000081240000000200000002000000012719347c000006b2000000230000000c00000000000000000000001600000000usr/include/sys/ipl.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_IPL_H
#define _SYS_IPL_H

#ident	"@(#)/usr/include/sys/ipl.h.sl 1.1 4.0 10/15/90 7758 AT&T-SF"

/*
 * Interrupt Priority Levels
 *
 * The following defines are used in misc.s to map
 * spl*() functions to interrupt priority levels,
 * and in initializing the intpri[] array in conf.c,
 * which is generated by the config command.
 * The interrupt priority (intpri) levels specified in the
 * master.d/ * /config files are SPL* constants, not ipl's.
 * Thus the spl to ipl mapping can be changed to add new spls and ipls
 * without changing the intpri values in the config files.
 *
 * IPLHI is the priority level at which interrupts are entirely disabled
 * by clearing the IF flag with a cli instruction.
 * Interrupts are selectively disabled at lower priority levels
 * by loading interrupt masks into the PICs.
 */

#define IPLHI           8

/*      spl             ipl     */

#define SPL0            0
#define SPL1            1
#define SPL2            2
#define SPL3            3
#define SPL4            4
#define SPL5            5
#define SPLPP           5
#define SPL6            6
#define SPLNI           6
#define SPLVM		6		/* 4.0 specific */
#define SPLIMP		7		/* 4.0 specific */
#define SPLTTY          7

/*
 * SPL7 and SPLHI must be at the same priority level, typically IPLHI.
 * The clock must be the only device at SPL7/SPLHI.
 */

#define SPL7            IPLHI
#define SPLHI           IPLHI

#endif	/* _SYS_IPL_H */
  0707010000599d000081240000000200000002000000012719347c00000194000000230000000c00000000000000000000001700000000usr/include/sys/istk.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ISTK_H
#define _SYS_ISTK_H

#ident	"@(#)/usr/include/sys/istk.h.sl 1.1 4.0 10/15/90 23085 AT&T-SF"

#endif	/* _SYS_ISTK_H */
0707010000599e000081240000000200000002000000012719347c00000d77000000230000000c00000000000000000000001900000000usr/include/sys/jioctl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_JIOCTL_H
#define _SYS_JIOCTL_H

#ident	"@(#)/usr/include/sys/jioctl.h.sl 1.1 4.0 10/15/90 15686 AT&T-SF"

/*
 * jioctl.h
 *
 * Low level control codes for communication between the host and a
 * windowing terminal. See windows.h for additional messages used by
 * libwindows.
 * 
 * In case you are wondering what the "j" in jioctl stands for,
 * the "j" stands for jerq which was the first windowing terminal.
 * The jerq became the Blit which begot the 5620 DMD which begot
 * the 615, the 620 and the 630 MTG.
 */


/*
 * Ioctl requests sent to the xt driver. The types JMPX, JWINSIZE,
 * and JTRUN are processed locally by xt. The others involve sending
 * a control message to the terminal on channel 0 (the control
 * channel). In the control message, the lower bytes of these defines
 * are used as the first byte of the control message.
 *
 * Note that packets sent from the host to the terminal on channels
 * other than 0 are implicitly data packets.
 */

#define	JTYPE		('j'<<8)
#define	JBOOT		(JTYPE|1)  /* start a download in a window */
#define	JTERM		(JTYPE|2)  /* return to default terminal emulator */
#define	JMPX		(JTYPE|3)  /* currently running layers? */

/*** Timeout in seconds. Not supported by streams xt, but reserve
*    this number to avoid confusion.
#define	JTIMO		(JTYPE|4)
***/

#define	JWINSIZE	(JTYPE|5)  /* inquire window size */
#define	JTIMOM		(JTYPE|6)  /* timeouts in millisecs */
#define	JZOMBOOT	(JTYPE|7)  /* JBOOT but wait for debugger to run */
#define JAGENT		(JTYPE|9)  /* control for both directions */
#define JTRUN		(JTYPE|10) /* send runlayer command to layers cmd */
#define JXTPROTO	(JTYPE|11) /* set xt protocol type */

/*
 * jwinsize structure used by JWINSIZE message.
 */

struct jwinsize
{
	char	bytesx, bytesy;	/* Window size in characters */
	short	bitsx, bitsy;	/* Window size in bits */
};

/*
 * Channel 0 control message format.
 */

struct jerqmesg
{
	char	cmd;		/* A control code above */
	char	chan;		/* Channel it refers to */
};

/*
 * The first byte of every xt packet from the terminal to the host
 * is one of these control codes. Data packets start with either
 * C_SENDCHAR or C_SENDNCHARS.
 *
 * The usual format is: [command][data]
*/

#define	C_SENDCHAR	1	/* Send character to layer process */
#define	C_NEW		2	/* Create a new layer */
#define	C_UNBLK		3	/* Unblock layer process */
#define	C_DELETE	4	/* Delete layer process group */
#define	C_EXIT		5	/* Exit layers */
#define	C_DEFUNCT	6	/* Send terminate signal to proc. group */
#define	C_SENDNCHARS	7	/* Send several characters to layer proc. */
#define	C_RESHAPE	8	/* Layer has been reshaped */
#define C_RUN           9       /* Run command in layer (local to xt/layers) */
#define C_NOFLOW        10      /* Disable network xt flow control */
#define C_YESFLOW       11      /* Enable network xt flow control */

/*
 * Format of JAGENT packets.
 */

struct bagent{        /* this is supposed to be 12 bytes long */
    long size;      /* size of src string going in and dest string out */
	char * src;	/* address of the source byte string */
	char * dest;	/* address of the destination byte string */
};

#endif	/* _SYS_JIOCTL_H */
 0707010000599f000081240000000200000002000000012719347c000001ed000000230000000c00000000000000000000001500000000usr/include/sys/kb.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/kb.h.sl 1.1 4.0 10/15/90 27061 AT&T-SF"

#ifndef	_SYS_KB_H
#define	_SYS_KB_H

#define SEND2KBD(port, byte) { \
	while (inb(KB_STAT) & KB_INBF) \
		; \
	outb(port, byte); \
}

#endif /* _SYS_KB_H */
   070701000059a0000081240000000200000002000000012719347c0000c2ee000000230000000c00000000000000000000001500000000usr/include/sys/kd.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/kd.h.sl 1.1 4.0 10/15/90 12174 AT&T-SF"

#ifndef	_SYS_KD_H
#define	_SYS_KD_H

/*
 * Types of displays supported
 */
#define	KD_MONO		01	/* monochrome display adapter */
#define	KD_HERCULES	02	/* Hercules monochrome graphics adapter */
#define	KD_CGA		03	/* color graphics adapter */
#define	KD_EGA		04	/* enhanced graphics adapter */
#define KD_VGA		05	/* video graphics array */
#define KD_VDC400	06	/* VDC 400 adapter */
#define KD_VDC750	07	/* VDC 750 adapter */
#define KD_VDC600	010	/* VDC 600 adapter */

#ifdef EVGA

#define KD_EVGA		011	/* extended vga. Used for Vdc.v_info.cntlr */	

/*
 * Specific evga card types
 */

#define EVGA_VGA	0	
#define EVGA_VEGA	1
#define EVGA_STBGA	2
#define EVGA_SIGMAH	3
#define EVGA_PVGA1A	4
#define EVGA_DELL	5
#define EVGA_VRAM	6
#define EVGA_ORVGA	7
#define EVGA_ORVGAni	8
#define EVGA_TVGA	9
#define EVGA_TVGAni	10
#define EVGA_GVGA	11
#define EVGA_EGA	12
#define EVGA_PEGA	13
#define EVGA_GEGA	14
#define EVGA_FASTWRITE	15
#define EVGA_WON	16

#endif	/*EVGA*/

/*
 * Types of monitors supported
 */

#define KD_UNKNOWN	0
#define KD_STAND_M	1	/* standard monochrome monitor */
#define KD_STAND_C	2	/* standard color monitor */
#define KD_MULTI_M	3	/* multi-mode monochrome monitor */
#define KD_MULTI_C	4	/* multi-mode color monitor */

/* Xenix display/adapter definitions */
#define MONO	1		/* Xenix value for monochrome */
#define CGA	2		/* Xenix value for color graphics */
#define PGA	3		/* Xenix value for professional graphics */
#define EGA	4		/* Xenix value for enhanced graphics */
#define VGA	5		/* Xenix value for Video Graphics Array */
#define	S_ADAP	100		/* special adapter which has no definition */

/*
 * Virtual display constants
 */
#define	KD_WIDTH	80		/* normal screen width */
#define	KD_NARROWWIDTH	40		/* narrow screen width */
#define	KD_EXTRAWIDTH	132		/* wide screen width */
#define	KD_HEIGHT	25		/* screen height */
#define	KD_TALLHEIGHT	43		/* tall screen height */
#define	KD_MAXSCRSIZE	(KD_EXTRAWIDTH * KD_TALLHEIGHT)	/* max screen size */
#define	KD_SCRTOBUF	0		/* transfer from screen to buffer */
#define	KD_BUFTOSCR	1		/* transfer from buffer to screen */

/*
 * keyboard controller I/O port addresses
 */
#define KB_OUT	0x60		/* output buffer R/O */
#define KB_IDAT 0x60		/* input buffer data write W/O */
#define KB_STAT 0x64		/* keyboard controller status R/O */
#define KB_ICMD 0x64		/* input buffer command write W/O */

/*
 * keyboard controller commands and flags
 */
#define KB_INBF		0x02	/* input buffer full flag */
#define KB_OUTBF	0x01	/* output buffer full flag */
#define KB_GATE20	0x02	/* set this bit to allow addresses > 1Mb */
#define KB_ROP		0xD0	/* read output port command */
#define KB_WOP		0xD1	/* write output port command */
#define	KB_RCB		0x20	/* read command byte command */
#define	KB_WCB		0x60	/* write command byte command */
#define	KB_ENAB		0xae	/* enable keyboard interface */
#define	KB_DISAB	0x10	/* disable keyboard */
#define	KB_EOBFI	0x01	/* enable interrupt on output buffer full */
#define KB_ACK		0xFA	/* Acknowledgement byte from keyboard */
#define	KB_RESETCPU	0xFE	/* command to reset AT386 cpu */
#define KB_READID	0xF2	/* command to read keyboard id */
#define	KB_RESEND	0xFE	/* response from keyboard to resend data */
#define	KB_ERROR	0xFF	/* response from keyboard to resend data */
#define	KB_RESET	0xFF	/* command to reset keyboard */
#define	KB_ENABLE	0xF4	/* command to to enable keyboard
				 * this is different from KB_ENAB above in
				 * that KB_ENAB is a command to the 8042 to
				 * enable the keyboard interface, not the
				 * keyboard itself */

/*
 * Structure of keyboard translation table
 */
#define NUM_KEYS	256		/* Maximum number of keys */
#define NUM_STATES	8		/* Number of key states */
#pragma pack(2)
typedef struct {
	short  n_keys ;			/* Number of entries in table */
	struct key_t {
		unsigned char map[NUM_STATES];	/* Key code for each state */
		unsigned char spcl;	/* Bits marking states as special */
		unsigned char flgs;	/* Flags */
	} key[NUM_KEYS+1];		/* One entry for each key */
} keymap_t;
#pragma pack()
/*
 * Keyboard translation modes
 */
#define	K_RAW		0x00		/* Just send raw up/down scan codes */
#define	K_XLATE		0x01		/* Translate scan codes to ASCII */
/*
 * character table flag bits.
 */
#define	NUMLCK		0x8000	/* flag key as affected by num lock key */
#define	CAPLCK		0x4000	/* flag key as affected by caps lock key */
#define	CTLKEY		0x2000	/* flag key as afected by control keys */
/*
 * character table key types
 */
#define	NORMKEY		0x0000	/* key is a normal key, send with no prefix */
#define	SHIFTKEY	0x0100	/* key is a shift key */
#define	BREAKKEY	0x0200	/* key is a break key */
#define	SS2PFX		0x0300	/* prefix key with <ESC> N */
#define	SS3PFX		0x0400	/* prefix key with <ESC> O */
#define	CSIPFX		0x0500	/* prefix key with <ESC> [ */
#define	SPECIALKEY	0x0600	/* special key type */
#define	NOKEY		0x0f00	/* flag a key as nonexistant */
#define	TYPEMASK	0x0f00	/* select key type bits */


/*
 * Table selectors for KDSKBENT/KDGKBENT ioctl's
 */
#define	K_NORMTAB	0x00		/* Select unaugmented keyboard table */
#define	K_SHIFTTAB	0x01		/* Select shifted keyboard table */
#define	K_ALTTAB	0x02		/* Select alted keyboard table */
#define	K_ALTSHIFTTAB	0x03		/* Select alt-shifted keyboard table */
#define	K_SRQTAB	0x04		/* select sysreq table */
/*
 * Make/break distinctions
 */
#define	KBD_BREAK	0x80		/* Key make/break bit (break=1) */
/*
 * Flags for key state calculation.
 */
#define SHIFTED	0x01			/* Keys are shifted */
#define CTRLED	0x02			/* Keys are ctrl'd */
#define ALTED 	0x04			/* Keys are alt'd */
/*
 * Possible key states.  Used as index into translation entry for key.
 */
#define NORMAL		0		/* Unmodified */
#define SHIFT		SHIFTED		/* Shift key depressed */
#define CNTRL		CTRLED		/* Ctrl key depressed */
#define	SHFCTL		(CTRLED|SHIFTED)	/* Shift and ctrl keys */
#define ALT		ALTED		/* Alt key depressed */
#define	ALTSHF		(ALTED|SHIFTED)	/* Shift and alt keys depressed */
#define	ALTCTL		(ALTED|CTRLED)	/* Ctrl and alt keys depressed */
#define	ALTSHFCTL	(ALTED|CTRLED|SHIFTED)	/* Shift, ctrl, and alt keys */
/*
 * Key map table flags
 */
#define	KMF_CLOCK	0x01		/* Key affected by caps lock */
#define	KMF_NLOCK	0x02		/* Key affected by num lock */
/*
 * kb_state bit definitions
 */
#define LEFT_SHIFT	0x0001	/* left shift key depressed */
#define	LEFT_ALT	0x0002	/* left alt key depressed */
#define	LEFT_CTRL	0x0004	/* left control key depressed */
#define	RIGHT_SHIFT	0x0008	/* right shift key depressed */
#define	RIGHT_ALT	0x0010	/* right alt key depressed */
#define	RIGHT_CTRL	0x0020	/* right control key depressed */
#define	CAPS_LOCK	0x0040	/* caps lock key down */
#define	NUM_LOCK	0x0080	/* num lock key down */
#define	SCROLL_LOCK	0x0100	/* scroll lock key down */
#define	ALTSET		(LEFT_ALT|RIGHT_ALT)
#define	SHIFTSET	(LEFT_SHIFT|RIGHT_SHIFT)
#define	CTRLSET		(LEFT_CTRL|RIGHT_CTRL)
#define	NONTOGGLES	(ALTSET|SHIFTSET|CTRLSET)
/*
 * Keyboard scan codes
 */
#define	SCROLLLOCK	0x46		/* Scroll lock key */
/*
 * Number of entries in 0xe0 prefix translation table
 */
#define	ESCTBLSIZ	18		/* Entries in 101/102 key table */
/*
 * Character flags.  Should not conflict with FRERROR and friends in tty.h
 */
#define NO_CHAR		0x8000		/* Do not generate a char */
#define GEN_ESCLSB	0x0800		/* Generate <ESC> [ prefix to char */
#define GEN_ESCN	0x0400		/* Generate <ESC> N prefix to char */
#define GEN_ZERO	0x0200		/* Generate 0 prefix to char */
#define	GEN_FUNC	0x0100		/* Generate function key */
#define GEN_ESCO	0x1000		/* Generate <ESC> O prefix to char */
/*
 * Special key code definitions
 */
#define	K_NOP	0			/* Keys with no function */
#define K_LSH	2			/* Left shift */
#define K_RSH	3			/* Right shift */
#define K_CLK	4			/* Caps lock */
#define K_NLK	5			/* Num lock */
#define K_SLK	6			/* Scroll lock */
#define K_ALT	7			/* Alt */
#define	K_BTAB	8			/* Back tab */
#define K_CTL	9			/* Control */
#define	K_LAL	10			/* Left alt */
#define	K_RAL	11			/* Right alt */
#define	K_LCT	12			/* Left control */
#define	K_RCT	13			/* Right control */
#define K_AGR	14			/* ALT-GR key  -- 102 keyboard only */
#define	K_FUNF	27			/* First function key */
#define	K_FUNL	122			/* Last function key */
#define	K_SRQ	123			/* System request */
#define	K_BRK	124			/* Break */
#define	K_ESN	125			/* <ESC> N <unalt'd value> sequence */
#define	K_ESO	126
#define	K_ESL	127
#define	K_RBT	128			/* Reboot system */
#define	K_DBG	129			/* Invoke debugger */
#define	K_NEXT	130
#define	K_PREV	131
#define	K_FRCNEXT 132
#define	K_FRCPREV 133
#define K_VTF	134
#define	K_VTL	148
#define K_MGRF	149
#define	K_MGRL	191
#define	K_PFXF	192
#define	K_PFXL	255



/*
 * Macro for recognizing scan codes for special keys
 */
#define	IS_SPECIAL(s,i)	(kdkeymap.key[(s)].spcl & (0x80>>(i)))	/* Special? */
#define	IS_SPECKEY(k,s,i)	((k)->key[(s)].spcl & (0x80>>(i)))	/* Special? */
#define	IS_NPKEY(s)	(((s) >= 71) && ((s) <=83))	/* Number pad? */
/*
 * Function key constants and macros
 */
#define	NSTRKEYS	(K_FUNL-K_FUNF+1)	/* Number of string keys */
#define STRTABLN	512		/* Max length of sum of all strings */
#define STRTABLN_21	256		/* Max length of sum in version 2.1 */
#define	IS_FUNKEY(c)	(((int)(c) >= K_FUNF) && ((int)(c) <= K_FUNL) || ((int)(c) >= K_PFXF) && ((int)(c) <= K_PFXL))	/* Function? */
typedef unchar strmap_t[STRTABLN];	/* String map table type */
typedef ushort stridx_t[NSTRKEYS + 1];	/* String map index type */

typedef unsigned char	srqtab_t[NUM_KEYS + 1];

/* Shorthand for constants so columns line up neatly */
#define	KF	K_FUNF			/* First function key */
#define	L_O	0			/* Key not affected by locks */
#define	L_C	KMF_CLOCK		/* Key affected by caps lock */
#define	L_N	KMF_NLOCK		/* Key affected by num lock */
#define	L_B	(KMF_CLOCK|KMF_NLOCK)	/* Key affected by caps and num lock */

/*
 * Structure used for SETFKEY and GETFKEY ioctls
 */
#define MAXFK	30			/* Maximum length of string */
#pragma pack(2)
struct fkeyarg {
	unsigned short	keynum;		/* Function key number */
	unchar	 	keydef[MAXFK];	/* Key definition */
	char		flen;		/* Length of key definition */
};
#pragma pack()
/*
 * Constants for extended keys
 */
#define	NUMEXTSTATES	4		/* Number of extended states */

/* Commands for LED and typematic start/rate on the AT */
#define	KDCQMAX		8	/* length of keyboard command queue */
#define LED_WARN	0xED	/* Tell kbd that following byte is led status */
#define LED_SCR		0x01	/* Flag bit for scroll lock */
#define LED_CAP		0x04	/* Flag bit for cap lock */
#define LED_NUM		0x02	/* Flag bit for num lock */
#define	ACK_WAIT	0x01	/* flag for waiting for kbd response */
#define	TYPE_WARN	0xF3	/* command--next byte is typematic values */
#define	TYPE_VALS	0x20	/* max speed (30/s) and 1/2 sec delay */
#define	SCAN_WARN	0xF0	/* kbd command to set scan code set */


/*
 * Screen mapping constants and types
 */
#define NUM_ASCII	256		/* Number of ASCII characters */
typedef unsigned char scrnmap_t[NUM_ASCII];	/* Screen map type */
typedef unsigned char *scrnmapp_t;	/* Pointer to screen map type */


/*
 * defines for KDDFLTKEYMAP, KDDFLTSTRMAP and KDDFLTSCRNMAP ioctls
 */
#define	KD_DFLTSET	1
#define	KD_DFLTGET	2

/*
 * structure for KDDFLTSTRMAP ioctl 
 */
struct str_dflt {
	int	str_direction;
	strmap_t	str_map;
};

/*
 * structure for KDDFLTSCRNMAP ioctl 
 */
struct scrn_dflt {
	int	scrn_direction;
	scrnmap_t	scrn_map;
};

/*
 * structure for KDDFLTKEYMAP ioctl 
 */
struct key_dflt {
	int	key_direction;
	keymap_t	key_map;
};


/*
 * defines and structures for WS_PIO_ROMFONT ioctl
 */

#define F8x8_SIZE	2048
#define F8x14_SIZE	3072
#define F8x16_SIZE	4096

#define	F8x8_BPC	8
#define	F8x14_BPC	14
#define	F8x16_BPC	16
#define	F9x16_BPC	16

#define	MAX_ROM_CHAR	256	/* Current EGA/VGA support only 256 chars */

struct char_def {
	int cd_index;
	unchar cd_map_8x8[F8x8_BPC];
	unchar cd_map_8x14[F8x14_BPC];
	unchar cd_map_8x16[F8x16_BPC];
	unchar cd_map_9x16[F9x16_BPC];
};

typedef struct rom_font_arg {
	unsigned int fnt_numchar;
	struct char_def	fnt_chars[MAX_ROM_CHAR];
} rom_font_t;

/*
 * type of adapter installed, matches bits in CMOS ram
 */
#define	MCAP_UNK	0xff	/* adapter not determined yet */
#define MCAP_MONO	0x03	/* mono adapter installed */
#define MCAP_COLOR	0x02	/* color adapter installed in 80 column mode */
#define MCAP_COLOR40	0x01	/* color adapter installed in 40 column mode */
#define MCAP_EGA	0x00	/* EGA adapter installed */

/* 6845 base addresses */
#define	MONO_REGBASE	0x03b4	/* Base register address for mono modes */
#define	COLOR_REGBASE	0x03d4	/* Base register address for color modes */

/* offsets from 6845 base address for various registers */
#define DATA_REG	0x1
#define MODE_REG	0x4
#define MODE2_REG	0x0A	/* rite-vu card only */
#define COLOR_REG	0x5	/* color adapter only */
#define STATUS_REG	0x6

/* definitions for bits in the color adapter mode register */
#define M_ALPHA40	0x00	/* 40 by 25 alphanumeric */
#define M_ALPHA80	0x01	/* 80 by 25 alphanumeric */
#define M_GRAPH		0x02	/* 320x200 or 640x200 graphics */
#define M_BW		0x04	/* black & white */
#define M_ENABLE	0x08	/* video enable */
#define M_HIGHRES	0x10	/* 640x200 B&W graphics */
#define M_BLINK		0x20	/* enable blink attribute */

/* definitions for bits in the color adapter mode2 register ( rite-vu card )*/
#define	M_GRAPH2	0x01	/* 640x400 graphics AT&T mode */
#define	M_DEGAUSS	0x02	/* degauss color monitor */
#define	M_ALTCHAR	0x04	/* rite-vu card alternate character set */
#define	M_PGSEL		0x08	/* switch to 2nd 16kbytes of memory */
#define	M_UNDRLINE	0x40	/* underline white chars, not blue */


/* definitions for bits in the color adapter status register */
#define S_UPDATEOK	0x01	/* safe to update regen buffer */
#define S_VSYNC		0x08	/* raster is in vertical retrace mode */

/* definitions for loading data into CRT controller registers */
#define R_STARTADRH	12	/* start address, high word */
#define R_STARTADRL	13	/* start address, low word */
#define R_CURADRH	14	/* cursor address, high word */
#define R_CURADRL	15	/* cursor address, low word */

/* definitions for the EGA */
#define IN_STAT_0	0x3c2	/* input status register zero */
#define MISC_OUT	0x3c2	/* miscellaneous output register */
#define IN_STAT_1	6	/* offset of input status register 1 */
#define FEAT_CTRL	6	/* offset of feature control register */
#define SW_SENSE	0x10	/* switch sense bit in input status zero */
#define CLKSEL		2	/* shift to select switch number */
#define GRAPH_1_POS	0x3cc	/* graphics 1 position */
#define GRAPH_2_POS	0x3ca	/* graphics 2 position */
#define GRAPHICS1	0	/* value for graphics 1 */
#define GRAPHICS2	1	/* value for graphics 2 */
#define SEQ_RST		0x01	/* reset sequencer */
#define SEQ_RUN		0x03	/* start sequencer */
#define PALETTE_ENABLE	0x20	/* palette address source in attribute reg */
#define CHGEN_BASE	0xa0000	/* base address for character generator */
#define CHGEN_SIZE	8192	/* character generator is 8K */
#define MONO_BASE	0xb0000	/* Location of monochrome display memory */
#define MONO_SIZE	0x8000	/* Monochrome has 32K of memory available */
#define MONO_SCRMASK	0x7ff	/* Mono text memory wraps at 4K */
#define COLOR_BASE	0xb8000	/* Location of color display memory */
#define COLOR_SIZE	0x8000	/* Color has up to 32K of memory available */
#define COLOR_SCRMASK	0x1fff	/* Color text memory wraps at 16K */
#define	EGA_BASE	0xa0000	/* Location of enhanced display memory */
#define EGA_SIZE	0x10000	/* EGA has at 64K of memory available */
#define EGA_LGSIZE	0x20000	/* Larger EGA has 128K of memory available */
#define EGA_SCRMASK	0x3fff	/* EGA text memory wraps at 32K (minimum) */
#define NSEQ		5	/* number of sequencer registers */
#define NATTR		20	/* number of attribute registers */
#define NGRAPH		9	/* number of graphics registers */
#define LOAD_COLOR	8	/* mode number for loading color characters */
#define LOAD_MONO	9	/* mode number for loading mono characters */

/* Font types supported */
#define	FONTINV		0
#define	FONT8x8		1		/* 8x8 font */
#define	FONT8x14	2		/* 8x14 font */
#define	FONT8x14m	3		/* 8x14 font for monochrome */
#define	FONT8x16	4		/* 8x16 font (VGA) */
#define	FONT9x16	5		/* 9x16 font (VGA) */
#define FONT7x9		6		/* 7x9 font (VDC-600) */
#define FONT7x16	7		/* 7x16 font (VDC-600) */

/* Offsets of font tables in ROM */
#define F8x8_OFF	0xf30		/* Offset of 8x8 font table */
#define	F8x8_BPC	8		/* Bytes per character in 8x8 font */
#define	F8x8_NCH	256		/* Number of characters in 8x8 font */

#define	F8x14_OFF	0		/* Offset of 8x14 font table */
#define F8x14m_OFF	0xe00		/* Offset of 8x14 mono fudge table */
#define	F8x14_BPC	14		/* Bytes per character in 8x14 font */
#define	F8x14_NCH	256		/* Number of characters in 8x14 font */
#define	F8x16_BPC	16		/* Bytes per character in 8x16 font */
#define	F8x16_NCH	256		/* Number of characters in 8x16 font */

#define	F8x8_INDX	0		/* Index of 8x8 font pointer */
#define F8x14_INDX	1		/* Index of 8x14 font pointer */
#define F9x14_INDX	2		/* Index of 9x14 font pointer */
#define F8x16_INDX	3		/* Index of 8x16 font pointer */
#define F9x16_INDX	4		/* Index of 9x16 font pointer */

#define	FONT_TAB_LIM	0x172f		/* Total size of all font tables */

/* definitions for bits in the attribute byte */
#define BLINK		0x80
#define BRIGHT		0x08
#define REVERSE		0x70
#define NORM		0x07
#define UNDERLINE	0x01	/* underline on mono, blue on color */

#define CLEAR		(NORM<<8|0x20)
#define BCLEAR		(NORM|BRIGHT<<8|0x20)
#define ALLATTR		(BLINK|BRIGHT|REVERSE|NORM|UNDERLINE)
#define NOTBGRND	(ALLATTR&(~REVERSE))
#define NOTFGRND	(ALLATTR&(~NORM))

/* definitions for ringing the bell */
#define NORMBELL	1331	/* initial value loaded into timer */
#define BELLLEN		(HZ/10)	/* ring for 1/10 sec. between checks */
#define BELLCNT		2	/* check bell twice before turning off */
#define TONE_ON		3	/* 8254 gate 2 and speaker and-gate enabled */
#define TIMER		0x40	/* 8254.2 timer address */
#define TIMERCR		TIMER+3	/* timer control register address */
#define TIMER2		TIMER+2	/* timer tone generation port */
#define T_CTLWORD	0xB6	/* value for timer control word */
#define TONE_CTL	0x61	/* address for enabling timer port 2 */


struct adtstruct {
	ushort	*ad_scraddr;	/* address of adaptor memory */
	ushort	ad_scrmask;	/* mask for fitting text into screen memory */
	ushort	ad_address;	/* address of corresponding M6845 or EGA */
	unchar	ad_type;	/* adapter type */
	unchar	ad_colsel;	/* color select register byte */
	unchar	ad_modesel;	/* mode register byte */
	unchar	ad_mode2sel;	/* mode2 register byte (rite-vu card ) */
	unchar	ad_undattr;	/* attribute to use when underlining */
};


#define	KD_TEXT		0	/* ansi x3.64 emulation mode */
#define KD_TEXT0	0	/* same as above */
#define KD_TEXT1	2	/* new text mode doesnt load char generator */
#define	KD_GRAPHICS	1	/* graphics mode */

/*
 * Values for kv_flags
 */
#define	KD_MAPPED	0x01		/* Display is mapped */
#define	KD_LOCKED	0x02		/* Keyboard is locked */
#define	KD_QRESERVE	0x04		/* Queue mode init in progress */

/*
 * Types for indexing into reginfo table.
 */
#define I_6845MONO	0
#define I_6845COLOR	1
#define I_EGAMONO	2
#define I_EGACOLOR	3
#define I_SEQ		4
#define I_GRAPH		5
#define I_ATTR		6

/*
 * Macro for setting a particular EGA register.
 */
#define out_reg(riptr, index, data)	outb((riptr)->ri_address, (index)); \
					outb((riptr)->ri_data, (data));

#ifdef EVGA
#define in_reg(riptr, index, data)	outb((riptr)->ri_address, (index)); \
					(data) = inb((riptr)->ri_data);
#endif	/*EVGA*/

struct reginfo {
	ushort	ri_count;	/* number of registers */
	ushort	ri_address;	/* address register */
	ushort	ri_data;	/* data register */
};

struct m6845init {
	unchar  mi_hortot;	/* Reg  0: Horizontal Total     (chars) */
	unchar  mi_hordsp;	/* Reg  1: Horizontal Displayed (chars) */
	unchar  mi_hsnpos;	/* Reg  2: Hsync Position       (chars) */
	unchar  mi_hsnwid;	/* Reg  3: Hsync Width          (chars) */
	unchar  mi_vertot;	/* Reg  4: Vertical Total   (char rows) */
	unchar  mi_veradj;	/* Reg  5: Vtotal Adjust   (scan lines) */
	unchar  mi_vsndsp;	/* Reg  6: Vertical Display (char rows) */
	unchar  mi_vsnpos;	/* Reg  7: Vsync Position   (char rows) */
	unchar  mi_intlac;	/* Reg  8: Interlace Mode               */
	unchar  mi_maxscn;	/* Reg  9: Max Scan Line   (scan lines) */
	unchar  mi_curbeg;	/* Reg 10: Cursor Start    (scan lines) */
	unchar  mi_curend;	/* Reg 11: Cursor End      (scan lines) */
	unchar  mi_stadh;	/* Reg 12: Start Address (H)            */
	unchar  mi_stadl;	/* Reg 13: Start Address (L)            */
	unchar  mi_cursh;	/* Reg 14: Cursor (H)                   */
	unchar  mi_cursl;	/* Reg 15: Cursor (L)                   */
};

struct egainit {
	unchar  ei_hortot;	/* Reg  0: Horizontal Total */
	unchar  ei_hde;		/* Reg  1: Horizontal Display End */
	unchar  ei_shb;		/* Reg  2: Start horizontal blank */
	unchar  ei_ehb;		/* Reg  3: End horizontal blank */
	unchar  ei_shr;		/* Reg  4: Start horizontal retrace */
	unchar  ei_ehr;		/* Reg  5: End horizontal retrace */
	unchar  ei_vertot;	/* Reg  6: Vertical total */
	unchar  ei_ovflow;	/* Reg  7: Overflow */
	unchar  ei_prs;		/* Reg  8: Preset row scan */
	unchar  ei_maxscn;	/* Reg  9: Max Scan Line */
	unchar  ei_curbeg;	/* Reg 10: Cursor Start */
	unchar  ei_curend;	/* Reg 11: Cursor End */
	unchar  ei_stadh;	/* Reg 12: Start Address (H) */
	unchar  ei_stadl;	/* Reg 13: Start Address (L) */
	unchar  ei_cursh;	/* Reg 14: Cursor location (H) */
	unchar  ei_cursl;	/* Reg 15: Cursor location (L) */
	unchar	ei_vrs;		/* Reg 16: Vertical retrace start */
	unchar	ei_vre;		/* Reg 17: Vertical retrace end */
	unchar	ei_vde;		/* Reg 18: Vertical display end */
	unchar	ei_offset;	/* Reg 19: Offset */
	unchar	ei_undloc;	/* Reg 20: Underline location */
	unchar	ei_svb;		/* Reg 21: Start vertical blank */
	unchar	ei_evb;		/* Reg 22: End vertical blank */
	unchar	ei_mode;	/* Reg 23: Mode control */
	unchar	ei_lcomp;	/* Reg 24: Line compare */
};

struct reginit {
	unchar		seqtab[NSEQ];
	unchar		miscreg;
	struct egainit	egatab;
	unchar		attrtab[NATTR];
	unchar		graphtab[NGRAPH];
};


struct adtmode {
	unchar	am_capability;
	unchar	am_colmode;
	unchar	am_colsel;
};

struct kd_dispinfo {
	char    *vaddr;		/* display memory address */
	paddr_t	physaddr;	/* display memory address */
	unsigned long size;	/* display memory size */
};

/* Display mode definitions */
#define DM_B40x25	0		/* 40x25 black & white text */
#define DM_C40x25	1		/* 40x25 color text */
#define DM_B80x25	2		/* 80x25 black & white text */
#define DM_C80x25	3		/* 80x25 color text */
#define DM_BG320	4		/* 320x200 black & white graphics */
#define DM_CG320	5		/* 320x200 color graphics */
#define DM_BG640	6		/* 640x200 black & white graphics */
#define DM_EGAMONO80x25	7		/* EGA mode 7 */
#define LOAD_COLOR	8		/* mode for loading color characters */
#define LOAD_MONO	9		/* mode for loading mono characters */
#define DM_ENH_B80x43	10		/* 80x43 black & white text */
#define DM_ENH_C80x43	11		/* 80x43 color text */
#define DM_CG320_D	13		/* EGA mode D */
#define DM_CG640_E	14		/* EGA mode E */
#define DM_EGAMONOAPA	15		/* EGA mode F */
#define DM_CG640x350	16		/* EGA mode 10 */
#define DM_ENHMONOAPA2	17		/* EGA mode F with extended memory */
#define DM_ENH_CG640	18		/* EGA mode 10* */
#define DM_ENH_B40x25	19		/* enhanced 40x25 black & white text */
#define DM_ENH_C40x25	20		/* enhanced 40x25 color text */
#define DM_ENH_B80x25	21		/* enhanced 80x25 black & white text */
#define DM_ENH_C80x25	22		/* enhanced 80x25 color text */
#define	DM_VGA_C40x25	23		/* VGA 40x25 color text */
#define	DM_VGA_C80x25	24		/* VGA 80x25 color text */
#define	DM_VGAMONO80x25	25		/* VGA mode 7 */
#define DM_VGA640x480C	26		/* VGA 640x480 2 color graphics */
#define	DM_VGA640x480E	27		/* VGA 640x480 16 color graphics */
#define	DM_VGA320x200	28		/* VGA 320x200 256 color graphics */
#define	DM_VGA_B40x25	29		/* VGA 40x25 black & white text */
#define	DM_VGA_B80x25	30		/* VGA 80x25 black & white text */
#define	DM_VGAMONOAPA	31		/* VGA mode F+ */
#define	DM_VGA_CG640	32		/* VGA mode 10+ */
#define	DM_ENH_CGA	33		/* AT&T 640x400 CGA hw emulation mode */
#define DM_ATT_640	34		/* AT&T 640x400 16 color graphics */
#define DM_VGA_B132x25	35		/* VGA 132x25 black & white text */
#define DM_VGA_C132x25	36		/* VGA 132x25 color text */
#define DM_VGA_B132x43	37		/* VGA 132x43 black & white text */
#define DM_VGA_C132x43	38		/* VGA 132x43 color text */
#define DM_VDC800x600E	39		/* VDC-600 800x600 16 color graphics */
#define DM_VDC640x400V	40		/* VDC-600 640x400 256 color graphics */
#ifdef	EVC
#define DM_EVC640x480V	41		/* EVC 640x480 256 color graphics */
#define DM_EVC1024x768E 42		/* EVC 1024x768 16 color graphics */
#define DM_EVC1024x768D 43		/* EVC 1024x768 256 color graphics */
#endif	/*EVC*/

#ifdef EVGA

/*  THE FOLLOWING VALUES SHOULD REFLECT THE NUMBER OF NON-EVGA MODE
 *  DEFINITIONS AND ENTRIES IN KD_INITTAB, RESPECTIVELY. IF THESE
 *  ARE CHANGED THEN ENDNONEVGAMODE AND STEVGA SHOULD BE ADJUSTED
 *  ACCORDINGLY.
 */
#ifndef EVC

#define ENDNONEVGAMODE 40
#define STEVGA 7

#else /* EVC defined */

#define ENDNONEVGAMODE 43
#define STEVGA 9

#endif /* EVC */ 
#endif /* EVGA */


/* Xenix display mode definitions.  Most are identical to the internal
   definitions above. */
#define M_B40x25	DM_B40x25	/* black & white 40 columns */
#define M_C40x25	DM_C40x25	/* color 40 columns */
#define M_B80x25	DM_B80x25	/* black & white 80 columns */
#define M_C80x25	DM_C80x25	/* color 80 columns */
#define M_BG320		DM_BG320	/* black & white graphics 320x200 */
#define M_CG320		DM_CG320	/* color graphics 320x200 */
#define M_BG640		DM_BG640	/* black & white graphics 640x200 */
#define M_EGAMONO80x25  DM_EGAMONO80x25	/* ega-mono 80x25 */
#define M_CG320_D	DM_CG320_D	/* ega mode D */
#define M_CG640_E	DM_CG640_E	/* ega mode E */
#define M_EGAMONOAPA	DM_EGAMONOAPA	/* ega mode F */
#define M_CG640x350	DM_CG640x350	/* ega mode 10 */
#define M_ENHMONOAPA2	DM_ENHMONOAPA2	/* ega mode F with extended memory */
#define M_ENH_CG640	DM_ENH_CG640	/* ega mode 10* */
#define M_ENH_B40x25    DM_ENH_B40x25	/* enhanced black & white 40 columns */
#define M_ENH_C40x25    DM_ENH_C40x25	/* enhanced color 40 columns */
#define M_ENH_B80x25    DM_ENH_B80x25	/* enhanced black & white 80 columns */
#define M_ENH_C80x25    DM_ENH_C80x25	/* enhanced color 80 columns */
#define M_VGA_40x25	DM_VGA_C40x25	/* vga 8x16 font on color */
#define M_VGA_80x25	DM_VGA_C80x25	/* vga 8x16 font on color */
#define M_VGA_M80x25	DM_VGAMONO80x25	/* vga 8x16 font on mono */
#define M_VGA11		DM_VGA640x480C	/* vga 640x480 2 colors */
#define M_VGA12		DM_VGA640x480E	/* vga 640x480 16 colors */
#define M_VGA13		DM_VGA320x200	/* vga 640x200 256 colors */
					/* "640" because double scan */
#define M_HGC_P0	0xe0	/* hercules graphics - page 0 @ B0000 */
#define M_HGC_P1	0xe1	/* hercules graphics - page 1 @ B8000 */
#define M_ENH_B80x43	0x70		/* ega black & white 80x43 */
#define M_ENH_C80x43	0x71		/* ega color 80x43 */
#define M_MCA_MODE	0xff		/* monochrome adapter mode */
#define	OFFSET_80x43	(M_ENH_B80x43-DM_ENH_B80x43)	/* Offset for converting 80x43 numbers */
#define M_ENH_CGA	DM_ENH_CGA	/* AT&T 640x400 CGA hardware mode - (Super-VU adapter) */

/* Defines for keyboard and display ioctl's */
#define KIOC		('K'<<8)
#define	KDDISPTYPE	(KIOC|1)	/* return display type to user */
#define	KDMAPDISP	(KIOC|2)	/* map display into user space */
#define	KDUNMAPDISP	(KIOC|3)	/* unmap display from user space */
#define	KDGKBENT	(KIOC|4)	/* get keyboard table entry */
#define	KDSKBENT	(KIOC|5)	/* set keyboard table entry */
#define	KDGKBMODE	(KIOC|6)	/* get keyboard translation mode */
#define	KDSKBMODE	(KIOC|7)	/* set keyboard translation mode */
#define	KDMKTONE	(KIOC|8)	/* sound tone */
#define	KDGETMODE	(KIOC|9)	/* get text/graphics mode */
#define	KDSETMODE	(KIOC|10)	/* set text/graphics mode */
#define	KDADDIO		(KIOC|11)	/* add I/O address to list */
#define	KDDELIO		(KIOC|12)	/* delete I/O address from list */
#define KDSBORDER	(KIOC|13)	/* set ega color border */
#define KDQUEMODE	(KIOC|15)	/* enable/disable queue mode */
#define KIOCDOSMODE     (KIOC | 16)     /* obsolete -- set DOSMODE	    */
#define KIOCNONDOSMODE  (KIOC | 17)     /* obsolete -- clear DOSMODE	    */
#define KDDISPINFO	(KIOC | 18)	/* get display start and size	    */
#define KDGKBSTATE	(KIOC | 19)	/* get state of keyboard shift keys */
#define KDSETRAD        (KIOC|20)       /* set keyboard typematic rate/delay */
#define KDSCROLL        (KIOC|21)       /* set hardware scrolling on/off */

/* VP/ix reserved ioctls */
#define KDENABIO	(KIOC|60)	/* enable direct I/O to ports */
#define KDDISABIO	(KIOC|61)	/* disable direct I/O to ports */
#define KIOCINFO	(KIOC|62)	/* tell user what device we are */
#define KIOCSOUND	(KIOC|63)	/* start sound generation */
#define KDGKBTYPE	(KIOC|64)	/* get keyboard type */
#define KDGETLED	(KIOC|65)	/* get keyboard LED status */
#define KDSETLED	(KIOC|66)	/* set keyboard LED status */


/* New ioctls for UNIX System V Release 4.0. 0-50 reserved for base system */
/* 50-100 reserved for AT&T-DSG */

#define	WSIOC		(('w' << 24) | ('s' << 16))
#define	KDVDCTYPE	(WSIOC|1)	/* VDC controller/display information */
#define KDDFLTKEYMAP	(WSIOC|2)	/* set/get default keyboard map for
					 * this workstation */
#define KDDFLTSCRNMAP	(WSIOC|3)	/* set/get default screen map for
					 * this workstation */
#define KDDFLTSTRMAP	(WSIOC|4)	/* set/get default function key map for
					 * this workstation */
#define WS_PIO_ROMFONT	(WSIOC|5)	/* add user-supplied font overlays */
#define WS_CLRXXCOMPAT	(WSIOC|6)	/* add user-supplied font overlays */
#define WS_GETXXCOMPAT	(WSIOC|7)	/* add user-supplied font overlays */
#define WS_SETXXCOMPAT	(WSIOC|8)	/* add user-supplied font overlays */
#define KDEVGA        	(WSIOC|9)       /* set evga card type */

/* Defines for Xenix keyboard and display ioctl's */
#define MIOC		('k' << 8)	/* Upper byte of mapping ioctl's */
#define GETFKEY   	(MIOC | 0)	/* Get function key */
#define SETFKEY   	(MIOC | 1)	/* Set function key */
#define GIO_SCRNMAP	(MIOC | 2)	/* Get screen output map table */
#define PIO_SCRNMAP	(MIOC | 3)	/* Set screen output map table */
#define	GIO_STRMAP_21	(MIOC | 4)	/* Get 2.1 function key string table */
#define	PIO_STRMAP_21	(MIOC | 5)	/* Put 2.1 function key string table */
#define GIO_KEYMAP	(MIOC | 6)	/* Get keyboard map table */
#define PIO_KEYMAP	(MIOC | 7)	/* Set keyboard map table */
#define SETLOCKLOCK	(MIOC|10)	/* global cap/num lock on/off */
#define GIO_STRMAP	(MIOC | 11)	/* Get function key string table */
#define PIO_STRMAP	(MIOC | 12)	/* Set function key string table */
#define	KBIO_SETMODE	(MIOC|13)	/* Put AT keyboard into XT | AT mode */
#define	KBIO_GETMODE	(MIOC|14)	/* Get the AT/XT keyboard mode */

/* keyboard mode -- set by KBIO_MODE */
#define	KBM_XT	0	/* XT keyboard mode */
#define	KBM_AT	1	/* AT keyboard mode */

#define GIO_ATTR	('a' << 8)	/* Get present screen attribute */
#define GIO_COLOR	('c' << 8)	/* Get whether adaptor is color */

#define MODESWITCH	('x' << 8)	/* Upper byte of mode switch ioctl's */
#define KDMODEMASK	0xff		/* Lower byte of mode switch ioctl's */
#define SW_B40x25	(MODESWITCH | DM_B40x25)	/* Select 40x25 b&w */
#define SW_C40x25	(MODESWITCH | DM_C40x25)	/* Select 40x25 clr */
#define SW_B80x25	(MODESWITCH | DM_B80x25)	/* Select 80x25 b&w */
#define SW_C80x25	(MODESWITCH | DM_C80x25)	/* Select 80x25 clr */
#define SW_BG320	(MODESWITCH | DM_BG320)	/* Select 320x200 b&w */
#define SW_CG320	(MODESWITCH | DM_CG320)	/* Select 320x200 color */
#define SW_BG640	(MODESWITCH | DM_BG640)	/* Select 640x200 b&w */
#define SW_EGAMONO80x25	(MODESWITCH | DM_EGAMONO80x25)	/* Select EGA mode 7 */
#define SW_CG320_D	(MODESWITCH | DM_CG320_D)	/* Select EGA mode D */
#define SW_CG640_E	(MODESWITCH | DM_CG640_E)	/* Select EGA mode E */
#define SW_EGAMONOAPA	(MODESWITCH | DM_EGAMONOAPA)	/* Select EGA mode F */
#define SW_CG640x350	(MODESWITCH | DM_CG640x350)	/* EGA mode 10 */
#define SW_ENH_MONOAPA2	(MODESWITCH | DM_ENHMONOAPA2)	/* EGA mode F* */
#define SW_ENH_CG640	(MODESWITCH | DM_ENH_CG640)	/* EGA mode 16 */
#define SW_ENHB40x25	(MODESWITCH | DM_ENH_B40x25)	/* 40x25 b&w */
#define SW_ENHC40x25	(MODESWITCH | DM_ENH_C40x25)	/* 40x25 color */
#define SW_ENHB80x25	(MODESWITCH | DM_ENH_B80x25)	/* 80x25 b&w */
#define SW_ENHC80x25	(MODESWITCH | DM_ENH_C80x25)	/* 80x25 color */
#define SW_ENHB80x43	(MODESWITCH | M_ENH_B80x43)	/* 80x43 b&w */
#define SW_ENHC80x43	(MODESWITCH | M_ENH_C80x43)	/* 80x43 color */
#define SW_MCAMODE	(MODESWITCH | M_MCA_MODE)	/* Reinitialize mono */
#define SW_ATT640	(MODESWITCH | DM_ATT_640)	/* 640x400 16 color */
#define	SW_VGAC40x25	(MODESWITCH | DM_VGA_C40x25)	/* VGA 40x25 color */
#define	SW_VGAC80x25	(MODESWITCH | DM_VGA_C80x25)	/* VGA 80x25 color */
#define	SW_VGAMONO80x25	(MODESWITCH | DM_VGAMONO80x25)	/* VGA mode 7 */
#define	SW_VGA640x480C	(MODESWITCH | DM_VGA640x480C)	/* VGA mode 11 */
#define	SW_VGA640x480E	(MODESWITCH | DM_VGA640x480E)	/* VGA mode 12 */
#define	SW_VGA320x200	(MODESWITCH | DM_VGA320x200)	/* VGA mode 13 */
#define SW_VDC800x600E	(MODESWITCH | DM_VDC800x600E)	/* 800x600 16 color */
#define SW_VDC640x400V	(MODESWITCH | DM_VDC640x400V)	/* 640x400 256 color */
#define	SW_VGAB40x25	(MODESWITCH | DM_VGA_B40x25)	/* VGA 40x25 b&w */
#define	SW_VGAB80x25	(MODESWITCH | DM_VGA_B80x25)	/* VGA 80x25 b&w */
#define	SW_VGAMONOAPA	(MODESWITCH | DM_VGAMONOAPA)	/* VGA mode F+ */
#define	SW_VGA_CG640	(MODESWITCH | DM_VGA_CG640)	/* VGA mode 10+ */
#define	SW_VGA_B132x25	(MODESWITCH | DM_VGA_B132x25)	/* VGA 132x25 b&w */
#define	SW_VGA_C132x25	(MODESWITCH | DM_VGA_C132x25)	/* VGA 132x25 color */
#define	SW_VGA_B132x43	(MODESWITCH | DM_VGA_B132x43)	/* VGA 132x43 b&w */
#define	SW_VGA_C132x43	(MODESWITCH | DM_VGA_C132x43)	/* VGA 132x43 color */
#ifdef	EVC
#define SW_EVC640x480V	(MODESWITCH | DM_EVC640x480V)	/* 640x480 256 color */
#define SW_EVC1024x768E (MODESWITCH | DM_EVC1024x768E)	/* 1024x768 16 color */
#define SW_EVC1024x768D (MODESWITCH | DM_EVC1024x768D)  /* 1024x768 256 color*/
#endif	/*EVC*/

/* XENIX names for VGA modes */
#define	SW_VGA40x25	SW_VGAC40x25
#define	SW_VGA80x25	SW_VGAC80x25
#define	SW_VGAM80x25	SW_VGAMONO80x25
#define	SW_VGA11	SW_VGA640x480C
#define	SW_VGA12	SW_VGA640x480E
#define	SW_VGA13	SW_VGA320x200
#define SW_VGA_C40x25   SW_VGAC40x25
#define SW_BG640x480    SW_VGA640x480C
#define SW_CG640x480    SW_VGA640x480E
#define SW_VGA_CG320    SW_VGA320x200
#define SW_VGA_B40x25   SW_VGAB40x25


#ifdef EVGA
/* display modes for evga */

#define	VT_EGA		0	/* EGA 		640x350 16 colors */
#define	VT_PEGA		1	/* PEGA2 	640x480 16 colors*/
#define	VT_VGA		2	/* VGA 		640x480 16 colors*/
#define	VT_VEGA720	3	/* VEGA VGA 	720x540	16 colors */
#define	VT_VEGA800	4	/* VEGA VGA 	800x600	16 colors */
#define	VT_TSL8005_16	5	/* Tseng Labs	800x560	16 colors */
#define	VT_TSL8006_16	6	/* Tseng Labs	800x600	16 colors */
#define	VT_TSL960	7	/* Tseng Labs	960x720	16 colors */
#define	VT_TSL1024	8	/* Tseng Labs  1024x768 16 colors */
#define VT_TSL1024ni	9	/* Tseng Labs  1024x768 16 colors NI */
#define	VT_SIGMAH	10	/* Sigma VGA/H  800x600 16 colors */
#define VT_PVGA1A	11	/* Paradise PVGA1A 800x600 16 colors */
#define VT_V7VRAM6	12	/* Video 7 VRAM	640x480 16 colors */
#define VT_V7VRAM7	13	/* Video 7 VRAM	720x540 16 colors */
#define VT_V7VRAM8	14	/* Video 7 VRAM	800x600 16 colors */
#define VT_V7VRAM1_2	15	/* Video 7 VRAM 1024x768  2 colors */
#define VT_V7VRAM1_4	16	/* Video 7 VRAM 1024x768  4 colors */
#define VT_V7VRAM1_16	17	/* Video 7 VRAM 1024x768 16 colors */
#define VT_GENEGA_6	18	/* Genoa EGA    640x480 16 colors */
#define VT_GENEGA_8	19	/* Genoa EGA    800x600 16 colors */
#define VT_ORVGA8	20	/* Orchid VGA   800x600 16 colors */
#define VT_GVGA8_6	21	/* Genoa VGA    800x600 16 colors */
#define VT_DELL7	22	/* Dell VGA (Video 7)    720x540 16 colors */
#define VT_DELL8	23	/* Dell VGA (Video 7)    800x600 16 colors */
#define VT_VGAWON	24	/* ATI VGA Wonder    800x600 16 colors */
/* 
 * NOTICE:  Insert new types here.  FastWrite goes at end so we can save
 * space in the register initialization table.  These are dummy entries
 */
#define VT_V7FW6	25	/* Video 7 FastWrite 640x480 16 colors */
#define VT_V7FW7	26	/* Video 7 FastWrite 720x540 16 colors */
#define VT_V7FW8	27	/* Video 7 FastWrite 800x600 16 colors */
#define VT_V7FW1_2	28	/* Video 7 FastWrite 1024x768  2 colors */
#define VT_V7FW1_4	29	/* Video 7 FastWrite 1024x768  4 colors */

#endif	/*EVGA*/

#define EVGAIOC (('E'<<24)|('V'<<16))
#define EVGAMODEMASK	0xffff	

#ifdef EVGA
/* generic mode constants for evga */

#define GEN_640x350		0
#define GEN_640x480		1
#define GEN_720x540		2
#define GEN_800x560		3
#define GEN_800x600		4
#define GEN_960x720		5
#define GEN_1024x768		6
#define GEN_1024x768x2		7
#define GEN_1024x768x4		8

/*
 * generic mode switches for evga. Currently these values
 * are just supported for the card types for which evga support
 * has been implemented. Eventually these mode switching constants 
 * will be supported for other card types as well.
 */

#define SW_GEN_640x350		(EVGAIOC | GEN_640x350)
#define SW_GEN_640x480		(EVGAIOC | GEN_640x480)
#define SW_GEN_720x540		(EVGAIOC | GEN_720x540)
#define SW_GEN_800x560		(EVGAIOC | GEN_800x560)
#define SW_GEN_800x600		(EVGAIOC | GEN_800x600)
#define SW_GEN_960x720		(EVGAIOC | GEN_960x720)
#define SW_GEN_1024x768		(EVGAIOC | GEN_1024x768)
#define SW_GEN_1024x768x2	(EVGAIOC | GEN_1024x768x2)
#define SW_GEN_1024x768x4	(EVGAIOC | GEN_1024x768x4)

/* temporary kludge for X server */
#define TEMPEVC1024x768E	(MODESWITCH | 42)

#define MISC_OUT_READ 	0x3cc
#define IO_ADDR_SEL	1

/*
 * General adaptor information for evga such as size of display, 
 * pixels per inch, etc.
 */
struct at_disp_info {
	int 	type;		/* controller type, EVGA_VRAM */
	int	vt_type;	/* mode, VT_V7VRAM7 */
	int	is_vga;		/* true if adapter supports VGA write modes */
	int	xpix;		/* pixels per scanline */
	int	ypix;		/* number of scanlines */
	int	planes;		/* number of planes of memory */
	int	colors;		/* number of colors available */
	int	buf_size;	/* size of screen memory */
	int	map_size;	/* size of one plane of memory */
	int	slbytes;	/* number of bytes in a scanline */
	int	(*ext_init)();	/* called to initialize 'extended' modes */
	int	(*ext_rest)();	/* called to recover from 'extended' modes */
	struct b_param *regs;	/* registers for mode */
};

/* end of evga stuff */
#endif	/*EVGA*/


/* Hercules support */
#define SW_HGC_P0  (MODESWITCH | M_HGC_P0)
#define SW_HGC_P1  (MODESWITCH | M_HGC_P1)

#define O_MODESWITCH	('S' << 8)	/* Upper byte of mode switch ioctl's */
#define O_SW_B40x25	(O_MODESWITCH | DM_B40x25)	/* Select 40x25 b&w */
#define O_SW_C40x25	(O_MODESWITCH | DM_C40x25)	/* Select 40x25 clr */
#define O_SW_B80x25	(O_MODESWITCH | DM_B80x25)	/* Select 80x25 b&w */
#define O_SW_C80x25	(O_MODESWITCH | DM_C80x25)	/* Select 80x25 clr */
#define O_SW_BG320	(O_MODESWITCH | DM_BG320)	/* Select 320x200 b&w */
#define O_SW_CG320	(O_MODESWITCH | DM_CG320)	/* Select 320x200 color */
#define O_SW_BG640	(O_MODESWITCH | DM_BG640)	/* Select 640x200 b&w */
#define O_SW_EGAMONO80x25	(O_MODESWITCH | DM_EGAMONO80x25)	/* Select EGA mode 7 */
#define O_SW_CG320_D	(O_MODESWITCH | DM_CG320_D)	/* Select EGA mode D */
#define O_SW_CG640_E	(O_MODESWITCH | DM_CG640_E)	/* Select EGA mode E */
#define O_SW_EGAMONOAPA	(O_MODESWITCH | DM_EGAMONOAPA)	/* Select EGA mode F */
#define O_SW_CG640x350	(O_MODESWITCH | DM_CG640x350)	/* EGA mode 10 */
#define O_SW_ENH_MONOAPA2	(O_MODESWITCH | DM_ENHMONOAPA2)	/* EGA mode F* */
#define O_SW_ENH_CG640	(O_MODESWITCH | DM_ENH_CG640)	/* EGA mode 16 */
#define O_SW_ENHB40x25	(O_MODESWITCH | DM_ENH_B40x25)	/* 40x25 b&w */
#define O_SW_ENHC40x25	(O_MODESWITCH | DM_ENH_C40x25)	/* 40x25 color */
#define O_SW_ENHB80x25	(O_MODESWITCH | DM_ENH_B80x25)	/* 80x25 b&w */
#define O_SW_ENHC80x25	(O_MODESWITCH | DM_ENH_C80x25)	/* 80x25 color */
#define O_SW_ENHB80x43	(O_MODESWITCH | M_ENH_B80x43)	/* 80x43 b&w */
#define O_SW_ENHC80x43	(O_MODESWITCH | M_ENH_C80x43)	/* 80x43 color */
#define O_SW_MCAMODE	(O_MODESWITCH | M_MCA_MODE)	/* Reinitialize mono */
#define O_SW_ATT640	(O_MODESWITCH | DM_ATT_640)	/* 640x400 16 color */
#define	O_SW_VGA40x25	(O_MODESWITCH | M_VGA_40x25)
#define	O_SW_VGA80x25	(O_MODESWITCH | M_VGA_80x25)
#define	O_SW_VGAM80x25	(O_MODESWITCH | M_VGA_M80x25)
#define	O_SW_VGA11	(O_MODESWITCH | M_VGA11)
#define	O_SW_VGA12	(O_MODESWITCH | M_VGA12)
#define	O_SW_VGA13	(O_MODESWITCH | M_VGA13)
#define O_SW_VGA_C40x25 (O_MODESWITCH | M_VGA_40x25)
#define O_SW_BG640x480  (O_MODESWITCH | M_VGA11)
#define O_SW_CG640x480  (O_MODESWITCH | M_VGA12)
#define O_SW_VGA_CG320  (O_MODESWITCH | M_VGA13)
#define O_SW_VGA_B40x25 (O_MODESWITCH | DM_VGA_B40x25)
#define O_SW_VGA_B80x25 (O_MODESWITCH | DM_VGA_B80x25)

#define	CGAIOC		('C' << 8)	/* Upper byte of CGA ioctl's */
#define CGAMODE		(CGAIOC | 1)	/* Obsolete */
#define CGAIO		(CGAIOC | 2)	/* Do I/O on CGA port */
#define CGA_GET 	(CGAIOC | 3)	/* Get CGA mode setting */
#define INTERNAL_VID	(CGAIOC|72)	/* internal plasma monitor	*/
#define EXTERNAL_VID	(CGAIOC|73)	/* external plasma monitor	*/

#define PGAIOC		('P' << 8)	/* Upper byte of PGA ioctl's */
#define PGAMODE		(PGAIOC | 1)	/* Obsolete */
#define PGAIO		(PGAIOC | 2)	/* Do I/O on PGA port */
#define PGA_GET 	(PGAIOC | 3)	/* Get PGA mode setting */

#define EGAIOC		('E' << 8)	/* Upper byte of EGA ioctl's */
#define EGAMODE		(EGAIOC | 1)	/* Obsolete */
#define EGAIO		(EGAIOC | 2)	/* Do I/O on EGA port */
#define EGA_GET 	(EGAIOC | 3)	/* Get EGA mode setting */
#define EGA_IOPRIVL (EGAIOC | 4)	/* get in/out privilege for ega ports */

#define MCAIOC		('M' << 8)	/* Upper byte of MCA ioctl's */
#define MCAMODE		(MCAIOC | 1)	/* Obsolete */
#define MCAIO		(MCAIOC | 2)	/* Do I/O on MCA port */
#define MCA_GET 	(MCAIOC | 3)	/* Get MCA mode setting */

/* PC/AT Vga adapter control */
#define VGAIOC	('E' << 8)
#define VGAMODE (VGAIOC | 65)		/* change vga mode */
#define VGAIO	(VGAIOC | 66)		/* do inb/outb on vga port */
#define VGA_GET (VGAIOC | 67)		/* get vga mode setting */
#define VGA_IOPRIVL (VGAIOC | 68)	/* get in/out privilege for vga ports */

/* The following ioctl conflicts with the ioctls TCGETX in termiox.h
 * and STSET in stermio.h. The ioctl is defined only for source
 * compatibility and is only valid if SCO compatibility mode is turned
 * on -- see WS_GETXXCOMPAT
 */
/* PC/AT Special Adapter Support */
#define	S_IOC	('X' << 8)
#define	SPECIAL_IOPRIVL (S_IOC | 1)	/* get IO privl on special board.
					   using  vid_iop[] */

#define CONSIOC		('c' << 8)	/* Upper byte of console ioctl's */
#define CONS_CURRENT 	(CONSIOC | 1)	/* Get display adapter type */
#define CONS_GET	(CONSIOC | 2)	/* Get display mode setting */
#define CONSIO		(CONSIOC | 3)	/* do inb/outb on console port */

#define PIO_FONT8x8	(CONSIOC|64)
#define GIO_FONT8x8	(CONSIOC|65)
#define PIO_FONT8x14	(CONSIOC|66)
#define GIO_FONT8x14	(CONSIOC|67)
#define PIO_FONT8x16	(CONSIOC|68)
#define GIO_FONT8x16	(CONSIOC|69)

#define CONSADP		(CONSIOC|72)	/* get specific adapter screen */
#define CONS_GETINFO	(CONSIOC|73)	/* get vid_info struct S001 */
#define CONS_6845INFO	(CONSIOC|74)	/* get m6845_info struct S001 */

struct colors {
	char fore;			/* foreground colors	*/
	char back;			/* background colors	*/
};

#define	BLACK		0x0
#define	BLUE		0x1
#define	GREEN		0x2
#define	CYAN		0x3
#define	RED		0x4
#define	MAGENTA		0x5
#define	BROWN		0x6
#define	WHITE		0x7
#define	GRAY		0x8
#define	LT_BLUE		0x9
#define	LT_GREEN	0xA
#define	LT_CYAN		0xB
#define	LT_RED		0xC
#define	LT_MAGENTA	0xD
#define	YELLOW		0xE
#define	HI_WHITE	0xF

/*
 * flag definitions for mk_keylock
 */
#define	CLKED	0x01		/* caps   locked */
#define	NLKED	0x02		/* num    locked */
#define	SLKED	0x04		/* scroll locked */

struct vid_info
{
	short	size;			/* must be first field		*/
	short	m_num;			/* multiscreen number, 0 based	*/
	ushort	mv_row, mv_col;		/* cursor position		*/
	ushort	mv_rsz, mv_csz;		/* text screen size		*/
	struct colors	mv_norm,	/* normal attributes		*/
			mv_rev,		/* reverse video attributes	*/
			mv_grfc;	/* graphic character attributes	*/
	uchar_t mv_ovscan;		/* border color			*/
	uchar_t mk_keylock;		/* caps/num/scroll lock		*/
};

struct m6845_info
{
	short	size;		/* must be first field */
	ushort	screen_top;	/* offset of screen in video	*/
	ushort	cursor_type;	/* cursor shape			*/
};

typedef struct {
	int cmd, flg;		/* weird data structure to make loadable */
	faddr_t faddr;		/* fonts easier to implement	*/
} pgiofontarg_t;		/* Not for use by user programs!! */

#define MAPADAPTER 	('m' << 8)	/* Upper byte of mapping ioctl's */
#define MAPCONS 	(MAPADAPTER)	/* Map display adapter memory */
#define MAPMONO 	(MAPADAPTER | MONO)	/* Map MCA adapter memory */
#define MAPCGA  	(MAPADAPTER | CGA) 	/* Map CGA adapter memory */
#define MAPPGA  	(MAPADAPTER | PGA)	/* Map PGA adapter memory */
#define MAPEGA  	(MAPADAPTER | EGA)	/* Map EGA adapter memory */
#define MAPVGA		(MAPADAPTER | VGA)
#define MAPSPECIAL	(MAPADAPTER | S_ADAP)

#define SWAPCONS 	('s' << 8)	/* Upper byte of switching ioctl's */
#define SWAPMONO 	(SWAPCONS | MONO)	/* Swap MCA adapter */
#define SWAPCGA  	(SWAPCONS | CGA)	/* Swap CGA adapter */
#define SWAPPGA  	(SWAPCONS | PGA)	/* Swap PGA adapter */
#define SWAPEGA  	(SWAPCONS | EGA)	/* Swap EGA adapter */
#define SWAPVGA  	(SWAPCONS | VGA)	/* Swap VGA adapter */

#ifndef _KB_386	/* These are also defined in termios.h	*/
#define _KB_386
#define TIOCKBON  	(TIOC | 8)	/* Turn on extended keys */
#define TIOCKBOF  	(TIOC | 9)	/* Turn off extended keys */
#define KBENABLED 	(TIOC | 10)	/* Are extended keys enabled? */
#endif	/* _KB_386	*/


/* VP/ix keyboard types */
#define KB_84		1
#define KB_101		2
#define KB_OTHER	3

struct kbentry {
	unchar	kb_table;	/* which table to use */
	unchar	kb_index;	/* which entry in table */
	ushort	kb_value;	/* value to get/set in table */
};

#define	MKDCONFADDR	20	/* max no. of configurable addrs 
				 * that can be supported */
#define	MKDIOADDR	64	/* max no. of I/O addresses supported */

struct kd_disparam {
	long	type;		/* display type */
	char	*addr;		/* display memory address */
	ushort	ioaddr[MKDIOADDR];	/* valid I/O addresses */
};

struct kd_vdctype {
	long	cntlr,	/* controller type */
		dsply,	/* display type */
		rsrvd;	/* reserved for future enhancement */
};

struct kd_memloc {
	char	*vaddr;		/* virtual address to map to */
	char	*physaddr;	/* physical address to map from */
	long	length;		/* size in bytes to map */
	long	ioflg;		/* enable I/O addresses if non-zero */
};

struct	kd_range {
	ulong	start;		/* start address of video memory */
	ulong	end;		/* last address of video memory */
};

struct kd_quemode {
	int	qsize;	/* desired # elements in queue (set by user) */
	int	signo;	/* signal number to send when queue goes non-empty
							(set by user) */
	char	*qaddr;	/* user virtual address of queue (set by driver) */
};

/* Defines for port I/O ioctls for graphics adapter ports */
#define IN_ON_PORT	1
#define OUT_ON_PORT	0

/* Structures for port I/O ioctls for graphics adapter ports */
#pragma pack(2)
struct port_io_struct {
	char	dir;		/* Direction flag (in or out) */
	ushort	port;		/* Port address */
	char	data;		/* Port data */
};
struct port_io_arg {
	struct port_io_struct args[4];	/* Port I/O's for single call */
};
#pragma pack()

#define MKDBASEIO	35	/* base system I/O address array size */

struct b_param { /* format of video parameters in bios */
	unchar		fill[5];
	unchar		seqtab[NSEQ - 1],
			miscreg;
	struct egainit	egatab;
	unchar		attrtab[NATTR],
			graphtab[NGRAPH];
};

#define	KD_BIOS	0	/* video parameters reside in the BIOS tables */
#define	KD_TBLE	1	/* video parameters reside in hard-coded tables */
#define	KD_CAS2	2	/* video parameters reside in supplemental table */

/*
 * Register values for CGA modes
 */

struct cgareginfo {
	unchar	cga_mode;		/* Mode select register value */
	unchar	cga_color;		/* Color select register value */
	ushort	cga_index;		/* Index into cga_videop array */
} ;

/*
 * EGA mode information.
 */

/* NOTE: This structure defined for compatibility only. Use the modeinfo struct
 * in vid.h
 */
struct mode_info {
	ushort	width,	/* alphanumeric mode widths (0 indicates graphics) */
		height; /* alphanumeric mode heights (0 indicates graphics) */
	unchar	color;	/* non-zero value indicates a color mode */
	paddr_t	base;	/* base screen memory physical address */
	ulong	size;	/* screen memory size */
	unchar	font,	/* font type (0 indicates graphics) */
		params,	/* parameter location: in bios or static table */
		offset,	/* offset given m_loc above */
		ramdac;	/* RAMDAC table offset to use */
} ;

struct kb_shiftmkbrk {
	ushort	mb_mask;
	unchar	mb_make,
		mb_break;
	unchar	mb_prfx;
} ;

struct font_info {
	unchar	*f_fontp;
	ushort	f_bpc;
	ulong	f_count;
};

struct vertim {
	unchar	v_ind,
		v_val;
} ;

#define KD_HERCINDX	0
#define KD_MONOINDX	1
#define KD_COLRINDX	2
#define KD_EGAINDX	3

#define VDCGRNUM	6

struct vdc_graphadds {
	unchar	v_graphtab[VDCGRNUM];
};

struct kdvtinfo {		/* device specific info for kd vt driver */
	scrnmapp_t		kv_scrnmap;	/* Output character map */
	unsigned		kv_sending;	/* Sending screen? */
	ushort			kv_rows;	/* Rows sent from screen */
	ushort			kv_cols;	/* Columns sent from screen */
	unchar			kv_kbmode;	/* keyboard mode */
	unchar			kv_dmode;	/* display mode */
	unchar			kv_flags;	/* flags */
	unchar			kv_egamode;	/* Saved EGA mode */
};

struct ext_graph {
	long	pid;
	struct proc *procp;
};


#endif /* _SYS_KD_H */
  070701000059a2000081240000000200000002000000012719347c00000a28000000230000000c00000000000000000000001900000000usr/include/sys/kmacct.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/kmacct.h.sl 1.1 4.0 10/15/90 57642 AT&T-SF"
/*
 * Kernel Memory Allocator accounting package
 */

/*
 * Command types for KMACCT ioctl()
 */

#define	KMACCT_ON	1	/* Turn KMEM accounting on */
#define	KMACCT_OFF	2	/* Turn KMEM accounting off */
#define	KMACCT_ZERO	3	/* Zero the counters */
#define	KMACCT_SIZE	4	/* Return size of accounting data */
#define	KMACCT_NDICT	5	/* Return number of dictionary entries */
#define	KMACCT_DEPTH	6	/* Return depth of trace stack */
#define	KMACCT_STATE	7	/* Return state of accounting (on or off) */

/*
 * The kernel text start address and kernel text length parameters should
 * agree with the kernel text origin and length values given in the
 * kernel ifile.  These are used to detect when we traced back out of
 * the kernel stack.
 */

#define	KTXTSTRT	KVSBASE
#define	KTXTLEN		0x00400000

/*
 * The number of different sizes to track should agree with the 
 * number of sizes allocatable by KMEM; in 4.0 this includes all
 * sizes in powers of 2 from 16 to 4096, plus outsize requests
 * greater than 4096 bytes.
 */

#define	KMSIZES		10

/*
 * MAXDEPTH is the maximum amount of stack that we can trace back through.
 * The master.d tunable must be no greater than MAXDEPTH.
 */

#define	MAXDEPTH	10	

/*
 * Calling sequence symbol table structure.
 * Note: if this structure changes, so must master.d/kmacct.  Also, *next
 * pointer must be first item in structure so hash chain will work.
 */

struct	kmasym {
	struct kmasym	*next;		/* Next structure on hash chain */
	caddr_t		*pc;		/* Pointer to pc calling sequence */
	ulong		reqa[KMSIZES];	/* Requests to allocate in each class */
	ulong		reqf[KMSIZES];	/* Requests to free in each class */
	};

typedef	struct kmasym	kmasym_t;

/*
 * Header for allocated buffers.  Each buffer that has been allocated while
 * accounting is enabled has a buffer header associated with it.
 */

struct	kmabuf	{
	struct	kmabuf	*next;	/* Next header in hash chain or free list */
	struct	kmabuf	*prev;	/* Previous header in hash chain */
	caddr_t		*addr;	/* Address of this buffer */
	kmasym_t	*kp;	/* Pointer to  dictionary entry */
	};

typedef	struct kmabuf	kmabuf_t;

/*
 * Calls to kmaccount() must identify whether they are allocating
 * or freeing space.
 */

#define	KMACCT_ALLOC	0x0100
#define	KMACCT_FREE	0x0200
070701000059a3000081240000000200000002000000012719347c000005f4000000230000000c00000000000000000000001700000000usr/include/sys/kmem.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_KMEM_H
#define _SYS_KMEM_H

#ident	"@(#)/usr/include/sys/kmem.h.sl 1.1 4.0 10/15/90 50654 AT&T-SF"

/*
 *	public definitions for kernel memory allocator
 */


/*
 * KM_SLEEP -- can sleep to get memory.
 * KM_NOSLEEP -- cannot sleep to get memory. *MUST* agree
 *			with NOSLEEP as defined in sys/immu.h
 * KM_NO_DMA -- By default, the seg_kmem segment driver will return DMA able
 *		pages. Since we do not want to penalize the KM allocator and
 *		other guys that rely on seg_kmem segment driver - we specify
 *		that they need not worry about DMAable pages.
 */
#define	KM_SLEEP	0
#define	KM_NOSLEEP	1
#define	KM_NO_DMA	2


/* function declarations */

#if defined(__STDC__)

extern void kmem_init(void);
extern _VOID * kmem_alloc(size_t, int);
extern _VOID * kmem_zalloc(size_t, int);
extern _VOID * kmem_fast_alloc(caddr_t *, size_t, int, int);
extern _VOID * kmem_fast_zalloc(caddr_t *, size_t, int, int);
extern void kmem_free(_VOID *, size_t);
extern void kmem_fast_free(caddr_t *, caddr_t);

#else

extern void kmem_init();
extern _VOID *kmem_alloc();
extern _VOID *kmem_zalloc();
extern _VOID *kmem_fast_alloc();
extern _VOID *kmem_fast_zalloc();
extern void kmem_free();
extern void kmem_fast_free();

#endif

#endif	/* _SYS_KMEM_H */
070701000059a4000081240000000200000002000000012719347c000043fe000000230000000c00000000000000000000001900000000usr/include/sys/ldterm.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_LDTERM_H
#define _SYS_LDTERM_H

#ident	"@(#)/usr/include/sys/ldterm.h.sl 1.1 4.0 10/15/90 63743 AT&T-SF"

#include <sys/emap.h>
#define	IBSIZE	16		/* "standard" input data block size */
#define	OBSIZE	64		/* "standard" output data block size */
#define	EBSIZE	16		/* "standard" echo data block size */

#ifndef MIN
#define	MIN(a,b) (((a)<(b))?(a):(b))
#endif

#define V_MIN 		(char) tp->t_modes.c_cc[VMIN]
#define V_TIME		(char) tp->t_modes.c_cc[VTIME]
#define RAW_MODE	!(tp->t_modes.c_lflag & ICANON)
#define CANON_MODE	(tp->t_modes.c_lflag & ICANON)

/*
 * The following for EUC.
 */

#define EUCSIZE	sizeof(struct eucioc)
#define EUCIN	0	/* copying eucioc_t IN from ioctl */
#define EUCOUT	1	/* copying it OUT to user format */

/*
 * One assumption made throughout this module is:  EUC characters have
 * a display width less than 255.  Also, assumed around, is that they
 * consist of < 256 bytes, but we don't worry much about that.
 */

#define EUC_TWIDTH	255	/* Width of a TAB, as returned by "ldterm_dispwidth" */
#define EUC_BSWIDTH	254	/* Width of a backspace as returned */
#define EUC_NLWIDTH	253	/* newline & cr */
#define EUC_CRWIDTH	252
#define EUC_MAXW	4	/* max display width and memory width, both */
#define EUC_WARNCNT	20	/* # bad EUC erase attempts before hollering */

typedef struct ldterm_mod {
	mblk_t	*t_savbp;	/* saved mblk that holds ld struct */
	struct termios t_modes;	/* Effective modes set by the provider below */
	struct termios t_amodes;/* Apparent modes for user programs */
	struct termios t_dmodes;/* Modes that driver wishes to process */
	unsigned long t_state;	/* internal state of ldterm module */
	int	t_line;		/* output line of tty */
	int	t_col;		/* output column of tty */
	int	t_rocount;	/* number of chars echoed since last output */
	int	t_rocol;	/* column in which first such char appeared */
	mblk_t	*t_message;	/* pointer to first mblk in message being built */
	mblk_t	*t_endmsg;	/* pointer to last mblk in that message */
	int	t_msglen;	/* number of characters in that message */
	mblk_t	*t_echomp;	/* echoed output being assembled */
	int	t_rd_request;   /* Number of bytes requested by M_READ during
				 * vmin/vtime read
				 */
	/*
	 * The following are for EUC processing. 
	 */
	unchar	t_codeset;	/* current code set indicator (read side) */
	unchar	t_eucleft;	/* bytes left to get in current char (read) */
	unchar	t_eucign;	/* bytes left to ignore (output post proc) */
	unchar	t_eucpad;	/* padding ... for eucwioc */
	eucioc_t eucwioc;	/* eucioc structure (have to use bcopy) */
	unchar	*t_eucp;	/* ptr to parallel array of column widths */
	mblk_t	*t_eucp_mp;	/* the m_blk that holds parallel array */
	unchar	t_maxeuc;	/* the max length in memory bytes of an EUC */
	int	t_eucwarn;	/* bad EUC counter */
	unsigned int	t_tid;	/* timeout ID for VMIN/VTIME processing */
	struct emp_tty t_emap;	/* XENIX character mapping info */
} ldtermstd_state_t;

/*
 * Internal state bits.
 */
#define	TS_XCLUDE	0x00000001	/* exclusive-use flag against open */
#define	TS_TTSTOP	0x00000002	/* output stopped by ^S */
#define	TS_TBLOCK	0x00000004	/* input stopped by IXOFF mode */
#define	TS_QUOT		0x00000008	/* last character input was \ */
#define	TS_ERASE	0x00000010	/* within a \.../ for PRTRUB */
#define	TS_SLNCH	0x00000020	/* next character service routine sees is literal */
#define	TS_PLNCH	0x00000040	/* next character put routine sees is literal */

#define TS_TTCR		0x00000080	/* mapping NL to CR-NL */
#define	TS_NOCANON	0x00000100	/* canonicalization done by somebody below us */
#define	TS_RESCAN	0x00000400	/* canonicalization mode changed, rescan input queue */
#define	TS_RTO		0x00000800	/* timer started for vmin/vtime */
#define	TS_TACT		0x00001000	/* timer active for vmin/vtime */
#define TS_MEUC		0x00010000	/* TRUE if multi-byte codesets used */
#define TS_WARNED	0x00020000	/* already warned on console */
#define TS_CLOSE	0x00040000	/* close in progress */



/*
 * Character types.
 */
#define	ORDINARY	0
#define	CONTROL		1
#define	BACKSPACE	2
#define	NEWLINE		3
#define	TAB		4
#define	VTAB		5
#define	RETURN		6

/*
 * The following for EUC handling:
 */
#define T_SS2		7
#define T_SS3		8

/*
 * Table indicating character classes to tty driver.  In particular,
 * if the class is ORDINARY, then the character needs no special
 * processing on output.
 *
 * Characters in the C1 set are all considered CONTROL; this will
 * work with terminals that properly use the ANSI/ISO extensions,
 * but might cause distress with terminals that put graphics in
 * the range 0200-0237.  On the other hand, characters in that
 * range cause even greater distress to other UNIX terminal drivers....
 */

static char typetab[256] = {
/* 000 */ 	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 004 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 010 */	BACKSPACE,	TAB,		NEWLINE,	CONTROL,
/* 014 */	VTAB,		RETURN,		CONTROL,	CONTROL,
/* 020 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 024 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 030 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 034 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 040 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 044 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 050 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 054 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 060 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 064 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 070 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 074 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 100 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 104 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 110 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 114 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 120 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 124 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 130 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 134 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 140 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 144 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 150 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 154 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 160 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 164 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 170 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 174 */	ORDINARY,	ORDINARY,	ORDINARY,	CONTROL,
/* 200 */ 	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 204 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 210 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 214 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 220 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 224 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 230 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 234 */	CONTROL,	CONTROL,	CONTROL,	CONTROL,
/* 240 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 244 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 250 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 254 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 260 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 264 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 270 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 274 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 300 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 304 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 310 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 314 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 320 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 324 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 330 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 334 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 340 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 344 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 350 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 354 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 360 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 364 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/* 370 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
/*
 * WARNING:  For EUC, 0xFF must be an ordinary character.  It is used with
 * single-byte EUC in some of the "ISO Latin Alphabet" codesets, and occupies
 * a screen position; in those ISO sets where that position isn't used, it
 * shouldn't make any difference.
 */
/* 374 */	ORDINARY,	ORDINARY,	ORDINARY,	ORDINARY,
};

/*
 * Translation table for output without OLCUC.  All ORDINARY-class characters
 * translate to themselves.  All other characters have a zero in the table,
 * which stops the copying.
 */
static unsigned char notrantab[256] = {
/* 000 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 010 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 020 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 030 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 040 */	' ',	'!',	'"',	'#',	'$',	'%',	'&',	'\'',
/* 050 */	'(',	')',	'*',	'+',	',',	'-',	'.',	'/',
/* 060 */	'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',
/* 070 */	'8',	'9',	':',	';',	'<',	'=',	'>',	'?',
/* 100 */	'@',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 110 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 120 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 130 */	'X',	'Y',	'Z',	'[',	'\\',	']',	'^',	'_',
/* 140 */	'`',	'a',	'b',	'c',	'd',	'e',	'f',	'g',
/* 150 */	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
/* 160 */	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
/* 170 */	'x',	'y',	'z',	'{',	'|',	'}',	'~',	0,
/* 200 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 210 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 220 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 230 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 240 */	'\240',	'\241',	'\242',	'\243',	'\244',	'\245',	'\246',	'\247',
/* 250 */	'\250',	'\251',	'\252',	'\253',	'\254',	'\255',	'\256',	'\257',
/* 260 */	'\260',	'\261',	'\262',	'\263',	'\264',	'\265',	'\266',	'\267',
/* 270 */	'\270',	'\271',	'\272',	'\273',	'\274',	'\275',	'\276',	'\277',
/* 300 */	'\300',	'\301',	'\302',	'\303',	'\304',	'\305',	'\306',	'\307',
/* 310 */	'\310',	'\311',	'\312',	'\313',	'\314',	'\315',	'\316',	'\317',
/* 320 */	'\320',	'\321',	'\322',	'\323',	'\324',	'\325',	'\326',	'\327',
/* 330 */	'\330',	'\331',	'\332',	'\333',	'\334',	'\335',	'\336',	'\337',
/* 340 */	'\340',	'\341',	'\342',	'\343',	'\344',	'\345',	'\346',	'\347',
/* 350 */	'\350',	'\351',	'\352',	'\353',	'\354',	'\355',	'\356',	'\357',
/* 360 */	'\360',	'\361',	'\362',	'\363',	'\364',	'\365',	'\366',	'\367',
/*
 * WARNING: as for above ISO sets, \377 may be used.  Translate it to
 * itself.
 */
/* 370 */	'\370',	'\371',	'\372',	'\373',	'\374',	'\375',	'\376',	'\377',
};

/*
 * Translation table for output with OLCUC.  All ORDINARY-class characters
 * translate to themselves, except for lower-case letters which translate
 * to their upper-case equivalents.  All other characters have a zero in
 * the table, which stops the copying.
 */
static unsigned char lcuctab[256] = {
/* 000 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 010 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 020 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 030 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 040 */	' ',	'!',	'"',	'#',	'$',	'%',	'&',	'\'',
/* 050 */	'(',	')',	'*',	'+',	',',	'-',	'.',	'/',
/* 060 */	'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',
/* 070 */	'8',	'9',	':',	';',	'<',	'=',	'>',	'?',
/* 100 */	'@',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 110 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 120 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 130 */	'X',	'Y',	'Z',	'[',	'\\',	']',	'^',	'_',
/* 140 */	'`',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 150 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 160 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 170 */	'X',	'Y',	'Z',	'{',	'|',	'}',	'~',	0,
/* 200 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 210 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 220 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 230 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 240 */	'\240',	'\241',	'\242',	'\243',	'\244',	'\245',	'\246',	'\247',
/* 250 */	'\250',	'\251',	'\252',	'\253',	'\254',	'\255',	'\256',	'\257',
/* 260 */	'\260',	'\261',	'\262',	'\263',	'\264',	'\265',	'\266',	'\267',
/* 270 */	'\270',	'\271',	'\272',	'\273',	'\274',	'\275',	'\276',	'\277',
/* 300 */	'\300',	'\301',	'\302',	'\303',	'\304',	'\305',	'\306',	'\307',
/* 310 */	'\310',	'\311',	'\312',	'\313',	'\314',	'\315',	'\316',	'\317',
/* 320 */	'\320',	'\321',	'\322',	'\323',	'\324',	'\325',	'\326',	'\327',
/* 330 */	'\330',	'\331',	'\332',	'\333',	'\334',	'\335',	'\336',	'\337',
/* 340 */	'\340',	'\341',	'\342',	'\343',	'\344',	'\345',	'\346',	'\347',
/* 350 */	'\350',	'\351',	'\352',	'\353',	'\354',	'\355',	'\356',	'\357',
/* 360 */	'\360',	'\361',	'\362',	'\363',	'\364',	'\365',	'\366',	'\367',
/*
 * WARNING: as for above ISO sets, \377 may be used.  Translate it to
 * itself.
 */
/* 370 */	'\370',	'\371',	'\372',	'\373',	'\374',	'\375',	'\376',	'\377',
};

/*
 * Input mapping table -- if an entry is non-zero, and XCASE is set,
 * when the corresponding character is typed preceded by "\" the escape
 * sequence is replaced by the table value.  Mostly used for
 * upper-case only terminals.
 */
static char	imaptab[256] = {
/* 000 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 010 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 020 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 030 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 040 */	0,	'|',	0,	0,	0,	0,	0,	'`',
/* 050 */	'{',	'}',	0,	0,	0,	0,	0,	0,
/* 060 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 070 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 100 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 110 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 120 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 130 */	0,	0,	0,	0,	'\\',	0,	'~',	0,
/* 140 */	0,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 150 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 160 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 170 */	'X',	'Y',	'Z',	0,	0,	0,	0,	0,
/* 200-377 aren't mapped */
};

/*
 * Output mapping table -- if an entry is non-zero, and XCASE is set,
 * the corresponding character is printed as "\" followed by the table
 * value.  Mostly used for upper-case only terminals.
 */
static char	omaptab[256] = {
/* 000 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 010 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 020 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 030 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 040 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 050 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 060 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 070 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 100 */	0,	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 110 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 120 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 130 */	'X',	'Y',	'Z',	0,	0,	0,	0,	0,
/* 140 */	'\'',	0,	0,	0,	0,	0,	0,	0,
/* 150 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 160 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 170 */	0,	0,	0,	'(',	'!',	')',	'^',	0,
/* 200-377 aren't mapped */
};

/*
 * Translation table for TS_MEUC output without OLCUC.  All printing ASCII
 * characters translate to themselves.  All other _bytes_ have a zero in
 * the table, which stops the copying.  This and the following table exist
 * only so we can use the existing movtuc processing with or without OLCUC.
 * Maybe it speeds up something...because we can copy a block of characters
 * by only looking for zeros in the table.
 *
 * If we took the simple expedient of DISALLOWING "olcuc" with multi-byte
 * processing, we could rid ourselves of both these tables and save 512 bytes;
 * seriously, it doesn't make much sense to use olcuc with multi-byte, and
 * it will probably never be used.  Consideration should be given to disallowing
 * the combination TS_MEUC & OLCUC.
 */
static unsigned char enotrantab[256] = {
/* 000 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 010 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 020 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 030 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 040 */	' ',	'!',	'"',	'#',	'$',	'%',	'&',	'\'',
/* 050 */	'(',	')',	'*',	'+',	',',	'-',	'.',	'/',
/* 060 */	'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',
/* 070 */	'8',	'9',	':',	';',	'<',	'=',	'>',	'?',
/* 100 */	'@',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 110 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 120 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 130 */	'X',	'Y',	'Z',	'[',	'\\',	']',	'^',	'_',
/* 140 */	'`',	'a',	'b',	'c',	'd',	'e',	'f',	'g',
/* 150 */	'h',	'i',	'j',	'k',	'l',	'm',	'n',	'o',
/* 160 */	'p',	'q',	'r',	's',	't',	'u',	'v',	'w',
/* 170 */	'x',	'y',	'z',	'{',	'|',	'}',	'~',	0,
/* 200 - 377 aren't mapped (they're stoppers). */
};

/*
 * Translation table for TS_MEUC output with OLCUC.  All printing ASCII
 * translate to themselves, except for lower-case letters which translate
 * to their upper-case equivalents.  All other bytes have a zero in
 * the table, which stops the copying.  Useless for ISO Latin Alphabet
 * translations, but *sigh* OLCUC is really only defined for ASCII anyway.
 * We only have this table so we can use the existing OLCUC processing with
 * TS_MEUC set (multi-byte mode).  Nobody would ever think of actually
 * _using_ it...would they?
 */
static unsigned char elcuctab[256] = {
/* 000 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 010 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 020 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 030 */	0,	0,	0,	0,	0,	0,	0,	0,
/* 040 */	' ',	'!',	'"',	'#',	'$',	'%',	'&',	'\'',
/* 050 */	'(',	')',	'*',	'+',	',',	'-',	'.',	'/',
/* 060 */	'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',
/* 070 */	'8',	'9',	':',	';',	'<',	'=',	'>',	'?',
/* 100 */	'@',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 110 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 120 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 130 */	'X',	'Y',	'Z',	'[',	'\\',	']',	'^',	'_',
/* 140 */	'`',	'A',	'B',	'C',	'D',	'E',	'F',	'G',
/* 150 */	'H',	'I',	'J',	'K',	'L',	'M',	'N',	'O',
/* 160 */	'P',	'Q',	'R',	'S',	'T',	'U',	'V',	'W',
/* 170 */	'X',	'Y',	'Z',	'{',	'|',	'}',	'~',	0,
/* 200 - 377 aren't mapped (they're stoppers). */
};


#endif	/* _SYS_LDTERM_H */
  070701000059a5000081240000000200000002000000012719347c00001585000000230000000c00000000000000000000001800000000usr/include/sys/lihdr.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_LIHDR_H
#define _SYS_LIHDR_H

#ident	"@(#)/usr/include/sys/lihdr.h.sl 1.1 4.0 10/15/90 64158 AT&T-SF"

/*
 * Data Link Level Interface standard definitions.
 */


/*
 *	Primitive that are initiated by the Link-Layer user
 */

#define	DL_INFO_REQ	0	/* data link layer protocol parameter sizes*/
#define DL_BIND_REQ	1	/* bind protocol address request 	   */
#define	DL_UNBIND_REQ	2	/* unbind protocol address request 	   */
#define	DL_UNITDATA_REQ	7	/* unit_data send request 		   */


/*
 *	Primitives that are initiated by the Link-Layer provider
 */

#define	DL_INFO_ACK	3	/* protocol information acknowledgement */
#define	DL_BIND_ACK	4	/* protocol bind acknowledgement 	*/
#define	DL_ERROR_ACK	5	/* error acknowledgement 		*/
#define	DL_OK_ACK	6	/* success acknowledgement 		*/
#define	DL_UNITDATA_IND	8	/* unitdata receive indication 		*/
#define	DL_UDERROR_IND	9	/* unitdata receive indication 		*/


/*
 *	Primitive Non-fatal error return codes
 */

#define DLBADSAP	0	/* bad LSAP selector			 */
#define	DLACCES		2	/* inproper permissions 		 */
#define	DLOUTSTATE	3	/* Link layer interface out of state     */
#define	DLSYSERR	4	/* Unix system error 			 */


/*
 *	Subnetwork types
 */

#define	DL_CSMACD	0	/* CSMA/CD network (802.3)   */
#define	DL_TPB		1	/* Token Passing Bus (802.4) */
#define	DL_TPR		2	/* Token Ring Bus (802.5)    */
#define	DL_METRO	3	/* Metro Net (802.6)         */
#define	DL_ETHER	4	/* ETHERNET bus 	     */


/*
 *	Link-Layer service classes
 */

#define	DL_NOSERV	0	/* No service class    */
#define	DL_CLASSES	1	/* Has a service class */


/*
 *	Link-Layer current state definitions
 */

#define	DL_UNBND	0	/* LL not bound 	     */
#define	DL_WACK_B	1	/* LL waiting for bind ack   */
#define	DL_WACK_U	2	/* LL waiting for unbind ack */
#define	DL_IDLE		3	/* LL is active		     */


/*
 * The following structure definitions define the format of the 
 * streams message blocks used to define the Link-Layer Interface.
 */


/* 
 *	User Originated Primitives
 */

struct DL_info_req {
	long	PRIM_type;		/* always DL_INFO_REQ */
};


struct	DL_bind_req {
	long	PRIM_type;		/* always DL_BIND_REQ */
	long	LLC_sap;		/* the LSAP selector */
	long	GROWTH_field[2];	/* 802.2 llc type 2 fields */
};


struct DL_unbind_req {
	long	PRIM_type;		/* always DL_UNBIND_REQ */
};


struct DL_unitdata_req {
	long	PRIM_type;		/* always DL_UNITDATA_REQ */
	long	RA_length;		/* dest LSAP addr length */
	long	RA_offset;		/* dest LSAP addr offset */
	long	SERV_class;		/* service class */
	long	FILLER_field;		/* 802.2 LLC2 field */
};


/* 
 *	Provider Originated Primitives
 */

struct DL_info_ack {
	long	PRIM_type;		/* always DL_INFO_ACK */
	long	SDU_max;		/* max lsdu size */
	long	SDU_min;		/* min lsdu size */
	long	ADDR_length;		/* LSAP address length in bytes */
	long	SUBNET_type;		/* subnet type */
	long	SERV_class;		/* service class */
	long	CURRENT_state;		/* link layer state */
	long	GROWTH_field[2];	/* 802.2 LLC2 fields */
};


struct DL_bind_ack {
	long	PRIM_type;		/* always DL_BIND_ACK */
	long	LLC_sap;		/* lsap selector */
	long	ADDR_length;		/* LSAP address length in bytes */
	long	ADDR_offset;		/* LSAP address offset in the message */
	long	GROWTH_field[2];	/* 802.2 LLC2 fields */
};


struct DL_error_ack {
	long	PRIM_type;		/* always DL_ERROR_ACK */
	long	ERROR_prim;		/* primitive in error */
	long	LLC_error;		/* LLC error code */
	long	UNIX_error;		/* UNIX error code */
};


struct DL_ok_ack {
	long	PRIM_type;		/* always DL_OK_ACK */
	long	CORRECT_prim;		/* correct primitive */
};


struct DL_unitdata_ind {
	long	PRIM_type;		/* always DL_UNITDATA_IND */
	long	RA_length;		/* dest LSAP address length in bytes */
	long	RA_offset;		/* dest offset LSAP into message */
	long	LA_length;		/* src LSAP address length in bytes */
	long	LA_offset;		/* src offset LSAP into message */
	long	SERV_class;		/* service class */
};


struct DL_uderror_ind {
	long	PRIM_type;		/* always DL_UDERROR_IND */
	long	RA_length;		/* dest LSAP address length in bytes */
	long	RA_offset;		/* dest LSAP offset into msg in bytes */
	long	SERV_class;		/* service class */
	long	ERROR_type;		/* error type */
};


/*
 * 	The following is a union of all the primitives.
 */

union DL_primitives {
	long			prim_type;
	struct DL_info_req	info_req;
	struct DL_bind_req	bind_req;
	struct DL_unbind_req	unbind_req;
	struct DL_unitdata_req	data_req;
	struct DL_info_ack	info_ack;
	struct DL_bind_ack	bind_ack;
	struct DL_error_ack	error_ack;
	struct DL_ok_ack	ok_ack;
	struct DL_unitdata_ind	data_ind;
	struct DL_uderror_ind	error_ind;
};


/*
 *	Structure/union size constants.
 */

#define DL_INFO_REQ_SIZE	sizeof(struct DL_info_req)
#define DL_BIND_REQ_SIZE	sizeof(struct DL_bind_req)
#define DL_UNBIND_REQ_SIZE	sizeof(struct DL_unbind_req)
#define DL_INFO_ACK_SIZE	sizeof(struct DL_info_ack)
#define DL_BIND_ACK_SIZE	sizeof(struct DL_bind_ack)
#define DL_ERROR_ACK_SIZE	sizeof(struct DL_error_ack)
#define DL_OK_ACK_SIZE		sizeof(struct DL_ok_ack)
#define DL_UNITDATA_REQ_SIZE	sizeof(struct DL_unitdata_req)
#define DL_UNITDATA_IND_SIZE	sizeof(struct DL_unitdata_ind)
#define DL_UDERROR_IND_SIZE	sizeof(struct DL_uderror_ind)
#define DL_PRIMITIVES_SIZE	sizeof(union DL_primitives)


#endif	/* _SYS_LIHDR_H */
   070701000059a6000081240000000200000002000000012719347c0000077f000000230000000c00000000000000000000001700000000usr/include/sys/list.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_LIST_H
#define _SYS_LIST_H

#ident	"@(#)/usr/include/sys/list.h.sl 1.1 4.0 10/15/90 63921 AT&T-SF"
/* Generic lists
 * Lists are circular and doubly-linked, with headers.
 * When a list is empty, both pointers in the header
 * point to the header itself.
 */

/* list element */
typedef struct ls_elt {
	struct ls_elt *ls_next;
	struct ls_elt *ls_prev;
	/* your ad in this space */
} ls_elt_t;

/* 
 * All take as arguments side effect-free pointers to list structures
 */
#define LS_ISEMPTY(listp)	\
	(((struct ls_elt *)(listp))->ls_next == (struct ls_elt *)(listp))
#define LS_INIT(listp) {			\
	((struct ls_elt *)(listp))->ls_next =	\
	((struct ls_elt *)(listp))->ls_prev =	\
	((struct ls_elt *)(listp));		\
}

#define LS_REMOVE(listp)	ls_remove((struct ls_elt *)(listp))

/* 
 * For these five, ptrs are to list elements, but qp and stackp are
 * implicitly headers.
 */
#define LS_INS_BEFORE(oldp, newp)	\
	ls_ins_before((struct ls_elt *)(oldp), (struct ls_elt *)(newp))
 
#define LS_INS_AFTER(oldp, newp)	\
	ls_ins_after((struct ls_elt *)(oldp), (struct ls_elt *)(newp))

#define LS_INSQUE(qp, eltp)	\
	ls_ins_before((struct ls_elt *)(qp), (struct ls_elt *)(eltp))

/* result needs cast; NULL result if empty queue
 */
#define LS_REMQUE(qp)		ls_remque((struct ls_elt *)(qp))

#define LS_PUSH(stackp, newp) \
	ls_ins_after((struct ls_elt *)(stackp), (struct ls_elt *)(newp))

/* result needs cast; NULL result if empty stack
 */
#define LS_POP(stackp)		ls_remque((struct ls_elt *)(stackp))

extern void ls_ins_before();
extern void ls_ins_after();
extern struct ls_elt *ls_remque();
extern void ls_remove();


#endif	/* _SYS_LIST_H */
 070701000059a7000081240000000200000002000000012719347c000002f1000000230000000c00000000000000000000001700000000usr/include/sys/lock.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_LOCK_H
#define _SYS_LOCK_H

#ident	"@(#)/usr/include/sys/lock.h.sl 1.1 4.0 10/15/90 50961 AT&T-SF"
/*
 * flags for locking procs and texts
 */
#define	UNLOCK	 0
#define	PROCLOCK 1
#define	TXTLOCK	 2
#define	DATLOCK	 4

#ifdef _KERNEL

#define	MEMLOCK	 8

#if defined(__STDC__)
int punlock(void);
#else
int punlock();
#endif	/* __STDC__ */

#else

#if defined(__STDC__)
int plock(int);
#else
int plock();
#endif	/* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _SYS_LOCK_H */
   070701000059a8000081240000000200000002000000012719347c000003ba000000230000000c00000000000000000000001a00000000usr/include/sys/locking.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_LOCKING_H
#define _SYS_LOCKING_H

#ident	"@(#)/usr/include/sys/locking.h.sl 1.1 4.0 10/15/90 62752 AT&T-SF"

/*
 * THIS FILE CONTAINS CODE WHICH IS DESIGNED TO BE
 * PORTABLE BETWEEN DIFFERENT MACHINE ARCHITECTURES
 * AND CONFIGURATIONS. IT SHOULD NOT REQUIRE ANY
 * MODIFICATIONS WHEN ADAPTING XENIX TO NEW HARDWARE.
 */
/*
 *   Flag values for XENIX locking() system call (os/xsys.c)
 */


#define LK_UNLCK  0	/* unlock request */
#define LK_LOCK   1	/* lock request */
#define LK_NBLCK  20	/* non-blocking lock request */
#define LK_RLCK   3	/* read permitted only lock request */
#define LK_NBRLCK 4	/* non-blocking read only lock request */

#endif	/* _SYS_LOCKING_H */
  070701000059a9000081240000000200000002000000012719347c0000083d000000230000000c00000000000000000000001600000000usr/include/sys/log.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_LOG_H
#define _SYS_LOG_H

#ident	"@(#)/usr/include/sys/log.h.sl 1.1 4.0 10/15/90 61200 AT&T-SF"
/*
 * Header file for the Streams Log Driver
 */

/*
 * Minor devices for the log driver.
 * 0 through 5 are reserved for well-known entry points.
 * Minors above CLONEMIN are given out on clone opens.
 */
#define CONSWMIN	0	/* minor device to write to console log */
#define CLONEMIN	5	/* minor device of clone interface */

struct log {
	unsigned log_state;
	queue_t *log_rdq;
	mblk_t	*log_tracemp;
};

/*
 * Driver state values.
 */
#define LOGOPEN 	0x01
#define LOGERR		0x02
#define LOGTRC		0x04
#define LOGCONS		0x08

/* 
 * Module information structure fields
 */
#define LOG_MID		44
#define LOG_NAME	"LOG"
#define LOG_MINPS	0
#define LOG_MAXPS	128
#define LOG_HIWAT	4096
#define LOG_LOWAT	256

extern struct log log_log[];	/* log device state table */
extern int log_cnt;		/* number of configured minor devices */

/*
 * STRLOG(mid,sid,level,flags,fmt,args) should be used for those trace
 * calls that are only to be made during debugging.
 */
#if defined(DEBUG) || defined(lint)
#define STRLOG	strlog
#else
#define STRLOG	0 && strlog
#endif


/*
 * Utility macros for strlog.
 */

/*
 * logadjust - move a character pointer up to the next int boundary after
 * its current value.  Assumes sizeof(int) is 2**n bytes for some integer n. 
 */
#define logadjust(wp) (char *)(((unsigned)wp + sizeof(int)) & ~(sizeof(int)-1))

/*
 * logstrcpy(dp, sp) copies string sp to dp.
 */

#ifdef u3b2
asm 	char *
logstrcpy(dp, sp) 
{
%	mem dp, sp;

	MOVW dp,%r1
	MOVW sp,%r0
	STRCPY
	MOVW %r1,dp
	MOVW %r0,sp
}
#else	/* !u3b2 */
/*
 * This is a catchall definition for those processors that have not had
 * this coded in assembler above.
 */
#define logstrcpy(dp, sp)  for (; (*dp = *sp) != 0; dp++, sp++)
#endif
	

#endif	/* _SYS_LOG_H */
   070701000059aa000081240000000200000002000000012719347c000003f6000000230000000c00000000000000000000001500000000usr/include/sys/lp.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/lp.h.sl 1.1 4.0 10/15/90 1996 AT&T-SF"

#define SPL()		splstr()/* protection from interrupts */


#define	UNBUSY		0x80
#define	READY		0x40
#define	NOPAPER		0x20
#define	ONLINE		0x10
#define	ERROR		0x08

#define	INTR_ON		0x10
#define	SEL		0x08
#define	RESET		0x04
#define	AUTOLF		0x02
#define	STROBE		0x01

/* States: */
#define OPEN	0x01
#define LPPRES	0x10    /* set if parallel adapter present */


/*
 * Structures for the LP 
 * ____________________________
 *
 *
 */

struct lpcfg{
	int		flag;		/* lp is configured in */
	unsigned	data;		/* data latch address */
	unsigned	status;		/* printer status address */
	unsigned	control;	/* printer controls address */
	unsigned	vect;		/* printer controls address */
};


  070701000059ab000081240000000200000002000000012719347c00000198000000230000000c00000000000000000000001800000000usr/include/sys/macro.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MACRO_H
#define _SYS_MACRO_H

#ident	"@(#)/usr/include/sys/macro.h.sl 1.1 4.0 10/15/90 59262 AT&T-SF"

#endif	/* _SYS_MACRO_H */
070701000059ac000081240000000200000002000000012719347c00000579000000230000000c00000000000000000000001600000000usr/include/sys/map.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MAP_H
#define _SYS_MAP_H

#ident	"@(#)/usr/include/sys/map.h.sl 1.1 4.0 10/15/90 40912 AT&T-SF"

/*
 *		struct map	X[]	.m_size		.m_addr
 *				---	------------	-----------
 *				[0]	mapsize(X)	mapwant(X)
 *					# X[] unused	sleep value
 *
 *		  mapstart(X)->	[1]	# units		unit number
 *				 :	    :		  :
 *				[ ]	    0
 */

struct map
{
	unsigned long m_size;	/* number of units available */
	unsigned long m_addr;	/* address of first available unit */
};

extern struct map sptmap[];	/* Map for system virtual space.   */

#define	mapstart(X)	&X[1]		/* start of map array */
#define	mapwant(X)	X[0].m_addr
#define	mapsize(X)	X[0].m_size	/* number of empty slots \
					   remaining in map array */
#define	mapdata(X) {(X)-2, 0} , {0, 0}
#define	mapinit(X, Y)	X[0].m_size = (Y)-2


#if defined(__STDC__)
extern void rmfree(struct map *, size_t, u_long);
extern void mfree(struct map *, size_t, u_long);
extern u_long rmalloc(struct map *, size_t);
extern u_long malloc(struct map *, size_t);
#else
extern void rmfree();
extern void mfree();
extern u_long malloc();
extern u_long rmalloc();
#endif

#endif	/* _SYS_MAP_H */
   070701000059ae000081240000000200000002000000012719347c0000085c000000230000000c00000000000000000000001800000000usr/include/sys/mkdev.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MKDEV_H
#define _SYS_MKDEV_H

#ident	"@(#)/usr/include/sys/mkdev.h.sl 1.1 4.0 10/15/90 13562 AT&T-SF"

/* SVR3 device number constants */

#define ONBITSMAJOR	7	/* # of SVR3 major device bits */
#define ONBITSMINOR	8	/* # of SVR3 minor device bits */
#define OMAXMAJ		0x7f	/* SVR3 max major value */
#define OMAXMIN		0xff	/* SVR3 max major value */


#define NBITSMAJOR	14	/* # of SVR4 major device bits */
#define NBITSMINOR	18	/* # of SVR4 minor device bits */
#define MAXMAJ		0xff	/* Although 14 bits are reserved, 
				** the 3b2 major number is restricted
				** to 8 bits. 
				*/

#define MAXMIN		0x3ffff	/* MAX minor for 3b2 software drivers.
				** For 3b2 hardware devices the minor is
				** restricted to 256 (0-255)
				*/

#if !defined(_KERNEL)

/* undefine sysmacros.h device macros */

#undef makedev
#undef major
#undef minor

#if defined(__STDC__)

dev_t makedev(const major_t, const minor_t);
major_t major(const dev_t);
minor_t minor(const dev_t);
dev_t __makedev(const int, const major_t, const minor_t);
major_t __major(const int, const dev_t);
minor_t __minor(const int, const dev_t);

#else

dev_t makedev();
major_t major();
minor_t minor();
dev_t __makedev();
major_t __major();
minor_t __minor();

#endif	/* defined(_STDC_) */

#define OLDDEV 0	/* old device format */
#define NEWDEV 1	/* new device format */


static dev_t
makedev(maj, min)
major_t maj;
minor_t min;
{
int ver;
#if !defined(_STYPES)
	ver = NEWDEV;
#else
	ver = OLDDEV;
#endif

	return(__makedev(ver, maj, min));
}

static major_t 
major(dev)
dev_t dev;
{
int ver;
#if !defined(_STYPES)
	ver = NEWDEV;
#else
	ver = OLDDEV;
#endif

	return(__major(ver, dev));
}

static minor_t 
minor(dev)
dev_t dev;
{
int ver;
#if !defined(_STYPES)
	ver = NEWDEV;
#else
	ver = OLDDEV;
#endif

	return(__minor(ver, dev));
}

#endif	/* !defined(_KERNEL) */

#endif	/* _SYS_MKDEV_H */
070701000059af000081240000000200000002000000012719347c00000f59000000230000000c00000000000000000000001700000000usr/include/sys/mman.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MMAN_H
#define _SYS_MMAN_H

#ident	"@(#)/usr/include/sys/mman.h.sl 1.1 4.0 10/15/90 53578 AT&T-SF"

/*
 * Protections are chosen from these bits, or-ed together.
 * Note - not all implementations literally provide all possible
 * combinations.  PROT_WRITE is often implemented as (PROT_READ |
 * PROT_WRITE) and (PROT_EXECUTE as PROT_READ | PROT_EXECUTE).
 * However, no implementation will permit a write to succeed
 * where PROT_WRITE has not been set.  Also, no implementation will
 * allow any access to succeed where prot is specified as PROT_NONE.
 */
#define	PROT_READ	0x1		/* pages can be read */
#define	PROT_WRITE	0x2		/* pages can be written */
#define	PROT_EXEC	0x4		/* pages can be executed */

#ifdef _KERNEL
#define	PROT_USER	0x8		/* pages are user accessable */
#define	PROT_ALL	(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_USER)
#endif /* _KERNEL */

#define	PROT_NONE	0x0		/* pages cannot be accessed */

/* sharing types:  must choose either SHARED or PRIVATE */
#define	MAP_SHARED	1		/* share changes */
#define	MAP_PRIVATE	2		/* changes are private */
#define	MAP_TYPE	0xf		/* mask for share type */

/* other flags to mmap (or-ed in to MAP_SHARED or MAP_PRIVATE) */
#define	MAP_FIXED	0x10		/* user assigns address */

/* these flags not yet implemented */
#define	MAP_RENAME	0x20		/* rename private pages to file */
#define	MAP_NORESERVE	0x40		/* don't reserve needed swap area */

/* these flags are used by memcntl */
#define PROC_TEXT	(PROT_EXEC | PROT_READ)
#define PROC_DATA	(PROT_READ | PROT_WRITE | PROT_EXEC)
#define SHARED		0x10
#define PRIVATE		0x20

#ifdef _KERNEL
#define PROT_EXCL	0x20
#endif /* _KERNEL */

#define VALID_ATTR  (PROT_READ|PROT_WRITE|PROT_EXEC|SHARED|PRIVATE)
#ifdef notdef
/*
 * Not clear that this flag will ever be implemented
 */
#define	MAP_INHERIT	0x80		/* inherit this mapping accross exec */
#endif /* notdef */

/*
 * For the sake of backward object compatibility, we use the _MAP_NEW flag.
 * This flag will be automatically or'ed in by the C library for all
 * new mmap calls.  Previous binaries with old mmap calls with continue
 * to get 0 or -1 for return values.  New mmap calls will get the mapped
 * address as the return value if successful and -1 on errors.  By default,
 * new mmap calls automatically have the kernel assign the map address
 * unless the MAP_FIXED flag is given.
 */
#define	_MAP_NEW	0x80000000	/* user's should not need to use this */

#if !defined(LOCORE) && !defined(_KERNEL)
#include <sys/types.h>

/*
 * Except for old binaries mmap() will return the resultant
 * address of mapping on success and (caddr_t)-1 on error.
 */
extern caddr_t mmap();
#endif /* !LOCORE && !_KERNEL */

/* advice to madvise */
#define	MADV_NORMAL	0		/* no further special treatment */
#define	MADV_RANDOM	1		/* expect random page references */
#define	MADV_SEQUENTIAL	2		/* expect sequential page references */
#define	MADV_WILLNEED	3		/* will need these pages */
#define	MADV_DONTNEED	4		/* don't need these pages */

/* flags to msync */
#define	MS_SYNC		0x0		/* wait for msync */
#define	MS_ASYNC	0x1		/* return immediately */
#define	MS_INVALIDATE	0x2		/* invalidate caches */

/* functions to mctl */
#define	MC_SYNC		1		/* sync with backing store */
#define	MC_LOCK		2		/* lock pages in memory */
#define	MC_UNLOCK	3		/* unlock pages from memory */
#define	MC_ADVISE	4		/* give advice to management */
#define	MC_LOCKAS	5		/* lock address space in memory */
#define	MC_UNLOCKAS	6		/* unlock address space from memory */

/* flags to mlockall */
#define	MCL_CURRENT	0x1		/* lock current mappings */
#define	MCL_FUTURE	0x2		/* lock future mappings */

#endif	/* _SYS_MMAN_H */
   070701000059b0000081240000000200000002000000012719347c00000655000000230000000c00000000000000000000001900000000usr/include/sys/mntent.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sys/mntent.h.sl 1.1 4.0 10/15/90 6743 AT&T-SF"
#define bcopy(f,t,n)    memcpy(t,f,n)
#define bzero(s,n)	memset(s,0,n)
#define bcmp(s,d,n)	memcmp(s,d,n)

#define index(s,r)	strchr(s,r)
#define rindex(s,r)	strrchr(s,r)

#define MNTTAB		"/etc/mnttab"
#define VFSTAB		"/etc/vfstab"

#define	MNTTYPE_UFS	"ufs"
#define MNTTYPE_SWAP    "swap"  /* swap file system */
#define MNTTYPE_IGNORE  "ignore"/* No type specified, ignore this entry */
#define MNTTYPE_LO      "lo"    /* Loop back File system */

#define      MNTOPT_RO       "ro"    /* read only */
#define   MNTMAXSTR       128
#define MNTOPT_RW       "rw"    /* read/write */
#define MNTOPT_RQ	"rq"	/* read/write with quotas */
#define MNTOPT_QUOTA    "quota" /* quotas */
#define MNTOPT_NOQUOTA  "noquota"/* no quotas */
#define MNTOPT_SOFT     "soft"  /* soft mount */
#define MNTOPT_HARD     "hard"  /* hard mount */
#define MNTOPT_NOSUID   "nosuid"/* no set uid allowed */
#define MNTOPT_NOAUTO   "noauto"/* hide entry from mount -a */
#define MNTOPT_GRPID    "grpid" /* SysV-compatible group-id on create */
#define MNTOPT_REMOUNT  "remount"/* change options on previous mount */
#define MNTOPT_NOSUB    "nosub"  /* disallow mounts beneath this one */
#define MNTOPT_MULTI    "multi"  /* Do multi-component lookup */

#define L_SET		0	/* for lseek */

char * hasmntopt();
   070701000059b1000081240000000200000002000000012719347c0000054e000000230000000c00000000000000000000001900000000usr/include/sys/mnttab.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MNTTAB_H
#define _SYS_MNTTAB_H

#ident	"@(#)/usr/include/sys/mnttab.h.sl 1.1 4.0 10/15/90 12554 AT&T-SF"

#define	MNTTAB	"/etc/mnttab"
#define	MNT_LINE_MAX	1024

#define	MNT_TOOLONG	1	/* entry exceeds MNT_LINE_MAX */
#define	MNT_TOOMANY	2	/* too many fields in line */
#define	MNT_TOOFEW	3	/* too few fields in line */

#define	mntnull(mp)\
	((mp)->mnt_special = (mp)->mnt_mountp =\
	 (mp)->mnt_fstype = (mp)->mnt_mntopts =\
	 (mp)->mnt_time = NULL)

#define	putmntent(fd, mp)\
	fprintf((fd), "%s\t%s\t%s\t%s\t%s\n",\
		(mp)->mnt_special ? (mp)->mnt_special : "-",\
		(mp)->mnt_mountp ? (mp)->mnt_mountp : "-",\
		(mp)->mnt_fstype ? (mp)->mnt_fstype : "-",\
		(mp)->mnt_mntopts ? (mp)->mnt_mntopts : "-",\
		(mp)->mnt_time ? (mp)->mnt_time : "-")

struct mnttab {
	char	*mnt_special;
	char	*mnt_mountp;
	char	*mnt_fstype;
	char	*mnt_mntopts;
	char	*mnt_time;
};

#ifdef __STDC__
extern int	getmntent(FILE *, struct mnttab *);
extern int	getmntany(FILE *, struct mnttab *, struct mnttab *);
#else
extern int	getmntent();
extern int	getmntany();
#endif

#endif	/* _SYS_MNTTAB_H */
  070701000059b2000081240000000200000002000000012719347c00000306000000230000000c00000000000000000000001700000000usr/include/sys/mode.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MODE_H
#define _SYS_MODE_H

#ident	"@(#)/usr/include/sys/mode.h.sl 1.1 4.0 10/15/90 37276 AT&T-SF"

/*
 * REQUIRES sys/stat.h
 * REQUIRES sys/vnode.h
 */

/*
 * Conversion between vnode types/modes and encoded type/mode as
 * seen by stat(2) and mknod(2).
 */
extern enum vtype	iftovt_tab[];
extern ushort		vttoif_tab[];
#define IFTOVT(M)	(iftovt_tab[((M) & S_IFMT) >> 12])
#define VTTOIF(T)	(vttoif_tab[(int)(T)])
#define MAKEIMODE(T, M)	(VTTOIF(T) | ((M) & ~S_IFMT))

#endif	/* _SYS_MODE_H */
  070701000059b3000081240000000200000002000000012719347c000003e5000000230000000c00000000000000000000001800000000usr/include/sys/mount.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MOUNT_H
#define _SYS_MOUNT_H

#ident	"@(#)/usr/include/sys/mount.h.sl 1.1 4.0 10/15/90 11853 AT&T-SF"
/*
 * Flags bits passed to mount(2).
 */
#define	MS_RDONLY	0x01	/* Read-only */
#define	MS_FSS		0x02	/* Old (4-argument) mount (compatibility) */
#define	MS_DATA		0x04	/* 6-argument mount */
#define MS_HADBAD	0x08	/* File system incurred a bad block */
				/* so set s_state to FsBADBLK on umount */
#define	MS_NOSUID	0x10	/* Setuid programs disallowed */
#define MS_REMOUNT	0x20	/* Remount */
#define MS_NOTRUNC	0x40	/* Return ENAMETOOLONG for long filenames */

#if defined(__STDC__) && !defined(_KERNEL)
int mount(const char *, const char *, int, ...);
int umount(const char *);
#endif

#endif	/* _SYS_MOUNT_H */
   070701000059b4000081240000000200000002000000012719347c00001083000000230000000c00000000000000000000001800000000usr/include/sys/mouse.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/mouse.h.sl 1.1 4.0 10/15/90 17991 AT&T-SF"

#define BUTCHNGMASK	0x38
#define MOVEMENT	0x40

#define BUTSTATMASK	7
#define BUT3STAT	1
#define BUT2STAT	2
#define BUT1STAT	4
#define BUT3CHNG	8
#define BUT2CHNG	0x10
#define BUT1CHNG	0x20
#define PACKETDONE	0x80

struct mse_event {
	unchar	type;		/* event type (see below) */
	unchar	code;		 /* when type is XQ_MOTION or XQ_BUTTON, =>
					bit 0 clear if right button pushed;
					bit 1 clear if middle button pushed;
					bit 2 clear if left button pushed; */
	char	x;		/* delta x movement (mouse motion only) */
	char	y;		/* delta y movement (mouse motion only) */
};

#define	MSE_BUTTON	0
#define	MSE_MOTION	1

struct mouseinfo {       
	unsigned char	status;
	char	xmotion, ymotion;
};

/* Ioctl Command definitions */

#define MOUSEIOC        ('M'<<8)
#define MOUSEIOCREAD    (MOUSEIOC|60)
#define MOUSEISOPEN     (MOUSEIOC|66)
#define MOUSE320    	(MOUSEIOC|67)
#define MSEBUTTONS	(MOUSEIOC|68)
#define TS_CALIB	(MOUSEIOC|70)	/* Touch screen: set the calibration */
#define TS_RECALIB	(MOUSEIOC|71)	/* Touch screen: disable calibration */
#define TS_CURPOS	(MOUSEIOC|72)	/* Touch screen: set cursor position */
#define MOUSEIOCDELAY	(MOUSEIOC|80)
#define MOUSEIOCNDELAY	(MOUSEIOC|81)
#define MOUSEIOCCONFIG	(MOUSEIOC|100)
#define MOUSEIOCMON	(MOUSEIOC|101)

#define VPC_MOUSE_READ  MOUSEIOCREAD

#define UPPERLIM	127
#define LOWERLIM	-128
#define ONEBYTE(x)	((x)>UPPERLIM?UPPERLIM:(x)<LOWERLIM?LOWERLIM:(x))

/* 320 mouse command/query structure */

struct	cmd_320 {
	int	cmd;
	int	arg1;
	int	arg2;
	int	arg3;
};

/*
 * AT&T 320 (PS/2 style) Mouse Commands 
 */
#define	MSERESET	0xff	/* reset mouse */
#define	MSERESEND	0xfe	/* resend last data stream */
#define	MSESETDEF	0xf6	/* set default status */
#define	MSEOFF		0xf5	/* disable mouse */
#define	MSEON		0xf4	/* enable mouse */
#define	MSECHGMOD	0xf3	/* set sampling rate and/or button mode */
#define	MSEGETDEV	0xf2	/* read device type */
#define	MSESPROMPT	0xf0	/* set prompt mode (resets stream mode) */
#define	MSEECHON	0xee	/* set echo mode */
#define	MSEECHOFF	0xec	/* reset echo mode */
#define	MSEREPORT	0xeb	/* read mouse report */
#define	MSESTREAM	0xea	/* set Incremental Stream Mode */
#define	MSESTATREQ	0xe9	/* status request */
#define	MSESETRES	0xe8	/* set counts per mm. resolution */
#define MSESCALE2	0xe7	/* set 2:1 scaling */
#define MSESCALE1	0xe6	/* set 1:1 scaling */

/*
 * 320 mouse 8042 controller commands and flags
 */
#define MSE_ROP		0xD0	/* read output port command */
#define MSE_RIP		0xC0	/* read input port command */
#define MSE_WOP		0xD3	/* write to loopback command */
#define MSE_WAD		0xD4	/* write to device command */
#define	MSE_RCB		0x20	/* read command byte command */
#define	MSE_WCB		0x60	/* write command byte command */
#define MSE_INBF	0x03	/* input/output buffer full flag */
#define MSE_OUTBF	0x21	/* output buffer full flag */
#define	MSE_ENAB	0xA8	/* enable 8042 interface */
#define	MSE_DISAB	0xA7	/* disable 8042 interface */
#define MSE_ACK		0xFA	/* Acknowledgement byte from 8042 */

typedef struct mouseinfo MOUSEINFO;

/*
 * Begin Carrol touch screen-specific definitions.
 */

/*
 * Calibration data structure.	Used with TS_CALIB ioctl to register the upper
 * left opto-coordinate that cooresponds to the upper left corner of the active
 * video area, and the lower right opto-coordinate that cooresponds to the
 * lower right corner of the active video area.
 */

struct ts_calib {
	int	c_ulx,	/* upper left X opto-coordinate of active video area */
		c_uly,	/* upper left Y opto-coordinate of active video area */
		c_lrx,	/* lower right X opto-coordinate of active video area */		c_lry;	/* lower right Y opto-coordinate of active video area */};

/*
 * Position cursor at the given "pixel" coordinate.
 */

struct ts_curpos {
	int	p_xpos, /* X cursor coordinate */
		p_ypos;	/* Y cursor coordinate */
};

/*
 * End Carrol touch screen-specific difinitions.
 */
 070701000059b5000081240000000200000002000000012719347c00001646000000230000000c00000000000000000000001600000000usr/include/sys/msg.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_MSG_H
#define _SYS_MSG_H

#ident	"@(#)/usr/include/sys/msg.h.sl 1.1 4.0 10/15/90 38830 AT&T-SF"

/*
 * IPC Message Facility.
 */

/*
 * Implementation Constants.
 */

#define	PMSG	(PZERO + 2)	/* message facility sleep priority */

/*
 * Permission Definitions.
 */

#define	MSG_R	0400	/* read permission */
#define	MSG_W	0200	/* write permission */

/*
 * ipc_perm Mode Definitions.
 */

#define	MSG_RWAIT	01000	/* a reader is waiting for a message */
#define	MSG_WWAIT	02000	/* a writer is waiting to send */

/*
 * Message Operation Flags.
 */

#define	MSG_NOERROR	010000	/* no error if big message */

/*
 * There is one msg queue id data structure for each q in the system.
 */

/* Applications that read /dev/mem must be built like the kernel. A new
** symbol "_KMEMUSER" is defined for this purpose.
*/

#if defined(_KERNEL) || defined(_KMEMUSER)
/* expanded msqid_ds structure */

struct msqid_ds {
	struct ipc_perm msg_perm;	/* operation permission struct */
	struct msg	*msg_first;	/* ptr to first message on q */
	struct msg	*msg_last;	/* ptr to last message on q */
	ulong		msg_cbytes;	/* current # bytes on q */
	ulong		msg_qnum;	/* # of messages on q */
	ulong		msg_qbytes;	/* max # of bytes on q */
	pid_t		msg_lspid;	/* pid of last msgsnd */
	pid_t		msg_lrpid;	/* pid of last msgrcv */
	time_t		msg_stime;	/* last msgsnd time */
	long		msg_pad1;	/* reserved for time_t expansion */
	time_t		msg_rtime;	/* last msgrcv time */
	long		msg_pad2;	/* time_t expansion */
	time_t		msg_ctime;	/* last change time */
	long		msg_pad3;	/* time expansion */
	long		msg_pad4[4];		/* reserve area */
};

/* SVR3 structure */

struct o_msqid_ds {
	struct o_ipc_perm msg_perm;	/* operation permission struct */
	struct msg	*msg_first;	/* ptr to first message on q */
	struct msg	*msg_last;	/* ptr to last message on q */
	ushort		msg_cbytes;	/* current # bytes on q */
	ushort		msg_qnum;	/* # of messages on q */
	ushort		msg_qbytes;	/* max # of bytes on q */
	o_pid_t		msg_lspid;	/* pid of last msgsnd */
	o_pid_t		msg_lrpid;	/* pid of last msgrcv */
	time_t		msg_stime;	/* last msgsnd time */
	time_t		msg_rtime;	/* last msgrcv time */
	time_t		msg_ctime;	/* last change time */
};
#else	/* user definition */

#if !defined(_STYPES) 		/* EFT system */
/* this maps to the kernel struct msgid_ds */

struct msqid_ds {
	struct ipc_perm	msg_perm;	/* operation permission struct */
	struct msg	*msg_first;	/* ptr to first message on q */
	struct msg	*msg_last;	/* ptr to last message on q */
	ulong		msg_cbytes;	/* current # bytes on q */
	ulong		msg_qnum;	/* # of messages on q */
	ulong		msg_qbytes;	/* max # of bytes on q */
	pid_t		msg_lspid;	/* pid of last msgsnd */
	pid_t		msg_lrpid;	/* pid of last msgrcv */
	time_t		msg_stime;	/* last msgsnd time */
	long		msg_pad1;	/* reserved for time_t expansion */
	time_t		msg_rtime;	/* last msgrcv time */
	long		msg_pad2;	/* time_t expansion */
	time_t		msg_ctime;	/* last change time */
	long		msg_pad3;	/* time_t expansion */
	long		msg_pad4[4];	/* reserve area */
};
#else	/* NON EFT */

/* SVR3 structure - maps to kernel structure o_msqid_ds */

struct msqid_ds {
	struct ipc_perm	msg_perm;	/* operation permission struct */
	struct msg	*msg_first;	/* ptr to first message on q */
	struct msg	*msg_last;	/* ptr to last message on q */
	ushort		msg_cbytes;	/* current # bytes on q */
	ushort		msg_qnum;	/* # of messages on q */
	ushort		msg_qbytes;	/* max # of bytes on q */
	o_pid_t		msg_lspid;	/* pid of last msgsnd */
	o_pid_t		msg_lrpid;	/* pid of last msgrcv */
	time_t		msg_stime;	/* last msgsnd time */
	time_t		msg_rtime;	/* last msgrcv time */
	time_t		msg_ctime;	/* last change time */
};

#endif	/* !defined(_STYPES) */
#endif  /* defined(_KERNEL) */

/*
 * There is one msg structure for each message that may be in the system.
 */

struct msg {
	struct msg	*msg_next;	/* ptr to next message on q */
	long		msg_type;	/* message type */
	ushort		msg_ts;		/* message text size */
	short		msg_spot;	/* message text map address */
};

/*
 * User message buffer template for msgsnd and msgrecv system calls.
 */

struct msgbuf {
	long	mtype;		/* message type */
	char	mtext[1];	/* message text */
};

/*
 * Message information structure.
 */

struct msginfo {
	int	msgmap;	/* # of entries in msg map */
	int	msgmax;	/* max message size */
	int	msgmnb;	/* max # bytes on queue */
	int	msgmni;	/* # of message queue identifiers */
	int	msgssz;	/* msg segment size (should be word size multiple) */
	int	msgtql;	/* # of system message headers */
	ushort	msgseg;	/* # of msg segments (MUST BE < 32768) */
};

/*
 * We have to be able to lock a message queue since we can
 * sleep during message processing due to a page fault in
 * copyin/copyout or iomove.  We cannot add anything to the
 * msqid_ds structure since this is used in user programs
 * and any change would break object file compatibility.
 * Therefore, we allocate a parallel array, msglock, which
 * is used to lock a message queue.  The array is defined
 * in the msg master file.  The following macro takes a
 * pointer to a message queue and returns a pointer to the
 * lock entry.  The argument must be a pointer to a msgqid
 * structure.
 */

#define	MSGLOCK(X)	&msglock[X - msgque]

#if defined(__STDC__) && !defined(_KERNEL)
int msgctl(int, int, ...);
int msgget(key_t, int);
int msgrcv(int, void *, size_t, long, int);
int msgsnd(int, const void *, size_t, int);
#endif

#endif	/* _SYS_MSG_H */
  070701000059b6000081240000000200000002000000012719347c0000110f000000230000000c00000000000000000000001700000000usr/include/sys/nami.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */

#ident	"@(#)/usr/include/sys/nami.h.sl 1.1 4.0 10/15/90 21789 AT&T-SF"

/*
 * Structure used by system calls to pass parameters
 * to the file system independent namei and attribute
 * functions.
 */
struct argnamei {	/* namei's flag argument */
	ushort	cmd;	/* command type (see below) */
	short	rcode;	/* a scratch for return codes (see below) */
	long	ino;	/* ino for link */
	long	mode;	/* mode for creat and chmod */
	ushort	ftype;	/* file type */
	ushort	uid;	/* uid for chown */
	ushort	gid;	/* gid for chown */
	dev_t	idev;	/* dev for link and creat */
};

/*
 * Possible values for argnamei.cmd field 
 */
#define	NI_DEL		0x1	/* unlink this file */
#define	NI_CREAT	0x2	/* create */
#define	NI_XCREAT	0x3	/* Exclusive create, error if */
				/* the file exists */
#define	NI_LINK		0x4	/* make a link */
#define	NI_MKDIR	0x5	/* mkdir */
#define	NI_RMDIR	0x6	/* rmdir */
#define	NI_MKNOD	0x7	/* mknod */

/* Requests to fs_setattr */
#define	NI_CHOWN	0x1	/* change owner */
#define	NI_CHMOD	0x2	/* change mode (permissions and 
				/* ISUID, ISGID, ISVTX) */

/* Codes to fs_notify */
#define	NI_OPEN		0x1	/* open - some fstyps may want */
				/* to know when a file is opened */
#define	NI_CLOSE	0x2	/* close */
#define	NI_CHDIR	0x3	/* let fstyp know that a cd */
				/* is happening (e.g., some fstyp */
				/* may need to know so that */
				/* directory cache can be */
				/* flushed - if it has one) */

/*
 * Return Codes for argnamei.rcode
 */
#define	FSN_FOUND	0x1	/* The file was found by namei (it exists) */
#define	FSN_NOTFOUND	0x2	/* The file was not found by namei  */
				/* (i.e., it does not exist */

/*
 * Return Codes for file sytem dependent namei's
 */
#define	NI_PASS		0	/* Error free FS specific namei */
#define	NI_FAIL		1	/* Error encountered in FS specific namei */
#define	NI_RESTART	2	/* The fs dependent code overwrote */
				/* the buffer and the namei must */
				/* begin again. Used mostly for */
				/* symbolic links. */
#define	NI_DONE		3	/* The fs dependent operation is */
				/* complete. There is no need to do */
				/* any further pathnme processing. */
				/* This is equivalent to NI_PASS for */
				/* those commands that require some */
				/* action from the fs dependent code */
#define NI_NULL 	4	/* Tell fs independent to return NULL to */
				/* the calling procedure without doing /*
				/* an iput */
#define NI_SYMRESTART	5	/* The fs dependent code overwrote the */
				/* buffer and namei must reparse */
				/* starting at the current directory */
				/* in the parse.  Used mostly for */
				/* symbolic links */

/*
 * Data that is passed from the file system independent namei to the
 * file system dependent namei.
 */
struct nx {
	struct	inode *dp;	/* inode of matched file */
				/* characters */
	caddr_t	comp;		/* pointer to beginning of current */
				/* pathname component */
	caddr_t	bufp;		/* pointer to the beginning of the */
				/* pathname buffer */
	long	ino;		/* inode number returned by fs dep code */
	long	flags;		/* Flag field */
};

#define	NX_ISROOT	0x1	/* Inode is root of fs */

/* Values for fsinfo[].fs_notify. If an fstyp wishes to be */
/* notified of an action the appropriate flag should be set */
/* in fsinfo[].fs_notify and fstypsw[].fs_notify should point */
/* to the desired fs dependent function */
#define	NO_CHDIR	0x1	/* chdir */
#define	NO_CHROOT	0x2	/* chroot */
#define	NO_SEEK		0x4	/* seek */
#define NO_CHSIZE	0x8000	/* XENIX chsize */

struct argnotify {
	long 	cmd;	/* command - see above */
	long	data1;	/* Allow caller to pass two pieces of data. */
	long 	data2;	/* These should be caste appropriately in */
			/* the fs_notify routine. They are declared */
			/* as longs here. However, they should be */
			/* large enough to hold the largest machine */
			/* specific data types (e.g., if a pointer is */
			/* larger than a long then these should be */
			/* int *). */
};
 070701000059b7000081240000000200000002000000012719347c000009a6000000230000000c00000000000000000000001c00000000usr/include/sys/netconfig.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef	_SYS_NETCONFIG_H
#define	_SYS_NETCONFIG_H

#ident	"@(#)/usr/include/sys/netconfig.h.sl 1.1 4.0 10/15/90 20283 AT&T-SF"
#define NETCONFIG "/etc/netconfig"
#define NETPATH   "NETPATH"

struct  netconfig {
	char 	       *nc_netid;	/* network identifier         */
	unsigned long   nc_semantics;	/* defined below              */
	unsigned long   nc_flag;	/* defined below              */
	char   	       *nc_protofmly;	/* protocol family name	      */
	char   	       *nc_proto;	/* protocol name	      */
	char           *nc_device;	/* device name for network id */
	unsigned long   nc_nlookups;	/* # of entries in nc_lookups */
	char          **nc_lookups;	/* list of lookup directories */
	unsigned long   nc_unused[8];
};

typedef struct {
	struct netconfig **nc_head;
	struct netconfig **nc_curr;
} NCONF_HANDLE;

/*
 *	Values of nc_semantics
 */

#define NC_TPI_CLTS	1
#define NC_TPI_COTS	2
#define NC_TPI_COTS_ORD	3
#define NC_TPI_RAW	4

/*
 *	Values of nc_flag
 */

#define NC_NOFLAG	00
#define NC_VISIBLE	01
#define NC_BROADCAST	02

/*
 *	Values of nc_protofmly
 */

#define NC_NOPROTOFMLY	"-"
#define NC_LOOPBACK	"loopback"
#define NC_INET		"inet"
#define NC_IMPLINK	"implink"
#define NC_PUP		"pup"
#define NC_CHAOS	"chaos"
#define NC_NS		"ns"
#define NC_NBS		"nbs"
#define NC_ECMA		"ecma"
#define NC_DATAKIT	"datakit"
#define NC_CCITT	"ccitt"
#define NC_SNA		"sna"
#define NC_DECNET	"decnet"
#define NC_DLI		"dli"
#define NC_LAT		"lat"
#define NC_HYLINK	"hylink"
#define NC_APPLETALK	"appletalk"
#define NC_NIT		"nit"
#define NC_IEEE802	"ieee802"
#define NC_OSI		"osi"
#define NC_X25		"x25"
#define NC_OSINET	"osinet"
#define NC_GOSIP	"gosip"

/*
 *	Values for nc_proto
 */

#define NC_NOPROTO	"-"
#define NC_TCP		"tcp"
#define NC_UDP		"udp"
#define NC_ICMP		"icmp"

#if defined(__STDC__)

extern void 		 *setnetconfig(void);
extern int   		  endnetconfig(void *);
extern struct netconfig  *getnetconfig(void *);
extern struct netconfig  *getnetconfigent(char *);
extern void  		  freenetconfigent(struct netconfig *);
extern void 		 *setnetpath(void);
extern int   		  endnetpath(void *);
extern struct netconfig  *getnetpath(void *);

#endif	/* __STDC__ */

#endif /* _SYS_NETCONFIG_H */
  070701000059b8000081240000000200000002000000012719347c0000055a000000230000000c00000000000000000000001c00000000usr/include/sys/netcspace.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/netcspace.h.sl 1.1 4.0 10/15/90 37301 AT&T-SF"
/* TEMPORARY - added for kernel rpc */

struct nc_data {
	char         *string;
	unsigned long value;
};

static struct nc_data nc_semantics[] = {
	"tpi_clts",	NC_TPI_CLTS,
	"tpi_cots",	NC_TPI_COTS,
	"tpi_cots_ord",	NC_TPI_COTS_ORD,
	"npi_raw",	NC_NPI_RAW,
	NULL,		(unsigned)-1L
};

static struct nc_data nc_flag[] = {
	"-",		NC_NOFLAG,
	"v",		NC_VISIBLE,
	NULL,		(unsigned)-1L
};

static struct nc_data nc_protofmly[] = {
	"-",		NC_NOPROTOFMLY,
	"loopback",	NC_LOOPBACK,
	"inet",		NC_INET,
	"implink",	NC_IMPLINK,
	"pup",		NC_PUP,
	"chaos",	NC_CHAOS,
	"ns",		NC_NS,
	"nbs",		NC_NBS,
	"ecma",		NC_ECMA,
	"datakit",	NC_DATAKIT,
	"ccitt",	NC_CCITT,
	"sna",		NC_SNA,
	"decnet",	NC_DECNET,
	"dli",		NC_DLI,
	"lat",		NC_LAT,
	"hylink",	NC_HYLINK,
	"appletalk",	NC_APPLETALK,
	"nit",		NC_NIT,
	"ieee802",	NC_IEEE802,
	"osi",		NC_OSI,
	"x25",		NC_X25,
	"osinet",	NC_OSINET,
	"gosip",	NC_GOSIP,
	NULL,		(unsigned)-1L
};

static struct nc_data nc_proto[] = {
	"-",		NC_NOPROTO,
	"tcp",		NC_TCP,
	"udp",		NC_UDP,
	NULL,		(unsigned)-1L
};
  070701000059b9000081240000000200000002000000012719347c0000083e000000230000000c00000000000000000000001900000000usr/include/sys/nserve.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_NSERVE_H
#define _SYS_NSERVE_H

#ident	"@(#)/usr/include/sys/nserve.h.sl 1.1 4.0 10/15/90 12276 AT&T-SF"
/*
 * Contains definitions needed both in the kernel and in user programs 
 * for RFS adv, mount, and name service functions
 */
#define TPNSPID	  "/etc/rfs/%s/nspid" /* TP lock file for ns, also has pid */
#define	TPNS_PIPE "/etc/rfs/%s/nspip" /* transport-specific ns pipe */
#define TPNETMASTER "/etc/rfs/%s/rfmaster"	/* TP master file for nudnix network */
#define TPDOMMASTER "/etc/rfs/%s/dom.master"	/* TP file for outside domains  */
#define	TPNSERVE  "/usr/lib/rfs/TPnserve"	/* TP name serve executable */

#define A_RDWR		0	/* read/write flag */
#define A_RDONLY	1	/* read only flag */
#define A_CLIST		2	/* client list flag */
#define A_MODIFY	4	/* modify (really replace) clist flag */
#define A_INUSE		8	/* advertise table entry in use */
#define A_FREE		0	/* advertise table entry free */
#define A_MINTER	16	/* unadv -- but not free yet */
#define SEPARATOR	'.'
#define MAXDNAME	64
#define RFS_NMSZ	15

#define R_NOERR	0	/* no error */
#define R_FORMAT 1	/* format error */
#define R_NSFAIL 2	/* name server failure */
#define R_NONAME 3	/* name does not exist */
#define R_IMP	 4	/* request type not implemented or bad */
#define R_PERM	 5	/* no permission for this operation */
#define R_DUP	 6	/* name not unique (for advertise) */
#define R_SYS	 7	/* a system call failed in name server */
#define R_EPASS  8	/* error accessing primary passwd file */
#define R_INVPW  9   	/* invalid password */
#define R_NOPW   10	/* no passwd in primary passwd file */
#define R_SETUP  11	/* error in ns_setup() */
#define R_SEND   12	/* error in ns_send() */
#define R_RCV    13	/* error in ns_rcv() */
#define R_INREC	 14	/* in recovery, try again */
#define R_FAIL	 15	/* unknown failure */

#endif	/* _SYS_NSERVE_H */
  070701000059ba000081240000000200000002000000012719347c00000a38000000230000000c00000000000000000000001700000000usr/include/sys/nsxt.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_NSXT_H
#define _SYS_NSXT_H

#ident	"@(#)/usr/include/sys/nsxt.h.sl 1.1 4.0 10/15/90 382 AT&T-SF"

/*	nsxt.h: STREAMS SXT driver header */

/*
 **	Multiplexed channels driver header
 */

#define	SXTRACE		0		/* 1 to include tracing */

#define	MAXLINKS	32
#define	CHAN(dev)	(dev&CHANMASK)
#define	LINK(dev)	((dev>>CHANBITS)&(0xff>>CHANBITS))

#if	(MAXPCHAN*MAXLINKS) > 256
	ERROR -- product cannot be greater than minor(dev)
#endif

/*
 * Flags for virtual TTY channels
 */
#define	SXTCTL	1
#define SXTBLK	2
#define SXT_IOCTL 4

/*
 * Flags for control channel
 */
#define WAITSW  2	/* M_CTL (+ others, maybe) queued waiting for ACK/NAK */
#define SXTIOCWAIT 4	/* waiting for ACK/NAK on active virtual TTY */

struct Channel
{
	struct strtty	tty;		/* Virtual tty for this channel */
};

typedef struct Channel *Ch_p;

struct Link
{
	struct strtty  *line;		/* Real tty for this link */
	char		controllingtty;	/* the current top dog */
	char		old;		/* Old line discipline for line */
	char		nchans;		/* Number of channels allowed */
	unsigned char	chanmask;	/* Allowable channel bits */
	char		open;		/* Channel open bits */
	char		xopen;		/* Exclusive open bits */
	char		wpending;	/* pending writes/channel */
	char		iblocked;	/* channels blocked for input */
	char		oblocked;	/* channels blocked for output*/
	char		lwchan;		/* Last channel written bit */
	char		wrcnt;		/* Number of writes on last channel written */
	dev_t		dev;		/* major and minor device # */
	struct Channel	chans[1];	/* Array of channels for this link */
};

typedef	struct Link *	Link_p;

/*
**	Ioctl args
*/

#define	SXTIOCLINK	('b'<<8)
#define	SXTIOCTRACE	(SXTIOCLINK|1)
#define	SXTIOCNOTRACE	(SXTIOCLINK|2)
#define SXTIOCSWTCH	(SXTIOCLINK|3)
#define	SXTIOCWF	(SXTIOCLINK|4)
#define SXTIOCBLK	(SXTIOCLINK|5)
#define SXTIOCUBLK	(SXTIOCLINK|6)
#define SXTIOCSTAT	(SXTIOCLINK|7)


/* the following structure is used for the SXTIOCSTAT ioctl call */
struct sxtblock
{
	char	input;		/* channels blocked on input  */
	char	output;		/* channels blocked on output */
};



#define	t_link		t_dstat		/* Use dstat in real tty for linknumber */

#define	MAXPCHAN	8			/* Maximum channel number */
#define	CHANBITS	3			/* Bits for channel number */
#define	CHANMASK	07			/* 2**CHANBITS - 1 */
#define	SXTHOG		2			/* Channel consecutive write limit */

#endif	/* _SYS_NSXT_H */
070701000059bb000081240000000200000002000000012719347c00001cb4000000230000000c00000000000000000000001600000000usr/include/sys/nxt.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_NXT_H
#define _SYS_NXT_H

#ident	"@(#)/usr/include/sys/nxt.h.sl 1.1 4.0 10/15/90 25673 AT&T-SF"

/*
 * nxt.h -- Defines for the windowing terminal streams xt driver. See xt(7).
 */

#define	NPCBUFS	2			/* number of saved packets in proto*/
#define	SEQMOD	8			/* sequence number modulus */
#define	SEQBITS	3			/* bits for sequence number */
#define	MAXPCHAN	8		/* number of chans per xt */
#define	CHANBITS	3		/* number of bits for channel number */
#define	LINK(dev)	((dev >> CHANBITS) & (0xff >> CHANBITS))
#define	SEQMOD		8		/* Seq num modulus */

#define	XTSCANRATE	(2*HZ)		/* call xtscan @ 2 seconds */
#define XTSCANSLOP	(HZ + (HZ/2)) 	/* Increment to exact calculated
					   retransmission timeout
					   to allow for turnaround, the
					   terminal being slow, etc. */

#define	SET_CNTL(x)	(x)|=0100
#define	CHANMASK	07
#define	CHAN(dev)	(dev&CHANMASK)
#define	SEQMASK		07		/* 2**SEQBITS - 1 */

/* define to get packet type  (control or not) */
#define	GET_CNTL(x)	(((x) >> 6) &1)
#define	GET_PTYP(x)	(((x) >> 7) &1)
#define	GET_SEQ(x)	((x) & 7)
#define	GET_CHAN(x)	(((x) >> 3) & 7)


/* These are no longer used by nxt.c since they are always
** enabled. The defines are retained, however, for other commands
** like xtt.
*/
#define XTRACE		1	/* 1 to enable tracing */
#define XTSTATS		1	/* 1 to enable statistics */

typedef long Stats_t;

#define PKTPTSZ 11		/* Pkt part captured for trace */
#define PKTHIST 40		/* Size of trace history */

struct Tpkt
{
	unsigned char	pktpart[PKTPTSZ];	/* record of captured pkts */
	unsigned char	flag;			/* packet direction */
	clock_t		time;			/* log time (ticks) */
};

struct Tbuf
{
	struct Tpkt	log[PKTHIST];	/* history of transactions */
	short		flags;		/* assorted status flags */
	char 		index;		/* next slot */
	char		used;		/* # of slots used */
};


#define S_XPKTS		0
#define S_RPKTS		1
#define	S_CRCERR	2
#define	S_BADACK	3
#define	S_BADNAK	4
#define	S_OUTSEQ	5
#define	S_NAKRETRYS	6
#define	S_RDUP		7
#define	S_RNAK		8
#define	S_XNAK		9
#define	S_RACK		10
#define	S_XACK		11
#define	S_BADHDR	12
#define	S_BADSIZE	13
#define	S_LOSTACK	14
#define	S_BADCNTL	15
#define	S_BADCDATA	16
#define	S_NOMBLK	17
#define	S_BADCOUNT	18
#define	S_BADCHAN	19
#define	S_BADCTYPE	20
#define	S_NORBUF	21
#define	S_RTIMO		22
#define	S_XTIMO		23
#define	S_WIOW		24 /* not used in STREAMS XT driver */
#define	S_WOAS		25 /* not used in STREAMS XT driver */
#define	S_NSTATS	26	/* 'count' macro used only for size below */
				/* make sure this one remains last in the list */

#define STATS(A,B)	(A)->stats[B]++	/* A is a channel pointer, B an offset */


/*
 *	XT Driver Control Structures
 *
 *	One "xtctl" structure is allocated for each instantiation
 *	of the XT driver.
 *
 *	One "xtchan" structure is allocated for each window on
 *	the user's terminal.
 *
 */
struct xt_msg {
	mblk_t *mp;			/* ptr to message */
	clock_t timestamp;		/* stamp for ACK/NAK timeout */
	unsigned char seq;		/* sequence number */
	unsigned char xt_saveoutpkts;	/* outpkts when packet was sent */
};


struct xt_chan {
	queue_t *xt_upq;		/* upstream read queue */
	struct xtctl *xt_ctlp;		/* ptr to ctl struct */
	struct jwinsize xt_jwinsize;	/* Layer parms for JWINSIZE ioctl */
	short xt_chflg;			/* flags */
#ifdef SVR32
	t_pid_t xt_pgrp;		/* proc grp of first opening proc*/
#endif /* SVR32 */
#ifdef SVR40
	pid_t xt_pgrp;			/* proc grp of first opening proc*/
#endif /* SVR40 */
	short xt_channo;		/* channel number for easy ref*/
	short xt_outbufs;		/* slots for outpackets */
	struct xt_msg xt_msg[2];	/* outpacket awaiting ACK */
	unsigned char xt_inseq;		/* expected inpacket sequence num */
	unsigned short xt_bytesent;	/* for flow control in network xt */
#ifdef VPIX
	v86_t *xt_v86p;
	pid_t *xt_v86pid;
	struct proc *xt_v86procp;
#endif /* VPIX */
};

/* flags for channels */
#define	XT_CTL		0x1		/* control channel */
#define	XT_ON		0x2		/* channel has been opened */
#define	XT_WCLOSE	0x4		/* channel being closed */
#define XT_IOCTL	0x8		/* channel processing ioctl */
#define XT_NONETFLOW	0x10		/* network xt flow control disabled */
#define XT_M_STOPPED	0x20		/* channel stopped by user ^S */
#define XT_HOLDFLOW	0x40		/* temp disable net flow - see recvpkt() */
#define XT_WAIT4COPYIN	0x80		/* M_COPYIN for ioctl is pending */

struct xtioctl {
	int xti_seg;			/* which segment of ioctl to process */
	mblk_t *xti_bp;			/* state information for ioctl */
};


struct xtctl {
	struct queue *xt_ttyq;			/* downstream write queue */
	struct xt_chan xt_chan[MAXPCHAN];	/* channels per active tty */
	unsigned char xt_next;			/* sched this chan next */
	unsigned char xt_lastscan;		/* chan which got canput failure */
	short xt_ctlflg;			/* control flags */
	mblk_t *xt_inbp;			/* block for incoming packet */
	mblk_t *xt_pendjagent;			/* pending JAGENT ioctl pkt */
	unsigned short xt_insize;		/* number data bytes expected */
	unsigned short xt_incount;		/* number data bytes left */
	clock_t xt_intime;			/* timestamp for input timeout */
	short xt_instate;			/* state of incoming packet */
	unsigned char xt_inchan;		/* chan number of incoming packet */
	unsigned char xt_maxpkt;		/* max packet data size to terminal -
						   equals 1 for network xt */
	unsigned long xt_ttycflag;		/* dummy c_cflag (termio struct) */
	unsigned char xt_hex;			/* 1 if 6-bit path, 0 if 8-bit	*/
	unsigned char xt_firstchar;		/* first char in pkt on input */
	unsigned char xt_inpktcmd;		/* input packet command byte */
	unsigned char xt_outpkts;		/* total outstanding pkts waiting
						   for an ACK */
	short xt_recvtimo;			/* receive timeout in HZ for
						   current baud rate */
	short xt_HZperpkt;			/* time in HZ to transfer 1
						   outgoing pkt at current baud
						   rate */
	struct Tbuf trace;			/* trace strings stored here */
	Stats_t stats[S_NSTATS];		/* usage statistics */
};

/* xt_ctlflg flags for control struct */
#define	XT_INUSE	0x1	/* xt dev is in use */
#define XT_NETACK	0x2	/* processing incoming network xt ack packet */
#define XT_WANTTIMEOUT	0x4	/* nxtscan() found a chan that needs timeout */
#define XT_EXIT		0x8	/* C_EXIT in progress*/
#define XT_UNLINK	0x10	/* UNLINK in progress*/


/* The following are used for XT tracing. */


#define XMITLOG		0	/* Transmitted packet */
#define RECVLOG		1	/* Received packet */
#define TRACE_BADPKT	0x2	/* Bad packet flag */
#define TRACE_CMDBYTE	0x4	/* Packet has a command byte */

#define TRACEON		0x1	/* tracing enabled */
#define TRACELOCK	0x2	/* tracing locked */
#define TRACE_NETXT	0x4	/* tracing network xt protocol */

static void logpkt();

#define ISTRACEON(CTLP) (((CTLP)->trace.flags&(TRACEON|TRACELOCK))==TRACEON)


/*
 * ioctls for the XT driver
 *
 * Numbers 1, 5 and 6 have been used in old versions of the XT
 * driver and should not be re-used.
 *
 */
#define XTIOCTYPE ('b'<<8)
#define XTIOCSTATS (XTIOCTYPE|2)	/* Get xts statistics */
#define XTIOCTRACE (XTIOCTYPE|3)	/* Enable/Get xtt statistics */
#define XTIOCNOTRACE (XTIOCTYPE|4)	/* Disable xtt tracing */
#define XTIOCHEX (XTIOCTYPE|7)		/* Set LAN encoding */


#endif	/* _SYS_NXT_H */
070701000059bc000081240000000200000002000000012719347c000009bf000000230000000c00000000000000000000001b00000000usr/include/sys/nxtproto.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_NXTPROTO_H
#define _SYS_NXTPROTO_H

#ident	"@(#)/usr/include/sys/nxtproto.h.sl 1.1 4.0 10/15/90 39250 AT&T-SF"

/*
 * nxtproto.h -- xt packet protocol definitions.
 *
 * For additional information on xt packet structure, see the big comment
 * at the beginning of xt.c.
 */

typedef	unsigned char	Pbyte;			/* The unit of communication */

#define	NPCBUFS		2			/* Double buffered protocol */
#define	MAXPCHAN	8			/* Maximum channel number */
#define	CHANBITS	3			/* Bits for channel number */
#define	CHANMASK	07			/* 2**CHANBITS - 1 */
#define PKTHEADSIZE	(2 * sizeof(Pbyte))	/* Header size */
#define NETHEADSIZE	(3 * sizeof(Pbyte))	/* Header size for network xt */
#define	MAXPKTDSIZE	(32 * sizeof(Pbyte))	/* Maximum data part size 
						   for incoming packets. */
#define MAXOUTDSIZE	(252 * sizeof(Pbyte))	/* Maximum data part size
						   for outgoing packets. */
#define	EDSIZE		(2 * sizeof(Pbyte))	/* Error detection part size */
#define	SEQMOD		8			/* Sequence number modulus */
#define	SEQBITS		3			/* Bits for sequence number */
#define	SEQMASK		07			/* 2**SEQBITS - 1 */

/*
 * Control codes.
 */

#define	PCDATA		(Pbyte)002		/* Data only control packet */
#define	ACK		(Pbyte)006		/* Last packet with same sequence ok and in sequence */
#define	NAK		(Pbyte)025		/* Last packet with same sequence received out of sequence */

/*
 * Receive packet states.
 */

#define PR_NOINPUT	0x80		/* additional input not needed */

#define	PR_NULL		(1)		/* New packet expected */
#define	PR_GETBUF	(2|PR_NOINPUT)	/* About to get buffer */
#define	PR_SIZE		(3)		/* Size byte next */
#define	PR_DATA		(4)		/* Receiving data */
#define	PR_SENDUP	(5|PR_NOINPUT)	/* Send valid packet upstream */

#define	PR_NETNULL	(6|PR_NOINPUT)	/* Same states for network xt */
#define	PR_NETSIZE1	(7)
#define	PR_NETSIZE2	(8)		/* Two size bytes for network xt */
#define	PR_NETGETBUF	(9|PR_NOINPUT)
#define	PR_NETGETCMD	(10)		/* Get the command byte next */
#define	PR_NETDATA	(11)		/* Get the rest of the data */
#define PR_NETLOGPKT	(12|PR_NOINPUT)	/* About to log the packet */
#define	PR_NETSENDUP	(13|PR_NOINPUT)	/* Send buffer upstream */
#define	PR_NETERROR	(14)		/* Got an error in network xt */

#endif	/* _SYS_NXTPROTO_H */
 070701000059bd000081240000000200000002000000012719347c00000812000000230000000c00000000000000000000001700000000usr/include/sys/open.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_OPEN_H
#define _SYS_OPEN_H

#ident	"@(#)/usr/include/sys/open.h.sl 1.1 4.0 10/15/90 38543 AT&T-SF"
/* Some drivers need to be able to keep accurate records of open/close
 * calls to determine whether a device is still in use.  To allow this
 * open/close calls have been typed and the type is passed as a third
 * argument in open/close calls, as in:
 *	(*cdevsw[getmajor(dev)].d_open)(getminor(dev), flag, OTYP_CHR);
 * or
 *	(*cdevsw[getmajor(dev)].d_close)(getminor(dev), flag, OTYP_CHR);
 * Five types of open/close calls have been defined:
 * OTYP_BLK:	open/close of a block special file
 * OTYP_MNT:	open/close for mounting/unmounting a file system
 * OTYP_CHR:	open/close of a character special file
 * OTYP_SWP:	open/close of a swapping device.
 * OTYP_LYR:	open/close calls from a driver to another driver,
 *		without a file being open for the dev of the lower driver.
 *
 * The first four types of open/close calls obey the protocol rule
 * that many more opens may occur for a given minor(dev) for that type of open,
 * but a close call happens only on the last close of that dev.
 * This protocol allows a flag to be used (set by opens, cleared by closes)
 * to keep track of the state for a given minor device value.
 *
 * Calls of the fifth type (OTYP_LYR) must obey the protocol rule
 * that open and close call calls are always paired.  This protocol
 * permits several drivers to be layers above the same device driver.
 * A counter can be used for this protocol.
 *
 * The value OTYPCNT is defined for the purpose of declaring arrays
 * in drivers and for performing range checks (0 <= otyp < OTYPCNT)
 * on values passed.
 */

#define OTYPCNT		5
#define OTYP_BLK	0
#define OTYP_MNT	1
#define OTYP_CHR	2
#define OTYP_SWP	3
#define OTYP_LYR	4

#endif	/* _SYS_OPEN_H */
  070701000059be000081240000000200000002000000012719347c00000151000000230000000c00000000000000000000001700000000usr/include/sys/page.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/page.h.sl 1.1 4.0 10/15/90 24287 AT&T-SF"
   070701000059bf000081240000000200000002000000012719347c00001bb1000000230000000c00000000000000000000001800000000usr/include/sys/param.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PARAM_H
#define _SYS_PARAM_H

#ident	"@(#)/usr/include/sys/param.h.sl 1.1 4.0 10/15/90 59295 AT&T-SF"

#include <sys/types.h>
#include <sys/fs/s5param.h>
/*
 * Fundamental variables; don't change too often.
 */
#ifndef _POSIX_VDISABLE
#define _POSIX_VDISABLE 0 /* Disable special character functions */
#endif

#ifndef MAX_INPUT
#define MAX_INPUT 512     /* Maximum bytes stored in the input queue */
#endif

#ifndef MAX_CANON
#define MAX_CANON 256     /* Maximum bytes in a line for canoical processing */
#endif

#define UID_NOBODY  60001   /* user ID no body */
#define GID_NOBODY  UID_NOBODY

#define UID_NOACCESS    60002   /* user ID no access */


#define	MAXPID	30000		/* max process id */
#define	MAXUID	60002		/* max user id */
#define	MAXLINK	1000		/* max links */

#define	SSIZE	1		/* initial stack size (*4096 bytes) */
#define	SINCR	1		/* increment of stack (*4096 bytes) */
#define	USIZE	MINUSIZE	/* inital size of user block (*4096) */
#define	MINUSIZE  2		/* min size of user block (*4096 bytes) */
#define	MAXUSIZE 18		/* max size of user block (*4096 bytes) */

#define	CANBSIZ	256		/* max size of typewriter line	*/
#define	HZ	100		/* 100 ticks/second of the clock */
#define TICK    10000000	/* nanoseconds per tick */


#define NOFILE	20		/* this define is here for	*/
				/* compatibility purposes only	*/
				/* and will be removed in a	*/
				/* later release		*/

/*
 * The following macros are no longer supported in SVR 4.0
 * since there is no longer a limit on the number of files that
 * a process can open. However, for SVR3.2 source compatibility, 
 * you may uncomment  NOFILES_MIN and NOFILES_MAX.
 */

/* #define	NOFILES_MIN	 20	SVR3.2 Source Compatibility */
/* #define	NOFILES_MAX	100	SVR3.2 Source Compatibility */

/*
 * These define the maximum and minimum allowable values of the
 * configurable parameter NGROUPS_MAX.
 */
#define	NGROUPS_UMAX	32
#define	NGROUPS_UMIN	0

/*
 * The following defines apply to the kernel virtual address space.
 */

/*
 * The size of the kernel segment table in pages.  The starting address
 * comes from the vuifile.
 */
#define MAXKSEG		127	/*max no of pages per kseg */

/*
 * To avoid prefetch errors at the end of a region, it must
 * be padded with the following number of bytes.
 */

#define	PREFETCH	0

/*
 * Priorities.  Should not be altered too much.
 */

#define	PMASK	0177
#define	PCATCH	0400
#define	PNOSTOP	01000
#define	PSWP	0
#define	PINOD	10
#define PSNDD	PINOD
#define	PRIBIO	20
#define	PZERO	25
#define PMEM	0
#define	NZERO	20
#define	PPIPE	26
#define PVFS	27
#define	PWAIT	30
#define	PSLEP	39
#define	PUSER	60
#define	PIDLE	127

/*
 * Fundamental constants of the implementation--cannot be changed easily.
 */

#define	NBPW	sizeof(int)	/* number of bytes in an integer */
#define	NCPPT	1024		/* Number of clicks per page table */
#define	CPPTSHIFT	10	/* LOG2(NCPPT) if exact */
#define	NBPC	4096		/* Number of bytes per click */
#define	BPCSHIFT	12	/* LOG2(NBPC) if exact */
#define	NULL	0
#define	CMASK	0		/* default mask for file creation */
#define	CDLIMIT	(1L<<14)	/* default max write address */
#define NBPSCTR         512     /* Bytes per LOGICAL disk sector. */
#define	UBSIZE		512	/* unix block size.		*/
#define SCTRSHFT	9	/* Shift for BPSECT.		*/

#define	UMODE	3		/* current Xlevel == user */
#define	USERMODE(cs)	(((cs) & SEL_RPL) == UMODE)

#define	lobyte(X)	(((unsigned char *)&(X))[0])
#define	hibyte(X)	(((unsigned char *)&(X))[1])
#define	loword(X)	(((ushort *)&(X))[0])
#define	hiword(X)	(((ushort *)&(X))[1])

#define	MAXSUSE	255

/* REMOTE -- whether machine is primary, secondary, or regular */
#define SYSNAME 9		/* # chars in system name */
#define PREMOTE 39

/* XENIX compatibility */
#define	ktop(vaddr)	((paddr_t)svirtophys(vaddr))

/*
 * MAXPATHLEN defines the longest permissible path length,
 * including the terminating null, after expanding symbolic links.
 * MAXSYMLINKS defines the maximum number of symbolic links
 * that may be expanded in a path name. It should be set high
 * enough to allow all legitimate uses, but halt infinite loops
 * reasonably quickly.
 * MAXNAMELEN is the length (including the terminating null) of
 * the longest permissible file (component) name.
 */
#define	MAXPATHLEN	1024
#define	MAXSYMLINKS	20
#define	MAXNAMELEN	256

#ifndef NADDR
#define NADDR 13
#endif

/*
 * The following are defined to be the same as
 * defined in /usr/include/limits.h.  They are
 * needed for pipe and FIFO compatibility.
 */
#ifndef PIPE_BUF	/* max # bytes atomic in write to a pipe */
#ifdef u3b15
#define PIPE_BUF	4096
#else
#define PIPE_BUF	5120
#endif	/* u3b15 */
#endif	/* PIPE_BUF */

#ifndef PIPE_MAX	/* max # bytes written to a pipe in a write */
#ifdef u3b15
#define PIPE_MAX	4096
#else
#define PIPE_MAX	5120
#endif	/* u3b15 */
#endif	/* PIPE_MAX */

#define NBBY	8			/* number of bits per byte */

/*
 * File system parameters and macros.
 *
 * The file system is made out of blocks of at most MAXBSIZE units,
 * with smaller units (fragments) only in the last direct block.
 * MAXBSIZE primarily determines the size of buffers in the buffer
 * pool. It may be made larger without any effect on existing
 * file systems; however making it smaller make make some file
 * systems unmountable.
 *
 * Note that the blocked devices are assumed to have DEV_BSIZE
 * "sectors" and that fragments must be some multiple of this size.
 */
#define	MAXBSIZE	8192
#define	DEV_BSIZE	512
#define	DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
#define	MAXFRAG 	8

#define	btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
	((unsigned)(bytes) >> DEV_BSHIFT)
#define	dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
	((unsigned)(db) << DEV_BSHIFT)

/*
 * MMU_PAGES* describes the physical page size used by the mapping hardware.
 * PAGES* describes the logical page size used by the system.
 */

#define	MMU_PAGESIZE	0x1000		/* 4096 bytes */
#define	MMU_PAGESHIFT	12		/* log2(MMU_PAGESIZE) */
#define	MMU_PAGEOFFSET	(MMU_PAGESIZE-1)/* Mask of address bits in page */
#define	MMU_PAGEMASK	(~MMU_PAGEOFFSET)

#define	PAGESIZE	0x1000		/* All of the above, for logical */
#define	PAGESHIFT	12
#define	PAGEOFFSET	(PAGESIZE - 1)
#define	PAGEMASK	(~PAGEOFFSET)

#ifndef NODEV
#define NODEV	(dev_t)(-1)
#endif

/*
 * Some random macros for units conversion.
 */

/*
 * MMU pages to bytes, and back (with and without rounding)
 */
#define	mmu_ptob(x)	((x) << MMU_PAGESHIFT)
#define	mmu_btop(x)	(((unsigned)(x)) >> MMU_PAGESHIFT)
#define	mmu_btopr(x)	((((unsigned)(x) + MMU_PAGEOFFSET) >> MMU_PAGESHIFT))

/*
 * pages to bytes, and back (with and without rounding)
 */
#define	ptob(x)		((x) << PAGESHIFT)
#define	btop(x)		(((unsigned)(x)) >> PAGESHIFT)
#define	btopr(x)	((((unsigned)(x) + PAGEOFFSET) >> PAGESHIFT))

#define shm_alignment	ctob(1)		/* segment size */


#endif	/* _SYS_PARAM_H */
   070701000059c0000081240000000200000002000000012719347c00000925000000230000000c00000000000000000000001b00000000usr/include/sys/pathname.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PATHNAME_H
#define _SYS_PATHNAME_H

#ident	"@(#)/usr/include/sys/pathname.h.sl 1.1 4.0 10/15/90 57273 AT&T-SF"
/*
 * Pathname structure.
 * System calls that operate on path names gather the path name
 * from the system call into this structure and reduce it by
 * peeling off translated components.  If a symbolic link is
 * encountered the new path name to be translated is also
 * assembled in this structure.
 *
 * By convention pn_buf is not changed once it's been set to point
 * to the underlying storage; routines which manipulate the pathname
 * do so by changing pn_path and pn_pathlen.  pn_pathlen is redundant
 * since the path name is null-terminated, but is provided to make
 * some computations faster.
 */
typedef struct pathname {
	char	*pn_buf;		/* underlying storage */
	char	*pn_path;		/* remaining pathname */
	u_int	pn_pathlen;		/* remaining length */
} pathname_t;

#define PN_STRIP	0	/* Strip next component from pn */
#define PN_PEEK		1	/* Only peek at next component of pn */
#define pn_peekcomponent(pnp, comp) pn_getcomponent(pnp, comp, PN_PEEK)
#define pn_stripcomponent(pnp, comp) pn_getcomponent(pnp, comp, PN_STRIP)

#define	pn_peekchar(pnp)	((pnp)->pn_pathlen > 0 ? *((pnp)->pn_path) : 0)
#define pn_pathleft(pnp)	((pnp)->pn_pathlen)

extern void	pn_alloc();		/* allocate buffer for pathname */
extern int	pn_get();		/* allocate buffer, copy path into it */
extern int	pn_set();		/* set pathname to string */
extern int	pn_insert();		/* combine two pathnames (symlink) */
extern int	pn_getsymlink();	/* get symlink into pathname */
extern int	pn_getcomponent();	/* get next component of pathname */
extern void	pn_setlast();		/* set pathname to last component */
extern void	pn_skipslash();		/* skip over slashes */
extern void	pn_fixslash();		/* eliminate trailing slashes */
extern void	pn_free();		/* free pathname buffer */

extern int	lookupname();		/* convert name to vnode */
extern int	lookuppn();		/* convert pathname buffer to vnode */
extern int	traverse();		/* traverse a mount point */

#endif	/* _SYS_PATHNAME_H */
   070701000059c1000081240000000200000002000000012719347c00000816000000230000000c00000000000000000000001800000000usr/include/sys/pfdat.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/pfdat.h.sl 1.1 4.0 10/15/90 30998 AT&T-SF"

typedef struct pfdat {
	unsigned	pf_blkno : 24,	/* Disk block nummber.	*/
			pf_flags : 8;	/* page flags		*/
	cnt_t		pf_ndref;	/* Need ref cnt for	*/
					/* shared pg stealing	*/
	dev_t		pf_dev;		/* Disk device code.	*/
	long		pf_inumber;	/* inode number of 	*/
					/* matching file	*/
	char		pf_swpi;	/* Index into swaptab.	*/
	char		pf_rawcnt;	/* Cnt of processes	*/
					/* doing raw I/O to 	*/
					/* page.		*/
	short		pf_waitcnt;	/* Number of processes	*/
					/* waiting for PG_DONE	*/
	struct pfdat	*pf_next;	/* Next free pfdat.	*/
	struct pfdat	*pf_prev;	/* Previous free pfdat.	*/
	struct pfdat	*pf_hchain;	/* Hash chain link.	*/
	ulong		pf_use;		/* dbd share use count	*/
} pfd_t;

#define	P_QUEUE		0x01	/* Page on free queue		*/
#define	P_BAD		0x02	/* Bad page (parity error, etc.)*/
#define	P_HASH		0x04	/* Page on hash queue		*/
#define P_DONE		0x08	/* I/O to read page is done	*/
#define	P_SWAP		0x10	/* Page on swap (not file).	*/

extern struct pfdat phead;
extern struct pfdat pbad;
extern struct pfdat *pfdat;
extern struct pfdat **phash;
extern struct pfdat ptfree;
extern int phashmask;
extern struct pfdat	*pfind();


#define BLKNULL		0	/* pf_blkno null value		*/

extern int	mem_lock;
extern int	memlock();
extern int	memunlock();
extern int	memlocked();

/* DBD allocation defines */
#define DBDSIZE	128
#define DBDSZSHFT	7
#define NDBDPP		32
#define NDBDPPSHFT	5
#define NPGEPDBD	32	/* Number of page entries per DBD chunk */
#define PGEPDBDSHFT	5
#define pgetodbd(X)	(((X) + NPGEPDBD-1) >> PGEPDBDSHFT)
#define pgetodbdt(X)	((X) >> PGEPDBDSHFT)
#define dbdtopge(X)	((X) << PGEPDBDSHFT)
#define dbdtop(X)	(((X) + NDBDPP-1) >> NDBDPPSHFT)
#define dbdtob(X)	((X) << DBDSZSHFT)
extern struct pfdat dbdfree;
  070701000059c2000081240000000200000002000000012719347c00000ae6000000230000000c00000000000000000000001600000000usr/include/sys/pic.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PIC_H
#define _SYS_PIC_H

#ident	"@(#)/usr/include/sys/pic.h.sl 1.1 4.0 10/15/90 34241 AT&T-SF"

/* Definitions for 8259 Programmable Interrupt Controller */

#define PIC_NEEDICW4    0x01            /* ICW4 needed */
#define PIC_ICW1BASE    0x10            /* base for ICW1 */
#define PIC_86MODE      0x01            /* MCS 86 mode */
#define PIC_AUTOEOI     0x02            /* do auto eoi's */
#define PIC_SLAVEBUF    0x08            /* put slave in buffered mode */
#define PIC_MASTERBUF   0x0C            /* put master in bnuffered mode */
#define PIC_SPFMODE     0x10            /* special fully nested mode */
#define PIC_READISR     0x0B            /* Read the ISR */
#define PIC_NSEOI       0x20            /* Non-specific EOI command */

#define PIC_VECTBASE    0x40            /* Vectors for external interrupts */
					/* start at 64.                    */
/*
 * Interrupt configuration information specific to a particular computer.
 * These constants are used to initialize tables in modules/pic/space.c.
 * NOTE: The master pic must always be pic zero.
 */

#if defined (MB1) || defined (MB2)

#define NPIC    2                       /* 2 PICs */
/* Port addresses */
#define MCMD_PORT       0xC0            /* master command port */
#define MIMR_PORT       0xC2            /* master intr mask register port */
#define SCMD_PORT       0xC4            /* slave command port */
#define SIMR_PORT       0xC6            /* slave intr mask register port */
#define MASTERLINE      0x07            /* slave on IR7 of the master PIC */
#define SLAVEBASE       ((MASTERLINE+1)*8) /* slave IR0 interrupt number */
#define PICBUFFERED     1               /* PICs in buffered mode */
#define I82380          0               /* i82380 chip not used */

#endif /* MB1 || MB2 */


#ifdef AT386            /* AT386 board */

#define NPIC    2                       /* 2 PICs */
/* Port addresses */
#define MCMD_PORT       0x20            /* master command port */
#define MIMR_PORT       0x21            /* master intr mask register port */
#define SCMD_PORT       0xA0            /* slave command port */
#define SIMR_PORT       0xA1            /* slave intr mask register port */
#define MASTERLINE      0x02            /* slave on IR2 of master PIC */
#define SLAVEBASE       8               /* slave IR0 interrupt number */
#define PICBUFFERED     0               /* PICs not in buffered mode */
#define I82380          0               /* i82380 chip not used */

#endif /* AT386 */

#endif	/* _SYS_PIC_H */
  070701000059c3000081240000000200000002000000012719347c00000c2a000000230000000c00000000000000000000001600000000usr/include/sys/pit.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PIT_H
#define _SYS_PIT_H

#ident	"@(#)/usr/include/sys/pit.h.sl 1.1 4.0 10/15/90 36284 AT&T-SF"

/*
 *         INTEL CORPORATION PROPRIETARY INFORMATION
 *
 *     This software is supplied under the terms of a license 
 *    agreement or nondisclosure agreement with Intel Corpo-
 *    ration and may not be copied or disclosed except in
 *    accordance with the terms of that agreement.
 */

#if defined (MB1) || defined (MB2)
/* Definitions for 8254 Programmable Interrupt Timer ports on 386/20 */
#define	PITCTR0_PORT	0xD0		/* counter 0 port */	
#define	PITCTR1_PORT	0xD2		/* counter 1 port */	
#define	PITCTR2_PORT	0xD4		/* counter 2 port */	
#define	PITCTL_PORT	0xD6		/* PIT control port */
#endif

#ifdef AT386
/* Definitions for 8254 Programmable Interrupt Timer ports on AT 386 */
#define	PITCTR0_PORT	0x40		/* counter 0 port */	
#define	PITCTR1_PORT	0x41		/* counter 1 port */	
#define	PITCTR2_PORT	0x42		/* counter 2 port */	
#define	PITCTL_PORT	0x43		/* PIT control port */
#define	PITAUX_PORT	0x61		/* PIT auxiliary port */
#define SANITY_CTR0	0x48		/* sanity timer counter */
#define SANITY_CTL	0x4B		/* sanity control word */
#define SANITY_CHECK	0x461		/* bit 7 set if sanity timer went off*/
#define FAILSAFE_NMI	0x80		/* to test if sanity timer went off */
#define ENABLE_SANITY	0x04		/* Enables sanity clock NMI ints */
#define RESET_SANITY	0x00		/* resets sanity NMI interrupt */
#endif /* AT386 */

/* Definitions for 8254 commands */

/* Following are used for Timer 0 */
#define PIT_C0          0x00            /* select counter 0 */
#define	PIT_LOADMODE	0x30		/* load least significant byte followed
					 * by most significant byte */
#define PIT_NDIVMODE	0x04		/*divide by N counter */
#define	PIT_SQUAREMODE	0x06		/* square-wave mode */
#define	PIT_ENDSIGMODE	0x00		/* assert OUT at end-of-count mode*/

/* Used for Timer 1. Used for delay calculations in countdown mode */
#define PIT_C1          0x40            /* select counter 1 */
#define	PIT_READMODE	0x30		/* read or load least significant byte
					 * followed by most significant byte */
#define	PIT_RATEMODE	0x06		/* square-wave mode for USART */

#if defined(MB1)
#define CLKNUM 12300			/* clock speed for the timer in hz 
					 * divided by the constant HZ
					 * ( defined in param.h )
					 */
#endif /* MB1 */

#if defined(MB2)
#define CLKNUM 12500			/* clock speed for the timer in hz 
					 * divided by the constant HZ
					 * ( defined in param.h )
					 */
#endif /* MB2 */

#ifdef AT386
#define	CLKNUM	(1193167/HZ)		/* clock speed for timer */
#define SANITY_NUM	0xFFFF		/* Sanity timer goes off every .2 secs*/
/* bits used in auxiliary control port for timer 2 */
#define	PITAUX_GATE2	0x01		/* aux port, PIT gate 2 input */
#define	PITAUX_OUT2	0x02		/* aux port, PIT clock out 2 enable */
#endif /* AT386 */

#endif	/* _SYS_PIT_H */
  070701000059c4000081240000000200000002000000012719347c000009fd000000230000000c00000000000000000000001700000000usr/include/sys/poll.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_POLL_H
#define _SYS_POLL_H

#ident	"@(#)/usr/include/sys/poll.h.sl 1.1 4.0 10/15/90 55945 AT&T-SF"

/*
 * Structure of file descriptor/event pairs supplied in
 * the poll arrays.
 */
struct pollfd {
	int fd;				/* file desc to poll */
	short events;			/* events of interest on fd */
	short revents;			/* events that occurred on fd */
};

/*
 * Testable select events 
 */
#define POLLIN		0x0001		/* fd is readable */
#define POLLPRI		0x0002		/* high priority info at fd */
#define	POLLOUT		0x0004		/* fd is writeable (won't block) */
#define POLLRDNORM	0x0040		/* normal data is readable */
#define POLLWRNORM	POLLOUT
#define POLLRDBAND	0x0080		/* out-of-band data is readable */
#define POLLWRBAND	0x0100		/* out-of-band data is writeable */

#define POLLNORM	POLLRDNORM

/*
 * Non-testable poll events (may not be specified in events field,
 * but may be returned in revents field).
 */
#define POLLERR		0x0008		/* fd has error condition */
#define POLLHUP		0x0010		/* fd has been hung up on */
#define POLLNVAL	0x0020		/* invalid pollfd entry */

/*
 * Poll list head structure.  A pointer to this is passed
 * to pollwakeup() from the caller indicating the event has
 * occurred.  NOTE: First two pointers correspond to first
 * two elements in polldat structure.
 */
struct pollhead {
	struct polldat	*ph_list;	/* list of pollers */
	struct polldat	*ph_dummy;	/* dummy pointer */
	short		ph_events;	/* events pending on list */
	long		ph_filler[5];	/* reserved for future use */
};

/*
 * Data necessary to notify process sleeping in poll(2)
 * when an event has occurred.
 */
struct polldat {
	struct polldat *pd_next;	/* next in poll list */
	struct polldat *pd_prev;	/* previous in poll list */
	struct polldat *pd_chain;	/* other fds polled in same call */
	short		pd_events;	/* events being polled */
	struct pollhead *pd_headp;	/* backpointer to head of list */
	void		(*pd_fn)();	/* function to call */
	long		pd_arg;		/* argument to function */
};

/*
 * Routine called to notify a process of the occurrence
 * of an event.
 */
extern void pollwakeup();

/*
 * Internal routines.
 */
extern void polltime(), pollrun(), polladd(), polldel();

#if defined(__STDC__) && !defined(_KERNEL)
int poll(struct pollfd *, unsigned long, int);
#endif

#endif	/* _SYS_POLL_H */
   070701000059c5000081240000000200000002000000012719347c00000445000000230000000c00000000000000000000001900000000usr/include/sys/pp_dep.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PP_DEP_H
#define _SYS_PP_DEP_H

#ident	"@(#)/usr/include/sys/pp_dep.h.sl 1.1 4.0 10/15/90 18463 AT&T-SF"
/*
 * PORTS CIO Definitions
 *
 ***** WARNING ***** WARNING ***** WARNING ***** WARNING
 *	This header file is shared by both sw and fw
 ***** WARNING ***** WARNING ***** WARNING ***** WARNING
 */

typedef struct
{
	unsigned char	pc[4];	/* ports codes */
} RAPP, CAPP;

#define CQSIZE		35		/* size one completion queue  */
#define RQSIZE		18		/* size all requeust queues   */
#define NUM_QUEUES	6		/* (5 output) + (1 supply buf)*/

#define NUM_ELEMENTS	10		/* max size rqueues 0->4      */

#define CENTRONICS	4		/* printer rqueue	      */
#define PPPUMP		5		/* ports pump		      */
#define SUPPLYBUF	5		/* input(read) supply buffer  */

#define RAM_START	0
#define RAM_END		32768

#endif	/* _SYS_PP_DEP_H */
   070701000059c6000081240000000200000002000000012719347c000006d0000000230000000c00000000000000000000001b00000000usr/include/sys/priocntl.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PRIOCNTL_H
#define _SYS_PRIOCNTL_H

#ident	"@(#)/usr/include/sys/priocntl.h.sl 1.1 4.0 10/15/90 49147 AT&T-SF"

#define	PC_VERSION	1	/* First version of priocntl */

#define priocntl(idtype, id, cmd, arg)\
	__priocntl(PC_VERSION, idtype, id, cmd, arg)

#define priocntlset(psp, cmd, arg)\
	__priocntlset(PC_VERSION, psp, cmd, arg)

extern long	__priocntl(), __priocntlset();

/*
 * The following are the possible values of the command
 * argument for the priocntl system call.
 */

#define PC_GETCID	0	/* Get class ID */
#define	PC_GETCLINFO	1	/* Get info about a configured class */
#define	PC_SETPARMS	2	/* Set scheduling parameters */
#define	PC_GETPARMS	3	/* Get scheduling parameters */
#define PC_ADMIN	4	/* Scheduler administration (used by     */
				/*   dispadmin(1M), not for general use) */

#define PC_CLNULL	-1

#define	PC_CLNMSZ	16
#define	PC_CLINFOSZ	(32 / sizeof(long))
#define	PC_CLPARMSZ	(32 / sizeof(long))

typedef struct pcinfo {
	id_t	pc_cid;			/* class id */
	char	pc_clname[PC_CLNMSZ];	/* class name */
	long	pc_clinfo[PC_CLINFOSZ];	/* class information */
} pcinfo_t;

typedef struct pcparms {
	id_t	pc_cid;			    /* process class */
	long	pc_clparms[PC_CLPARMSZ];    /* class specific parameters */
} pcparms_t;

/*
 * The following is used by the dispadmin(1M) command for
 * scheduler administration and is not for general use.
 */

typedef struct pcadmin {
	id_t	pc_cid;
	caddr_t	pc_cladmin;
} pcadmin_t;

#endif	/* _SYS_PRIOCNTL_H */
070701000059c7000081240000000200000002000000012719347c00002f15000000230000000c00000000000000000000001700000000usr/include/sys/proc.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ifndef _SYS_PROC_H
#define _SYS_PROC_H

#ident	"@(#)/usr/include/sys/proc.h.sl 1.1 4.0 10/15/90 3663 AT&T-SF"

#include <sys/immu.h>
#include <sys/param.h>

/*
 * One structure allocated per active process.  It contains all
 * data needed about the process while the process may be swapped
 * out.  Other per-process data (user.h) may be swapped with the
 * process.
 */

typedef struct	proc {
	char	p_stat;			/* status of process */
	char	p_cpu;			/* cpu usage for scheduling */
	u_char	p_curflt;		/* current fault (/proc) */
	u_char	p_swlocks;		/* number of swap vnode locks held */
	u_int	p_flag;			/* flags defined below */
	o_uid_t	p_uid;			/* real user id */

	/* the following pid fields declared o_pid_t are for
	** binary compatibility only. They will be removed in
	** the next release following SVR4.0.
	*/

	o_pid_t	p_oppid;		/* process id of parent*/
	o_pid_t	p_opgrp;		/* name of process group leader */
	o_pid_t	p_opid;			/* unique process id*/
	struct	cred	*p_cred;	/* process credentials */
	struct sess	*p_sessp;	/* session information */
	int	p_pri;			/* scheduling priority */
	
	union {				/* wait addr for sleeping processes */
		caddr_t p_cad;		/* Union is for XENIX compatibility */
		int	p_int;
	} p_unw;
#define p_wchan p_unw.p_cad		/* Map MP name to old UNIX name */
#define p_arg	p_unw.p_int		/* Map MP name to old UNIX name */

	struct	proc	*p_link;	/* forward link */
	struct	proc	*p_parent;	/* ptr to parent process */
	struct	proc	*p_child;	/* ptr to first child process */
	struct	proc	*p_sibling;	/* ptr to next sibling proc on chain */
	int	p_clktim;		/* time to alarm clock signal */

	caddr_t	p_brkbase;		/* base address of heap */
	u_int	p_brksize;		/* heap size in bytes */
	caddr_t	p_stkbase;		/* base address of stack */
	u_int	p_stksize;		/* stack size in bytes */

	u_int	p_swrss;		/* resident set size before last swap */
	clock_t	p_utime;		/* user time, this process */
	clock_t	p_stime;		/* system time, this process */
					 
	ushort	p_usize;		/* size of u-block (*4096 bytes) */
	ushort	p_user_license;		/* per-user licensing */

	caddr_t	p_ldt;			/* address of ldt */

	/* for MERGE386    */
	struct	vm86	*p_vm86p;	/* info about Merge vm86 task */

	struct as *p_as;		/* process address space pointer */
	int 	p_wdata;		/* current wait return value */
	char	p_wcode;		/* current wait code */
	char	p_pollflag;		/* flags for use during poll(2) */
	u_char	p_cursig;		/* current signal */
	pid_t	p_epid;			/* effective pid; normally same as
					 * p_pid; for servers, the system that
					 * sent the msg
					 */
	sysid_t p_sysid;		/* normally same as sysid; for servers,
					 * the system that sent the msg
					 */
	struct	proc  *p_rlink;		/* linked list for server */
	int	p_srwchan;		/* RFS server awaiting work; sleep */
	struct	vnode *p_trace;		/* pointer to /proc vnode */
	k_sigset_t p_sig;		/* signals pending to this process */
	k_sigset_t p_sigmask;		/* tracing signal mask for /proc */
	k_sigset_t p_hold;		/* hold signal bit mask */
	k_sigset_t p_ignore;		/* ignore when generated */
	k_sigset_t p_siginfo;		/* gets signal info with signal */
	struct	v86dat *p_v86;		/* pointer to v86 structure */

	ushort	p_raiocnt;		/* # of outstanding raw disk AIOs */

	char	p_filler1[70];		/* unused */

	u_short	p_whystop;
	u_short	p_whatstop;

	pte_t	*p_ubptbl;		/* pointer to (floating) ublock page tbl */

	char	p_filler2[64];		/* unused */
	struct	proc	*p_semlink;

	k_fltset_t	p_fltmask;	/* mask of traced faults (/proc) */
	struct	evpd	*p_evpdp;	/* ptr to events per-process data */

	struct timer  *p_italarm[2];	/* Ptrs to the alarms for the clocks
					 * measuring user  process virtual
					 * time and user+system process
					 * virtual time.
					 */
	struct proc *p_pglink;		/* process group hash chain link */
	clock_t	p_cutime;		/* sum of children's user time */
	clock_t	p_cstime;		/* sum of children's system time */
 	short	p_aiocount;		/* # of async requests accepted */
 	short	p_aiowcnt;		/* # of async operations currently
 					 * in progress and the process is
 					 * waiting for their completion
					 */
 	id_t	p_cid;			/* scheduling class id */
 	_VOID	*p_clproc;		/* per process class specific data */
 	struct classfuncs *p_clfuncs;	/* ptr to structure containing
 					 * class specific function ptrs
					 */
	struct sigqueue *p_sigqueue;	/* queued siginfo structures */
	struct sigqueue *p_curinfo;	/* siginfo for current signal */
	caddr_t *p_segacct;		/* segment accounting info */
	struct seguser *p_segu;		/* u segment */
	struct	vnode *p_exec;		/* pointer to a.out vnode */
    pid_t   p_ppid;         /* process id of parent*/
    struct pid *p_pidp;     /* process ID info */
    struct pid *p_pgidp;        /* process group ID info */
    struct sd *p_sdp;       /* pointer to XENIX shared data */
    struct proc *p_next;        /* active chain link */
    struct proc *p_nextofkin;   /* gets accounting info at exit */
    struct proc *p_orphan;
    struct proc *p_nextorph;
} proc_t;

extern proc_t *practive;

/* Well known processes */

extern proc_t *proc_sched;      /* memory scheduler */
extern proc_t *proc_init;       /* init */
extern proc_t *proc_pageout;        /* pageout daemon */
extern proc_t *proc_bdflush;        /* block cache flush daemon */

/* process ID info */

struct pid {
    unsigned int pid_prinactive :1;
    unsigned int pid_pgorphaned :1;
    unsigned int pid_ref :6;
    unsigned int pid_prslot :24;
    pid_t pid_id;
    struct proc *pid_pglink;
    struct pid *pid_link;
};

extern struct pid pid0;

#define p_pgrp p_pgidp->pid_id
#define p_pid  p_pidp->pid_id
#define p_slot p_pidp->pid_prslot
#define p_detached p_pgidp->pid_pgorphaned

#define PID_HOLD(pidp)  (++(pidp)->pid_ref)
#define PID_RELE(pidp)    ((pidp)->pid_ref>1 ? --(pidp)->pid_ref : pid_rele(pidp))


#if defined(_KERNEL)

#if defined(__STDC__)

/* process management functions */
extern caddr_t findvaddr(proc_t *);
extern paddr_t vtop(caddr_t, proc_t *);
extern void pexit(void);
extern int newproc(int, pid_t *, int *);
extern void vfwait(pid_t);
extern void freeproc(proc_t *);
extern void setrun(proc_t *);
extern void unsleep(proc_t *);
extern void exit(int, int);
extern void relvm(proc_t *);

extern void sigcld(proc_t *);
extern void psig(void);
extern int stop(proc_t *, int, int, int);
extern int issig(int);
extern void psignal(proc_t *, int);
extern void sigtoproc(proc_t *, int, int);

void pid_setmin(void);
pid_t pid_assign(int, proc_t **);
int pid_rele(struct pid *);
void pid_exit(proc_t *);
proc_t *prfind(pid_t);
proc_t *pgfind(pid_t);
void pid_init(void);
proc_t *pid_entry(int);
int pid_slot(proc_t *);
void signal(pid_t, int);
void prsignal(struct pid *, int);

void pgsignal(struct pid *, int);
void pgjoin(proc_t *, struct pid *);
void pgexit(proc_t *);
void pgdetach(proc_t *);
int pgmembers(pid_t);


#else 

extern caddr_t findvaddr();
extern paddr_t vtop();
extern void pexit();
extern int newproc();
extern void vfwait();
extern void freeproc();
extern void setrun();
extern void unsleep();
extern void exit();
extern void relvm();

extern void sigcld();
extern void psig();
extern int stop();
extern int issig();
extern void psignal();
extern void sigtoproc();

void pid_setmin();
pid_t pid_assign();
int pid_rele();
void pid_exit();
proc_t *prfind();
proc_t *pgfind();
void pid_init();
proc_t *pid_entry();
int pid_slot();
void signal();
void prsignal();

void pgsignal();
void pgjoin();
void pgexit();
void pgdetach();
int pgmembers();

#endif /* __STDC__ */

#endif /* _KERNEL */

/* stat codes */

#define	SSLEEP	1		/* awaiting an event */
#define	SRUN	2		/* running */
#define	SZOMB	3		/* process terminated but not waited for */
#define	SSTOP	4		/* process stopped by debugger */
#define	SIDL	5		/* intermediate state in process creation */
#define	SONPROC	6		/* process is being run on a processor */
#define SXBRK	7		/* process being xswapped */

/* flag codes */

#define	SSYS	0x00000001	/* system (resident) process */
#define	STRC	0x00000002	/* process is being traced */
#define	SPRWAKE	0x00000004	/* debugger is waiting to prlock() */
#define	SNWAKE	0x00000008	/* process cannot be awakened by a signal */
#define	SLOAD	0x00000010	/* in core */
#define	SLOCK   0x00000020	/* process cannot be swapped */
#define SLKDONE 0x00000040	/* NFS record-locking has been done */
#define	SPOLL	0x00000080	/* process in stream poll */
#define	SPRSTOP	0x00000100	/* process is being stopped via /proc */
#define	SPROCTR	0x00000200	/* signal or syscall tracing via /proc */
#define	SPROCIO	0x00000400	/* doing I/O via /proc, so don't run */
#define	SPRFORK	0x00000800	/* child inherits /proc tracing flags */
#define	SPROPEN	0x00001000	/* process is open via /proc */
#define	SULOAD  0x00002000	/* u-block in core */
#define	SRUNLCL	0x00004000	/* set process running on last /proc close */
#define	SNOSTOP	0x00008000	/* proc asleep, stop not allowed */
#define	SPTRX	0x00010000	/* process is exiting via ptrace(2) */
#define	SASLEEP	0x00020000	/* proc is stopped within a call to sleep() */
#define	SUSWAP	0x00040000	/* u-block is being swapped in or out */
#define	SUWANT	0x00080000	/* waiting for u-block swap to complete */
#define SEXECED 0x00100000	/* this process has execed */
#define SDETACHED 0x00200000	/* this process detached from ctty */
/* unused 	0x00400000 */
/* unused	0x00800000 */
#define SJCTL	0x01000000	/* SIGCLD sent when children stop/continue */
#define SNOWAIT 0x02000000	/* children never become zombies */
#define SVFORK	0x04000000	/* process resulted from vfork */
#define SVFDONE 0x08000000	/* vfork child releasing parent as */
#define SSWLOCKS 0x10000000	/* process has swap locks */
#define	SXSTART	0x20000000	/* setrun() by SIGCONT or ptrace() */
#define	SPSTART	0x40000000	/* setrun() by /proc */
#define	SNEWSYS	0x80000000	/* proc in sys class being created */

/* pollflags */

#define SINPOLL		0x01	/* process in poll */
#define SPOLLTIME	0x02	/* poll timeout pending */

/* Flags for p_user_license */

#define PU_LIM_OK	0x01
#define PU_LOGIN_PROC	0x02
#define PU_UUCP		0x04

#define EUA_GET_LIM	0
#define EUA_GET_CUR	1
#define EUA_REM_USER	3
#define EUA_ADD_USER	4
#define EUA_UUCP	5
#define EUA_FORK	6

/* Flags for newproc() */

#define NP_FAILOK	0x01	/* don't panic if cannot create process */
#define NP_NOLAST	0x02	/* don't use last process slot */
#define	NP_SYSPROC	0x04	/* system (resident) process */
#define	NP_INIT		0x08	/* this is init process */
#define NP_VFORK	0x10	/* share address space - vfork */
#define NP_SHARE	0x20	/* share address space - asyncio */

/* Macro to convert proc table pointers to user block pointers */
#define PTOU(p) ((struct user *)((p)->p_segu))

#define PTRACED(p)	((p)->p_flag&(STRC|SPROCTR|SPROPEN))

/* Macro to reduce unnecessary calls to issig() */

#define	ISSIG(p, why) \
  (((p)->p_cursig || !sigisempty(&(p)->p_sig) || ((p)->p_flag & SPRSTOP)) \
    && issig(why))

/* Reasons for calling issig() */

#define	FORREAL		0	/* Usual side-effects */
#define	JUSTLOOKING	1	/* Don't stop the process */

/* Macros for pid manipulation */

#define	PIDSHIFT		12		/* 2^PIDSHIFT >= NPROC */
#define	PIDINDEXMAX		0x0fff		/* = 2^PIDSHIFT-1 */
#define	PIDINCARMAX		0x7000		/* 3 bits for incarnation number as of 08/15/88 */

#define	GET_INDEX(PI_PID)	((PI_PID)&(PIDINDEXMAX))
#define	GET_INCAR(PI_PID)	(((unsigned)((PI_PID)&(PIDINCARMAX))) >> (PIDSHIFT))
#define	INC_INCAR(PI_PID)	((PI_PID) = (((unsigned)(PI_PID) + ((0x1)<<(PIDSHIFT)))&((PIDINDEXMAX)|(PIDINCARMAX))))
#define INC_INDEX(PI_PID)	PUT_INDEX(PI_PID,(GET_INDEX(PI_PID)+1)%NPROC)
#define	PUT_INCAR(PI_PID,INCAR)	((PI_PID) = (((PI_PID)&(PIDINDEXMAX)) | (((INCAR)<<(PIDSHIFT))&(PIDINCARMAX))))
#define PUT_INDEX(PI_PID,INDEX)	((PI_PID) = (((PI_PID)&(PIDINCARMAX)) | ((INDEX)&(PIDINDEXMAX))))

#endif	/* _SYS_PROC_H */
   070701000059c8000081240000000200000002000000012719347c00002591000000230000000c00000000000000000000001900000000usr/include/sys/procfs.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PROCFS_H
#define _SYS_PROCFS_H

#ident	"@(#)/usr/include/sys/procfs.h.sl 1.1 4.0 10/15/90 42852 AT&T-SF"

#include <sys/types.h>
#include <sys/time.h>
#include <sys/regset.h>
#include <sys/tss.h>
#include <sys/signal.h>
#include <sys/siginfo.h>
#include <sys/ucontext.h>
#include <sys/fault.h>
#include <sys/syscall.h>

/*
 * ioctl codes and system call interfaces for /proc.
 */

#define	PIOC		('q'<<8)
#define	PIOCSTATUS	(PIOC|1)	/* get process status */
#define	PIOCSTOP	(PIOC|2)	/* post STOP request and... */
#define	PIOCWSTOP	(PIOC|3)	/* wait for process to STOP */
#define	PIOCRUN		(PIOC|4)	/* make process runnable */
#define	PIOCGTRACE	(PIOC|5)	/* get traced signal set */
#define	PIOCSTRACE	(PIOC|6)	/* set traced signal set */
#define	PIOCSSIG	(PIOC|7)	/* set current signal */
#define	PIOCKILL	(PIOC|8)	/* send signal */
#define	PIOCUNKILL	(PIOC|9)	/* delete a signal */
#define	PIOCGHOLD	(PIOC|10)	/* get held signal set */
#define	PIOCSHOLD	(PIOC|11)	/* set held signal set */
#define	PIOCMAXSIG	(PIOC|12)	/* get max signal number */
#define	PIOCACTION	(PIOC|13)	/* get signal action structs */
#define	PIOCGFAULT	(PIOC|14)	/* get traced fault set */
#define	PIOCSFAULT	(PIOC|15)	/* set traced fault set */
#define	PIOCCFAULT	(PIOC|16)	/* clear current fault */
#define	PIOCGENTRY	(PIOC|17)	/* get syscall entry set */
#define	PIOCSENTRY	(PIOC|18)	/* set syscall entry set */
#define	PIOCGEXIT	(PIOC|19)	/* get syscall exit set */
#define	PIOCSEXIT	(PIOC|20)	/* set syscall exit set */
#define	PIOCSFORK	(PIOC|21)	/* set inherit-on-fork flag */
#define	PIOCRFORK	(PIOC|22)	/* reset inherit-on-fork flag */
#define	PIOCSRLC	(PIOC|23)	/* set run-on-last-close flag */
#define	PIOCRRLC	(PIOC|24)	/* reset run-on-last-close flag */
#define	PIOCGREG	(PIOC|25)	/* get general registers */
#define	PIOCSREG	(PIOC|26)	/* set general registers */
#define	PIOCGFPREG	(PIOC|27)	/* get floating-point registers */
#define	PIOCSFPREG	(PIOC|28)	/* set floating-point registers */
#define	PIOCNICE	(PIOC|29)	/* set nice priority */
#define	PIOCPSINFO	(PIOC|30)	/* get ps(1) information */
#define	PIOCNMAP	(PIOC|31)	/* get number of memory mappings */
#define	PIOCMAP		(PIOC|32)	/* get memory map information */
#define	PIOCOPENM	(PIOC|33)	/* open mapped object for reading */
#define	PIOCCRED	(PIOC|34)	/* get process credentials */
#define	PIOCGROUPS	(PIOC|35)	/* get supplementary groups */
#define	PIOCGETPR	(PIOC|36)	/* read struct proc */
#define	PIOCGETU	(PIOC|37)	/* read user area */
#define	PIOCGDBREG	(PIOC|40)	/* get debug registers */
#define	PIOCSDBREG	(PIOC|41)	/* set debug registers */

/* Holds one 3B2 instruction op code */

typedef	char	instr_t;

/* Process status structure */

typedef struct prstatus {
	long	pr_flags;	/* Process flags */
	short	pr_why;		/* Reason for process stop (if stopped) */
	short	pr_what;	/* More detailed reason */
	siginfo_t pr_info;	/* Info associated with signal or fault */
	short	pr_cursig;	/* Current signal */
	short	pr_pad;		/* pad to long boundary */
	sigset_t pr_sigpend;	/* Set of other pending signals */
	sigset_t pr_sighold;	/* Set of of held signals */
	struct	sigaltstack pr_altstack; /* Alternate signal stack info */
	struct	sigaction pr_action; /* Signal action for current signal */
	pid_t	pr_pid;		/* Process id */
	pid_t	pr_ppid;	/* Parent process id */
	pid_t	pr_pgrp;	/* Process group id */
	pid_t	pr_sid;		/* Session id */
	timestruc_t pr_utime;	/* Process user cpu time */
	timestruc_t pr_stime;	/* Process system cpu time */
	timestruc_t pr_cutime;	/* Sum of children's user times */
	timestruc_t pr_cstime;	/* Sum of children's system times */
	char	pr_clname[8];	/* Scheduling class name */
	long	pr_filler[20];	/* Filler area for future expansion */
	long	pr_instr;	/* Current instruction */
	gregset_t pr_reg;	/* General registers */
} prstatus_t;

/* Process status flags */

#define	PR_STOPPED	0x0001	/* Process is stopped */
#define	PR_ISTOP	0x0002	/* Process stopped on an event of interest */
#define	PR_DSTOP	0x0004	/* A stop directive is in effect */
#define	PR_ASLEEP	0x0008	/* Process is sleep()ing in a system call */
#define	PR_FORK		0x0010	/* Inherit-on-fork is in effect */
#define	PR_RLC		0x0020	/* Run-on-last-close is in effect */
#define	PR_PTRACE	0x0040	/* Process is being controlled by ptrace(2) */
#define	PR_PCINVAL	0x0080	/* %pc refers to an invalid virtual address */
#define	PR_ISSYS	0x0100	/* System process */

/* Reasons for stopping */

#define	PR_REQUESTED	1
#define	PR_SIGNALLED	2
#define	PR_SYSENTRY	3
#define	PR_SYSEXIT	4
#define	PR_JOBCONTROL	5
#define	PR_FAULTED	6

/* Information for the ps(1) command */

#define	PRARGSZ		80		/* Number of chars of arguments */

typedef struct prpsinfo {
	char	pr_state;	/* numeric process state (see pr_sname) */
	char	pr_sname;	/* printable character representing pr_state */
	char	pr_zomb;	/* !=0: process terminated but not waited for */
	char	pr_nice;	/* nice for cpu usage */
	u_long	pr_flag;	/* process flags */
	uid_t	pr_uid;		/* real user id */
	gid_t	pr_gid;		/* real group id */
	pid_t	pr_pid;		/* unique process id */
	pid_t	pr_ppid;	/* process id of parent */
	pid_t	pr_pgrp;	/* pid of process group leader */
	pid_t	pr_sid;		/* session id */
	caddr_t	pr_addr;	/* physical address of process */
	long	pr_size;	/* size of process image in pages */
	long	pr_rssize;	/* resident set size in pages */
	caddr_t	pr_wchan;	/* wait addr for sleeping process */
	timestruc_t pr_start;	/* process start time, sec+nsec since epoch */
	timestruc_t pr_time;	/* usr+sys cpu time for this process */
	long	pr_pri;		/* priority, high value is high priority */
	char	pr_oldpri;	/* pre-SVR4, low value is high priority */
	char	pr_cpu;		/* pre-SVR4, cpu usage for scheduling */
	o_dev_t	pr_ottydev;	/* short tty device number */
	dev_t	pr_lttydev;	/* controlling tty device (PRNODEV if none) */
	char	pr_clname[8];	/* Scheduling class name */
	char	pr_fname[16];	/* last component of exec()ed pathname */
	char	pr_psargs[PRARGSZ];	/* initial characters of arg list */
	long	pr_filler[20];	/* for future expansion */
} prpsinfo_t;

#if !defined(_STYPES)
#define	pr_ttydev	pr_lttydev
#else
#define	pr_ttydev	pr_ottydev
#endif	

#define	PRNODEV	(dev_t)(-1)	/* non-existent device */

/* Optional actions to take when process continues */

typedef struct prrun {
	long	pr_flags;	/* Flags */
	sigset_t pr_trace;	/* Set of signals to be traced */
	sigset_t pr_sighold;	/* Set of signals to be held */
	fltset_t pr_fault;	/* Set of faults to be traced */
	caddr_t	pr_vaddr;	/* Virtual address at which to resume */
	long	pr_filler[8];	/* Filler area for future expansion */
} prrun_t;

#define	PRCSIG		0x001	/* Clear current signal */
#define	PRCFAULT	0x002	/* Clear current fault */
#define	PRSTRACE	0x004	/* Use traced-signal set in pr_trace */
#define	PRSHOLD		0x008	/* Use held-signal set in pr_sighold */
#define	PRSFAULT	0x010	/* Use traced-fault set in pr_fault */
#define	PRSVADDR	0x020	/* Resume at virtual address in pr_vaddr */
#define	PRSTEP		0x040	/* Single-step the process */
#define	PRSABORT	0x080	/* Abort syscall */
#define	PRSTOP		0x100	/* Set directed stop request */

/* Memory-management interface */

typedef struct prmap {
	caddr_t		pr_vaddr;	/* Virtual address base */
	u_long		pr_size;	/* Size of mapping in bytes */
	off_t		pr_off;		/* Offset into mapped object, if any */
	long		pr_mflags;	/* Protection and attribute flags */
	long		pr_filler[4];	/* Filler for future expansion */
} prmap_t;

/* Protection and attribute flags */

#define	MA_READ		0x04	/* Readable by the traced process */
#define	MA_WRITE	0x02	/* Writable by the traced process */
#define	MA_EXEC		0x01	/* Executable by the traced process */
#define	MA_SHARED	0x08	/* Changes are shared by mapped object */
#define	MA_BREAK	0x10	/* Grown by brk(2) */
#define	MA_STACK	0x20	/* Grown automatically on stack faults */

/* Process credentials */

typedef struct prcred {
	uid_t	pr_euid;	/* Effective user id */
	uid_t	pr_ruid;	/* Real user id */
	uid_t	pr_suid;	/* Saved user id (from exec) */
	gid_t	pr_egid;	/* Effective group id */
	gid_t	pr_rgid;	/* Real group id */
	gid_t	pr_sgid;	/* Saved group id (from exec) */
	u_int	pr_ngroups;	/* Number of supplementary groups */
} prcred_t;

/*
 * Macros for manipulating sets of flags.
 * sp must be a pointer to one of sigset_t, fltset_t, or sysset_t.
 * flag must be a member of the enumeration corresponding to *sp.
 */

/* turn on all flags in set */
#define	prfillset(sp) \
	{ register int _i_ = sizeof(*(sp))/sizeof(u_long); \
		while(_i_) ((u_long*)(sp))[--_i_] = 0xFFFFFFFF; }

/* turn off all flags in set */
#define	premptyset(sp) \
	{ register int _i_ = sizeof(*(sp))/sizeof(u_long); \
		while(_i_) ((u_long*)(sp))[--_i_] = 0L; }

/* turn on specified flag in set */
#define	praddset(sp, flag) \
	(((unsigned)((flag)-1) < 32*sizeof(*(sp))/sizeof(u_long)) ? \
	(((u_long*)(sp))[((flag)-1)/32] |= (1L<<(((flag)-1)%32))) : 0)

/* turn off specified flag in set */
#define	prdelset(sp, flag) \
	(((unsigned)((flag)-1) < 32*sizeof(*(sp))/sizeof(u_long)) ? \
	(((u_long*)(sp))[((flag)-1)/32] &= ~(1L<<(((flag)-1)%32))) : 0)

/* query: != 0 iff flag is turned on in set */
#define	prismember(sp, flag) \
	(((unsigned)((flag)-1) < 32*sizeof(*(sp))/sizeof(u_long)) \
	&& (((u_long*)(sp))[((flag)-1)/32] & (1L<<(((flag)-1)%32))))


#endif	/* _SYS_PROCFS_H */
   070701000059c9000081240000000200000002000000012719347c00000ca6000000230000000c00000000000000000000001a00000000usr/include/sys/procset.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PROCSET_H
#define _SYS_PROCSET_H

#ident	"@(#)/usr/include/sys/procset.h.sl 1.1 4.0 10/15/90 36437 AT&T-SF"

/*	This file defines the data needed to specify a set of
**	processes.  These types are used by the sigsend, sigsendset,
**	priocntl, priocntlset, waitid, evexit, and evexitset system
**	calls.
*/

#define	P_INITPID	1
#define	P_INITUID	0
#define	P_INITPGID	0


/*	The following defines the values for an identifier type.  It
**	specifies the interpretation of an id value.  An idtype and
**	id together define a simple set of processes.
*/

typedef enum idtype {
	P_PID,		/* A process identifier.		*/
	P_PPID,		/* A parent process identifier.		*/
	P_PGID,		/* A process group (job control group)	*/
			/* identifier.				*/
	P_SID,		/* A session identifier.		*/
	P_CID,		/* A scheduling class identifier.	*/
	P_UID,		/* A user identifier.			*/
	P_GID,		/* A group identifier.			*/
	P_ALL		/* All processes.			*/
} idtype_t;


/*	The following defines the operations which can be performed to
**	combine two simple sets of processes to form another set of
**	processes.
*/

typedef enum idop {
	POP_DIFF,	/* Set difference.  The processes which	*/
			/* are in the left operand set and not	*/
			/* in the right operand set.		*/
	POP_AND,	/* Set disjunction.  The processes	*/
			/* which are in both the left and right	*/
			/* operand sets.			*/
	POP_OR,		/* Set conjunction.  The processes	*/
			/* which are in either the left or the	*/
			/* right operand sets (or both).	*/
	POP_XOR		/* Set exclusive or.  The processes 	*/
			/* which are in either the left or	*/
			/* right operand sets but not in both.	*/
} idop_t;


/*	The following structure is used to define a set of processes.
**	The set is defined in terms of two simple sets of processes
**	and an operator which operates on these two operand sets.
*/

typedef struct procset {
	idop_t		p_op;	/* The operator connection the	*/
				/* following two operands each	*/
				/* of which is a simple set of	*/
				/* processes.			*/

	idtype_t	p_lidtype;
				/* The type of the left operand	*/
				/* simple set.			*/
	id_t		p_lid;	/* The id of the left operand.	*/

	idtype_t	p_ridtype;
				/* The type of the right	*/
				/* operand simple set.		*/
	id_t		p_rid;	/* The id of the right operand.	*/
} procset_t;


/*	The following macro can be used to initialize a procset_t
**	structure.
*/

#define	setprocset(psp, op, ltype, lid, rtype, rid) \
			(psp)->p_op		= (op); \
			(psp)->p_lidtype	= (ltype); \
			(psp)->p_lid		= (lid); \
			(psp)->p_ridtype	= (rtype); \
			(psp)->p_rid		= (rid);

#ifdef _KERNEL

/*
 * Public functions.
 */
#if defined(__STDC__)

extern int dotoprocs(procset_t *psp, int (*funcp)(), char *arg);
extern int procinset(proc_t *pp, procset_t *psp);
extern boolean_t cur_inset_only(procset_t *psp);

#else

extern int dotoprocs();
extern int procinset();
extern boolean_t cur_inset_only();

#endif	/* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _SYS_PROCSET_H */
  070701000059ca000081240000000200000002000000012719347c00000409000000230000000c00000000000000000000001900000000usr/include/sys/proctl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PROCTL_H
#define _SYS_PROCTL_H

#ident	"@(#)/usr/include/sys/proctl.h.sl 1.1 4.0 10/15/90 40857 AT&T-SF"
/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */


/*
 *	@(#) proctl.h 1.2 88/08/30 head.sys:proctl.h
 */

/*
 * THIS FILE CONTAINS CODE WHICH IS DESIGNED TO BE
 * PORTABLE BETWEEN DIFFERENT MACHINE ARCHITECTURES
 * AND CONFIGURATIONS. IT SHOULD NOT REQUIRE ANY
 * MODIFICATIONS WHEN ADAPTING XENIX TO NEW HARDWARE.
 */

/* proctl() requests */

#define PRHUGEX		1	/* allow process > swapper size to execute */
#define PRNORMEX 	2	/* remove PRHUGEX permission */

#endif	/* _SYS_PROCTL_H */
   070701000059cb000081240000000200000002000000012719347c0000200d000000230000000c00000000000000000000001a00000000usr/include/sys/protosw.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PROTOSW_H
#define _SYS_PROTOSW_H

#ident	"@(#)/usr/include/sys/protosw.h.sl 1.1 4.0 10/15/90 2481 AT&T-SF"

/*	@(#)protosw.h 1.1 88/12/05 SMI; from UCB 7.1 6/4/86	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */


/*
 * Protocol switch table.
 *
 * Each protocol has a handle initializing one of these structures,
 * which is used for protocol-protocol and system-protocol communication.
 *
 * A protocol is called through the pr_init entry before any other.
 * Thereafter it is called every 200ms through the pr_fasttimo entry and
 * every 500ms through the pr_slowtimo for timer based actions.
 * The system will call the pr_drain entry if it is low on space and
 * this should throw away any non-critical data.
 *
 * Protocols pass data between themselves as chains of mbufs using
 * the pr_input and pr_output hooks.  Pr_input passes data up (towards
 * UNIX) and pr_output passes it down (towards the imps); control
 * information passes up and down on pr_ctlinput and pr_ctloutput.
 * The protocol is responsible for the space occupied by any the
 * arguments to these entries and must dispose it.
 *
 * The userreq routine interfaces protocols to the system and is
 * described below.
 */
struct protosw {
	short	pr_type;		/* socket type used for */
	struct	domain *pr_domain;	/* domain protocol a member of */
	short	pr_protocol;		/* protocol number */
	short	pr_flags;		/* see below */
/* protocol-protocol hooks */
	int	(*pr_input)();		/* input to protocol (from below) */
	int	(*pr_output)();		/* output to protocol (from above) */
	int	(*pr_ctlinput)();	/* control input (from below) */
	int	(*pr_ctloutput)();	/* control output (from above) */
/* user-protocol hook */
	int	(*pr_usrreq)();		/* user request: see list below */
/* utility hooks */
	int	(*pr_init)();		/* initialization hook */
	int	(*pr_fasttimo)();	/* fast timeout (200ms) */
	int	(*pr_slowtimo)();	/* slow timeout (500ms) */
	int	(*pr_drain)();		/* flush any excess space possible */
};

#define	PR_SLOWHZ	2		/* 2 slow timeouts per second */
#define	PR_FASTHZ	5		/* 5 fast timeouts per second */

/*
 * Values for pr_flags
 */
#define	PR_ATOMIC	0x01		/* exchange atomic messages only */
#define	PR_ADDR		0x02		/* addresses given with messages */
/* in the current implementation, PR_ADDR needs PR_ATOMIC to work */
#define	PR_CONNREQUIRED	0x04		/* connection required by protocol */
#define	PR_WANTRCVD	0x08		/* want PRU_RCVD calls */
#define	PR_RIGHTS	0x10		/* passes capabilities */
#define PR_OOB_ADDR     0x20            /* addresses given with OOB data */

/*
 * The arguments to usrreq are:
 *	(*protosw[].pr_usrreq)(up, req, m, nam, opt);
 * where up is a (struct socket *), req is one of these requests,
 * m is a optional mbuf chain containing a message,
 * nam is an optional mbuf chain containing an address,
 * and opt is a pointer to a socketopt structure or nil.
 * The protocol is responsible for disposal of the mbuf chain m,
 * the caller is responsible for any space held by nam and opt.
 * A non-zero return from usrreq gives an
 * UNIX error number which should be passed to higher level software.
 */
#define	PRU_ATTACH		0	/* attach protocol to up */
#define	PRU_DETACH		1	/* detach protocol from up */
#define	PRU_BIND		2	/* bind socket to address */
#define	PRU_LISTEN		3	/* listen for connection */
#define	PRU_CONNECT		4	/* establish connection to peer */
#define	PRU_ACCEPT		5	/* accept connection from peer */
#define	PRU_DISCONNECT		6	/* disconnect from peer */
#define	PRU_SHUTDOWN		7	/* won't send any more data */
#define	PRU_RCVD		8	/* have taken data; more room now */
#define	PRU_SEND		9	/* send this data */
#define	PRU_ABORT		10	/* abort (fast DISCONNECT, DETATCH) */
#define	PRU_CONTROL		11	/* control operations on protocol */
#define	PRU_SENSE		12	/* return status into m */
#define	PRU_RCVOOB		13	/* retrieve out of band data */
#define	PRU_SENDOOB		14	/* send out of band data */
#define	PRU_SOCKADDR		15	/* fetch socket's address */
#define	PRU_PEERADDR		16	/* fetch peer's address */
#define	PRU_CONNECT2		17	/* connect two sockets */
/* begin for protocols internal use */
#define	PRU_FASTTIMO		18	/* 200ms timeout */
#define	PRU_SLOWTIMO		19	/* 500ms timeout */
#define	PRU_PROTORCV		20	/* receive from below */
#define	PRU_PROTOSEND		21	/* send to below */

#define	PRU_NREQ		21

#ifdef PRUREQUESTS
char *prurequests[] = {
	"ATTACH",	"DETACH",	"BIND",		"LISTEN",
	"CONNECT",	"ACCEPT",	"DISCONNECT",	"SHUTDOWN",
	"RCVD",		"SEND",		"ABORT",	"CONTROL",
	"SENSE",	"RCVOOB",	"SENDOOB",	"SOCKADDR",
	"PEERADDR",	"CONNECT2",	"FASTTIMO",	"SLOWTIMO",
	"PROTORCV",	"PROTOSEND",
};
#endif

/*
 * The arguments to the ctlinput routine are
 *	(*protosw[].pr_ctlinput)(cmd, arg);
 * where cmd is one of the commands below, and arg is
 * an optional argument (caddr_t).
 *
 * N.B. The IMP code, in particular, pressumes the values
 *      of some of the commands; change with extreme care.
 * TODO:
 *	spread out codes so new ICMP codes can be
 *	accomodated more easily
 */
#define	PRC_IFDOWN		0	/* interface transition */
#define	PRC_ROUTEDEAD		1	/* select new route if possible */
#define	PRC_QUENCH		4	/* some said to slow down */
#define	PRC_MSGSIZE		5	/* message size forced drop */
#define	PRC_HOSTDEAD		6	/* normally from IMP */
#define	PRC_HOSTUNREACH		7	/* ditto */
#define	PRC_UNREACH_NET		8	/* no route to network */
#define	PRC_UNREACH_HOST	9	/* no route to host */
#define	PRC_UNREACH_PROTOCOL	10	/* dst says bad protocol */
#define	PRC_UNREACH_PORT	11	/* bad port # */
#define	PRC_UNREACH_NEEDFRAG	12	/* IP_DF caused drop */
#define	PRC_UNREACH_SRCFAIL	13	/* source route failed */
#define	PRC_REDIRECT_NET	14	/* net routing redirect */
#define	PRC_REDIRECT_HOST	15	/* host routing redirect */
#define	PRC_REDIRECT_TOSNET	16	/* redirect for type of service & net */
#define	PRC_REDIRECT_TOSHOST	17	/* redirect for tos & host */
#define	PRC_TIMXCEED_INTRANS	18	/* packet lifetime expired in transit */
#define	PRC_TIMXCEED_REASS	19	/* lifetime expired on reass q */
#define	PRC_PARAMPROB		20	/* header incorrect */
#define	PRC_GWDOWN		21	/* gateway down */

#define	PRC_NCMDS		22

#ifdef PRCREQUESTS
char	*prcrequests[] = {
	"IFDOWN", "ROUTEDEAD", "#2", "#3",
	"QUENCH", "MSGSIZE", "HOSTDEAD", "HOSTUNREACH",
	"NET-UNREACH", "HOST-UNREACH", "PROTO-UNREACH", "PORT-UNREACH",
	"FRAG-UNREACH", "SRCFAIL-UNREACH", "NET-REDIRECT", "HOST-REDIRECT",
	"TOSNET-REDIRECT", "TOSHOST-REDIRECT", "TX-INTRANS", "TX-REASS",
	"PARAMPROB"
};
#endif

/*
 * The arguments to ctloutput are:
 *	(*protosw[].pr_ctloutput)(req, so, level, optname, optval);
 * req is one of the actions listed below, so is a (struct socket *),
 * level is an indication of which protocol layer the option is intended.
 * optname is a protocol dependent socket option request,
 * optval is a pointer to a mbuf-chain pointer, for value-return results.
 * The protocol is responsible for disposal of the mbuf chain *optval
 * if supplied,
 * the caller is responsible for any space held by *optval, when returned.
 * A non-zero return from usrreq gives an
 * UNIX error number which should be passed to higher level software.
 */
#define	PRCO_GETOPT	0
#define	PRCO_SETOPT	1

#define	PRCO_NCMDS	2

#ifdef PRCOREQUESTS
char	*prcorequests[] = {
	"GETOPT", "SETOPT",
};
#endif

#ifdef _KERNEL
extern	struct protosw *pffindproto(), *pffindtype();
#endif

#endif	/* _SYS_PROTOSW_H */
   070701000059cc000081240000000200000002000000012719347c000003b8000000230000000c00000000000000000000001a00000000usr/include/sys/prsystm.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PRSYSTM_H
#define _SYS_PRSYSTM_H

#ident	"@(#)/usr/include/sys/prsystm.h.sl 1.1 4.0 10/15/90 54388 AT&T-SF"

#include <sys/procfs.h>

#if defined(__STDC__)
extern void prawake(proc_t *);
extern void prinvalidate(struct user *);
extern void prgetpsinfo(proc_t *, struct prpsinfo *);
extern void prgetfpregs(proc_t *, fpregset_t *);
extern int prnsegs(proc_t *);
extern void prexit(proc_t *);
extern void prgetstatus(proc_t *, prstatus_t *);
#else
extern void prawake();
extern void prinvalidate();
extern void prgetpsinfo();
extern void prgetfpregs();
extern int prnsegs();
extern void prexit();
extern void prgetstatus();
#endif	/* __STDC__ */

#endif	/* _SYS_PRSYSTM_H */
070701000059cd000081240000000200000002000000012719347c0000063d000000230000000c00000000000000000000001700000000usr/include/sys/ptem.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PTEM_H
#define _SYS_PTEM_H

#ident	"@(#)/usr/include/sys/ptem.h.sl 1.1 4.0 10/15/90 14997 AT&T-SF"

#ifndef _SYS_TTOLD_H
#ifndef _SYS_TERMIOS_H

/* Windowing structure to support TIOCSWINSZ/TIOCGWINSZ */
struct winsize {
	unsigned short ws_row;       /* rows, in characters*/
	unsigned short ws_col;       /* columns, in character */
	unsigned short ws_xpixel;    /* horizontal size, pixels */
	unsigned short ws_ypixel;    /* vertical size, pixels */
};

#endif /* end _SYS_TERMIOS_H */
#endif /* end _SYS_TTOLD_H */
/*
 * The ptem data structure used to define the global data
 * for the psuedo terminal emulation streams module
 */
struct ptem
{
	long cflags;		/* copy of c_cflags */
	mblk_t *dack_ptr;	/* pointer to preallocated message block used to ACK disconnect */
	queue_t *q_ptr;		/* pointer to the ptem read queue */
	struct winsize wsz;	/* struct to hold the windowing info. */
	unsigned short state;	/* state of ptem entry, free or not */
};
/*
 * state flags
 * if state is zero then ptem entry is free to be allocated
 */
#define INUSE 		0x1	/* Internal ptem entry in use */
#define OFLOW_CTL 	0x2	/* Outflow control on */
/*
 * Constants used to distinguish between a common function invoked
 * from the read or write side put procedures
 */
#define	RDSIDE	1
#define	WRSIDE	2

#endif	/* _SYS_PTEM_H */
   070701000059ce000081240000000200000002000000012719347c00000545000000230000000c00000000000000000000001700000000usr/include/sys/ptms.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_PTMS_H
#define _SYS_PTMS_H

#ident	"@(#)/usr/include/sys/ptms.h.sl 1.1 4.0 10/15/90 27825 AT&T-SF"
/*
 ================================================================
 =   WARNING!!!! This source is not supported in future source  =
 =   releases.                                                  =
 ================================================================
 */

/*
 * Structures and definitions supporting the pseudo terminal
 * drivers.
 */
struct pt_ttys {
	unsigned pt_state;	/* state of master/slave pair */
	queue_t *ptm_wrq; 	/* master's write queue pointer */
	queue_t *pts_wrq; 	/* slave's write queue pointer */
	mblk_t *pt_bufp;        /* ptr. to zero byte msg. blk. */
	pid_t tty;	        /* controlling tty pid */
};

/*
 * pt_state values
 */
#define PTLOCK	01	/* master/slave pair is locked */
#define PTMOPEN 02  	/* master side is open */
#define PTSOPEN 04	/* slave side is open */

/*
 * ioctl commands
 */
#define ISPTM	(('P'<<8)|1)	/* query for master */
#define UNLKPT	(('P'<<8)|2)	/* unlock master/slave pair */


#endif	/* _SYS_PTMS_H */
   070701000059cf000081240000000200000002000000012719347c000004e5000000230000000c00000000000000000000001600000000usr/include/sys/que.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sys/que.h.sl 1.1 4.0 10/15/90 36010 AT&T-SF"

/*********************************************************************

	following structures declares the data structures used for
	queue manipulation.

*********************************************************************/

/*****

	Queues consist simply of one-way list.  Each queue is
	defined by a 'queue control element' made up of head
	and tail pointers.  Each item held on a queue contains
	a pointer word used to link successive item together.
	The head pointer contains the address of the first
	item in the queue and the tail pointer contains the
	address of the last item.

*****/



/*
 *	Queue Item
 */

#define	QITEM	struct qitem_st

struct	qitem_st
	{
	QITEM	*qi_next;	/* next queue item pointer */
	char	data[1];	/* data */
	};



/*
 *	Queue Control Element
 */

#define	QCTRL	struct qctrl_st

struct	qctrl_st
	{
	QITEM	*qc_head;		/* head pointer */
	QITEM	*qc_tail;		/* tail pointer */
	};





   070701000059d0000081240000000200000002000000012719347c000017a7000000230000000c00000000000000000000001800000000usr/include/sys/queue.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_QUEUE_H
#define _SYS_QUEUE_H

#ident	"@(#)/usr/include/sys/queue.h.sl 1.1 4.0 10/15/90 46970 AT&T-SF"
/* Express Queue Macros */
#define R_EXP ((RQUEUE *)R_ADDR)->express
#define C_EXP ((CQUEUE *)C_ADDR)->express

/* QUEUE POINTER MACROS */

/* all pointers */
#define R_ALL(Q) ((RQUEUE *)R_ADDR)->queue[Q].p_queues.all
#define C_ALL ((CQUEUE *)C_ADDR)->queue.p_queues.all

/* pointers as a sixteen bit quantity */
#define R_SLOAD(Q) ((RQUEUE *)R_ADDR)->queue[Q].p_queues.bit16.load
#define R_SULOAD(Q) ((RQUEUE *)R_ADDR)->queue[Q].p_queues.bit16.unload

#define C_SLOAD ((CQUEUE *)C_ADDR)->queue.p_queues.bit16.load
#define C_SULOAD ((CQUEUE *)C_ADDR)->queue.p_queues.bit16.unload

/* pointers as an eight bit quantity  */
#define R_BLOAD(Q) ((RQUEUE *)R_ADDR)->queue[Q].p_queues.bit8.unload
#define R_BULOAD(Q) ((RQUEUE *)R_ADDR)->queue[Q].p_queues.bit8.unload

#define C_BLOAD ((CQUEUE *)C_ADDR)->queue.p_queues.bit8.load
#define C_BULOAD ((CQUEUE *)C_ADDR)->queue.p_queues.bit8.unload

/* job entry at load pointer for 16 bit ptrs */
#define Q_RSENTRY(Q) (RENTRY *)(R_SLOAD(Q)+(((RQUEUE *)R_ADDR)->queue[Q].entry))

/* job entry at load pointer for 8 bit ptrs */
#define Q_RBENTRY(Q) (RENTRY *)(R_BLOAD(Q)+(((RQUEUE *)R_ADDR)->queue[Q].entry))

/* job completion at unload pointer for 16 bit ptrs */
#define Q_CSENTRY (CENTRY *)(C_SULOAD+(((CQUEUE *)C_ADDR)->queue.entry))

/* job completion at unload pointer for 8 bit */
#define Q_CBENTRY (CENTRY *)(C_BULOAD+(((CQUEUE *)C_ADDR)->queue.entry))

struct com_entry{
       union{
          struct {
             unsigned bytcnt:16;     /* offset of last byte to transfer  */
                                     /* 0 transfers byte 0               */

#ifdef x86
	     /* this for the Intel side since bit fields are assigned      */
	     /* opposite from WE32000                                    */
             unsigned subdev:6;      /* Subdevice being addressed.       */
             unsigned seqbit:1;      /* flag for block available         */
             unsigned cmd_stat:1;    /* flag for command/status opcode   */
#else
#	ifdef b16
	     /* this for the Intel side since bit fields are assigned      */
	     /* opposite from WE32000                                    */
             unsigned subdev:6;      /* Subdevice being addressed.       */
             unsigned seqbit:1;      /* flag for block available         */
             unsigned cmd_stat:1;    /* flag for command/status opcode   */
#	else
	     /*                this for the m32 side                     */
             unsigned cmd_stat:1;    /* flag for command/status opcode   */
             unsigned seqbit:1;      /* flag for block available         */
             unsigned subdev:6;      /* Subdevice being addressed.       */

#	endif
#endif
             unsigned opcode:8;      /* command or status opcode         */
           }bits;
           struct {
             unsigned short bytcnt;
             char subdev;
             char opcode;
           }bytes;
        }codes;
     	long addr;     /* data or memory address of data       */
};


typedef struct {

     struct com_entry common;
     CAPP appl;		              /* application defined area      	*/
               		   	      /* CAPP for CENTRY	 	*/

}CENTRY;                     /* CENTRY in completion queue		*/


typedef struct {

        /* entry for express requests */
        CENTRY express;

        struct {
                /* Three ways of accessing load and unload ptrs */
                union {
                        /* All pointers at once */
                        long all;

                        /* 16 bit load ptr and 16 bit unload ptr */
                        struct {
                                short load;
                                short unload;
                        }bit16;

                        /* 8 bit load ptr and 8 bit unload ptr */
                        struct {
                                char pad1;
                                char load;
                                char pad2;
                                char unload;
                        }bit8;

                 }p_queues;

                 CENTRY entry[CQSIZE];

        }queue;            /* one for completion queue     */

} CQUEUE;

typedef struct {

     	struct com_entry common;
	RAPP appl;              	/* application defined area	*/
}RENTRY;			/* RENTRY in request queue		*/

typedef struct {

        /* entry for express requests */
        RENTRY express;

        struct {
                /* Three ways of accessing load and unload ptrs */
                union {
                        /* All pointers at once */
                        long all;

                        /* 16 bit load ptr and 16 bit unload ptr */
                        struct {
                                short load;
                                short unload;
                        }bit16;

                        /* 8 bit load ptr and 8 bit unload ptr */
                        struct {
                                char pad1;
                                char load;
                                char pad2;
                                char unload;
                        }bit8;

                 }p_queues;

                 RENTRY entry[RQSIZE];

        }queue[NUM_QUEUES];            /* #defined for request queue	*/

} RQUEUE;

typedef struct {		 /* sysgen data block */
	long request;   /* address of request queue */
	long complt;    /* address of cmplt queue   */
	unsigned char req_size;  /* no entries in req q  */
	unsigned char comp_size; /* no entries in cmplt q*/
	unsigned char int_vect;  /* base intrpt vector   */
	unsigned char no_rque;   /* number of req queues */
}SG_DBLK;

#endif	/* _SYS_QUEUE_H */
 070701000059d2000081240000000200000002000000012719347c000004c0000000230000000c00000000000000000000001a00000000usr/include/sys/recover.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sys/recover.h.sl 1.1 4.0 10/15/90 13824 AT&T-SF"

extern struct rd_user * cr_rduser();
extern void del_rduser();
extern void clean_GEN_rd();
extern void cleanup();


/* opcodes */
#define REC_DISCONN	1	/* circuit gone */
#define REC_KILL	2	/* exit */
#define REC_FUMOUNT	3	/* forced unmount */
#define REC_MSG		4 

/* rfdaemon msgflag flags */
#define  MORE_SERVE	0x001
#define  DISCONN	0x002
#define  RFSKILL	0x004
#define  FUMOUNT	0x008
#define  DEADLOCK	0x010

/* active general and specific RDs */
#define ACTIVE_GRD(R) 	((R->rd_stat & RDUSED) && \
	    		(R->rd_qtype & GENERAL) && (R->rd_user_list))
#define ACTIVE_SRD(R)   ((R->rd_stat & RDUSED) && \
		         (R->rd_user_list != NULL) && \
		         (R->rd_qtype & SPECIFIC))

/* This is the structure that gets passed to the user daemon */
#define ULINESIZ 120	/* want a 128-char buffer */
struct u_d_msg {
	int opcode;
	int count;
	char res_name[ULINESIZ];
};

070701000059d3000081240000000200000002000000012719347c00000322000000230000000c00000000000000000000001600000000usr/include/sys/reg.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_REG_H
#define _SYS_REG_H

#ident	"@(#)/usr/include/sys/reg.h.sl 1.1 4.0 10/15/90 48256 AT&T-SF"

/*
 * Location of the users' stored registers relative to EAX.
 * Usage is u.u_ar0[XX].
 *
 * NOTE: ERR is the error code.
 */

#define SS	18
#define UESP	17
#define EFL	16
#define CS	15
#define EIP	14
#define ERR	13
#define TRAPNO	12
#define EAX	11
#define ECX	10
#define EDX	9
#define EBX	8
#define ESP	7
#define EBP	6
#define ESI	5
#define EDI	4
#define DS	3
#define ES	2
#define FS	1
#define GS	0

#endif	/* _SYS_REG_H */
  070701000059d4000081240000000200000002000000012719347c00000263000000230000000c00000000000000000000001900000000usr/include/sys/region.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/region.h.sl 1.1 4.0 10/15/90 6398 AT&T-SF"

/* This header file, region.h is kept for source compatibility for those
 * pre-SVR4.0 applications that may include it, but are not regions-based.
 * SVR4.0 memory management is implemented using VM and will not support
 * any application which depends upon regions.
 */
 070701000059d5000081240000000200000002000000012719347c000006ed000000230000000c00000000000000000000001900000000usr/include/sys/regset.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_REGSET_H
#define _SYS_REGSET_H

#ident	"@(#)/usr/include/sys/regset.h.sl 1.1 4.0 10/15/90 25909 AT&T-SF"

/* General register access (3B2) */

typedef int greg_t;
#ifdef u3b2
#define NGREG   16
#endif

#ifdef i386
#define NGREG   19
#endif

typedef	greg_t	gregset_t[NGREG];

#ifdef u3b2
#define	R_R0	0
#define	R_R1	1
#define	R_R2	2
#define	R_R3	3
#define	R_R4	4
#define	R_R5	5
#define	R_R6	6
#define	R_R7	7
#define	R_R8	8
#define	R_FP	9
#define	R_AP	10
#define	R_PS	11
#define	R_SP	12
#define	R_PCBP	13
#define	R_ISP	14
#define	R_PC	15

/* Floating-point register access (3B2 MAU) */

typedef	struct fpregset {
	int	f_asr;
	int	f_dr[3];
	int	f_fpregs[4][3];
} fpregset_t;
#endif  /* u3b2 */

#ifdef i386
/*
 * The following picks up the defines for '386 registers.
 *
 */

#include <sys/reg.h>

typedef struct fpregset {
    union {
        struct fpchip_state     /* fp extension state */
        {
            int state[27];  /* 287/387 saved state */
            int status;     /* status word saved at exception */
        } fpchip_state;
        struct fp_emul_space        /* for emulator(s) */
        {
            char    fp_emul[246];
            char    fp_epad[2];
        } fp_emul_space;
        int f_fpregs[62];       /* union of the above */
    } fp_reg_set;
    long    f_wregs[33];            /* saved weitek state */
} fpregset_t;

#define NDEBUGREG	8

typedef struct dbregset {
	unsigned	debugreg[NDEBUGREG];
} dbregset_t;

#endif  /* i386 */


#endif	/* _SYS_REGSET_H */
   070701000059d6000081240000000200000002000000012719347c0000052f000000230000000c00000000000000000000001b00000000usr/include/sys/resource.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RESOURCE_H
#define _SYS_RESOURCE_H

#ident	"@(#)/usr/include/sys/resource.h.sl 1.1 4.0 10/15/90 6965 AT&T-SF"
/*
 * Process priority specifications
 */

#define	PRIO_PROCESS	0
#define	PRIO_PGRP	1
#define	PRIO_USER	2


/*
 * Resource limits
 */

#define	RLIMIT_CPU	0		/* cpu time in milliseconds */
#define	RLIMIT_FSIZE	1		/* maximum file size */
#define	RLIMIT_DATA	2		/* data size */
#define	RLIMIT_STACK	3		/* stack size */
#define	RLIMIT_CORE	4		/* core file size */
#define RLIMIT_NOFILE	5		/* file descriptors */
#define RLIMIT_VMEM	6		/* maximum mapped memory */

#define	RLIM_NLIMITS	7		/* number of resource limits */
#define RLIMIT_AS	RLIMIT_VMEM
#define	RLIM_INFINITY	0x7fffffff

typedef unsigned long rlim_t;

struct rlimit {
	rlim_t	rlim_cur;		/* current limit */
	rlim_t	rlim_max;		/* maximum value for rlim_cur */
};

#ifdef _KERNEL

extern struct rlimit rlimits[];

#if defined(__STDC__)

extern int rlimit(int, rlim_t, rlim_t);

#else

extern int rlimit();

#endif	/* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _SYS_RESOURCE_H */
 070701000059d7000081240000000200000002000000012719347c00000c04000000230000000c00000000000000000000001900000000usr/include/sys/rf_adv.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/rf_adv.h.sl 1.1 4.0 10/15/90 49198 AT&T-SF"

#ifndef _SYS_RF_ADV_H
#define _SYS_RF_ADV_H

/*
 * Resource structure, supplants both advertise table and server mount
 * table.  Each advertised resource has an entry in this table holding
 * necessary info, including a list of info about each remote mount of
 * the resource.
 */

#define RFS_NMSZ 15		/* size of advertised name */

typedef struct sr_mount {
	struct sr_mount *srm_nextp;	/* ptr to next in list */
	struct sr_mount *srm_prevp;	/* ptr to prev in list */
	sysid_t 	srm_sysid;	/* which client */
	ushort  	srm_flags;	/* see sr_flag values below */
	long     	srm_mntid;	/* denotes mounted resource on client */
	int 		srm_kbcnt;	/* Kbytes read/written by this client */
	int 		srm_refcnt;	/* number of outstanding gifts */
	int		srm_slpcnt;	/* used by fumount, recover */
} sr_mount_t;

/* sr_flag values */
#define	SRM_RDONLY	1	/* This mount is read only */
#define SRM_LINKDOWN 	2	/* Link to client is down */ 
#define SRM_FUMOUNT	4	/* being fumounted */
#define SRM_CACHE	8	/* this client is cacheing this resource */

typedef struct rf_resource {
	struct rf_resource *r_nextp;	/* ptr to next in list */
	struct rf_resource *r_prevp;	/* ptr to prev in list */
	/*
	 * r_mountp heads the list of sr_mount structures for this resource.
	 */
	struct sr_mount *r_mountp;	
	int		r_flags;		/* see values below */
	struct vnode   *r_rootvp;		/* root vnodep */
	char		r_name[RFS_NMSZ];	/* sent to name server */
	struct	rcvd   *r_queuep;		/* receive queue */
	char	       *r_clistp;		/* authorization list */
	/*
	 * Pre-release 4 clients expect to be given an index into the server's
	 * srmount table when they mount a resource, then pass that back
	 * to the server with each request.  The srmount table is no longer
	 * used in RFS, so a replacement to that index is r_mntid which is a
	 * pseudo index used for the same purpose.
	 */
	long		r_mntid;	
} rf_resource_t;

/* r_flag values */
#define R_RDONLY	1	/* advertised read only */
#define R_CACHEOK    	2	/* files are cacheable */
#define R_UNADV		4	/* unadvertised, but not free yet */
#define R_FUMOUNT	8	/* being fumounted */

typedef struct rf_resource_head {
	rf_resource_t *rh_nextp;
	rf_resource_t *rh_prevp;
} rf_resource_head_t;

extern rf_resource_head_t rf_resource_head;

extern int	nsrmount;	/* configurable limit on srmounts */
extern uint	srm_count;	/* number of extant srmounts */

extern rf_resource_t *ind_to_rsc();
extern rf_resource_t *vp_to_rsc();
extern rf_resource_t *name_to_rsc();
extern char *rsc_nm();
extern int localrsrc();
extern rf_resource_t *allocrsc();
extern int insertrsc();
extern void freersc();
extern sr_mount_t *id_to_srm();
extern int srm_alloc();
extern int srm_remove();
extern void srm_free();

#endif	/* _SYS_RF_ADV_H */
070701000059d8000081240000000200000002000000012719347c00000d70000000230000000c00000000000000000000001c00000000usr/include/sys/rf_cirmgr.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RF_CIRMGR_H
#define _SYS_RF_CIRMGR_H

#ident	"@(#)/usr/include/sys/rf_cirmgr.h.sl 1.1 4.0 10/15/90 27121 AT&T-SF"

#define MAXTOKLEN sizeof(rf_token_t)       /* maximum token length in bytes */

struct gdpmisc {
        int	hetero;
        int	version;
        int	ngroups_max;
};
typedef struct gdpmisc gdpmisc_t;

struct rf_token {
        int     t_id;    /* token id for differentiating multiple ckts  */
        char    t_uname[MAXDNAME]; /* full domain name of machine */
};
typedef struct rf_token rf_token_t;

struct gdp {
	struct queue	*queue;		/* pointer to associated stream head */
	struct file	*file;		/* to stream head we stole */
	short		mntcnt;		/* number of mounts on this stream */
	sysid_t		sysid;
	short		constate;	/* connection info */
	struct {
		char	istate;		/* input state machine */
		int	oneshot : 1;	/* 1 if expect to find entire incoming
					 * message in queue at same time */
		int	mcdecan	: 1;	/* messsage and common headers already
					 * decanonized */
		int	rhdecan : 1;	/* request or response header already
					 * decanonized */
	} input;
	int		hetero;		/* need to canonicalize messages */
	int		version;	/* RFS version at the other end */
	long		timeskew_sec;	/* time skew in sec */
	rf_token_t	token;		/* circuit identification */
	char		*idmap[2];	/* 0=uid=UID_DEV, 1=gid=GID_DEV */
	ushort		timeout;
	struct msgb	*hdr;		/* message header collected so far */
	struct msgb	*idata;		/* request/response collected so far */
	size_t		hlen;		/* header length yet to be collected */
	size_t		rhlen;		/* saved request/response header len */
	size_t		dlen;		/* data length yet to be collected */
	size_t		maxpsz;		/* max TIDU size of the provider */
	int		ngroups_max;	/* max # suppl. groups per user */
	size_t		datasz;		/* max data in RFS message */
    ulong       outseq;
    ulong       inseq;

};
typedef struct gdp gdp_t;

/*
 * Sysids are unique only among pairs of machines and are constructed
 * as follows:
 *      hibyte:  index on other machine of GDP on that end of virtual
 *               circuit
 *      lobyte:  index of GDP on this end of virtual circuit
 * TO DO:  network-unique sysids
 */
#define SDTOSYSID(sdp)	((gdp_t *)(sdp)->sd_queue->q_ptr)->sysid
#define QPTOGP(qp)	((gdp_t *)((queue_t *)(qp))->q_ptr)
extern int maxgdp;
extern gdp_t *gdp;


/* GDP circuit states */
#define GDPFREE		0
#define GDPCONNECT	1	/* sound circuit */
#define GDPDISCONN	2	/* not yet in recovery */
#define GDPRECOVER	4

/* istate */
#define GDPSTGMC	0 /* gathering rf_message_t and rf_common_t headers */
#define GDPSTPMC	1 /* pulling up rf_message_t and rf_common_t headers */
#define GDPSTGR		2 /* gathering rf_request_t or rf_response_t header */
#define GDPSTPR		3 /* pulling up rf_request_t or rf_response_t header */
#define GDPSTGD		4 /* gathering data */

/* RFS version numbers */
#define RFS1DOT0	1
#define RFS2DOT0	2

#ifdef _KERNEL

extern queue_t	*gdp_sysidtoq();
extern int	gdp_get_circuit();
extern void	gdp_put_circuit();
extern int	gdp_init();
extern void	gdp_discon();
extern void	gdp_j_accuse();
extern void	gdp_kill();
extern void	gdp_put_discon();

#endif /* _KERNEL */

#endif /* _SYS_RF_CIRMGR_H */
070701000059d9000081240000000200000002000000012719347c00002cb6000000230000000c00000000000000000000001a00000000usr/include/sys/rf_comm.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RF_COMM_H
#define _SYS_RF_COMM_H

#ident	"@(#)/usr/include/sys/rf_comm.h.sl 1.1 4.0 10/15/90 48607 AT&T-SF"

/* parameters of this implementation */

#define NADDRLEN	6	/* length of network address */

#define RF_UP		1	/* on network */
#define RF_DOWN 	0	/* not on network */
#define RF_INTER 	2	/* RFS in an intermediate state */

#ifndef TRUE
#define TRUE	1
#define FALSE	0
#endif

#ifndef NULL
#define NULL	0
#endif

/* is a receive queue empty? */
#define RCVDEMP(RD)	LS_ISEMPTY(&(RD)->rd_rcvdq)

typedef struct naddr	{
	ushort	length;
	char	address[NADDRLEN];
} naddr_t;

/*
 * receive descriptor structure
 */

typedef struct rcvd	{
	union {
		/* vp for RDGENERAL, sdp for RDSPECIFIC */
		struct vnode	*rdun_vp;
		struct sndd	*rdun_sdp;
	} rd_un;
	ls_elt_t 	rd_rcvdq;	/* receive descriptor queue */
	time_t		rd_mtime;	/* last write time - for cache */
	struct rd_user	*rd_user_list;	/* one for each time RD is a gift
					 * - meaningful only for general RD */
	struct rcvd	*rd_next;	/* pointer to next rcvd */
	long		rd_gen;		/* generation for gifts */
	int		rd_qslp;	/* recv desc queue sleep lock */
	char		rd_stat;	/* flags */
	char		rd_qtype;	/* RDGENERAL or RDSPECIFIC */
	ushort		rd_qcnt;	/* how many msgs queued */
	int		rd_refcnt;	/* how many remote clients */
} rcvd_t;

#define rd_vp	rd_un.rdun_vp
#define rd_sdp	rd_un.rdun_sdp

/* rd_stat values */
#define RDUSED		0x1
#define RDUNUSED	0x2
#define RDLINKDOWN	0x4
#define RDWANT		0x10
#define RDLOCKED	0x20

/* rd_qtype */
#define RDGENERAL	0x1
#define RDSPECIFIC	0x2

/* active general and specific RDs */
#define ACTIVE_GRD(rdp) \
 ((rdp)->rd_stat & RDUSED && (rdp)->rd_qtype & RDGENERAL && (rdp)->rd_user_list)
#define ACTIVE_SRD(rdp) \
 ((rdp)->rd_stat & RDUSED && (rdp)->rd_qtype & RDSPECIFIC)

/*
 * given a ptr to an rd, yield ptr to denoted sd
 */
#define RDTOSD(rdp)	((rdp) ? (rdp)->rd_sdp : NULL)
/*
 * given a ptr to an rd, yield ptr to denoted vnode
 */
#define RDTOV(rdp)	((rdp) ? (rdp)->rd_vp : NULLVP)
/*
 * given a ptr to a vnode, yield ptr to denoted rd
 */
#define VTORD(vp)	(vtord(vp))

extern rcvd_t	*rcvd;

/*
 * A send descriptor is the send end of a channel to a
 * remote system and contains a pointer to a virtual circuit that
 * identifies the remote machine.
 *
 * On the client side the send descriptor is kept as the file system
 * specific part (lower level) of the corresponding vnode for a persistent
 * reference, and as a temporary channel for a transient reference.
 *
 * Each server has its own private send descriptor that it uses to
 * send replies.  This send descriptor on the server does not point
 * to any particular resource.
 *
 * For the client side send descriptor, the sd_mntid is a cookie
 * used to access the remote side's resource list so that counts can
 * be kept properly for umount.	In the server side send descriptor
 * this same field is used as a cookie into the local resource list.
 */

typedef struct sndd {
	ls_elt_t 	sd_hash;	/* for hash list links */
	ls_elt_t	sd_free;	/* for free list links */
	long		sd_size;
	char		sd_stat;
	rf_gift_t	sd_gift;	/* for the remote rcvd */
	long 		sd_mntid;	/* denotes remote srmount entry */
	struct proc	*sd_srvproc;	/* points to proc of dedicated server */
	struct queue	*sd_queue;	/* points to stream head queue */
	long		sd_fhandle;	/* file handle for client caching */
	ulong		sd_vcode;	/* file vcode for client caching */
	daddr_t		sd_nextr;	/* read-ahead offset */
	/*
	 * Clients talking to 3.x servers sometimes hide stuff in sd_stashp.
	 */
	struct dustash	*sd_stashp;
	/*
	 * Clients talking to 4.0++ servers remember their contribution to
	 * the server's v_count in sd_remcnt.
	 */
	long		sd_remcnt;
	struct {
		int	want : 1;
		int	writer : 1;
		uint	nreaders;
	} sd_crwlock;			/* n readers, 1 writer in cache */
	struct vnode	sd_vn;		/* upper level node denoting sd */
} sndd_t;

/*
 * Values for sd_stat.  These must NOT be overloaded.
 */
#define SDUNUSED	0
#define SDUSED		0x1
#define SDLOCKED	0x2
#define SDLINKDOWN	0x4
#define SDSERVE		0x8
#define SDWANT		0x10
#define SDCACHE		0x20	/* remote file is cacheable */
#define SDMNDLCK	0x40	/* remote file mandatory lock set
				 * Old protocol only.
				 * (not updated if someone turns off mandatory
				 * lock with chmod on remote file before
				 * last file close)
				 */
#define SDINTER		0x80

/*
 * given a ptr to an sd, yield ptr to denoted vnode
 */
#define SDTOV(sdp)	(&(sdp)->sd_vn)
/*
 * given a ptr to a vnode, yield ptr to denoted sd
 */
#define VTOSD(vp)	((struct sndd *)(vp)->v_data)
/*
 * yield the sd containing the referenced sd_hash or sd_free ls_elt_t
 */
#define HASHTOSD(hp)	\
	((sndd_t *)(((char *)(hp)) - (char *)&((sndd_t *)0)->sd_hash))
#define FREETOSD(fp)	\
	((sndd_t *)(((char *)(fp)) - (char *)&((sndd_t *)0)->sd_free))
/*
 * Lock and unlock send descriptors.
 */
#define SDLOCK(sdp) {				\
	while ((sdp)->sd_stat & SDLOCKED) {	\
	    (sdp)->sd_stat |= SDWANT;		\
	    (void) sleep((caddr_t)(sdp), PSNDD);\
	}					\
	(sdp)->sd_stat |= SDLOCKED;		\
}

#define SDUNLOCK(sdp) {				\
	ASSERT((sdp)->sd_stat & SDLOCKED);	\
	(sdp)->sd_stat &= ~SDLOCKED;		\
	if ((sdp)->sd_stat & SDWANT) {		\
	    (sdp)->sd_stat &= ~SDWANT;		\
	    wakeprocs((caddr_t)(sdp), PRMPT);	\
	}					\
}

extern sndd_t	*sndd;
extern void	sndd_hash();
extern void	sndd_unhash();

/*
 * Every time a client creates a new reference to a file the
 * server creates a reference to an rduser structure.	This
 * server action can take two forms :
 *	1) create a new rduser structure;
 *	2) increment the ru_vcount.
 * At the same time, the rd_refcnt is incremented.
 * Each counted reference to an rduser structure contributes
 * 1 to the v_count on that file on the server.
 */

typedef struct rd_user {
	long		ru_srmntid;	/* which srmount entry */
	struct rd_user	*ru_next;	/* next user */
	struct queue	*ru_queue;	/* which stream queue */
	ushort		ru_vcount;	/* references to denoted vnode */
	ushort		ru_gen;		/* generation number */
	ushort		ru_frwcnt;	/* n r/w opens */
	ushort		ru_frcnt;	/* n read opens */
	ushort		ru_fwcnt;	/* n write opens */
	ushort		ru_flag;	/* flag (see below for values) */
	ls_elt_t	ru_mapdlist;	/* heads list of mapping descriptors */
} rd_user_t;

/* ru_flag values */
#define RU_CACHE_ON		0x1	/* remote cacheing is enabled */
#define RU_CACHE_DISABLE	0x2	/* remote cacheing is disabled
					 * as opposed to being off entirely
					 * which is assumed when ru_flag
					 * is 0.  This is only necessary
					 * for old clients who only expect
					 * vcode and fhandle with gifts.
					 */
#define RU_MAPDLOCK		0x4	/* ru_mapdlist is locked */
#define RU_MAPDWANT		0x8	/* ru_mapdlist lock is wanted */

#define RU_R_CREAT		0x10	/* This client successfully created
					 * this file for reading.
					 */
#define RU_W_CREAT		0x20	/* This client successfully created
					 * this file for writing.
					 */
#define RU_DONE			0x40	/* When walking rd_user_list,
					 * already processed
					 */

/*
 * Each rd_user_t has a list of rf_mapd_t's describing a client machine's
 * mappings to a file.  rfm_prots counts the number of times that each
 * combination of the PROT_READ, PROT_WRITE, and PROT_EXEC bits
 * are used in the maxprot of mappings to an offset/length pair.
 *
 * NOTE: rfm_prots[0] is present as padding for coding convenience. 
 * maxprot == 0 is disallowed by the vm/vfs interface.
 */
typedef struct rf_mapd {
	ls_elt_t	rfm_list;	/* heads list of mapping descriptors */
	off_t		rfm_off;	/* file offset of mapping */
	size_t		rfm_len;	/* length of mapping */
	uint		rfm_prots[8];	/* counts of R, W, RW, X, RX, WX, RWX */
} rf_mapd_t;

extern rd_user_t	*rd_user;

/* tunables */
extern int	nrcvd;		/* number of receive descriptors */
extern int	nsndd;		/* number of send descriptors */
extern int	nrduser;	/* number of rd_user entries */
extern int	maxserve;
extern int	minserve;

/*
 * rf_maxkmem limits persistently allocated kernel memory used by rfs, including
 * idmapping info, authorization lists and mapping descriptors.  A zero value
 * means no limit.  rf_availkmem is the amount of the maximum remaining.
 */
extern int	rf_maxkmem;
extern int	rf_availkmem;

#ifdef _KERNEL

extern void	rf_freeb();
extern void	rf_freemsg();

extern mblk_t	*rf_dequeue();

extern int	sndd_create();
extern void	sndd_free();

#if defined(DEBUG)
#define sndd_set(sd, queue, giftp)				\
	((void)(ASSERT((sd)->sd_stat & SDUSED),			\
	  (sd)->sd_queue = (queue_t *)(queue), (sd)->sd_gift = (giftp)[0]))
#else
#define sndd_set(sd, queue, giftp)			\
	((void)((sd)->sd_queue = (queue_t *)(queue),	\
		(sd)->sd_gift = (giftp)[0]))
#endif /* DEBUG */

extern int	rf_sndmsg();
extern		rf_rcvmsg();

extern int	rf_allocmsg();
extern int	rf_allocb();

extern int	rcvd_create();
extern void	rcvd_delete();
extern void	rcvd_free();
extern rcvd_t	*vtord();

extern mblk_t	*rf_dequeue();
extern int	rf_comminit();
extern void	rf_commdinit();
extern void	rf_deliver();

#ifdef DEBUG
extern int	rdu_match();
#else
#define rdu_match(rdup, sid, mntid) \
  (QPTOGP((rdup)->ru_queue)->sysid == (sid) && (rdup)->ru_srmntid == (mntid))
#endif

extern int	rfesb_fbread();
extern int	rfesb_pageio_setup();

#define NULLFRP		((frtn_t *)NULL)
#define NULLCADDR	((caddr_t)NULL)
#define NULLUIO		((uio_t *)NULL)
#define NULLCRED	((cred_t *)NULL)

/*
 * Signal conversion ops.
 *	rf_response_t	*rp;
 *	int		vcver;	-- virtual circuit version
 *	k_sigset_t	*kp;
 */
#define rf_sigisempty(rp, vcver)	\
	((vcver) == RFS1DOT0 ?	\
	  (rp)->rp_v1sig == 0 : (rp)->rp_v2sigset.word[0] == 0)

#define rf_setrpsigs(rp, vcver, kp)	\
	((void)((vcver) == RFS1DOT0 ?	\
	  ((rp)->rp_v1sig = (kp)[0]) : ((rp)->rp_v2sigset.word[0] = (kp)[0])))

#define rf_getrpsigs(rp, vcver, kp)	\
	((void)((vcver) == RFS1DOT0 ?	\
	  ((kp)[0] = (rp)->rp_v1sig) : ((kp)[0] = (rp)->rp_v2sigset.word[0])))

#define rf_clrrpsigs(rp, vcver)	\
	((void)((vcver) == RFS1DOT0 ?	\
	  ((rp)->rp_v1sig = 0) : ((rp)->rp_v2sigset.word[0] = 0)))

extern void	rf_postrpsigs();
extern void	rf_delsig();

/*
 * Operations on rd_user structures.
 */
extern rd_user_t	*rdu_get();
extern rd_user_t	*rdu_find();
extern void		rdu_del();
extern void		rdu_open();
extern int		rdu_modecheck();

extern void		rftov_attr();
extern void		vtorf_attr();
extern int		rf_pullupmsg();
extern void		rf_iov_alloc();
extern mblk_t		*rf_dropbytes();
extern caddr_t		rf_msgdata();

extern rcvd_t	*rf_gifttord();
extern vnode_t	*rf_gifttovp();

/* Gift templates. */
extern rf_gift_t	rf_daemon_gift;
extern rf_gift_t	rf_null_gift;

#define RF_IOV_FREE(iovp, niov)	\
	kmem_free((caddr_t)(iovp), (size_t)((niov) * sizeof(iovec_t)))

/* fast for simple cases */
#ifdef DEBUG
#define RF_PULLUP(bp, hdrsz, datasz) \
	(RF_MSG(bp)->m_size == (hdrsz) + (datasz) && !(bp)->b_cont ? \
	  (ASSERT((bp)->b_wptr - (bp)->b_rptr == RF_MSG(bp)->m_size), 0) : \
	  rf_pullupmsg((bp), (hdrsz), (datasz)))
#else
#define RF_PULLUP(bp, hdrsz, datasz) \
	(RF_MSG(bp)->m_size == (hdrsz) + (datasz) && !(bp)->b_cont ? 0 : \
	  rf_pullupmsg((bp), (hdrsz), (datasz)))
#endif

#if defined(u3b2) && !defined(lint) && !defined(CXREF)
asm	int
ipl()
{
	ANDW3 &0x1e000,%psw,%r0
}
#endif

#endif /* _KERNEL */
#endif /* _SYS_RF_COMM_H */
  070701000059da000081240000000200000002000000012719347c000009c7000000230000000c00000000000000000000001b00000000usr/include/sys/rf_debug.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RF_DEBUG_H
#define _SYS_RF_DEBUG_H

#ident	"@(#)/usr/include/sys/rf_debug.h.sl 1.1 4.0 10/15/90 21380 AT&T-SF"
/* RFS debugging */

#define DB_SYSCALL	0x001	/* remote system calls */
#define DB_SD_RD	0x002	/* send and receive descriptors */
#define DB_SERVE	0x004	/* servers and server-control */
#define DB_MNT_ADV	0x008	/* advertising and remote mounts */
#define DB_RFSTART	0x010	/* rfstart, rfstop */
#define DB_RECOVER	0x020	/* rf_recovery */
#define DB_RDUSER	0x040	/* rd_user structures */
#define DB_RDWRI	0x080	/* remote readi/writei */
#define DB_PROT		0x100	/* protocol */
#define DB_COMM		0x200	/* communication interface */
#define DB_GDP		0x400	/* GDP */
#define DB_PACK		0x800	/* PACK stream interface */
#define DB_RMOVE	0x1000	/* rmove */
#define DB_RSC		0x2000	/* RSC ACK and NACK */
#define DB_RFSYS	0x4000	/* miscellaneous sys call */
#define DB_SIGNAL       0x8000  /* signal */
#define DB_GDPERR       0x10000  /* GDP temporary error */
#define NO_RETRANS      0x20000  /* turn off retransmission */
#define NO_RECOVER      0x40000  /* turn off rf_recovery */
#define NO_MONITOR      0x80000  /* turn off monitor */
#define DB_CANON     	0x100000  /* canonical form conversion */
#define	DB_FSS		0x200000  /* file sys type debugging */
#define DB_CACHE	0x400000  /* client cache debugging */
#define DB_LOOPBCK	0x800000  /* allow machine to mount own resources */

#if defined(_KERNEL) && ((DUDEBUG == YES) || defined(DEBUG))

extern	long	dudebug;
extern char	*rf_sysname();

/* mdash: printf() |--> cmn_err(CE_CONT) */
#define	DUPRINT1(x,y1) if (dudebug & x) cmn_err(CE_CONT,y1);
#define	DUPRINT2(x,y1,y2) if (dudebug & x) cmn_err(CE_CONT,y1,y2);
#define	DUPRINT3(x,y1,y2,y3) if (dudebug & x) cmn_err(CE_CONT,y1,y2,y3);
#define	DUPRINT4(x,y1,y2,y3,y4) if (dudebug & x) cmn_err(CE_CONT,y1,y2,y3,y4);
#define	DUPRINT5(x,y1,y2,y3,y4,y5) if (dudebug & x) cmn_err(CE_CONT,y1,y2,y3,y4,y5);
#define DUPRINT6(x,y1,y2,y3,y4,y5,y6) if (dudebug & x) cmn_err(CE_CONT,y1,y2,y3,y4,y5,y6);
#else
#define	DUPRINT1(x,y1)
#define	DUPRINT2(x,y1,y2)
#define	DUPRINT3(x,y1,y2,y3)
#define	DUPRINT4(x,y1,y2,y3,y4)
#define	DUPRINT5(x,y1,y2,y3,y4,y5)
#define	DUPRINT6(x,y1,y2,y3,y4,y5,y6)

#endif
#endif /* _SYS_RF_DEBUG_H */
 070701000059db000081240000000200000002000000012719347c00004aa6000000230000000c00000000000000000000001b00000000usr/include/sys/rf_messg.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RF_MESSG_H
#define _SYS_RF_MESSG_H

#ident	"@(#)/usr/include/sys/rf_messg.h.sl 1.1 4.0 10/15/90 53879 AT&T-SF"

/*
 * RFS network message definitions
 *
 * TO DO:  make message formats regular!
 */

#define RF_MAXSNAME	20	/* machine name size in mnt_data */

/*
 * maximum # of group id's per user, can only be increased with a new
 * version of rf_request_t.
 */
#define RF_MAXGROUPS	32

/*
 * A gift denotes a reference to a remote receive descriptor.  If the
 * gift denotes a GENERAL receive descriptor, the receive descriptor
 * is on a server, is persistent, and in turn denotes a file
 * on the server.  Otherwise the receive descriptor is SPECIFIC,
 * transient, and is merely one end of a communications channel.
 * gift_gen tags instances of the denoted receive descriptor, is
 * undefined for old clients/servers.
 */
typedef struct rf_gift {
	long	gift_id;
	long	gift_gen;
} rf_gift_t;

#ifdef _KERNEL

#define DU_DATASIZE	1024	/* max data bytes in old protocol message */

/*
 * RFS file attributes.
 */
typedef struct rf_attr {
	long		rfa_mask;	/* bit-mask of attributes */
	long		rfa_type;	/* vnode type (for create) */
	long		rfa_mode;	/* file access mode */
	long		rfa_uid;	/* owner user id */
	long		rfa_gid;	/* owner group id */
	long		rfa_fsid;	/* file system id (dev for now) */
	long		rfa_nodeid;	/* node id */
	long		rfa_nlink;	/* number of references to file */
	long		rfa_size;	/* file size in bytes */
	timestruc_t	rfa_atime;	/* time of last access */
	timestruc_t	rfa_mtime;	/* time of last modification */
	timestruc_t	rfa_ctime;	/* time file ``created'' */
	long		rfa_rdev;	/* device the file represents */
	long		rfa_blksize;	/* fundamental block size */
	long		rfa_nblocks;	/* # of blocks allocated */
	long		rfa_filler[8];
} rf_attr_t;

/*
 * RFS signal set.  Two longs are PLENTY until the next major protocol rev.
 */
typedef struct rf_sigset {
	long	word[2];
} rf_sigset_t;

/*
 * The message structure is the header to every message.
 */
typedef struct rf_message {
	long		filler0;	/* used as sequence w/ DEBUG */
	long	 	m_stat;		/* see stat values below */
	rf_gift_t	m_dest;		/* rcvd to which this goes */
	rf_gift_t	m_gift;		/* rcvd of reference we are giving */
	long 		m_size;		/* size of this message	*/
	long		m_queue;	/* streams queue message came in on */
} rf_message_t;

/*
 * Point to rf_message_t in streams data block;
 * argument is pointer to streams message block.
 */
#define RF_MSG(p)	((rf_message_t *)(p)->b_rptr)

/* m_stat values */
#define RF_GIFT		0x8		/* are address & index real? */
#define RF_SIGNAL	0x10		/* set for signal messages */
#define RF_VER1		0x20		/* set for NACKABLE messages */


/*
 * Well-known receive queue indices.
 * SIGRDX used to be 1, but that symbol was unused.  DAEMON_RD
 * remains 2 for compatibility.
 */
#define MOUNT_RD	0L	/* Mount request receive descriptor */
#define DAEMON_RD	2L	/* Recovery receive descriptor */

/*
 * In the original remote system call protocol, opcodes for remote service
 * frequently correspond to system call numbers.
 * The "DU" prefix is retained for operations that are always based on
 * system calls, or are specific to the system call protocol.
 *
 * Operations shared between the system call and operation protocol, or
 * specific to the latter, use the "RF" prefix, even though they may
 * still use system call number for compatability.
 *
 * For ops protocol that does not look at u.u_syscall (except for wretched
 * hook in rf_lookup preventing mounts on remote names), the sysent table
 * is of no concern, and opcodes can be chosen arbitrarily.
 */
#define RFSETFL		0
#define RFDELMAP	1
#define RFADDMAP	2
#define RFREAD		3
#define RFWRITE		4
#define RFOPEN		5
#define RFCLOSE		6
#define RFLOOKUP	7
#define RFCREATE	8
#define DULINK		9
#define DUUNLINK	10
#define DUEXEC		11
#define DUCHDIR		12
#define RFPUTPAGE	13
#define DUMKNOD		14
#define DUCHMOD		15
#define DUCHOWN		16
#define RFGETPAGE	17
#define DUSTAT		18
#define DUSEEK		19
#define RFGETATTR	20	/* for VOP_GETATTR */
#define DUMOUNT		21	/* retained for compatability;
				 * mount(2), not old rmount(2)
				 * must '..' back to client */
#define DUUMOUNT	22	/* retained for compatability;
				 * umount(2), not old rumount(2)
				 * must '..' back to client */
#define RFSETATTR	23	/* VOP_SETATTR */
#define RFACCESS	24	/* VOP_ACCESS */
#define RFPATHCONF	25	/* VOP_PATHCONF */
#define RFTMO		26	/* virtual circuit timeout */

#define DUFSTAT		28
#define DUUTIME		30
#define DUSACCESS	33	/* access system call */
#define DUSTATFS	35
#define DUFSTATFS	38
#define RFRENAME	40
#define DUSYSACCT	51	/* unused in protocol, but needed to recognize
				 * the sysacct() system call */
#define RFIOCTL		54
#define RFUSTAT  	57
#define RFFSYNC		58
#define DUEXECE		59
#define DUCHROOT	61
#define RFFCNTL		62
#define RFSPACE		63
#define RFFRLOCK	64
#define DURMOUNT	72	/* lookup on remote tree for mount;
				 * retained for compatability */
#define RFRMDIR		79
#define RFMKDIR		80
#define RFREADDIR	81
#define DULSTAT		88	/* unused in protocol, but needed to recognize
				 * the lstat() system call */
#define RFSYMLINK	89
#define RFREADLINK	90
#define RFMOUNT		97	/* differs from sys call for compatability;
				 * 3.X turned this into another op */
#define RFUMOUNT	98	/* differs from sys call for compatability;
				 * 3.X turned this into another op */
#define DUSTATVFS	103	/* name-based */
#define RFSTATVFS	104	/* vnode-based */
#define RFCOPYIN	106
#define RFCOPYOUT	107
#define RFLINK		109
#define DUCOREDUMP	111
#define DUWRITEI	112
#define DUREADI		113
#define RFRSIGNAL	119
#define RFSYNCTIME	122	/* date synchronization */
#define DUXSTAT		123	/* unused in protocol, but needed to recognize
				 * the xstat system call */
#define DULXSTAT	124	/* unused in protocol, but needed to recognize
				 * the lxstat system call */
#define RFDOTDOT	124	/* server sends this back to client when
				 * remote path crosses back to client */
#define RFPATHREVAL	125	/* path to be re-evaluated by client, for
				 * symlinks */
#define DUXMKNOD	126	/* unused in protocol, but needed to recognize
				 * the xmknod system call */
#define RFFUMOUNT	126	/* forced unmount */
#define RFSENDUMSG	127	/* send message to remote user-level */
#define RFGETUMSG	128	/* get message from remote user-level */
#define RFREMOVE	129
#define DULCHOWN	130	/* unused in protocol, but needed to recognize
				 * the lchown() system call */
#define RFINACTIVE	131
#define DUIUPDATE	132
#define DUUPDATE	133
/*
 * NOTE:  This overloading works ONLY because the two messages
 * have disjoint paths through RFS.  It is inevitable that something
 * like this would happen by virtue of the 3.X implementation using
 * existing syscall numbers and preempting future ones.
 */
#define DURENAME	134
#define RFCACHEDIS	134	/* disable cache */

/*
 * Precedes and discriminates response and request structures and
 * their variants.
 */
typedef struct rf_common {
	long	co_opcode;	/* what to do */
	long	co_sysid;	/* where we came from */
	long	co_type;	/* message type - request/response */
	long	co_pid;		/* client pid */
	long	co_uid;		/* client uid */
	long	co_gid;		/* client gid */
	long	co_ftype;
	union {
		long	nlink;	/* RFS1DOT0 only */
		long	svr4pad;
	} co_un;
	long	co_size;
	long	co_mntid;
} rf_common_t;

#define co_nlink co_un.nlink

/*
 * co_type values are tags for variant message types
 */
#define RF_REQ_MSG	1	/* request message */
#define RF_RESP_MSG	2	/* response message */
#define RF_NACK_MSG	3	/* RFS flow control nack message */

#define RF_COM(bp)	((rf_common_t *)(RF_MSG(bp) + 1))

#define RF_MCSZ		(sizeof(rf_message_t) + sizeof(rf_common_t))

/* Arg structures for RFS request opcodes.
 *
 * The svr3pad elements are to preserve alignment assumptions in
 * original protocol.  Do not depend on their continued existence.
 */
/* RFACCESS, DUCHMOD */
struct rqmode_op {
	long	svr3pad0;
	long	svr3pad1;
	long	svr3pad2;
	long	fmode;
};

struct rqchown {
	long	uid;
	long	gid;
};

/*
 * rqrele is used for RFS2DOT0 RFINACTIVE and RFUMOUNT requests
 */
struct rqrele {
	long	vcount;		/* unused in SVR3 */
};

/* unused in SVR3 */
struct rqpathconf {
	long	cmd;
};

#define RFPROT_TO_PROT(x) ((((x) & 0x1) ? PROT_READ : 0) |\
			   (((x) & 0x2) ? PROT_WRITE : 0) |\
			   (((x) & 0x4) ? PROT_EXEC : 0))

#define PROT_TO_RFPROT(x) ((((x) & PROT_READ) ? 0x1 : 0) |\
			   (((x) & PROT_WRITE) ? 0x2 : 0) |\
			   (((x) & PROT_EXEC) ? 0x4 : 0))
/*
 * Used by RFADDMAP, and RFDELMAP.  The server is able to record
 * current mapping because addmaps and delmaps also go remote.  Only maxprot
 * is sent in all cases because prot may be manipulated above the file
 * system interface.
 */
struct rqmap {
	long	offset;
	ulong	len;
	ulong	maxprot;
};

struct rqclose {
	long	vcount;		/* used only when lastclose */
	long	count;
	long	foffset;
	long	fmode;
	long	lastclose;	/* unused in SVR3 */
};

struct rqcreate {
	long	svr3pad0;
	long	ex;	/* unused in SVR3 */
	long	cmask;	/* unused in SVR4 */
	long	fmode;
};

struct rqfcntl {
	long	cmd;
	long	fcntl;
	long	offset;
	long	fflag;
	long	prewrite;
};
#define DUFRPREWRITE  0x20     /* Compatability:  redundant prewrite indicator
				* for file locks */

struct rqioctl {
	long	cmd;
	long	arg;
	long	svr3pad2;
	long	fflag;
};

struct rqmknod {
	long	svr3pad0;
	long	dev;
	long	cmask;
	long	fmode;
};

struct rqopen {
	long	svr3pad0;
	long	crtmode;
	long	cmask;
	long	fmode;
};

struct rqseek {
	long	svr3pad0;
	long	whence;
};

/* DUSTAT, DUFSTAT */
struct rqstat_op {
	long	buf;
};

/* DUSTATFS, DUFSTATFS */
struct rqstatfs_op {
	long	buf;
	long	len;
	long	fstyp;
};

struct rqutime {
	long	buf;
};

struct rqustat {
	long	buf;
	long	dev;
};

/* RFREAD(I), RFREADDIR, RFWRITE(I), RFGETPAGE
 */
struct rqxfer {
	long	offset;
	long	count;
	long	base;
	long	fmode;
	long	prewrite;		/* only used for RFWRITE */
};

struct rqmkdir {
	long	svr3pad0;
	long	svr3pad1;
	long	cmask;
	long	fmode;
};

struct rqsrmount {
	long	mntflag;
	long	svr3pad1;
	long	synctime;
};

struct rqslink {
	long 	tflag;
	long	targetln;
};

struct rqlink {
	rf_gift_t	from;	/* gen meaningful only SVR4 and later */
};

/*
 * Client pathname should be in "normal" form before it is sent with
 * a RFLOOKUP request.  Otherwise, path displacement with ".." or
 * ENOENT will be unexpected.
 */
struct rqlookup {
	long	flags;
};

/*
 * RFRENAME request.  We assume two canononized component names will
 * be able to fit in the data portion of the request.  If not the
 * call will fail gracefully.
 */
struct rqrename {
	rf_gift_t	from;
	rf_gift_t	to;
};

struct rqcoredump {
	long	svr3pad0;
	long	svr3pad1;
	long	cmask;
};

struct rqsynctime {
	long	svr3pad0;
	long	svr3pad1;
	long	time;
};

struct rqcachedis {
	long	fhandle;
	long	vcode;		/* SVR4 and later */
};

struct rqgetattr {
	long	mask;
	long	flags;
};

struct rqsetattr {
	long	flags;
};

/* SVR4 and later */
struct rqrmdir {
	rf_gift_t	dir;
};

/* RECOVERY OPCODES
 *
 * REC_FUMOUNT
 */
struct rqrec_fumount {
	long	srmntid;
};

/* REC_MSG */
struct rqrec_msg {
	long	svr3pad0;
	long	count;
};

union rq_arg {
	struct rqmode_op	rqmode_op;
	struct rqchown		rqchown;
	struct rqrele		rqrele;
	struct rqpathconf	rqpathconf;
	struct rqmap		rqmap;
	struct rqclose		rqclose;
	struct rqcreate		rqcreate;
	struct rqopen		rqopen;
	struct rqmknod		rqmknod;
	struct rqcoredump	rqcoredump;
	struct rqmkdir		rqmkdir;
	struct rqfcntl		rqfcntl;
	struct rqioctl		rqioctl;
	struct rqseek		rqseek;
	struct rqslink		rqslink;
	struct rqstat_op	rqstat_op;
	struct rqstatfs_op	rqstatfs_op;
	struct rqutime		rqutime;
	struct rqustat		rqustat;
	struct rqxfer		rqxfer;
	struct rqsrmount	rqsrmount;
	struct rqlink		rqlink;
	struct rqlookup		rqlookup;
	struct rqrename		rqrename;
	struct rqsynctime	rqsynctime;
	struct rqcachedis	rqcachedis;
	struct rqrec_fumount	rqrec_fumount;
	struct rqrec_msg	rqrec_msg;
	struct rqgetattr	rqgetattr;
	struct rqsetattr	rqsetattr;
	struct rqrmdir		rqrmdir;
};

/*
 * Header extenstion present only in messages later than version 1.
 * v2_ngroups and v2_groups extend the request message header and
 * the version 2 data portion is at a different offset from the old.
 */
struct rqv2 {
 	long	rqv2_ngroups;
 	long	rqv2_groups[RF_MAXGROUPS];
	long	rqv2_rrdir_gen;
	long	pad[2];		/* with RF_MAXGROUPS at 32, takes the
				 * message + request less data to 256 bytes */
};

/*
 * Op-specific structures that don't fit in the header go in
 * the data portion of the request.
 */

/*
 * VOP_SYMLINK, VOP_CREATE, and VOP_MKDIR create a new directory entry
 */
struct rqmkdent {
	rf_attr_t	attr;
	char		nm[MAXNAMELEN];
};

/*
 * for RFSYMLINK op; target is present if it can fit into the request.
 * Otherwise rqsymlink.target is undefined and the server will copy it in.
 */
struct rqsymlink {
	struct rqmkdent	rqmkdent;	/* link name and attributes */
	char		target[1];	/* begins target name string */
};

/*
 * SVR3 keeps write limit in blocks, SVR4 in bytes.  We continue
 * the message protocol convention of communicating blocks.
 */
#define ULIMSHIFT 9
#define R_ULIMIT		(u.u_rlimit[RLIMIT_FSIZE].rlim_cur)

typedef struct rf_request {
	long			rq_rrdir_id;
	daddr_t			rq_ulimit;
	union rq_arg		rq_arg;
	long			rq_flags;
	long			rq_sec;
	long			rq_nsec;
 	struct rqv2		rqv2;
} rf_request_t;

#define rq_mode_op	rq_arg.rqmode_op
#define rq_chown	rq_arg.rqchown
#define rq_rele		rq_arg.rqrele
#define rq_pathconf	rq_arg.rqpathconf
#define rq_map		rq_arg.rqmap
#define rq_close	rq_arg.rqclose
#define rq_create	rq_arg.rqcreate
#define rq_open		rq_arg.rqopen
#define rq_mknod	rq_arg.rqmknod
#define rq_coredump	rq_arg.rqcoredump
#define rq_mkdir	rq_arg.rqmkdir
#define rq_fcntl	rq_arg.rqfcntl
#define rq_ioctl	rq_arg.rqioctl
#define rq_seek		rq_arg.rqseek
#define rq_slink	rq_arg.rqslink
#define rq_stat_op	rq_arg.rqstat_op
#define rq_statfs_op	rq_arg.rqstatfs_op
#define rq_utime	rq_arg.rqutime
#define rq_ustat	rq_arg.rqustat
#define rq_xfer		rq_arg.rqxfer
#define rq_srmount	rq_arg.rqsrmount
#define rq_link		rq_arg.rqlink
#define rq_lookup	rq_arg.rqlookup
#define rq_rename	rq_arg.rqrename
#define rq_synctime	rq_arg.rqsynctime
#define rq_cachedis	rq_arg.rqcachedis
#define rq_rec_fumount	rq_arg.rqrec_fumount
#define rq_rec_msg	rq_arg.rqrec_msg
#define rq_getattr	rq_arg.rqgetattr
#define rq_setattr	rq_arg.rqsetattr
#define rq_rmdir	rq_arg.rqrmdir
#define rq_ngroups	rqv2.rqv2_ngroups
#define rq_groups	rqv2.rqv2_groups
#define rq_rrdir_gen	rqv2.rqv2_rrdir_gen

#define RF_REQ(bp)	((rf_request_t *)(RF_COM(bp) + 1))

/*
 * The size of a request message depends on the version of the circuit
 * over which it is sent.
 */
#define RFV1_MINREQ	(sizeof(rf_request_t) + RF_MCSZ - sizeof(struct rqv2))
#define RFV2_MINREQ	(sizeof(rf_request_t) + RF_MCSZ)
#define RF_MIN_REQ(version) (((version) == 1) ? RFV1_MINREQ : RFV2_MINREQ)

/* request flags (rq_flags) */
#define RQ_MNDLCK	0x1	/* used only by old protocol, suppresses
				 * inode locking on remote op and caching
				 * of mand lock-enabled files */

/* Arg structures for RFS response opcodes.
 *
 * The svr3pad elements are to preserve alignment assumptions in
 * original protocol.  Do not depend on their continued existence.
 */

/* These members are widely used, so we assume for now that all responses
 * have them.
 */
struct rp_all {
	union {
		long	v1sig;
		long	v2pad0;
	} all_u0;
	long 	nodata;	/* was subyte */
	union {
		/*
		 * This union is used only be RFWRITE(I) and RFFCNTL.
		 * The version code ('vcode') is used for client caching.
 		 * The 'offset' and 'cache' are overloaded by the server
		 * in case of opcode RFREADDIR.
		 */
		long	vcode;
		long	offset;
		long	cache;
	} all_u1;
	long	fhandle;	/* file handle for client caching */
};

/*
 * For old protocol ops that return new file references.
 */
struct rpv1giftinfo {
	long	svr3pad0;
	long	mode;
};

/* pathlen set by lookup, not by flakey /proc ioctl that opens a file */
struct rpv2giftinfo {
	long	pathlen;
	long	flags;
};
#define RPG_NOMAP	0x01
#define RPG_NOSWAP	0x02

/* RFREAD(I), RFWRITE(I) - used only by SVR4 server talking to old client */
struct rprdwr {
	long	isize;
	long	svr3pad1;
};

/* RFCOPYIN, RFREADDIR, DUFSTAT, DUFSTATFS, DUSTAT, DUSTATFS, RFUSTAT
 */
struct rpxfer {
	long	eof;
	long	buf;
};

struct rpcopyout {
	long	copysync;	/* vestige of static buffer allocation */
	long	buf;
};

struct rpfcntl {
	long	isize;	/* used only by SVR4 server talking to old client */
	long	buf;
};

struct rpsynctime {
	long	svr3pad0;
	long	time;
};

/*
 * Header extension present only in post-version 1 messages.
 */
struct rpv2 {
	rf_sigset_t	rpv2_sigset;
	long		pad[2];	/* takes the messsage + response less data
				 * to 128 bytes */
};

union rp_arg {
	struct rpv1giftinfo	rpv1giftinfo;
	struct rpv2giftinfo	rpv2giftinfo;
	struct rprdwr		rprdwr;
	struct rpxfer		rpxfer;
	struct rpcopyout	rpcopyout;
	struct rpfcntl		rpfcntl;
	struct rpsynctime	rpsynctime;
};

typedef struct rf_response {
	long			rp_errno;
	long			rp_v2vcode;
	long			rp_rval;	/* return value	 */
	long			rp_count;	/* not reliably set in 3.x */
	union rp_arg		rp_arg;
	struct rp_all		rp_all;
	struct rpv2		rpv2;
} rf_response_t;

#define RP_MNDLCK	0x8000	/* used only by old protocol, suppresses
				 * inode locking on remote op and caching
				 * of mand lock-enabled files */
#define RP_CACHE_ON	0x1	/* This file's data may be cached.  When
				 * this is set, rpv2_vcode is also set.
				 */
#define DU_CACHE_ENABLE 0x2     /* remote cacheing is enabled by 3.X server */


#define rp_v1giftinfo	rp_arg.rpv1giftinfo
#define rp_v2giftinfo	rp_arg.rpv2giftinfo
#define rp_rdwr		rp_arg.rprdwr
#define rp_xfer		rp_arg.rpxfer
#define rp_copyout	rp_arg.rpcopyout
#define rp_fcntl	rp_arg.rpfcntl
#define rp_synctime	rp_arg.rpsynctime
#define rp_v1sig	rp_all.all_u0.v1sig
#define rp_v2sigset	rpv2.rpv2_sigset
#define rp_nodata	rp_all.nodata
#define rp_vcode	rp_all.all_u1.vcode
#define rp_offset	rp_all.all_u1.offset
#define rp_cache	rp_all.all_u1.cache
#define rp_fhandle	rp_all.fhandle

#define RF_RESP(bp)	((rf_response_t *)(RF_COM(bp) + 1))

/*
 * RFLOOKUP responses ordinarily contain results of 3 VOP_ACCESS()'s and
 * a VOP_GETATTR().  These are briefly cached by the client in order to avoid
 * sending some messages.
 */
typedef struct rflkc_info {
	int		rflkc_read_err;
	int		rflkc_write_err;
	int		rflkc_exec_err;
	rf_attr_t	rflkc_attr;
} rflkc_info_t;

/*
 * The size of a request message depends on the version of the circuit
 * over which it is sent.
 */
#define RFV1_MINRESP	(sizeof(rf_response_t) + RF_MCSZ - sizeof(struct rpv2))
#define RFV2_MINRESP	(sizeof(rf_response_t) + RF_MCSZ)
#define RF_MIN_RESP(version) (((version) == 1) ? RFV1_MINRESP : RFV2_MINRESP)

#define RF_MAXHEAD(version) \
  (RF_MIN_RESP(version) >= RF_MIN_REQ(version) ? \
    RF_MIN_RESP(version) : RF_MIN_REQ(version))


#endif /* _KERNEL */
#endif /* _SYS_RF_MESSG_H */
  070701000059dc000081240000000200000002000000012719347c00000a07000000230000000c00000000000000000000001900000000usr/include/sys/rf_sys.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RF_SYS_H
#define _SYS_RF_SYS_H

#ident	"@(#)/usr/include/sys/rf_sys.h.sl 1.1 4.0 10/15/90 56962 AT&T-SF"

/* 
 * external interfaces to the rfsys system call 
 */
#include <sys/types.h>
#include <sys/nserve.h>
#include <sys/errno.h>

#ifdef _KERNEL
extern char rfs_domain[];       	/* local domain name */
extern struct queue *sysid_to_queue();
#endif

/* opcodes for rfsys system call */
#define RF_FUMOUNT      1       /* forced unmount */
#define RF_SENDUMSG     2       /* send buffer to remote user-level */
#define RF_GETUMSG      3       /* wait for buffer from remote user-level */
#define RF_LASTUMSG     4       /* wakeup from GETUMSG */
#define RF_SETDNAME     5       /* set domain name */
#define RF_GETDNAME     6       /* get domain name */
#define RF_SETIDMAP     7
#define RF_FWFD         8
#define RF_VFLAG        9
#define RF_VERSION      10
#define RF_RUNSTATE     11      /* see if RFS is running */
/*
 * return the value of one of the RFS system variables, needs one of the
 * values defined below
 */
#define RF_TUNEABLE     12
#define RF_CLIENTS      13      /* fill a buffer with info about remote use of a
                                 * local resource
                                 */
#define RF_RESOURCES    14      /* fill a buffer with info about local resources
                                 */
#define RF_ADVFS	15
#define RF_UNADVFS	16
#define RF_START	17
#define RF_STOP		18
#define RF_DEBUG	19

#ifdef RFSUNMOUNTHACK
/*
 * Support unmounting of stuff below gone rf_vfs.  This will be supplanted
 * by a general mechanism in a later release.
 */
#define RF_GETCAP	20
#define RF_PUTCAP	21
#define RF_SUBMNTS	22
#define RF_FUSERS	23
#define RF_UNMOUNT	24	/* cap expires after call */
#endif

/* RF_VFLAG options */
#define V_CLEAR 0
#define V_SET   1
#define V_GET   2

/* RF_VERSION options */
#define VER_CHECK       1
#define VER_GET         2

/* RF_TUNEABLE options */
#define T_NSRMOUNT      1
#define T_NADVERTISE    2

/* struct client is used by the RF_CLIENTS option */
struct client {
        sysid_t cl_sysid;
        int     cl_bcount;
        char    cl_node[MAXDNAME];
};

/* codes passed to the user daemon */
#define	RFUD_DISCONN	1
#define RFUD_FUMOUNT	2
#define RFUD_GETUMSG	3
#define RFUD_LASTUMSG	4

#endif	/* _SYS_RF_SYS_H */
 070701000059dd000081240000000200000002000000012719347c0000060d000000230000000c00000000000000000000001500000000usr/include/sys/rt.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RT_H
#define _SYS_RT_H

#ident	"@(#)/usr/include/sys/rt.h.sl 1.1 4.0 10/15/90 53295 AT&T-SF"
/*
 * Real-time dispatcher parameter table entry
 */
typedef struct	rtdpent {
	int	rt_globpri;	/* global (class independent) priority */
	long	rt_quantum;	/* default quantum associated with this level */
} rtdpent_t;


/*
 * Real-time class specific proc structure
 */
typedef struct rtproc {
	long		rt_pquantum;	/* time quantum given to this proc */
	long		rt_timeleft;	/* time remaining in procs quantum */
	short		rt_pri;		/* priority within rt class */
	ushort		rt_flags;	/* flags defined below */
	struct proc	*rt_procp;	/* pointer to proc table entry */
	char		*rt_pstatp;	/* pointer to p_stat */
	int		*rt_pprip;	/* pointer to p_pri */
	uint		*rt_pflagp;	/* pointer to p_flag */
	struct rtproc	*rt_next;	/* link to next rtproc on list */
	struct rtproc	*rt_prev;	/* link to previous rtproc on list */
} rtproc_t;


/* Flags */
#define RTRAN	0x0001		/* process has run since last swap out */
#define RTBACKQ	0x0002		/* proc goes to back of disp q when preempted */


#ifdef _KERNEL
/*
 * Kernel version of real-time class specific parameter structure
 */
typedef struct	rtkparms {
	short	rt_pri;
	long	rt_tqntm;
} rtkparms_t;
#endif	/* _KERNEL */

#endif	/* _SYS_RT_H */
   070701000059de000081240000000200000002000000012719347c00000956000000230000000c00000000000000000000001600000000usr/include/sys/rtc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RTC_H
#define _SYS_RTC_H

#ident	"@(#)/usr/include/sys/rtc.h.sl 1.1 4.0 10/15/90 23654 AT&T-SF"

/*
 * Definitions for Real Time Clock driver (Motorola MC146818 chip).
 */

#define	RTC_ADDR	0x70	/* I/O port address of for register select */
#define	RTC_DATA	0x71	/* I/O port address for data read/write */

/*
 * Register A definitions
 */
#define	RTC_A		0x0a	/* register A address */
#define	RTC_UIP		0x80	/* Update in progress bit */
#define	RTC_DIV0	0x00	/* Time base of 4.194304 MHz */
#define	RTC_DIV1	0x10	/* Time base of 1.048576 MHz */
#define	RTC_DIV2	0x20	/* Time base of 32.768 KHz */
#define	RTC_RATE6	0x06	/* interrupt rate of 976.562 */

/*
 * Register B definitions
 */
#define	RTC_B		0x0b	/* register B address */
#define	RTC_SET		0x80	/* stop updates for time set */
#define	RTC_PIE		0x40	/* Periodic interrupt enable */
#define	RTC_AIE		0x20	/* Alarm interrupt enable */
#define	RTC_UIE		0x10	/* Update ended interrupt enable */
#define	RTC_SQWE	0x08	/* Square wave enable */
#define	RTC_DM		0x04	/* Date mode, 1 = binary, 0 = BCD */
#define	RTC_HM		0x02	/* hour mode, 1 = 24 hour, 0 = 12 hour */
#define	RTC_DSE		0x01	/* Daylight savings enable */

/* 
 * Register C definitions
 */
#define	RTC_C		0x0c	/* register C address */
#define	RTC_IRQF	0x80	/* IRQ flag */
#define	RTC_PF		0x40	/* PF flag bit */
#define	RTC_AF		0x20	/* AF flag bit */
#define	RTC_UF		0x10	/* UF flag bit */

/*
 * Register D definitions
 */
#define	RTC_D		0x0d	/* register D address */
#define	RTC_VRT		0x80	/* Valid RAM and time bit */

#define	RTC_NREG	0x0e	/* number of RTC registers */
#define	RTC_NREGP	0x0a	/* number of RTC registers to set time */

/*
 * Ioctl definitions for accessing RTC.
 */
#define	RTCIOC	('R' << 8)

#define	RTCRTIME	(RTCIOC | 0x01)		/* Read time from RTC */
#define	RTCSTIME	(RTCIOC | 0x02)		/* Set time into RTC */

struct	rtc_t {
	char	rtc_sec;
	char	rtc_asec;
	char	rtc_min;
	char	rtc_amin;
	char	rtc_hr;
	char	rtc_ahr;
	char	rtc_dow;
	char	rtc_dom;
	char	rtc_mon;
	char	rtc_yr;
	char	rtc_statusa;
	char	rtc_statusb;
	char	rtc_statusc;
	char	rtc_statusd;
};

#endif	/* _SYS_RTC_H */
  070701000059df000081240000000200000002000000012719347c0000047d000000230000000c00000000000000000000001d00000000usr/include/sys/rtpriocntl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_RTPRIOCNTL_H
#define _SYS_RTPRIOCNTL_H

#ident	"@(#)/usr/include/sys/rtpriocntl..sl 1.1 4.0 10/15/90 525 AT&T-SF"
/*
 * Real-time class specific structures for the priocntl system call.
 */

typedef struct rtparms {
	short	rt_pri;		/* real-time priority */
	ulong	rt_tqsecs;	/* seconds in time quantum */
	long	rt_tqnsecs;	/* additional nanosecs in time quantum */
} rtparms_t;


typedef struct rtinfo {
	short	rt_maxpri;	/* maximum configured real-time priority */
} rtinfo_t;


#define	RT_NOCHANGE	-1
#define RT_TQINF	-2
#define RT_TQDEF	-3


/*
 * The following is used by the dispadmin(1M) command for
 * scheduler administration and is not for general use.
 */

typedef struct rtadmin {
	struct rtdpent	*rt_dpents;
	short		rt_ndpents;
	short		rt_cmd;
} rtadmin_t;

#define	RT_GETDPSIZE	1
#define	RT_GETDPTBL	2
#define	RT_SETDPTBL	3


#endif	/* _SYS_RTPRIOCNTL_H */
   070701000059e0000081240000000200000002000000012719347c00000ead000000230000000c00000000000000000000001600000000usr/include/sys/sad.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SAD_H
#define _SYS_SAD_H

#ident	"@(#)/usr/include/sys/sad.h.sl 1.1 4.0 10/15/90 41175 AT&T-SF"

/*
 * Streams Administrative Driver
 */

/*
 *  ioctl defines
 */
#define	SADIOC		('D'<<8)
#define SAD_SAP		(SADIOC|01)	/* set autopush */
#define SAD_GAP		(SADIOC|02)	/* get autopush */
#define SAD_VML		(SADIOC|03)	/* validate module list */

/*
 * Device naming and numbering conventions.
 */
#define USERDEV "/dev/sad/user"
#define ADMINDEV "/dev/sad/admin"

#define USRMIN 0
#define ADMMIN 1

/*
 * The maximum modules you can push on a stream using
 * the autopush feature.  This should be less than NSTRPUSH.
 */
#define MAXAPUSH	8

/*
 * autopush info common to user and kernel
 */
struct apcommon {
	uint	apc_cmd;		/* command (see below) */
	long	apc_major;		/* major # of device */
	long	apc_minor;		/* minor # of device */
	long	apc_lastminor;		/* last minor for range */
	uint	apc_npush;		/* number of modules to push */
};

/*
 * ap_cmd: various flavors of autopush
 */
#define SAP_CLEAR	0		/* remove configuration list */
#define SAP_ONE		1		/* configure one minor device */
#define SAP_RANGE	2		/* configure range of minor devices */
#define SAP_ALL		3		/* configure all minor devices */

/*
 * format for autopush ioctls
 */
struct strapush {
	struct apcommon sap_common;				/* see above */
	char		sap_list[MAXAPUSH][FMNAMESZ + 1];	/* module list */
};

#define sap_cmd		sap_common.apc_cmd
#define sap_major	sap_common.apc_major
#define sap_minor	sap_common.apc_minor
#define sap_lastminor	sap_common.apc_lastminor
#define sap_npush	sap_common.apc_npush

#ifdef _KERNEL

/*
 * state values for ioctls
 */
#define GETSTRUCT	1
#define GETRESULT	2
#define GETLIST		3

struct saddev {
	queue_t	*sa_qp;		/* pointer to read queue */
	caddr_t	 sa_addr;	/* saved address for copyout */
	int	 sa_flags;	/* see below */
};

/*
 * values for saddev flags field.
 */
#define SADPRIV		0x01

/*
 * Module Autopush Cache
 */
struct autopush {
	struct autopush	*ap_nextp;		/* next on list */
	int		 ap_flags;		/* see below */
	struct apcommon  ap_common;		/* see above */
	ushort		 ap_list[MAXAPUSH];	/* list of modules to push */
						/* (indices into fmodsw array) */
};

/*
 * The command issued by the user ultimately becomes
 * the type of the autopush entry.  Therefore, occurrences of
 * "type" in the code refer to an existing autopush entry.
 * Occurrences of "cmd" in the code refer to the command the
 * user is currently trying to complete.  types and cmds take
 * on the same values.
 */
#define ap_type		ap_common.apc_cmd
#define ap_major	ap_common.apc_major
#define ap_minor	ap_common.apc_minor
#define ap_lastminor	ap_common.apc_lastminor
#define ap_npush	ap_common.apc_npush

/*
 * autopush flag values
 */
#define APFREE	0x00	/* free */
#define APUSED	0x01	/* used */
#define APHASH	0x02	/* on hash list */

/*
 * hash function for cache
 */
#define strphash(maj)	strpcache[(((int)maj)&strpmask)]

extern struct saddev saddev[];		/* sad device array */
extern int sadcnt;			/* number of sad devices */
extern struct autopush autopush[];	/* autopush data array */
extern int nautopush;			/* maximum number of autopushable devices */
extern struct autopush *strpfreep;	/* autopush freelist */
extern struct autopush *strpcache[];	/* autopush hash list */
extern int nstrphash;			/* size of hash list */
extern int strpmask;			/* used in hash function */
extern queue_t *sadminqp;		/* queue for STREAMS admin daemon */

#endif /* _KERNEL */

#endif	/* _SYS_SAD_H */
   070701000059e1000081240000000200000002000000012719347c000006e0000000230000000c00000000000000000000001500000000usr/include/sys/sd.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/sd.h.sl 1.1 4.0 10/15/90 43145 AT&T-SF"
/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */


/*
 *	@(#) sd.h 1.3 87/06/22 
 */




/* Shared Data flags */
#define	SD_RDONLY	0x00
#define	SD_WRITE	0x01
#define	SD_CREAT	0x02
#define	SD_UNLOCK	0x04
#define	SD_NOWAIT	0x08

#if defined(_KERNEL) || defined(_KMEMUSER)

#define	SD_LOCKED	0x10
#define	SD_NTFY		0x20
#define	SD_BTWN		0x40

#define SDI_LOCKED	0x10
#define	SDI_NTFY	0x20
#define SDI_DEST	0x40
#define SDI_CLEAR	0x80


struct sd {                 /* XENIX shared data table */
	struct xnamnode *sd_xnamnode;	/* pointer to inode for segment */
	char 	     *sd_addr;	/* address in this proc's data space */
	char	     *sd_cpaddr;/* version # for local copy */
	char	     sd_flags;	/* describing state of this proc */
	struct sd    *sd_link;	/* ptr to next shared data seg for this proc */
};

extern struct sd sdtab[];	/* the XENIX shared data table itself */
#endif /* _KERNEL || KMEMUSER */

#ifndef _KERNEL
#ifdef __STDC__
extern char *sdget(char *path, int flags, ...);
int sdenter(char *addr, int flags);
int sdleave(char *addr);
int sdfree(char *addr);
int sdgetv(char *addr);
int sdwaitv(char *addr, int vnum);
#else
extern char *sdget();
int sdenter();
int sdfree();
int sdgetv();
int sdwaitv();
#endif /* __STDC__  */
#endif /* #ifndef _KERNEL */
070701000059e3000081240000000200000002000000012719347c000015e0000000230000000c00000000000000000000001600000000usr/include/sys/seg.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SEG_H
#define _SYS_SEG_H

#ident	"@(#)/usr/include/sys/seg.h.sl 1.1 4.0 10/15/90 40286 AT&T-SF"

/*
 * The segment structure is prototype and place holder for segment descriptors
 * s_base contains the 32 bit base field of the descriptor.
 * s_limacc contains 20 limit bits and 12 accbits in this order
 *
 * 0                      19  20  21      22   23   24  25,26 27-31
 * _____________________________________________________________________________
 * |                                                                           |
 * |   20 bit limit field   | G | B or D | 0 | AVL | P | DPL | Other Attributes|
 * |___________________________________________________________________________|
 * 
 *	The structure gets fixed up at run time to look like a descriptor
 *
 */

/* segment */
struct seg_desc {
	unsigned long s_base;	/* segment base */
	unsigned long s_limacc;	/* 4 limit and access bytes */
};

/* descriptor */
struct dscr {
	unsigned int	a_lim0015:16,
		 	a_base0015:16,
		  	a_base1623:8,
			a_acc0007:8,
			a_lim1619:4,
			a_acc0811:4,
			a_base2431:8;
};

/* access rights for data segments */ 
#define UDATA_ACC1	0xF2 	/* present dpl=3 writable */
#define KDATA_ACC1	0x92	/* present dpl=0 writable */
#define DATA_ACC2	0xC	/* 4Kbyte gran. 4Gb limit avl=0 */
#define DATA_ACC2_S	0x4	/* 1 byte gran., 32bit operands, avl=0 */
#define UTEXT_ACC1	0xFA 	/* present dpl=3 readable */
#define KTEXT_ACC1	0x9A 	/* present dpl=0 readable */
#define TEXT_ACC2	0xC	/* 4Kbyte gran., 32 bit operands avl=0 */
#define TEXT_ACC2_S	0x4	/* 1 byte gran., 32 bit operands avl=0 */
#define LDT_UACC1	0xE2	/* present dpl=3 type=ldt */
#define LDT_KACC1	0x82	/* present dpl=0 type=ldt */
#define LDT_ACC2	0x0	/* G=0 avl=0*/
#define TSS3_KACC1	0x89 	/* present dpl=0 type=available 386 TSS */
#define TSS3_KBACC1     0x8B    /* present dpl=0 type=busy 386 TSS      */
#define	TSS2_KACC1	0x81 	/* present dpl=0 type=available 286 TSS */
#define TSS3_UACC1	0xE9 	/* present dpl=3 type=available 386 TSS */
#define TGATE_UACC1     0xE5    /* present dpl=3 type=task gate         */
#define	TSS2_UACC1	0xE1 	/* present dpl=3 type=available 286 TSS */
#define TSS_ACC2	0x0	/* g=0 avl=0 */
#define SEG_CONFORM	0X4	/* conforming bit in acc0007 */

#define MKDSCR(base, limit, acc1, acc2) \
	{(u_long)(base), ((u_long)(limit)|((u_char)(acc2)<<20)|((u_char)(acc1)<<24))}

/* selector definitions */
#define LDTSEL		0x140	/* LDT for the current process */
#define UTSSSEL		0x148	/* TSS for the current process */
#define KTSSSEL 	0x150	/* TSS for the scheduler */
#define KCSSEL		0x158	/* kernel code segment selector */
#define KDSSEL		0x160	/* kernel data segment selector */
#define DFTSSSEL	0x168	/* TSS for double fault handler */
#define JTSSSEL		0x170
#define MON1SEL		0x178	/* Selector to get to monitor int 1 handler */
#define MON3SEL		0x180	/* Selector to get to monitor int 3 handler */
#define FPESEL		0x193	/* Selector for the FP emulator image */
#define XTSSSEL         0x188   /* XTSS for dual-mode processes */
#define GRANBIT		0x8	/* bit in acc0811 for granularity */

/* user selectors */
#define	USER_CS		0x17	/* user's code segment */
#define	USER_DS		0x1F	/* user's data segment */
#define	USER_SCALL	0x07	/* call gate for system calls */
#define	USER_SIGCALL	0x0F	/* call gate for sigreturn */
#define USER_FPSTK	0x27	/* alias 32 bit stack selector for emulator */
#define USER_FP		0x2F	/* selector for fp emulator to u area */
#define CSALIAS_SEL	0x37	/* CS alias selector for USER_DS (for XENIX */
				/* 	execseg()/unexecseg() system calls). */

#define IDTSZ		256
#define MONIDTSZ	16
#define MINLDTSZ        256	/* initial index of ldt */
#define MAXLDTSZ        8192	/* maximum index of ldt */
#define GDTSZ           90
#define SEL_LDT		4	/* mask to determine if sel is GDT or LDT */

#define KTBASE          0xC0008000
#define KDBASE          0xC0068000

/*
 *  Call/Interrupt/Trap Gate table descriptions
 *
 *	This is the structure used for declaration of Gates.
 *	If this is changed in any way, the code in uprt.s
 *	must be changed to match.  It is especially important
 *	that the type byte be in the last position so that the
 *	real mode start up code can determine if the gate is
 *	intended to be a gate or segment descriptor.
 */

struct gate_desc {
	unsigned long  g_off;		/* offset */
	unsigned short g_sel;		/* selector */
	unsigned char  g_wcount;	/* word count */
	unsigned char  g_type;		/* type of gate and access rights */
};

/* ...and the way the hardware sees it */

struct gdscr {
	unsigned int	gd_off0015:16,
		 	gd_selector:16,
			gd_unused:8,
			gd_acc0007:8,
			gd_off1631:16;
};
 
/* access rights field for gates */

#define GATE_UACC	0xE0		/* present and dpl = 3 */
#define GATE_KACC	0x80		/* present and dpl = 0 */
#define GATE_386CALL	0xC		/* 386 call gate */
#define GATE_386INT	0xE		/* 386 int gate */
#define GATE_386TRP	0xF		/* 386 trap gate */
#define GATE_TSS	0x5		/* Task gate */

/* make an interrupt gate */
#define MKGATE(rtn, sel, acc) \
	{(u_long)(rtn), (u_short)(sel), (u_char)0, (u_char)(acc)}
#define MKINTG(rtn)	MKGATE(rtn, KCSSEL, GATE_KACC|GATE_386INT)
#define MKKTRPG(rtn)	MKGATE(rtn, KCSSEL, GATE_KACC|GATE_386TRP)
#define MKUTRPG(rtn)	MKGATE(rtn, KCSSEL, GATE_UACC|GATE_386TRP)

#define	seltoi(sel)	((u_short)(sel) >> 3)

#endif	/* _SYS_SEG_H */
070701000059e4000081240000000200000002000000012719347c00000543000000230000000c00000000000000000000001900000000usr/include/sys/select.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SELECT_H
#define _SYS_SELECT_H

#ident	"@(#)/usr/include/sys/select.h.sl 1.1 4.0 10/15/90 22184 AT&T-SF"

/*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields.
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 */
#ifndef	FD_SETSIZE
#define	FD_SETSIZE	1024
#endif

#ifndef NBBY		/* number of bits per byte */
#define NBBY 8
#endif

typedef	long	fd_mask;
#define	NFDBITS	(sizeof(fd_mask) * NBBY)	/* bits per mask */
#ifndef	howmany
#define	howmany(x, y)	(((x)+((y)-1))/(y))
#endif

typedef	struct fd_set {
	fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
} fd_set;

#define	FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
#define	FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
#define	FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
#ifdef _KERNEL
#define	FD_ZERO(p)	bzero((char *)(p), sizeof(*(p)))
#else
#define	FD_ZERO(p)	memset((char *)(p), 0, sizeof(*(p)))
#endif /* _KERNEL */

#endif	/* _SYS_SELECT_H */
 070701000059e5000081240000000200000002000000012719347c000013b1000000230000000c00000000000000000000001600000000usr/include/sys/sem.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SEM_H
#define _SYS_SEM_H

#ident	"@(#)/usr/include/sys/sem.h.sl 1.1 4.0 10/15/90 19408 AT&T-SF"

/*
 * IPC Semaphore Facility.
 */

/*
 * Implementation Constants.
 */

#define	PSEMN	(PZERO + 3)	/* sleep priority waiting for greater value */
#define	PSEMZ	(PZERO + 2)	/* sleep priority waiting for zero */

/*
 * Permission Definitions.
 */

#define	SEM_A	0200	/* alter permission */
#define	SEM_R	0400	/* read permission */

/*
 * Semaphore Operation Flags.
 */

#define	SEM_UNDO	010000	/* set up adjust on exit entry */

/*
 * Semctl Command Definitions.
 */

#define	GETNCNT	3	/* get semncnt */
#define	GETPID	4	/* get sempid */
#define	GETVAL	5	/* get semval */
#define	GETALL	6	/* get all semval's */
#define	GETZCNT	7	/* get semzcnt */
#define	SETVAL	8	/* set semval */
#define	SETALL	9	/* set all semval's */

/*
 * Structure Definitions.
 */

/*
 * There is one semaphore id data structure (semid_ds) for each set of semaphores
 * in the system.
 */


#if defined(_KERNEL) || defined(_KMEMUSER)
/* expanded semid_ds structure */
struct semid_ds {
	struct ipc_perm sem_perm;	/* operation permission struct */
	struct sem	*sem_base;	/* ptr to first semaphore in set */
	ushort		sem_nsems;	/* # of semaphores in set */
	time_t		sem_otime;	/* last semop time */
	long		sem_pad1;	/* reserved for time_t expansion */
	time_t		sem_ctime;	/* last change time */
	long		sem_pad2;	/* time_t expansion */
	long		sem_pad3[4];		/* reserve area */
};
/* SVR3 structure */
struct o_semid_ds {
	struct o_ipc_perm sem_perm;	/* operation permission struct */
	struct o_sem	*sem_base;	/* ptr to first semaphore in set */
	ushort		sem_nsems;	/* # of semaphores in set */
	time_t		sem_otime;	/* last semop time */
	time_t		sem_ctime;	/* last change time */
};
/*
 * There is one semaphore structure (sem) for each semaphore in the system.
 */

struct sem {
	ushort	semval;		/* semaphore value */
	pid_t	sempid;		/* pid of last operation */
	ushort	semncnt;	/* # awaiting semval > cval */
	ushort	semzcnt;	/* # awaiting semval = 0 */
};

/* SVR3 sem structure */
struct o_sem {
	ushort	semval;		/* semaphore value */
	o_pid_t	sempid;		/* pid of last operation */
	ushort	semncnt;	/* # awaiting semval > cval */
	ushort	semzcnt;	/* # awaiting semval = 0 */
};


#else		/* user level definition */

#if !defined(_STYPES)

struct semid_ds {
	struct ipc_perm sem_perm;	/* operation permission struct */
	struct sem	*sem_base;	/* ptr to first semaphore in set */
	ushort		sem_nsems;	/* # of semaphores in set */
	time_t		sem_otime;	/* last semop time */
	long		sem_pad1;	/* reserved for time_t expansion */
	time_t		sem_ctime;	/* last change time */
	long		sem_pad2;		/* time_t expansion */
	long		sem_pad3[4];		/* reserve area */
};

struct sem {
	ushort	semval;		/* semaphore value */
	pid_t	sempid;		/* pid of last operation */
	ushort	semncnt;	/* # awaiting semval > cval */
	ushort	semzcnt;	/* # awaiting semval = 0 */
};

#else	/* SVR3 definition */

struct semid_ds {
	struct ipc_perm sem_perm;	/* operation permission struct */
	struct sem	*sem_base;	/* ptr to first semaphore in set */
	ushort		sem_nsems;	/* # of semaphores in set */
	time_t		sem_otime;	/* last semop time */
	time_t		sem_ctime;	/* last change time */
};

struct sem {
	ushort	semval;		/* semaphore value */
	o_pid_t	sempid;		/* pid of last operation */
	ushort	semncnt;	/* # awaiting semval > cval */
	ushort	semzcnt;	/* # awaiting semval = 0 */
};

#endif	/* !defined(_STYPES) */
#endif	/* defined(_KERNEL) */




/*
 * There is one undo structure per process in the system.
 */

struct sem_undo {
	struct sem_undo	*un_np;	/* ptr to next active undo structure */
	short		un_cnt;	/* # of active entries */
	struct undo {
		short	un_aoe;	/* adjust on exit values */
		ushort	un_num;	/* semaphore # */
		int	un_id;	/* semid */
	}	un_ent[1];	/* undo entries (one minimum) */
};

/*
 * Semaphore information structure
 */
struct	seminfo	{
	int	semmap;		/* # of entries in semaphore map */
	int	semmni;		/* # of semaphore identifiers */
	int	semmns;		/* # of semaphores in system */
	int	semmnu;		/* # of undo structures in system */
	int	semmsl;		/* max # of semaphores per id */
	int	semopm;		/* max # of operations per semop call */
	int	semume;		/* max # of undo entries per process */
	int	semusz;		/* size in bytes of undo structure */
	int	semvmx;		/* semaphore maximum value */
	int	semaem;		/* adjust on exit max value */
};

/*
 * User semaphore template for semop system calls.
 */

struct sembuf {
	ushort	sem_num;	/* semaphore # */
	short	sem_op;		/* semaphore operation */
	short	sem_flg;	/* operation flags */
};

#if defined(__STDC__) && !defined(_KERNEL)
int semctl(int, int, int, ...);
int semget(key_t, int, int);
int semop(int, struct sembuf *, unsigned);
#endif

#endif	/* _SYS_SEM_H */
   070701000059e6000081240000000200000002000000012719347c00000335000000230000000c00000000000000000000001700000000usr/include/sys/sema.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SEMA_H
#define _SYS_SEMA_H

#ident	"@(#)/usr/include/sys/sema.h.sl 1.1 4.0 10/15/90 370 AT&T-SF"
/*
 * defines for semaphore mapping
 */

typedef int	sema_t;

#define ALLOC_LOCK(X)
#define EXTERN_LOCK(X)
#define INITLOCK(X,Y)
#define SPSEMA(X)
#define SVSEMA(X)
#define	PSEMA(X,Y)
#define	VSEMA(X,Y)

#define appsema(a,b)	1
#define apvsema(a,b)	1
#define psema(a,b)	sleep(a,b)
#define vsema(a,b)	wakeup(a)
#define initsema(a,b)	*a = b
#define initlock(a,b)	*a = b
#define cvsema(a)	wakeup(a)
#define splrf()		spl5()

#endif	/* _SYS_SEMA_H */
   070701000059e7000081240000000200000002000000012719347c000006d0000000230000000c00000000000000000000001a00000000usr/include/sys/session.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SESSION_H
#define _SYS_SESSION_H

#ident	"@(#)/usr/include/sys/session.h.sl 1.1 4.0 10/15/90 38591 AT&T-SF"
typedef struct sess {

	short s_ref; 			/* reference count */
	short s_mode;			/* /sess current permissions */
	uid_t s_uid;			/* /sess current user ID */
	gid_t s_gid;			/* /sess current group ID */
	ulong s_ctime;			/* /sess change time */
	dev_t s_dev;			/* tty's device number */
	struct vnode *s_vp;		/* tty's vnode */
	struct pid *s_sidp;		/* session ID info */
	struct cred *s_cred;		/* allocation credentials */

} sess_t;

#define s_sid s_sidp->pid_id

extern sess_t session0;

/*
 * Enumeration of the types of access that can be requested for a 
 * controlling terminal under job control.
 */

enum jcaccess {
	JCREAD,			/* read data on a ctty */
	JCWRITE,		/* write data to a ctty */
	JCSETP,			/* set ctty parameters */
	JCGETP			/* get ctty parameters */
};

#define SESS_HOLD(sp)	(++(sp)->s_ref)
#define SESS_RELE(sp)	(--(sp)->s_ref > 0 ? 0 : sess_rele(sp))

#if defined(__STDC__)

extern int sess_rele(sess_t *);
extern void sess_create(void);
extern void freectty(sess_t *);
extern void alloctty(proc_t *, vnode_t *);
extern int realloctty(proc_t *, pid_t);
extern dev_t cttydev(proc_t *);
extern int hascttyperm(sess_t *, cred_t *, mode_t);

#else

extern int sess_rele();
extern void sess_create();
extern void freectty();
extern void alloctty();
extern int realloctty();
extern dev_t cttydev();
extern int hascttyperm();

#endif

#endif
070701000059e8000081240000000200000002000000012719347c000014d7000000230000000c00000000000000000000001600000000usr/include/sys/shm.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SHM_H
#define _SYS_SHM_H

#ident	"@(#)/usr/include/sys/shm.h.sl 1.1 4.0 10/15/90 40947 AT&T-SF"

/*
**	IPC Shared Memory Facility.
*/

/*
**	Implementation Constants.
*/

#define SHMLBA  ctob(1)   /* segment low boundary address multiple */

			/* (SHMLBA must be a power of 2) */

/*
**	Permission Definitions.
*/

#define	SHM_R	0400	/* read permission */
#define	SHM_W	0200	/* write permission */

/*
**	ipc_perm Mode Definitions.
*/

#define SHM_LOCKED      001000	/* shmid locked */
#define SHM_LOCKWAIT    010000	/* shmid wanted */

#define PSHM    (PZERO + 1)     /* sleep priority */

/* define resource locking macros */
#define SHMLOCK(sp) { \
        while ((sp)->shm_perm.mode & SHM_LOCKED) { \
                (sp)->shm_perm.mode |= SHM_LOCKWAIT; \
                (void) sleep((caddr_t)(sp), PSHM); \
        } \
        (sp)->shm_perm.mode |= SHM_LOCKED; \
}

#define SHMUNLOCK(sp) { \
        (sp)->shm_perm.mode &= ~SHM_LOCKED; \
        if ((sp)->shm_perm.mode & SHM_LOCKWAIT) { \
                (sp)->shm_perm.mode &= ~SHM_LOCKWAIT; \
                wakeprocs((caddr_t)(sp), PRMPT); \
        } \
}

/*
**	Message Operation Flags.
*/

#define	SHM_RDONLY	010000	/* attach read-only (else read-write) */
#define	SHM_RND		020000	/* round attach address to SHMLBA */

/*
**	Structure Definitions.
*/

/*
**	There is a shared mem id data structure (shmid_ds) for each 
**	segment in the system.
*/

#if defined(_KERNEL) || defined(_KMEMUSER)
struct shmid_ds {
	struct ipc_perm shm_perm;	/* operation permission struct */
	int		shm_segsz;	/* size of segment in bytes */
	struct anon_map	*shm_amp;	/* segment anon_map pointer */
	ushort		shm_lkcnt;	/* number of times it is being locked */
	pid_t		shm_lpid;	/* pid of last shmop */
	pid_t		shm_cpid;	/* pid of creator */
	ulong		shm_nattch;	/* used only for shminfo */
	ulong		shm_cnattch;	/* used only for shminfo */
	time_t		shm_atime;	/* last shmat time */
	long		shm_pad1;	/* reserved for time_t expansion */
	time_t		shm_dtime;	/* last shmdt time */
	long		shm_pad2;	/* reserved for time_t expansion */
	time_t		shm_ctime;	/* last change time */
	long		shm_pad3;	/* reserved for time_t expansion */
	long		shm_pad4[4];	/* reserve area  */
};

/* SVR3 structure */
struct o_shmid_ds {
	struct o_ipc_perm	shm_perm;	/* operation permission struct */
	int		shm_segsz;	/* size of segment in bytes */
	struct anon_map	*shm_amp;	/* segment anon_map pointer */
	ushort		shm_lkcnt;	/* number of times it is being locked */
	char 		pad[2];		
	o_pid_t		shm_lpid;	/* pid of last shmop */
	o_pid_t		shm_cpid;	/* pid of creator */
	ushort		shm_nattch;	/* used only for shminfo */
	ushort		shm_cnattch;	/* used only for shminfo */
	time_t		shm_atime;	/* last shmat time */
	time_t		shm_dtime;	/* last shmdt time */
	time_t		shm_ctime;	/* last change time */
};
#else	/* user definition */
#if !defined(_STYPES)
/* this maps to the kernel struct shmid_ds */
struct shmid_ds {
	struct ipc_perm	shm_perm;	/* operation permission struct */
	int		shm_segsz;	/* size of segment in bytes */
	struct anon_map	*shm_amp;	/* segment anon_map pointer */
	ushort		shm_lkcnt;	/* number of times it is being locked */
	pid_t		shm_lpid;	/* pid of last shmop */
	pid_t		shm_cpid;	/* pid of creator */
	ulong		shm_nattch;	/* used only for shminfo */
	ulong		shm_cnattch;	/* used only for shminfo */
	time_t		shm_atime;	/* last shmat time */
	long		shm_pad1;	/* reserved for time_t expansion */
	time_t		shm_dtime;	/* last shmdt time */
	long		shm_pad2;	/* reserved for time_t expansion */
	time_t		shm_ctime;	/* last change time */
	long		shm_pad3;	/* reserved for time_t expansion */
	long		shm_pad4[4];	/* reserve area  */
};
#else	/* NON EFT */
/* old struct for compatibility */
struct shmid_ds {
	struct ipc_perm	shm_perm;	/* operation permission struct */
	int		shm_segsz;	/* size of segment in bytes */
	struct anon_map	*shm_amp;	/* segment anon_map pointer */
	ushort		shm_lkcnt;	/* number of times it is being locked */
	char 		pad[2];		
	o_pid_t		shm_lpid;	/* pid of last shmop */
	o_pid_t		shm_cpid;	/* pid of creator */
	ushort		shm_nattch;	/* used only for shminfo */
	ushort		shm_cnattch;	/* used only for shminfo */
	time_t		shm_atime;	/* last shmat time */
	time_t		shm_dtime;	/* last shmdt time */
	time_t		shm_ctime;	/* last change time */
};
#endif	/* end defined(_LTYPES) */
#endif	/* end defined(_KERNEL */

struct	shminfo {
	int	shmmax,		/* max shared memory segment size */
		shmmin,		/* min shared memory segment size */
		shmmni,		/* # of shared memory identifiers */
		shmseg;		/* max attached shared memory	  */
				/* segments per process		  */
};


/*
 * Shared memory control operations
 */

#define SHM_LOCK	3	/* Lock segment in core */
#define SHM_UNLOCK	4	/* Unlock segment */

#if defined(__STDC__) && !defined(_KERNEL)
int shmctl(int, int, ...);
int shmget(key_t, int, int);
void *shmat(int, void *, int);
int shmdt(void *);
#endif

typedef struct segacct {
	struct segacct	*sa_next;
	caddr_t		 sa_addr;
	size_t		 sa_len;
	struct anon_map *sa_amp;
} segacct_t;

#endif	/* _SYS_SHM_H */
 070701000059e9000081240000000200000002000000012719347c000003bc000000230000000c00000000000000000000001c00000000usr/include/sys/sigaction.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SIGACTION_H
#define _SYS_SIGACTION_H

#ident	"@(#)/usr/include/sys/sigaction.h.sl 1.1 4.0 10/15/90 33690 AT&T-SF"
#ifndef _SIGACTION_
#define _SIGACTION_

struct sigaction {
	int sa_flags;
	void (*sa_handler)();
	sigset_t sa_mask;
	int sa_resv[2];
};
#endif	/* _SIGACTION_ */

/* definitions for the sa_flags field */

#define SA_ONSTACK	0x00000001
#define SA_RESETHAND	0x00000002
#define SA_RESTART	0x00000004
#define SA_SIGINFO	0x00000008
#define SA_NODEFER	0x00000010

/* these are only valid for SIGCLD */
#define SA_NOCLDWAIT	0x00010000	/* don't save zombie children	 */
#define SA_NOCLDSTOP	0x00020000	/* don't send job control SIGCLD's */

#endif /* _SYS_SIGACTION_H */
070701000059ea000081240000000200000002000000012719347c0000156d000000230000000c00000000000000000000001a00000000usr/include/sys/siginfo.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SIGINFO_H
#define _SYS_SIGINFO_H

#ident	"@(#)/usr/include/sys/siginfo.h.sl 1.1 4.0 10/15/90 8030 AT&T-SF"
#if !defined(_POSIX_SOURCE)
/*
 * negative signal codes are reserved for future use for user generated
 * signals 
 */

#define SI_FROMUSER(sip)	((sip)->si_code <= 0)
#define SI_FROMKERNEL(sip)	((sip)->si_code > 0)

#define SI_USER		0	/* user generated signal */

/* 
 * SIGILL signal codes 
 */

#define	ILL_ILLOPC	1	/* illegal opcode */
#define	ILL_ILLOPN	2	/* illegal operand */
#define	ILL_ILLADR	3	/* illegal addressing mode */
#define	ILL_ILLTRP	4	/* illegal trap */
#define	ILL_PRVOPC	5	/* privileged opcode */
#define	ILL_PRVREG	6	/* privileged register */
#define	ILL_COPROC	7	/* co-processor */
#define	ILL_BADSTK	8	/* bad stack */
#define NSIGILL		8

/* 
 * SIGFPE signal codes 
 */

#define	FPE_INTDIV	1	/* integer divide by zero */
#define	FPE_INTOVF	2	/* integer overflow */
#define	FPE_FLTDIV	3	/* floating point divide by zero */
#define	FPE_FLTOVF	4	/* floating point overflow */
#define	FPE_FLTUND	5	/* floating point underflow */
#define	FPE_FLTRES	6	/* floating point inexact result */
#define	FPE_FLTINV	7	/* invalid floating point operation */
#define FPE_FLTSUB	8	/* subscript out of range */
#define NSIGFPE		8

/* 
 * SIGSEGV signal codes 
 */

#define	SEGV_MAPERR	1	/* address not mapped to object */
#define	SEGV_ACCERR	2	/* invalid permissions */
#define NSIGSEGV	2

/* 
 * SIGBUS signal codes 
 */

#define	BUS_ADRALN	1	/* invalid address alignment */
#define	BUS_ADRERR	2	/* non-existent physical address */
#define	BUS_OBJERR	3	/* object specific hardware error */
#define NSIGBUS		3

/* 
 * SIGTRAP signal codes 
 */

#define TRAP_BRKPT	1	/* process breakpoint */
#define TRAP_TRACE	2	/* process trace */
#define NSIGTRAP	2

/* 
 * SIGCLD signal codes 
 */

#define	CLD_EXITED	1	/* child has exited */
#define	CLD_KILLED	2	/* child was killed */
#define	CLD_DUMPED	3	/* child has coredumped */
#define	CLD_TRAPPED	4	/* traced child has stopped */
#define	CLD_STOPPED	5	/* child has stopped on signal */
#define	CLD_CONTINUED	6	/* stopped child has continued */
#define NSIGCLD		6

/*
 * SIGPOLL signal codes
 */

#define POLL_IN		1	/* input available */
#define	POLL_OUT	2	/* output buffers available */
#define	POLL_MSG	3	/* output buffers available */
#define	POLL_ERR	4	/* I/O error */
#define	POLL_PRI	5	/* high priority input available */
#define	POLL_HUP	6	/* device disconnected */
#define NSIGPOLL	6

#define SI_MAXSZ	128
#define SI_PAD		((SI_MAXSZ / sizeof(int)) - 3)

typedef struct siginfo {

	int	si_signo;			/* signal from signal.h	*/
	int 	si_code;			/* code from above	*/
	int	si_errno;			/* error from errno.h	*/

	union {

		int	_pad[SI_PAD];		/* for future growth	*/

		struct {			/* kill(), SIGCLD	*/
			pid_t	_pid;		/* process ID		*/
			union {
				struct {
					uid_t	_uid;
				} _kill;
				struct {
					clock_t _utime;
					int	_status;
					clock_t _stime;
				} _cld;
			} _pdata;
		} _proc;			

		struct {	/* SIGSEGV, SIGBUS, SIGILL and SIGFPE	*/
			caddr_t	_addr;		/* faulting address	*/
		} _fault;

		struct {			/* SIGPOLL, SIGXFSZ	*/
		/* fd not currently available for SIGPOLL */
			int	_fd;		/* file descriptor	*/
			long	_band;
		} _file;

	} _data;

} siginfo_t;

/*
 * XXX -- internal version is identical to siginfo_t but without the padding.
 * This must be maintained in sync with it.
 */

typedef struct k_siginfo {

	int	si_signo;			/* signal from signal.h	*/
	int 	si_code;			/* code from above	*/
	int	si_errno;			/* error from errno.h	*/

	union {
		struct {			/* kill(), SIGCLD	*/
			pid_t	_pid;		/* process ID		*/
			union {
				struct {
					uid_t	_uid;
				} _kill;
				struct {
					clock_t _utime;
					int	_status;
					clock_t _stime;
				} _cld;
			} _pdata;
		} _proc;			

		struct {	/* SIGSEGV, SIGBUS, SIGILL and SIGFPE	*/
			caddr_t	_addr;		/* faulting address	*/
		} _fault;

		struct {			/* SIGPOLL, SIGXFSZ	*/
		/* fd not currently available for SIGPOLL */
			int	_fd;		/* file descriptor	*/
			long	_band;
		} _file;

	} _data;

} k_siginfo_t;

#define si_pid		_data._proc._pid
#define si_status	_data._proc._pdata._cld._status
#define si_stime	_data._proc._pdata._cld._stime
#define si_utime	_data._proc._pdata._cld._utime
#define si_uid		_data._proc._pdata._kill._uid
#define si_addr		_data._fault._addr
#define si_fd		_data._file._fd
#define si_band		_data._file._band

typedef struct sigqueue {
	struct sigqueue		*sq_next;
	struct k_siginfo	sq_info;
} sigqueue_t;

#endif /* !defined(_POSIX_SOURCE) */

#ifdef _KERNEL

#if defined(__STDC__)

extern void sigdeq(proc_t *, int, sigqueue_t **);
extern void sigdelq(proc_t *, int);
extern void sigaddq(proc_t *, k_siginfo_t *, int);
extern void sigdupq(proc_t *, proc_t *);
extern sigqueue_t *sigappend(k_sigset_t *, sigqueue_t *,
	k_sigset_t *, sigqueue_t *);
extern sigqueue_t *sigprepend(k_sigset_t *, sigqueue_t *,
	k_sigset_t *, sigqueue_t *);
extern void winfo(proc_t *, k_siginfo_t *, int);

#else

extern void sigdeq();
extern void sigdelq();
extern void sigaddq();
extern void sigdupq();
extern sigqueue_t *sigappend();
extern sigqueue_t *sigprepend();
extern void winfo();

#endif	/* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _SYS_SIGINFO_H */
   070701000059eb000081240000000200000002000000012719347c000013bb000000230000000c00000000000000000000001900000000usr/include/sys/signal.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SIGNAL_H
#define _SYS_SIGNAL_H

#ident	"@(#)/usr/include/sys/signal.h.sl 1.1 4.0 10/15/90 15954 AT&T-SF"

#define	SIGHUP	1	/* hangup */
#define	SIGINT	2	/* interrupt (rubout) */
#define	SIGQUIT	3	/* quit (ASCII FS) */
#define	SIGILL	4	/* illegal instruction (not reset when caught) */
#define	SIGTRAP	5	/* trace trap (not reset when caught) */
#define	SIGIOT	6	/* IOT instruction */
#define SIGABRT 6	/* used by abort, replace SIGIOT in the future */
#define	SIGEMT	7	/* EMT instruction */
#define	SIGFPE	8	/* floating point exception */
#define	SIGKILL	9	/* kill (cannot be caught or ignored) */
#define	SIGBUS	10	/* bus error */
#define	SIGSEGV	11	/* segmentation violation */
#define	SIGSYS	12	/* bad argument to system call */
#define	SIGPIPE	13	/* write on a pipe with no one to read it */
#define	SIGALRM	14	/* alarm clock */
#define	SIGTERM	15	/* software termination signal from kill */
#define	SIGUSR1	16	/* user defined signal 1 */
#define	SIGUSR2	17	/* user defined signal 2 */
#define	SIGCLD	18	/* child status change */
#define	SIGCHLD	18	/* child status change alias (POSIX) */
#define	SIGPWR	19	/* power-fail restart */
#define SIGWINCH 20	/* window size change */
#define SIGURG	21	/* urgent socket condition */
#define SIGPOLL 22	/* pollable event occured */
#define SIGIO	22	/* socket I/O possible (SIGPOLL alias) */
#define SIGSTOP 23	/* stop (cannot be caught or ignored) */
#define SIGTSTP 24	/* user stop requested from tty */
#define SIGCONT 25	/* stopped process has been continued */
#define SIGTTIN 26	/* background tty read attempted */
#define SIGTTOU 27	/* background tty write attempted */
#define SIGVTALRM 28	/* virtual timer expired */
#define SIGPROF 29	/* profiling timer expired */
#define SIGXCPU 30	/* exceeded cpu limit */
#define SIGXFSZ 31	/* exceeded file size limit */

#define	SIG_DFL	(void(*)())0

#if defined(lint)
#define SIG_ERR (void(*)())0
#define	SIG_IGN	(void (*)())0
#define SIG_HOLD (void(*)())0
#else
#define SIG_ERR	(void(*)())-1
#define	SIG_IGN	(void (*)())1
#define SIG_HOLD (void(*)())2
#endif

#define SIG_BLOCK	1
#define SIG_UNBLOCK	2
#define SIG_SETMASK	3

#define SIGNO_MASK	0xFF
#define SIGDEFER	0x100
#define SIGHOLD		0x200
#define SIGRELSE	0x400
#define SIGIGNORE	0x800
#define SIGPAUSE	0x1000

#if (__STDC__ - 0 == 0) || defined(_POSIX_SOURCE)
typedef struct {		/* signal set type */
	unsigned long	sigbits[4];
} sigset_t;

struct sigaction {
	int sa_flags;
	void (*sa_handler)();
	sigset_t sa_mask;
	int sa_resv[2];
};

/* these are only valid for SIGCLD */
#define SA_NOCLDSTOP	0x00020000	/* don't send job control SIGCLD's */
#endif

#if (__STDC__ - 0 == 0) && !defined(_POSIX_SOURCE)
			/* non-comformant ANSI compilation	*/

/* definitions for the sa_flags field */
#define SA_ONSTACK	0x00000001
#define SA_RESETHAND	0x00000002
#define SA_RESTART	0x00000004
#define SA_SIGINFO	0x00000008
#define SA_NODEFER	0x00000010

/* these are only valid for SIGCLD */
#define SA_NOCLDWAIT	0x00010000	/* don't save zombie children	 */

#define NSIG	32	/* valid signals range from 1 to NSIG-1 */
#define MAXSIG	32	/* size of u_signal[], NSIG-1 <= MAXSIG */

#define S_SIGNAL	1
#define S_SIGSET	2
#define S_SIGACTION	3
#define S_NONE		4

#define MINSIGSTKSZ	512
#define SIGSTKSZ	8192

#define SS_ONSTACK	0x00000001
#define SS_DISABLE	0x00000002

struct sigaltstack {
	char	*ss_sp;
	int	ss_size;
	int	ss_flags;
};

typedef struct sigaltstack stack_t;

#endif

#ifdef _KERNEL 

extern k_sigset_t	

	fillset,		/* valid signals, guaranteed contiguous */
	holdvfork,		/* held while doing vfork */
	cantmask,		/* cannot be caught or ignored */
	cantreset,		/* cannot be reset after catching */
	ignoredefault,		/* ignored by default */
	stopdefault,		/* stop by default */
	coredefault;		/* dumps core by default */

#define	sigmask(n)		((unsigned long)1 << ((n) - 1))

#define sigemptyset(s)		(*(s) = 0)
#define sigfillset(s)		(*(s) = fillset)
#define sigaddset(s,n)		(*(s) |= sigmask(n))
#define sigdelset(s,n)		(*(s) &= ~sigmask(n))
#define	sigismember(s,n)	(sigmask(n) & *(s))
#if !defined(_POSIX_SOURCE) 
#define sigisempty(s)		(*(s) == 0)
#define sigorset(s1,s2)		(*(s1) |= *(s2))
#define	sigandset(s1,s2)	(*(s1) &= *(s2))
#define	sigdiffset(s1,s2)	(*(s1) &= ~(*(s2)))
#define sigutok(us,ks)		(*(ks) = (us)->sigbits[0])
#define sigktou(ks,us)		((us)->sigbits[0] = *(ks),	\
				 (us)->sigbits[1] = 0,	\
				 (us)->sigbits[2] = 0,	\
				 (us)->sigbits[3] = 0)

#endif /* !defined(_POSIX_SOURCE) */ 
typedef struct {
	int	sig;
	int	perm;
	int	checkperm;
} sigsend_t;

#if !defined(_POSIX_SOURCE) 
#if defined(__STDC__)
extern void setsigact(int, void (*)(), k_sigset_t, int);
#else
extern void setsigact();
#endif	/* __STDC__ */
#endif /* !defined(_POSIX_SOURCE) */ 

#endif /* _KERNEL */

#endif /* _SYS_SIGNAL_H */
 070701000059ec000081240000000200000002000000012719347c000021db000000230000000c00000000000000000000001900000000usr/include/sys/socket.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef	_SYS_SOCKET_H
#define	_SYS_SOCKET_H

#ident	"@(#)/usr/include/sys/socket.h.sl 1.1 4.0 10/15/90 30231 AT&T-SF"

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _KERNEL
#include <sys/netconfig.h>
#endif

/*
 * Definitions related to sockets: types, address families, options.
 */

#ifndef NC_TPI_CLTS
#define NC_TPI_CLTS	1		/* must agree with netconfig.h */
#define NC_TPI_COTS	2		/* must agree with netconfig.h */
#define NC_TPI_COTS_ORD	3		/* must agree with netconfig.h */
#define	NC_TPI_RAW	4		/* must agree with netconfig.h */
#endif /* !NC_TPI_CLTS */

/*
 * Types
 */
#define	SOCK_STREAM	NC_TPI_COTS	/* stream socket */
#define	SOCK_DGRAM	NC_TPI_CLTS	/* datagram socket */
#define	SOCK_RAW	NC_TPI_RAW	/* raw-protocol interface */
#define	SOCK_RDM	5		/* reliably-delivered message */
#define	SOCK_SEQPACKET	6		/* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define	SO_DEBUG	0x0001		/* turn on debugging info recording */
#define	SO_ACCEPTCONN	0x0002		/* socket has had listen() */
#define	SO_REUSEADDR	0x0004		/* allow local address reuse */
#define	SO_KEEPALIVE	0x0008		/* keep connections alive */
#define	SO_DONTROUTE	0x0010		/* just use interface addresses */
#define	SO_BROADCAST	0x0020		/* permit sending of broadcast msgs */
#define	SO_USELOOPBACK	0x0040		/* bypass hardware when possible */
#define	SO_LINGER	0x0080		/* linger on close if data present */
#define	SO_OOBINLINE	0x0100		/* leave received OOB data in line */
#define SO_ORDREL	0x0200		/* give use orderly release */
#define SO_IMASOCKET	0x0400		/* use socket semantics */

/*
 * N.B.: The following definition is present only for compatibility
 * with release 3.0.  It will disappear in later releases.
 */
#define	SO_DONTLINGER	(~SO_LINGER)	/* ~SO_LINGER */

/*
 * Additional options, not kept in so_options.
 */
#define	SO_SNDBUF	0x1001		/* send buffer size */
#define	SO_RCVBUF	0x1002		/* receive buffer size */
#define	SO_SNDLOWAT	0x1003		/* send low-water mark */
#define	SO_RCVLOWAT	0x1004		/* receive low-water mark */
#define	SO_SNDTIMEO	0x1005		/* send timeout */
#define	SO_RCVTIMEO	0x1006		/* receive timeout */
#define	SO_ERROR	0x1007		/* get error status and clear */
#define	SO_TYPE		0x1008		/* get socket type */
#define SO_PROTOTYPE	0x1009		/* get/set protocol type */

/*
 * Structure used for manipulating linger option.
 */
struct	linger {
	int	l_onoff;		/* option on/off */
	int	l_linger;		/* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define	SOL_SOCKET	0xffff		/* options for socket level */

/*
 * Address families.
 */
#define AF_UNSPEC       0		/* unspecified */
#define AF_UNIX         1		/* local to host (pipes, portals) */
#define AF_INET         2		/* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3		/* arpanet imp addresses */
#define AF_PUP          4		/* pup protocols: e.g. BSP */
#define AF_CHAOS        5		/* mit CHAOS protocols */
#define AF_NS           6		/* XEROX NS protocols */
#define AF_NBS          7		/* nbs protocols */
#define AF_ECMA         8		/* european computer manufacturers */
#define AF_DATAKIT      9		/* datakit protocols */
#define AF_CCITT        10		/* CCITT protocols, X.25 etc */
#define AF_SNA          11		/* IBM SNA */
#define AF_DECnet       12		/* DECnet */
#define AF_DLI          13		/* Direct data link interface */
#define AF_LAT          14		/* LAT */
#define AF_HYLINK       15		/* NSC Hyperchannel */
#define AF_APPLETALK    16		/* Apple Talk */
#define AF_NIT          17		/* Network Interface Tap */
#define AF_802          18		/* IEEE 802.2, also ISO 8802 */
#define AF_OSI          19		/* umbrella for all families used
#define AF_X25          20		/* CCITT X.25 in particular */
#define AF_OSINET       2		/* AFI = 47, IDI = 4 */
#define AF_GOSIP        22		/* U.S. Government OSI */
#define	AF_MAX		21

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
	u_short	sa_family;		/* address family */
	char	sa_data[14];		/* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
	u_short	sp_family;		/* address family */
	u_short	sp_protocol;		/* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define	PF_UNSPEC	AF_UNSPEC
#define	PF_UNIX		AF_UNIX
#define	PF_INET		AF_INET
#define	PF_IMPLINK	AF_IMPLINK
#define	PF_PUP		AF_PUP
#define	PF_CHAOS	AF_CHAOS
#define	PF_NS		AF_NS
#define	PF_NBS		AF_NBS
#define	PF_ECMA		AF_ECMA
#define	PF_DATAKIT	AF_DATAKIT
#define	PF_CCITT	AF_CCITT
#define	PF_SNA		AF_SNA
#define	PF_DECnet	AF_DECnet
#define	PF_DLI		AF_DLI
#define	PF_LAT		AF_LAT
#define	PF_HYLINK	AF_HYLINK
#define	PF_APPLETALK	AF_APPLETALK
#define	PF_NIT		AF_NIT
#define	PF_802		AF_802
#define	PF_OSI		AF_OSI
#define	PF_X25		AF_X25
#define	PF_OSINET	AF_OSINET
#define	PF_GOSIP	AF_GOSIP

#define	PF_MAX		AF_MAX

/*
 * Maximum queue length specifiable by listen.
 */
#define	SOMAXCONN	5

/*
 * Message header for recvmsg and sendmsg calls.
 */
struct msghdr {
	caddr_t	msg_name;		/* optional address */
	int	msg_namelen;		/* size of address */
	struct	iovec *msg_iov;		/* scatter/gather array */
	int	msg_iovlen;		/* # elements in msg_iov */
	caddr_t	msg_accrights;		/* access rights sent/received */
	int	msg_accrightslen;
};

#define	MSG_OOB		0x1		/* process out-of-band data */
#define	MSG_PEEK	0x2		/* peek at incoming message */
#define	MSG_DONTROUTE	0x4		/* send without using routing tables */

#define	MSG_MAXIOVLEN	16

/*
 * An option specification consists of an opthdr, followed by the value of
 * the option.  An options buffer contains one or more options.  The len
 * field of opthdr specifies the length of the option value in bytes.  This
 * length must be a multiple of sizeof(long) (use OPTLEN macro).
 */

struct opthdr {
	long            level;	/* protocol level affected */
	long            name;	/* option to modify */
	long            len;	/* length of option value */
};

#define OPTLEN(x) ((((x) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))
#define OPTVAL(opt) ((char *)(opt + 1))

/*
 * the optdefault structure is used for internal tables of option default
 * values.
 */
struct optdefault {
	int             optname;/* the option */
	char           *val;	/* ptr to default value */
	int             len;	/* length of value */
};

/*
 * the opproc structure is used to build tables of options processing
 * functions for dooptions().
 */
struct opproc {
	int             level;	/* options level this function handles */
	int             (*func) ();	/* the function */
};

/*
 * This structure is used to encode pseudo system calls
 */
struct socksysreq {
	int             args[7];
};

/*
 * This structure is used for adding new protocols to the list supported by
 * sockets.
 */

struct socknewproto {
	int             family;	/* address family (AF_INET, etc.) */
	int             type;	/* protocol type (SOCK_STREAM, etc.) */
	int             proto;	/* per family proto number */
	dev_t           dev;	/* major/minor to use (must be a clone) */
	int             flags;	/* protosw flags */
};


/* defines for user/kernel interface */

#if (INTEL == 31) || (ATT == 31)
#define SOCKETSYS	88	/* MUST BE CHANGED DEPENDING ON OS/SYSENT.C!! */
#else
#define SOCKETSYS	83	/* MUST BE CHANGED DEPENDING ON OS/SYSENT.C!! */
#endif

#define  SO_ACCEPT	1
#define  SO_BIND	2
#define  SO_CONNECT	3
#define  SO_GETPEERNAME	4
#define  SO_GETSOCKNAME	5
#define  SO_GETSOCKOPT	6
#define  SO_LISTEN	7
#define  SO_RECV	8
#define  SO_RECVFROM	9
#define  SO_SEND	10
#define  SO_SENDTO	11
#define  SO_SETSOCKOPT	12
#define  SO_SHUTDOWN	13
#define  SO_SOCKET	14
#define  SO_SOCKPOLL	15
#define  SO_GETIPDOMAIN	16
#define  SO_SETIPDOMAIN	17
#define  SO_ADJTIME	18

#endif	/* _SYS_SOCKET_H */
 070701000059ed000081240000000200000002000000012719347c000019c1000000230000000c00000000000000000000001c00000000usr/include/sys/socketvar.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SOCKETVAR_H
#define _SYS_SOCKETVAR_H

#ident	"@(#)/usr/include/sys/socketvar.h.sl 1.1 4.0 10/15/90 61125 AT&T-SF"

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * Kernel structure per socket.
 * Contains send and receive buffer queues,
 * handle on protocol and pointer to protocol
 * private data and error information.
 */
struct socket {
	short	so_type;		/* generic type, see socket.h */
	short	so_options;		/* from socket call, see socket.h */
	short	so_linger;		/* time to linger while closing */
	short	so_state;		/* internal state flags SS_*, below */
	caddr_t	so_pcb;			/* protocol control block */
	struct	protosw *so_proto;	/* protocol handle */
/*
 * Variables for connection queueing.
 * Socket where accepts occur is so_head in all subsidiary sockets.
 * If so_head is 0, socket is not related to an accept.
 * For head socket so_q0 queues partially completed connections,
 * while so_q is a queue of connections ready to be accepted.
 * If a connection is aborted and it has so_head set, then
 * it has to be pulled out of either so_q0 or so_q.
 * We allow connections to queue up based on current queue lengths
 * and limit on number of queued connections for this socket.
 */
	struct	socket *so_head;	/* back pointer to accept socket */
	struct	socket *so_q0;		/* queue of partial connections */
	struct	socket *so_q;		/* queue of incoming connections */
	short	so_q0len;		/* partials on so_q0 */
	short	so_qlen;		/* number of connections on so_q */
	short	so_qlimit;		/* max number queued connections */
	short	so_timeo;		/* connection timeout */
	u_short	so_error;		/* error affecting connection */
	short	so_pgrp;		/* pgrp for signals */
	u_long	so_oobmark;		/* chars to oob mark */
/*
 * Variables for socket buffering.
 */
	struct	sockbuf {
		u_long	sb_cc;		/* actual chars in buffer */
		u_long	sb_hiwat;	/* max actual char count */
		u_long	sb_mbcnt;	/* chars of mbufs used */
		u_long	sb_mbmax;	/* max chars of mbufs to use */
		u_long	sb_lowat;	/* low water mark (not used yet) */
		struct	mbuf *sb_mb;	/* the mbuf chain */
		struct	proc *sb_sel;	/* process selecting read/write */
		short	sb_timeo;	/* timeout (not used yet) */
		short	sb_flags;	/* flags, see below */
	} so_rcv, so_snd;
#define	SB_MAX		(64*1024)	/* max chars in sockbuf */
#define	SB_LOCK		0x01		/* lock on data queue (so_rcv only) */
#define	SB_WANT		0x02		/* someone is waiting to lock */
#define	SB_WAIT		0x04		/* someone is waiting for data/space */
#define	SB_SEL		0x08		/* buffer is selected */
#define	SB_COLL		0x10		/* collision selecting */
/*
 * Hooks for alternative wakeup strategies.
 * These are used by kernel subsystems wishing to access the socket
 * abstraction.  If so_wupfunc is nonnull, it is called in place of
 * wakeup any time that wakeup would otherwise be called with an
 * argument whose value is an address lying within a socket structure.
 */
	struct wupalt	*so_wupalt;
};

struct wupalt {
	int	(*wup_func)();		/* function to call instead of wakeup */
	caddr_t	wup_arg;		/* argument for so_wupfunc */
	/*
	 * Other state information here, for example, for a stream
	 * connected to a socket.
	 */
};

/*
 * Socket state bits.
 */
#define	SS_NOFDREF		0x001	/* no file table ref any more */
#define	SS_ISCONNECTED		0x002	/* socket connected to a peer */
#define	SS_ISCONNECTING		0x004	/* in process of connecting to peer */
#define	SS_ISDISCONNECTING	0x008	/* in process of disconnecting */
#define	SS_CANTSENDMORE		0x010	/* can't send more data to peer */
#define	SS_CANTRCVMORE		0x020	/* can't receive more data from peer */
#define	SS_RCVATMARK		0x040	/* at mark on input */
#define SS_ISBOUND		0x080	/* socket is bound */

#define	SS_PRIV			0x080	/* privileged for broadcast, raw... */
#define	SS_NBIO			0x100	/* non-blocking ops */
#define	SS_ASYNC		0x200	/* async i/o notify */


/*
 * Macros for sockets and socket buffering.
 */

/* how much space is there in a socket buffer (so->so_snd or so->so_rcv) */
#define	sbspace(sb) \
    (MIN((int)((sb)->sb_hiwat - (sb)->sb_cc),\
	 (int)((sb)->sb_mbmax - (sb)->sb_mbcnt)))

/* do we have to send all at once on a socket? */
#define	sosendallatonce(so) \
    ((so)->so_proto->pr_flags & PR_ATOMIC)

/* can we read something from so? */
#define	soreadable(so) \
    ((so)->so_rcv.sb_cc || ((so)->so_state & SS_CANTRCVMORE) || \
	(so)->so_qlen || (so)->so_error)

/* can we write something to so? */
#define	sowriteable(so) \
    (sbspace(&(so)->so_snd) > 0 && \
	(((so)->so_state&SS_ISCONNECTED) || \
	  ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || \
     ((so)->so_state & SS_CANTSENDMORE) || \
     (so)->so_error)

/* adjust counters in sb reflecting allocation of m */
#define	sballoc(sb, m) { \
	(sb)->sb_cc += (m)->m_len; \
	(sb)->sb_mbcnt += MSIZE; \
	if ((m)->m_off > MMAXOFF) \
		(sb)->sb_mbcnt += MCLBYTES; \
}

/* adjust counters in sb reflecting freeing of m */
#define	sbfree(sb, m) { \
	(sb)->sb_cc -= (m)->m_len; \
	(sb)->sb_mbcnt -= MSIZE; \
	if ((m)->m_off > MMAXOFF) \
		(sb)->sb_mbcnt -= MCLBYTES; \
}

/* set lock on sockbuf sb */
#define	sblock(so, sb) { \
	while ((sb)->sb_flags & SB_LOCK) { \
		(sb)->sb_flags |= SB_WANT; \
		(void) sleep((caddr_t)&(sb)->sb_flags, PZERO+1); \
	} \
	(sb)->sb_flags |= SB_LOCK; \
}

/* release lock on sockbuf sb */
#define	sbunlock(so, sb) { \
	(sb)->sb_flags &= ~SB_LOCK; \
	if ((sb)->sb_flags & SB_WANT) { \
		(sb)->sb_flags &= ~SB_WANT; \
		if ((so)->so_wupalt) \
			(*(so)->so_wupalt->wup_func)(so, \
			(caddr_t)&(sb)->sb_flags, \
				(so)->so_wupalt->wup_arg);\
		else \
			wakeup((caddr_t)&(sb)->sb_flags); \
	} \
}

#define	sorwakeup(so)	sowakeup((so), &(so)->so_rcv)
#define	sowwakeup(so)	sowakeup((so), &(so)->so_snd)

#ifdef _KERNEL
struct	socket *sonewconn();
#endif

#endif	/* _SYS_SOCKETVAR_H */
   070701000059ee000081240000000200000002000000012719347c0000141d000000230000000c00000000000000000000001900000000usr/include/sys/sockio.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef	_SYS_SOCKIO_H
#define	_SYS_SOCKIO_H

#ident	"@(#)/usr/include/sys/sockio.h.sl 1.1 4.0 10/15/90 45519 AT&T-SF"

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/*
 * General socket ioctl definitions.
 */

#include <sys/ioccom.h>

/* socket i/o controls */
#define	SIOCSHIWAT	_IOW('s',  0, int)		/* set high watermark */
#define	SIOCGHIWAT	_IOR('s',  1, int)		/* get high watermark */
#define	SIOCSLOWAT	_IOW('s',  2, int)		/* set low watermark */
#define	SIOCGLOWAT	_IOR('s',  3, int)		/* get low watermark */
#define	SIOCATMARK	_IOR('s',  7, int)		/* at oob mark? */
#define	SIOCSPGRP	_IOW('s',  8, int)		/* set process group */
#define	SIOCGPGRP	_IOR('s',  9, int)		/* get process group */

#define	SIOCADDRT	_IOW('r', 10, struct rtentry)	/* add route */
#define	SIOCDELRT	_IOW('r', 11, struct rtentry)	/* delete route */

#define	SIOCSIFADDR	_IOW('i', 12, struct ifreq)	/* set ifnet address */
#define	SIOCGIFADDR	_IOWR('i',13, struct ifreq)	/* get ifnet address */
#define	SIOCSIFDSTADDR	_IOW('i', 14, struct ifreq)	/* set p-p address */
#define	SIOCGIFDSTADDR	_IOWR('i',15, struct ifreq)	/* get p-p address */
#define	SIOCSIFFLAGS	_IOW('i', 16, struct ifreq)	/* set ifnet flags */
#define	SIOCGIFFLAGS	_IOWR('i',17, struct ifreq)	/* get ifnet flags */
#define	SIOCSIFMEM	_IOW('i', 18, struct ifreq)	/* set interface mem */
#define	SIOCGIFMEM	_IOWR('i',19, struct ifreq)	/* get interface mem */
#define	SIOCGIFCONF	_IOWR('i',20, struct ifconf)	/* get ifnet list */
#define	SIOCSIFMTU	_IOW('i', 21, struct ifreq)	/* set if_mtu */
#define	SIOCGIFMTU	_IOWR('i',22, struct ifreq)	/* get if_mtu */

	/* from 4.3BSD */
#define	SIOCGIFBRDADDR	_IOWR('i',23, struct ifreq)	/* get broadcast addr */
#define	SIOCSIFBRDADDR	_IOW('i',24, struct ifreq)	/* set broadcast addr */
#define	SIOCGIFNETMASK	_IOWR('i',25, struct ifreq)	/* get net addr mask */
#define	SIOCSIFNETMASK	_IOW('i',26, struct ifreq)	/* set net addr mask */
#define	SIOCGIFMETRIC	_IOWR('i',27, struct ifreq)	/* get IF metric */
#define	SIOCSIFMETRIC	_IOW('i',28, struct ifreq)	/* set IF metric */

#define	SIOCSARP	_IOW('i', 30, struct arpreq)	/* set arp entry */
#define	SIOCGARP	_IOWR('i',31, struct arpreq)	/* get arp entry */
#define	SIOCDARP	_IOW('i', 32, struct arpreq)	/* delete arp entry */
#define	SIOCUPPER       _IOW('i', 40, struct ifreq)       /* attach upper layer */
#define	SIOCLOWER       _IOW('i', 41, struct ifreq)       /* attach lower layer */
#define	SIOCSETSYNC	_IOW('i',  44, struct ifreq)	/* set syncmode */
#define	SIOCGETSYNC	_IOWR('i', 45, struct ifreq)	/* get syncmode */
#define	SIOCSSDSTATS	_IOWR('i', 46, struct ifreq)	/* sync data stats */
#define	SIOCSSESTATS	_IOWR('i', 47, struct ifreq)	/* sync error stats */

#define	SIOCSPROMISC	_IOW('i', 48, int)		/* request promisc mode
							   on/off */
#define	SIOCADDMULTI	_IOW('i', 49, struct ifreq)	/* set m/c address */
#define	SIOCDELMULTI	_IOW('i', 50, struct ifreq)	/* clr m/c address */

/* protocol i/o controls */
#define	SIOCSNIT	_IOW('p',  0, struct nit_ioc)	/* set nit modes */
#define	SIOCGNIT	_IOWR('p', 1, struct nit_ioc)	/* get nit modes */

/* STREAMS based socket emulation */

#define SIOCPROTO	_IOW('s', 51, struct socknewproto)	/* link proto */
#define SIOCGETNAME	_IOR('s', 52, struct sockaddr)	/* getsockname */
#define SIOCGETPEER	_IOR('s', 53, struct sockaddr)	/* getpeername */
#define IF_UNITSEL	_IOW('s', 54, int)	/* set unit number */
#define SIOCXPROTO	_IO('s', 55)	/* empty proto table */

#define SIOCIFDETACH	_IOW('i', 56, struct ifreq)	/* detach interface */
#define SIOCGENPSTATS	_IOWR('i', 57, struct ifreq)	/* get ENP stats */
#define SIOCX25XMT	_IOWR('i', 59, struct ifreq)	/* start a slp proc in
							 * x25if */
#define SIOCX25RCV	_IOWR('i', 60, struct ifreq)	/* start a slp proc in
							 * x25if */
#define SIOCX25TBL	_IOWR('i', 61, struct ifreq)	/* xfer lun table to
							 * kernel */
#define SIOCSLGETREQ	_IOWR('i', 71, struct ifreq)	/* wait for switched
							 * SLIP request */
#define SIOCSLSTAT	_IOW('i', 72, struct ifreq)	/* pass SLIP info to
							 * kernel */
#define SIOCSIFNAME	_IOW('i', 73, struct ifreq)	/* set interface name */
#define SIOCGENADDR	_IOWR('i', 85, struct ifreq)	/* Get ethernet addr */
#define SIOCSOCKSYS	_IOW('i', 86, struct socksysreq)	/* Pseudo socket syscall */

#endif	/* _SYS_SOCKIO_H */
   070701000059ef000081240000000200000002000000012719347c0000127c000000230000000c00000000000000000000001a00000000usr/include/sys/sockmod.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef	_SYS_SOCKMOD_H
#define	_SYS_SOCKMOD_H

#ident	"@(#)/usr/include/sys/sockmod.h.sl 1.1 4.0 10/15/90 41032 AT&T-SF"

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988.1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#include <sys/un.h>	/* for sockaddr_un */

/* internal flags - in addition to the ones in timod.h */
#define		S_WINFO		0x01000	/* waiting for T_info to complete */
#define 	S_WRDISABLE	0x02000	/* write service queue disabled */
#define 	S_WUNBIND	0x04000	/* waiting on T_OK_ACK for 
					 * T_UNBIND_REQ
					 */
#define 	S_RBLOCKED	0x08000 /* read side is/was blocked */
#define 	S_WBLOCKED	0x10000 /* write side is/was blocked */
#define 	S_WCLOSE	0x20000 /* Waiting to free the so_so, but
					 * have pending esballoc'ed msgs.
					 */

/* socket module ioctls */
#define		SIMOD 		('I'<<8)

/*
 * The following are ioctl handled specially by the socket
 * module which were not handled by timod.
 */
#define		SI_GETUDATA		(SIMOD|101)
#define		SI_SHUTDOWN		(SIMOD|102)
#define		SI_LISTEN		(SIMOD|103)
#define		SI_SETMYNAME		(SIMOD|104)
#define		SI_SETPEERNAME		(SIMOD|105)
#define		SI_GETINTRANSIT		(SIMOD|106)
#define		SI_TCL_LINK		(SIMOD|107)
#define		SI_TCL_UNLINK		(SIMOD|108)


struct si_udata {
	int	tidusize;	/* TIDU size          */
	int	addrsize;	/* address size	      */
	int	optsize;	/* options size	      */
	int	etsdusize;	/* expedited size     */
	int	servtype;	/* service type       */
	int	so_state;	/* socket states      */
	int	so_options;	/* socket options     */
};

struct _si_user {
	struct	_si_user 	*next;		/* next one 	      */
	struct	_si_user 	*prev;		/* previous one	      */
	int		  	fd;		/* file descripter    */
	int		  	ctlsize;	/* ctl buffer size    */
	char   		 	*ctlbuf;	/* ctl buffer         */
	int			family;		/* protocol family    */
	struct	si_udata	udata;		/* socket info	      */
	int			flags;
};

/*
 * Flag bits.
 */
#define		S_SIGIO		0x1	/* If set, user has SIGIO enabled */
#define		S_SIGURG	0x2	/* If set, user has SIGURG enabled */

/*
 * Used for the tortuous UNIX domain
 * naming.
 */
struct ux_dev {
	dev_t	dev;
	ino_t	ino;
};

struct ux_extaddr {
	size_t	size;				/* Size of following address */
	union	{
		struct ux_dev	tu_addr;	/* User selected address */
		int		tp_addr;	/* TP selected address */
	} addr;
};
#define		extdev		ux_extaddr.addr.tu_addr.dev
#define		extino		ux_extaddr.addr.tu_addr.ino
#define		extsize		ux_extaddr.size
#define		extaddr		ux_extaddr.addr

struct bind_ux {
	struct	sockaddr_un	name;
	struct	ux_extaddr	ux_extaddr;
};

/*
 * Doubly linked list of so_so that
 * represent a UNIX domain socket.
 */
struct so_ux {
	struct so_so *next;
	struct so_so *prev;
};

struct so_so {
	long 			flags;
	queue_t			*rdq;
	mblk_t  		*iocsave;
	struct	t_info		tp_info;
	struct	netbuf		raddr;
	struct	netbuf		laddr;
	struct	ux_extaddr	lux_dev;
	struct	ux_extaddr	rux_dev;
	int			so_error;
	mblk_t  		*oob;
	struct	so_so		*so_conn;
	mblk_t 			*consave;
	struct	si_udata	udata;
	int			so_option;
	mblk_t  		*bigmsg;
	struct	so_ux		so_ux;
	int			hasoutofband;
	mblk_t			*urg_msg;
	int			sndbuf;
	int			rcvbuf;
	int			sndlowat;
	int			rcvlowat;
	int			linger;
	int			sndtimeo;
	int			rcvtimeo;
	int			prototype;
	int			esbcnt;
};

extern struct _si_user 	*_s_checkfd();
extern struct _si_user 	*_s_open();
extern void 		 _s_aligned_copy();
extern struct netconfig	*_s_match();
extern int 	 	 _s_sosend();
extern int		 _s_soreceive();
extern int 		 _s_getudata();
extern int 		 _s_is_ok();
extern int 		 _s_do_ioctl();
extern int 		 _s_min();
extern int		 _s_max();
extern void		 _s_close();
extern int		 _s_getfamily();
extern int		 _s_uxpathlen();
extern void		 (*sigset())();

/*
 * Socket library debugging
 */
extern int		_s_sockdebug;
#define	SOCKDEBUG(S, A, B)	\
			if ((((S) && (S)->udata.so_options & SO_DEBUG)) || \
						_s_sockdebug) { \
				(void)syslog(LOG_ERR, (A), (B)); \
			}
#endif /* _SYS_SOCKMOD_H */
070701000059f0000081240000000200000002000000012719347c00001e53000000230000000c00000000000000000000001700000000usr/include/sys/stat.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STAT_H
#define _SYS_STAT_H

#ident	"@(#)/usr/include/sys/stat.h.sl 1.1 4.0 10/15/90 54254 AT&T-SF"

#include <sys/time.h>

#define _ST_FSTYPSZ 16		/* array size for file system type name */

/*
 * stat structure, used by stat(2) and fstat(2)
 */

#if defined(_KERNEL)

	/* SVID stat struct */
struct	stat {
	o_dev_t	st_dev;
	o_ino_t	st_ino;
	o_mode_t st_mode;
	o_nlink_t st_nlink;
	o_uid_t st_uid;
	o_gid_t st_gid;
	o_dev_t	st_rdev;
	off_t	st_size;
	time_t	st_atime;
	time_t	st_mtime;
	time_t	st_ctime;
};
	/* Expanded stat structure */ 

struct	xstat {
	dev_t	st_dev;
	long	st_pad1[3];	/* reserve for dev expansion, sysid definition */
	ino_t	st_ino;
	mode_t	st_mode;
	nlink_t st_nlink;
	uid_t 	st_uid;
	gid_t 	st_gid;
	dev_t	st_rdev;
	long	st_pad2[2];
	off_t	st_size;
	long	st_pad3;	/* reserve pad for future off_t expansion */
	timestruc_t st_atime;
	timestruc_t st_mtime;
	timestruc_t st_ctime;
	long	st_blksize;
	long	st_blocks;
	char	st_fstype[_ST_FSTYPSZ];
	long	st_pad4[8];	/* expansion area */
};

#else /* !defined(_KERNEL) */
#if !defined(_STYPES)	/* user level 4.0 stat struct */

/* maps to kernel struct xstat */
struct	stat {
	dev_t	st_dev;
	long	st_pad1[3];	/* reserved for network id */
	ino_t	st_ino;
	mode_t	st_mode;
	nlink_t st_nlink;
	uid_t 	st_uid;
	gid_t 	st_gid;
	dev_t	st_rdev;
	long	st_pad2[2];
	off_t	st_size;
	long	st_pad3;	/* future off_t expansion */
	timestruc_t st_atim;	
	timestruc_t st_mtim;	
	timestruc_t st_ctim;	
	long	st_blksize;
	long	st_blocks;
	char	st_fstype[_ST_FSTYPSZ];
	long	st_pad4[8];	/* expansion area */
};
#define st_atime	st_atim.tv_sec
#define st_mtime	st_mtim.tv_sec
#define st_ctime	st_ctim.tv_sec

#else	/*  SVID Issue 2 stat */

struct	stat {
	o_dev_t	st_dev;
	o_ino_t	st_ino;
	o_mode_t st_mode;
	o_nlink_t st_nlink;
	o_uid_t	st_uid;
	o_gid_t	st_gid;
	o_dev_t	st_rdev;
	off_t	st_size;
	time_t	st_atime;
	time_t	st_mtime;
	time_t	st_ctime;
};
#endif	/* end !defined(_STYPES) */
#endif	/* end defined(_KERNEL) */


/* MODE MASKS */

/* de facto standard definitions */

#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	S_IFMT		0xF000	/* type of file */
#endif /*!defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE)*/ 
#if !defined(_POSIX_SOURCE) 
#define S_IAMB		0x1FF	/* access mode bits */
#endif /* !defined(_POSIX_SOURCE) */
#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	S_IFIFO		0x1000	/* fifo */
#define	S_IFCHR		0x2000	/* character special */
#define	S_IFDIR		0x4000	/* directory */
#endif /*!defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE)*/ 
#if !defined(_POSIX_SOURCE) 
#define	S_IFNAM		0x5000  /* XENIX special named file */
#define		S_INSEM 0x1	/* XENIX semaphore subtype of IFNAM */
#define		S_INSHD 0x2	/* XENIX shared data subtype of IFNAM */
#endif /* !defined(_POSIX_SOURCE) */

#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	S_IFBLK		0x6000	/* block special */
#define	S_IFREG		0x8000	/* regular */
#endif /*!defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE)*/ 
#if !defined(_POSIX_SOURCE) 
#define	S_IFLNK		0xA000	/* symbolic link */
#define	S_IFSOCK	0xC000	/* socket */
#endif /* !defined(_POSIX_SOURCE) */

#define	S_ISUID		0x800	/* set user id on execution */
#define	S_ISGID		0x400	/* set group id on execution */

#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	S_ISVTX		0x200	/* save swapped text even after use */
#endif /* !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) */

#if !defined(_POSIX_SOURCE) 
#define	S_IREAD		00400	/* read permission, owner */
#define	S_IWRITE	00200	/* write permission, owner */
#define	S_IEXEC		00100	/* execute/search permission, owner */
#define	S_ENFMT		S_ISGID	/* record locking enforcement flag */
#endif /* !defined(_POSIX_SOURCE) */


/* the following macros are for POSIX conformance */

#define	S_IRWXU	00700		/* read, write, execute: owner */
#define	S_IRUSR	00400		/* read permission: owner */
#define	S_IWUSR	00200		/* write permission: owner */
#define	S_IXUSR	00100		/* execute permission: owner */
#define	S_IRWXG	00070		/* read, write, execute: group */
#define	S_IRGRP	00040		/* read permission: group */
#define	S_IWGRP	00020		/* write permission: group */
#define	S_IXGRP	00010		/* execute permission: group */
#define	S_IRWXO	00007		/* read, write, execute: other */
#define	S_IROTH	00004		/* read permission: other */
#define	S_IWOTH	00002		/* write permission: other */
#define	S_IXOTH	00001		/* execute permission: other */


#define S_ISFIFO(mode)	((mode&0xF000) == 0x1000)
#define S_ISCHR(mode)	((mode&0xF000) == 0x2000)
#define S_ISDIR(mode)	((mode&0xF000) == 0x4000)
#define S_ISBLK(mode)	((mode&0xF000) == 0x6000)
#define S_ISREG(mode)	((mode&0xF000) == 0x8000) 


/* a version number is included in the SVR4 stat and mknod interfaces. */


#define _R3_MKNOD_VER 1		/* SVR3.0 mknod */
#define _MKNOD_VER 2		/* current version of mknod */
#define _R3_STAT_VER 1		/* SVR3.0 stat */
#define _STAT_VER 2		/* current version of stat */

#if !defined(_KERNEL)
#if defined(__STDC__)

#if !defined(_STYPES)
static int fstat(int, struct stat *);
static int stat(const char *, struct stat *);
#if !defined(_POSIX_SOURCE) 
static int lstat(const char *, struct stat *);
static int mknod(const char *, mode_t, dev_t);
#endif /* !defined(_POSIX_SOURCE) */
#else
int fstat(int, struct stat *);
int stat(const char *, struct stat *);
#if !defined(_POSIX_SOURCE) 
int lstat(const char *, struct stat *);
int mknod(const char *, mode_t, dev_t);
#endif /* !defined(_POSIX_SOURCE) */
#endif

int _fxstat(const int, int, struct stat *);
int _xstat(const int, const char *, struct stat *);
#if !defined(_POSIX_SOURCE) 
int _lxstat(const int, const char *, struct stat *);
int _xmknod(const int, const char *, mode_t, dev_t);
#endif /* !defined(_POSIX_SOURCE) */
extern int chmod(const char *, mode_t);
extern int mkdir(const char *, mode_t);
extern int mkfifo(const char *, mode_t);
extern mode_t umask(mode_t);

#else	/* !__STDC__ */

#if !defined(_STYPES)
static int fstat(), stat();
#if !defined(_POSIX_SOURCE) 
static int mknod(), lstat();
#endif /* !defined(_POSIX_SOURCE) */
#else
int fstat(), stat();
#if !defined(_POSIX_SOURCE) 
int mknod(), lstat();
#endif /* !defined(_POSIX_SOURCE) */
#endif

int _fxstat(), _xstat();
#if !defined(_POSIX_SOURCE) 
int _xmknod(), _lxstat();
#endif /* !defined(_POSIX_SOURCE) */
extern int chmod();
extern int mkdir();
extern int mkfifo();
extern mode_t umask();

#endif /* defined(__STDC__) */
#endif /* !defined(_KERNEL) */

/*
 * NOTE: Application software should NOT program 
 * to the _xstat interface.
 */

#if !defined(_STYPES) && !defined(_KERNEL)
static int
stat(path, buf)
const char *path;
struct stat *buf;
{
int ret;
	ret = _xstat(_STAT_VER, path, buf);
	return ret; 
}

#if !defined(_POSIX_SOURCE) 
static int
lstat(path, buf)
const char *path;
struct stat *buf;
{
int ret;
	ret = _lxstat(_STAT_VER, path, buf);
	return ret;
}
#endif /* !defined(_POSIX_SOURCE) */

static int
fstat(fd, buf)
int fd;
struct stat *buf;
{
int ret;
	ret = _fxstat(_STAT_VER, fd, buf);
	return ret;
}

#if !defined(_POSIX_SOURCE) 
static int
mknod(path, mode, dev)
const char *path;
mode_t mode;
dev_t dev;
{
int ret;
	ret = _xmknod(_MKNOD_VER, path, mode, dev);
	return ret;
}
#endif /* !defined(_POSIX_SOURCE) */

#endif
/*			Function prototypes
 *			___________________
 *
 * fstat()/stat() used for NON-EFT case - functions defined in libc.
 * fxstat/xstat/lxstat are called indirectly from fstat/stat/lstat when EFT is 
 * enabled.
 */



#endif	/* _SYS_STAT_H */
 070701000059f1000081240000000200000002000000012719347c000004bf000000230000000c00000000000000000000001900000000usr/include/sys/statfs.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STATFS_H
#define _SYS_STATFS_H

#ident	"@(#)/usr/include/sys/statfs.h.sl 1.1 4.0 10/15/90 61549 AT&T-SF"
/*
 * Structure returned by statfs(2) and fstatfs(2).
 * This structure and associated system calls have been replaced
 * by statvfs(2) and fstatvfs(2) and will be removed from the system
 * in a near-future release.
 */

struct	statfs {
	short	f_fstyp;	/* File system type */
	long	f_bsize;	/* Block size */
	long	f_frsize;	/* Fragment size (if supported) */
	long	f_blocks;	/* Total number of blocks on file system */
	long	f_bfree;	/* Total number of free blocks */
	ino_t	f_files;	/* Total number of file nodes (inodes) */
	ino_t	f_ffree;	/* Total number of free file nodes */
	char	f_fname[6];	/* Volume name */
	char	f_fpack[6];	/* Pack name */
};

#if defined(__STDC__) && !defined(_KERNEL)
int statfs(const char *, struct statfs *, int, int);
int fstatfs(int, struct statfs *, int, int);
#endif

#endif	/* _SYS_STATFS_H */
 070701000059f2000081240000000200000002000000012719347c00000662000000230000000c00000000000000000000001a00000000usr/include/sys/statvfs.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STATVFS_H
#define _SYS_STATVFS_H

#ident	"@(#)/usr/include/sys/statvfs.h.sl 1.1 4.0 10/15/90 33560 AT&T-SF"
/*
 * Structure returned by statvfs(2).
 */

#define	FSTYPSZ	16

typedef struct statvfs {
	u_long	f_bsize;	/* fundamental file system block size */
	u_long	f_frsize;	/* fragment size */
	u_long	f_blocks;	/* total # of blocks of f_frsize on fs */
	u_long	f_bfree;	/* total # of free blocks of f_frsize */
	u_long	f_bavail;	/* # of free blocks avail to non-superuser */
	u_long	f_files;	/* total # of file nodes (inodes) */
	u_long	f_ffree;	/* total # of free file nodes */
	u_long	f_favail;	/* # of free nodes avail to non-superuser */
	u_long	f_fsid;		/* file system id (dev for now) */
	char	f_basetype[FSTYPSZ]; /* target fs type name, null-terminated */
	u_long	f_flag;		/* bit-mask of flags */
	u_long	f_namemax;	/* maximum file name length */
	char	f_fstr[32];	/* filesystem-specific string */
	u_long	f_filler[16];	/* reserved for future expansion */
} statvfs_t;

/*
 * Flag definitions.
 */

#define	ST_RDONLY	0x01	/* read-only file system */
#define	ST_NOSUID	0x02	/* does not support setuid/setgid semantics */
#define ST_NOTRUNC	0x04	/* does not truncate long file names */

#if defined(__STDC__) && !defined(_KERNEL)
int statvfs(const char *, struct statvfs *);
int fstatvfs(int, struct statvfs *);
#endif

#endif	/* _SYS_STATVFS_H */
  070701000059f3000081240000000200000002000000012719347c00000706000000230000000c00000000000000000000001a00000000usr/include/sys/stermio.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STERMIO_H
#define _SYS_STERMIO_H

#ident	"@(#)/usr/include/sys/stermio.h.sl 1.1 4.0 10/15/90 43167 AT&T-SF"
/*
 * ioctl commands for control channels
 */
#define STSTART		1	/* start protocol */
#define STHALT		2	/* cease protocol */
#define STPRINT		3	/* assign device to printer */
#define STENABLE	4	/* enable polling */
#define STDISABLE	5	/* disable polling */
#define STPOLL		6	/* set polling rate */
#define STCNTRS		7	/* poke for status reports */
#define STTCHAN		8	/* set trace channel number */

/*
 * ioctl commands for terminal and printer channels
 */
#define STGET	(('X'<<8)|0)	/* get line options */
#define STSET	(('X'<<8)|1)	/* set line options */
#define	STTHROW	(('X'<<8)|2)	/* throw away queued input */
#define	STWLINE	(('X'<<8)|3)	/* get synchronous line # */
#define STTSV	(('X'<<8)|4)	/* get all line information */

struct stio {
	unsigned short	ttyid;
	char		row;
	char		col;
	char		orow;
	char		ocol;
	char		tab;
	char		aid;
	char		ss1;
	char		ss2;
	unsigned short	imode;
	unsigned short	lmode;
	unsigned short	omode;
};

/*
**	Mode Definitions.
*/
#define	STFLUSH	00400	/* FLUSH mode; lmode */
#define	STWRAP	01000	/* WRAP mode; lmode */
#define	STAPPL	02000	/* APPLICATION mode; lmode */

struct sttsv {
	char	st_major;
	short	st_pcdnum;
	char	st_devaddr;
	int	st_csidev;
};

struct stcntrs {
	char	st_lrc;
	char	st_xnaks;
	char	st_rnaks;
	char	st_xwaks;
	char	st_rwaks;
	char	st_scc;
};

/* trace message definitions */

#define LOC	113	/* loss of carrier */


#endif	/* _SYS_STERMIO_H */
  070701000059f4000081240000000200000002000000012719347c0000506a000000230000000c00000000000000000000001900000000usr/include/sys/stream.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STREAM_H
#define _SYS_STREAM_H

#ident	"@(#)/usr/include/sys/stream.h.sl 1.1 4.0 10/15/90 32835 AT&T-SF"

/*
 * For source compatibility
 */
#include <sys/vnode.h>
#include <sys/poll.h>
#include <sys/strmdep.h>
#include <sys/cred.h>

/*
 * Data queue
 */
#ifdef _STYPES

struct	queue {
	struct	qinit	*q_qinfo;	/* procs and limits for queue */
	struct	msgb	*q_first;	/* first data block */
	struct	msgb	*q_last;	/* last data block */
	struct	queue	*q_next;	/* Q of next stream */
	struct	equeue	*q_eq;		/* extended queue info */
	_VOID		*q_ptr;		/* to private data structure */
	ushort		q_count;	/* number of bytes on Q */
	ushort		q_flag;		/* queue state */
	short		q_minpsz;	/* min packet size accepted by */
					/* this module */
	short		q_maxpsz;	/* max packet size accepted by */
					/* this module */
	ushort		q_hiwat;	/* queue high water mark */
	ushort		q_lowat;	/* queue low water mark */
};

/*
 * Extended queue structure containing information that belongs
 * in the queue, but can't be added because of binary compatibility
 * of STREAMS modules and drivers.
 */
struct equeue {
	struct queue	*eq_link;	/* to next Q for scheduling */
	struct qband	*eq_bandp;	/* separate flow information */
	unsigned char	eq_nband;	/* number of priority bands > 0 */
};

#define q_link	q_eq->eq_link
#define q_bandp	q_eq->eq_bandp
#define q_nband	q_eq->eq_nband

#else /* large definition */

struct	queue {
	struct	qinit	*q_qinfo;	/* procs and limits for queue */
	struct	msgb	*q_first;	/* first data block */
	struct	msgb	*q_last;	/* last data block */
	struct	queue	*q_next;	/* Q of next stream */
	struct	queue	*q_link;	/* to next Q for scheduling */
	_VOID		*q_ptr;		/* to private data structure */
	ulong		q_count;	/* number of bytes on Q */
	ulong		q_flag;		/* queue state */
	long		q_minpsz;	/* min packet size accepted by */
					/* this module */
	long		q_maxpsz;	/* max packet size accepted by */
					/* this module */
	ulong		q_hiwat;	/* queue high water mark */
	ulong		q_lowat;	/* queue low water mark */
	struct qband	*q_bandp;	/* separate flow information */
	unsigned char	q_nband;	/* number of priority bands > 0 */
	unsigned char	q_pad1[3];	/* reserved for future use */
	long		q_pad2[2];	/* reserved for future use */
};

#endif /* _STYPES */

typedef struct queue queue_t;

/*
 * Queue flags
 */
#define	QENAB	0x001			/* Queue is already enabled to run */
#define	QWANTR	0x002			/* Someone wants to read Q */
#define	QWANTW	0x004			/* Someone wants to write Q */
#define	QFULL	0x008			/* Q is considered full */
#define	QREADR	0x010			/* This is the reader (first) Q */
#define	QUSE	0x020			/* This queue in use (allocation) */
#define	QNOENB	0x040			/* Don't enable Q via putq */
#define	QOLD	0x080			/* Pre-SVR4 open/close interface */
#define QBACK	0x100			/* queue has been back-enabled */
#define QHLIST	0x200			/* strhead write queue is on "scanqhead" */

/*
 * Structure that describes the separate information
 * for each priority band in the queue.
 */
struct qband {
	struct qband	*qb_next;	/* next band's info */
	ulong		qb_count;	/* number of bytes in band */
	struct msgb	*qb_first;	/* beginning of band's data */
	struct msgb	*qb_last;	/* end of band's data */
	ulong		qb_hiwat;	/* high water mark for band */
	ulong		qb_lowat;	/* low water mark for band */
	ulong		qb_flag;	/* see below */
	long		qb_pad1;	/* reserved for future use */
};

typedef struct qband qband_t;

/*
 * qband flags
 */
#define QB_FULL		0x01		/* band is considered full */
#define QB_WANTW	0x02		/* Someone wants to write to band */
#define QB_BACK		0x04		/* queue has been back-enabled */

/*
 * Maximum number of bands.
 */
#define NBAND	256

/*
 * Fields that can be manipulated through strqset() and strqget().
 */
typedef enum qfields {
	QHIWAT	= 0,		/* q_hiwat or qb_hiwat */
	QLOWAT	= 1,		/* q_lowat or qb_lowat */
	QMAXPSZ	= 2,		/* q_maxpsz */
	QMINPSZ	= 3,		/* q_minpsz */
	QCOUNT	= 4,		/* q_count or qb_count */
	QFIRST	= 5,		/* q_first or qb_first */
	QLAST	= 6,		/* q_last or qb_last */
	QFLAG	= 7,		/* q_flag or qb_flag */
	QBAD	= 8
} qfields_t;

/*
 * Module information structure
 */

#ifdef _STYPES

struct module_info {
	ulong	mi_idnum;		/* module id number */
	char 	*mi_idname;		/* module name */
	short   mi_minpsz;		/* min packet size accepted */
	short   mi_maxpsz;		/* max packet size accepted */
	ushort	mi_hiwat;		/* hi-water mark */
	ushort 	mi_lowat;		/* lo-water mark */
};

#else /* large definition */

struct module_info {
	ulong	mi_idnum;		/* module id number */
	char 	*mi_idname;		/* module name */
	long	mi_minpsz;		/* min packet size accepted */
	long	mi_maxpsz;		/* max packet size accepted */
	ulong	mi_hiwat;		/* hi-water mark */
	ulong 	mi_lowat;		/* lo-water mark */
};

#endif /* _STYPES */

/*
 * queue information structure
 */
struct	qinit {
	int	(*qi_putp)();		/* put procedure */
	int	(*qi_srvp)();		/* service procedure */
	int	(*qi_qopen)();		/* called on startup */
	int	(*qi_qclose)();		/* called on finish */
	int	(*qi_qadmin)();		/* for future use */
	struct module_info *qi_minfo;	/* module information structure */
	struct module_stat *qi_mstat;	/* module statistics structure */
};

/*
 * Streamtab (used in cdevsw and fmodsw to point to module or driver)
 */

struct streamtab {
	struct qinit *st_rdinit;
	struct qinit *st_wrinit;
	struct qinit *st_muxrinit;
	struct qinit *st_muxwinit;
};

/*
 * Structure sent to mux drivers to indicate a link.
 */
#ifdef _STYPES

struct linkblk {
	queue_t *l_qtop;	/* lowest level write queue of upper stream */
				/* (set to NULL for persistent links) */
	queue_t *l_qbot;	/* highest level write queue of lower stream */
	int      l_index;	/* index for lower stream. */
};

#else /* large definition */

struct linkblk {
	queue_t *l_qtop;	/* lowest level write queue of upper stream */
				/* (set to NULL for persistent links) */
	queue_t *l_qbot;	/* highest level write queue of lower stream */
	int      l_index;	/* index for lower stream. */
	long	 l_pad[5];	/* reserved for future use */
};

#endif /* _STYPES */

/*
 * Class 0 data buffer freeing routine
 */
struct free_rtn {
	void (*free_func)();
	char *free_arg;
};

/*
 *  Data block descriptor
 */

#ifdef _STYPES

struct datab {
	union {
		struct datab	*freep;
		struct free_rtn *frtnp;
	} db_f;
	unsigned char	*db_base;
	unsigned char	*db_lim;
	unsigned char	db_ref;
	unsigned char	db_type;
	unsigned char	db_band;
	unsigned char	db_iswhat;	/* status of the mesg/data/buffer triplet */
	unsigned int	db_size;
	unsigned short	db_flag;
	unsigned short	db_pad;	
	caddr_t		db_msgaddr; 	/* triplet mesg header that points to datab */
};

#else /* large definition */

struct datab {
	union {
		struct datab	*freep;
		struct free_rtn *frtnp;
	} db_f;
	unsigned char	*db_base;
	unsigned char	*db_lim;
	unsigned char	db_ref;
	unsigned char	db_type;
	unsigned char	db_iswhat;	/* status of the mesg/data/buffer triplet */
	unsigned int	db_size;
	long		db_filler;	/* reserved for future use */
	caddr_t		db_msgaddr;	/* triplet mesg header that points to datab */
};

#endif /* _STYPES */

#define db_freep db_f.freep
#define db_frtnp db_f.frtnp

/*
 * Message block descriptor
 */

#ifdef _STYPES

struct	msgb {
	struct	msgb	*b_next;
	struct  msgb	*b_prev;
	struct	msgb	*b_cont;
	unsigned char	*b_rptr;
	unsigned char	*b_wptr;
	struct datab 	*b_datap;
};

#define b_band	b_datap->db_band
#define b_flag	b_datap->db_flag

#else /* large definition */

struct	msgb {
	struct	msgb	*b_next;
	struct  msgb	*b_prev;
	struct	msgb	*b_cont;
	unsigned char	*b_rptr;
	unsigned char	*b_wptr;
	struct datab 	*b_datap;
	unsigned char	b_band;
	unsigned char	b_pad1;
	unsigned short	b_flag;
	long		b_pad2;
};

#endif /* _STYPES */

typedef struct msgb mblk_t;
typedef struct datab dblk_t;
typedef struct free_rtn frtn_t;




/*
 * Message flags.  These are interpreted by the stream head.
 */
#define MSGMARK		0x01		/* last byte of message is "marked" */
#define MSGNOLOOP	0x02		/* don't loop message around to */
					/* write side of stream */
#define MSGDELIM	0x04		/* message is delimited */
#define MSGNOGET	0x08		/* getq does not return message */

/*
 * Streams message types.
 */

/*
 * Data and protocol messages (regular and priority)
 */
#define	M_DATA		0x00		/* regular data */
#define M_PROTO		0x01		/* protocol control */

/*
 * Control messages (regular and priority)
 */
#define	M_BREAK		0x08		/* line break */
#define M_PASSFP	0x09		/* pass file pointer */
#define M_EVENT		0x0a		/* post an event to an event queue */
#define	M_SIG		0x0b		/* generate process signal */
#define	M_DELAY		0x0c		/* real-time xmit delay (1 param) */
#define M_CTL		0x0d		/* device-specific control message */
#define	M_IOCTL		0x0e		/* ioctl; set/get params */
#define M_SETOPTS	0x10		/* set various stream head options */
#define M_RSE		0x11		/* reserved for RSE use only */

/*
 * Control messages (high priority; go to head of queue)
 */
#define	M_IOCACK	0x81		/* acknowledge ioctl */
#define	M_IOCNAK	0x82		/* negative ioctl acknowledge */
#define M_PCPROTO	0x83		/* priority proto message */
#define	M_PCSIG		0x84		/* generate process signal */
#define	M_READ		0x85		/* generate read notification */
#define	M_FLUSH		0x86		/* flush your queues */
#define	M_STOP		0x87		/* stop transmission immediately */
#define	M_START		0x88		/* restart transmission after stop */
#define	M_HANGUP	0x89		/* line disconnect */
#define M_ERROR		0x8a		/* fatal error used to set u.u_error */
#define M_COPYIN	0x8b		/* request to copyin data */
#define M_COPYOUT	0x8c		/* request to copyout data */
#define M_IOCDATA	0x8d		/* response to M_COPYIN and M_COPYOUT */
#define M_PCRSE		0x8e		/* reserved for RSE use only */
#define	M_STOPI		0x8f		/* stop reception immediately */
#define	M_STARTI	0x90		/* restart reception after stop */
#define M_PCEVENT	0x91		/* post an event to an event queue */

/*
 * Queue message class definitions.  
 */
#define QNORM		0x00		/* normal priority messages */
#define QPCTL		0x80		/* high priority cntrl messages */

/*
 *  IOCTL structure - this structure is the format of the M_IOCTL message type.
 */

#ifdef _STYPES

struct iocblk {
	int 	ioc_cmd;		/* ioctl command type */
	o_uid_t	ioc_uid;		/* effective uid of user */
	o_gid_t	ioc_gid;		/* effective gid of user */
	uint	ioc_id;			/* ioctl id */
	uint	ioc_count;		/* count of bytes in data field */
	int	ioc_error;		/* error code */
	int	ioc_rval;		/* return value  */
};

#else /* large definition */

struct iocblk {
	int 	ioc_cmd;		/* ioctl command type */
	cred_t	*ioc_cr;		/* full credentials */
	uint	ioc_id;			/* ioctl id */
	uint	ioc_count;		/* count of bytes in data field */
	int	ioc_error;		/* error code */
	int	ioc_rval;		/* return value  */
	long	ioc_filler[4];		/* reserved for future use */
};

#define ioc_uid ioc_cr->cr_uid
#define ioc_gid ioc_cr->cr_gid

#endif /* _STYPES */

/*
 * structure for the M_COPYIN and M_COPYOUT message types.
 */

#ifdef _STYPES

struct copyreq {
	int	cq_cmd;			/* ioctl command (from ioc_cmd) */
	o_uid_t	cq_uid;			/* effective uid of user */
	o_gid_t	cq_gid;			/* effective gid of user */
	uint	cq_id;			/* ioctl id (from ioc_id) */
	caddr_t	cq_addr;		/* address to copy data to/from */
	uint	cq_size;		/* number of bytes to copy */
	int	cq_flag;		/* see below */
	mblk_t *cq_private;		/* privtate state information */
};

#else /* large defintion */

struct copyreq {
	int	cq_cmd;			/* ioctl command (from ioc_cmd) */
	cred_t	*cq_cr;			/* full credentials */
	uint	cq_id;			/* ioctl id (from ioc_id) */
	caddr_t	cq_addr;		/* address to copy data to/from */
	uint	cq_size;		/* number of bytes to copy */
	int	cq_flag;		/* see below */
	mblk_t *cq_private;		/* privtate state information */
	long	cq_filler[4];		/* reserved for future use */
};

#define cq_uid cq_cr->cr_uid
#define cq_gid cq_cr->cr_gid

#endif /* _STYPES */

/* cq_flag values */

#define STRCANON	0x01		/* b_cont data block contains */
					/* canonical format specifier */
#define RECOPY		0x02		/* perform I_STR copyin again, */
					/* this time using canonical */
					/* format specifier */

/*
 * structure for the M_IOCDATA message type.
 */

#ifdef _STYPES

struct copyresp {
	int	cp_cmd;			/* ioctl command (from ioc_cmd) */
	o_uid_t	cp_uid;			/* effective uid of user */
	o_gid_t	cp_gid;			/* effective gid of user */
	uint	cp_id;			/* ioctl id (from ioc_id) */
	caddr_t	cp_rval;		/* status of request: 0 -> success */
					/*             non-zero -> failure */
	uint	cp_pad1;		/* reserved */
	int	cp_pad2;		/* reserved */
	mblk_t *cp_private;		/* private state information */
};

#else /* large definition */

struct copyresp {
	int	cp_cmd;			/* ioctl command (from ioc_cmd) */
	cred_t	*cp_cr;			/* full credentials */
	uint	cp_id;			/* ioctl id (from ioc_id) */
	caddr_t	cp_rval;		/* status of request: 0 -> success */
					/*             non-zero -> failure */
	uint	cp_pad1;		/* reserved */
	int	cp_pad2;		/* reserved */
	mblk_t *cp_private;		/* private state information */
	long	cp_filler[4];		/* reserved for future use */
};

#define cp_uid cp_cr->cr_uid
#define cp_gid cp_cr->cr_gid

#endif /* _STYPES */

/*
 * Options structure for M_SETOPTS message.  This is sent upstream
 * by a module or driver to set stream head options.
 */

#ifdef _STYPES

struct stroptions {
	short	so_flags;		/* options to set */
	short	so_readopt;		/* read option */
	ushort	so_wroff;		/* write offset */
	short	so_minpsz;		/* minimum read packet size */
	short	so_maxpsz;		/* maximum read packet size */
	ushort	so_hiwat;		/* read queue high water mark */
	ushort	so_lowat;		/* read queue low water mark */
	unsigned char so_band;		/* band for water marks */
};

#else /* large definition */

struct stroptions {
	ulong	so_flags;		/* options to set */
	short	so_readopt;		/* read option */
	ushort	so_wroff;		/* write offset */
	long	so_minpsz;		/* minimum read packet size */
	long	so_maxpsz;		/* maximum read packet size */
	ulong	so_hiwat;		/* read queue high water mark */
	ulong	so_lowat;		/* read queue low water mark */
	unsigned char so_band;		/* band for water marks */
};

#endif /* _STYPES */

/* flags for stream options set message */

#define SO_ALL		0x003f	/* set all old options */
#define SO_READOPT	0x0001	/* set read option */
#define SO_WROFF	0x0002	/* set write offset */
#define SO_MINPSZ	0x0004	/* set min packet size */
#define SO_MAXPSZ	0x0008	/* set max packet size */
#define SO_HIWAT	0x0010	/* set high water mark */
#define SO_LOWAT	0x0020	/* set low water mark */
#define SO_MREADON      0x0040	/* set read notification ON */
#define SO_MREADOFF     0x0080	/* set read notification OFF */
#define SO_NDELON	0x0100	/* old TTY semantics for NDELAY reads/writes */
#define SO_NDELOFF      0x0200	/* STREAMS semantics for NDELAY reads/writes */
#define SO_ISTTY	0x0400	/* the stream is acting as a terminal */
#define SO_ISNTTY	0x0800	/* the stream is not acting as a terminal */
#define SO_TOSTOP	0x1000	/* stop on background writes to this stream */
#define SO_TONSTOP	0x2000	/* do not stop on background writes to stream */
#define SO_BAND		0x4000	/* water marks affect band */
#define SO_DELIM	0x8000	/* messages are delimited */
#ifndef _STYPES
#define SO_NODELIM	0x010000	/* turn off delimiters */
#define SO_STRHOLD    0x020000    /* enable strwrite message coalescing */
#endif /* _STYPES */

/*
 * Structure for M_EVENT and M_PCEVENT messages.  This is sent upstream
 * by a module or driver to have the stream head generate a call to the
 * General Events subsystem.  It is also contained in the first M_DATA
 * block of an M_IOCTL message for the I_STREV and I_UNSTREV ioctls.
 */
struct str_evmsg {
	long		 sv_event;	/* the event (module-specific) */
	vnode_t		*sv_vp;		/* vnode pointer of event queue */
	long		 sv_eid;	/* same as ev_eid */
	long		 sv_evpri;	/* same as ev_pri */
	long		 sv_flags;	/* same as ev_flags */
	uid_t		 sv_uid;	/* user id of posting process */
	pid_t		 sv_pid;	/* process id of posting process */
	hostid_t	 sv_hostid;	/* host id of posting process */
	long		 sv_pad[4];	/* reserved for future use */
};

/*
 * Miscellaneous parameters and flags.
 */

/*
 * New code for two-byte M_ERROR message.
 */
#define NOERROR	((unsigned char)-1)

/*
 * Values for stream flag in open to indicate module open, clone open;
 * return value for failure.
 */
#define MODOPEN 	0x1		/* open as a module */
#define CLONEOPEN	0x2		/* open for clone, pick own minor device */
#define OPENFAIL	-1		/* returned for open failure */

/*
 * Priority definitions for block allocation.
 */
#define BPRI_LO		1
#define BPRI_MED	2
#define BPRI_HI		3

/*
 * Value for packet size that denotes infinity
 */
#define INFPSZ		-1

/*
 * Flags for flushq()
 */
#define FLUSHALL	1	/* flush all messages */
#define FLUSHDATA	0	/* don't flush control messages */

/*
 * Flag for transparent ioctls
 */
#define TRANSPARENT	(unsigned int)(-1)

/*
 * Sleep priorities for stream io
 */
#define	STIPRI	PZERO+3
#define	STOPRI	PZERO+3

/*
 * Stream head default high/low water marks 
 */
#define STRHIGH 5120
#define STRLOW	1024

/*
 * Block allocation parameters
 */
#define MAXIOCBSZ	1024		/* max ioctl data block size */

/*
 * amount of time to hold small messages in strwrite hoping to to
 * able to append more data from a subsequent write.  one tick min.
 */
#define STRSCANP	((10*HZ+999)/1000)	/* 10 ms in ticks */

/*
 * Definitions of Streams macros and function interfaces.
 */

/*
 * Definition of spl function needed to provide critical region protection
 * for streams drivers and modules.
 *
 * Note that on the 386 processor splstr() has been implemented as a
 * an assembly language routine in ml/misc.s, and is controlled by a
 * tunable parameter (SPLSTRVAL). The #define below is left for
 * historical purposes.
 *
 * #define splstr() spl6()
 *
 */


/*
 * canenable - check if queue can be enabled by putq().
 */
#define canenable(q)	!((q)->q_flag & QNOENB)

/*
 * Finding related queues
 */
#define	OTHERQ(q)	((q)->q_flag&QREADR? (q)+1: (q)-1)
#define	WR(q)		((q)+1)
#define	RD(q)		((q)-1)
#define SAMESTR(q)	(((q)->q_next) && (((q)->q_flag&QREADR) == ((q)->q_next->q_flag&QREADR)))

/*
 * Put a message of the next queue of the given queue.
 */
#define putnext(q, mp)	((*(q)->q_next->q_qinfo->qi_putp)((q)->q_next, (mp)))

/*
 * Test if data block type is one of the data messages (i.e. not a control
 * message).
 */
#define datamsg(type) ((type) == M_DATA || (type) == M_PROTO || (type) == M_PCPROTO || (type) == M_DELAY)

/*
 * Extract queue class of message block.
 */
#define queclass(bp) (((bp)->b_datap->db_type >= QPCTL) ? QPCTL : QNORM)

/*
 * Align address on next lower word boundary.
 */
#define straln(a)	(caddr_t)((long)(a) & ~(sizeof(int)-1))

/*
 * Find the max size of data block.
 */
#define bpsize(bp) ((unsigned int)(bp->b_datap->db_lim - bp->b_datap->db_base))

/*
 * declarations of common routines
 */
extern mblk_t *allocb();
extern mblk_t *esballoc();
extern int esbbcall();
extern int testb();
extern int bufcall();
extern void freeb();
extern void freemsg();
extern mblk_t *dupb();
extern mblk_t *dupmsg();
extern mblk_t *copyb();
extern mblk_t *copymsg();
extern void linkb();
extern mblk_t *unlinkb();
extern mblk_t *rmvb();
extern int pullupmsg();
extern int adjmsg();
extern int msgdsize();
extern mblk_t *getq();
extern void rmvq();
extern void flushq();
extern void flushband();
extern int canput();
extern int bcanput();
extern int putq();
extern int putbq();
extern int insq();
extern int putctl();
extern int putctl1();
extern queue_t *backq();
extern void qreply();
extern void qenable();
extern int qsize();
extern void noenable();
extern void enableok();
extern ushort getmid();
extern int strqset();
extern int strqget();
extern void unbufcall();

/*
 * shared or externally configured data structures
 */
extern int strmsgsz;			/* maximum stream message size */
extern int strctlsz;			/* maximum size of ctl part of message */
extern int nstrpush;			/* maxmimum number of pushes allowed */
extern struct strstat strst;		/* STREAMS statistics structure */
extern char queueflag;          /* set iff inside queuerun() */

/*
 * Structure for 386 ioctls requiring user context
*/
struct  v86blk {
    struct  proc    *v86_u_procp;
    ulong   v86_u_renv ;
    pid_t   v86_p_pid;
    pid_t   v86_p_ppid;
    struct cred *v86_p_cred;
    struct  v86dat  *v86_p_v86;
};

#endif	/* _SYS_STREAM_H */
  070701000059f5000081240000000200000002000000012719347c00000754000000230000000c00000000000000000000001900000000usr/include/sys/strlog.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STRLOG_H
#define _SYS_STRLOG_H

#ident	"@(#)/usr/include/sys/strlog.h.sl 1.1 4.0 10/15/90 4136 AT&T-SF"
/*
 * Streams Log Driver Interface Definitions
 */

/*
 * structure of control portion of log message
 */
struct log_ctl {
	short	mid;
	short	sid;
	char 	level;		/* level of message for tracing */
	short	flags;		/* message disposition */
	clock_t	ltime;		/* time in machine ticks since boot */
	time_t	ttime;		/* time in seconds since 1970 */
	long	seq_no;		/* sequence number */
	int	pri;		/* priority = (facility|level) */
};

/* Flags for log messages */

#define SL_FATAL	0x01	/* indicates fatal error */
#define SL_NOTIFY	0x02	/* logger must notify administrator */
#define SL_ERROR	0x04	/* include on the error log */
#define SL_TRACE	0x08	/* include on the trace log */
#define SL_CONSOLE	0x10	/* log message to console */
#define SL_WARN		0x20	/* warning message */
#define SL_NOTE		0x40	/* notice message */

/*
 * Structure defining ids and levels desired by the tracer (I_TRCLOG).
 */
struct trace_ids {
	short ti_mid;
	short ti_sid;
	char  ti_level;
};

/*
 * Log Driver I_STR ioctl commands
 */

#define LOGCTL		(('L')<<8)
#define I_TRCLOG	(LOGCTL|1)	/* process is tracer */
#define I_ERRLOG	(LOGCTL|2)	/* process is error logger */
#define I_CONSLOG	(LOGCTL|3)	/* process is console logger */

/*
 * Parameter definitions for logger messages 
 */
#define LOGMSGSZ	1024
#define NLOGARGS	3

#ifdef _KERNEL
#if defined(__STDC__)
/*PRINTFLIKE5*/
extern int strlog(short, short, char, unsigned short, char *, ...);
#else
extern int strlog();
#endif
#endif

#endif	/* _SYS_STRLOG_H */
070701000059f6000081240000000200000002000000012719347c0000055d000000230000000c00000000000000000000001a00000000usr/include/sys/strmdep.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STRMDEP_H
#define _SYS_STRMDEP_H

#ident	"@(#)/usr/include/sys/strmdep.h.sl 1.1 4.0 10/15/90 21780 AT&T-SF"

/*
 * This file contains all machine-dependent declarations
 * in STREAMS.
 */

/*
 * Copy data from one data buffer to another.
 * The addresses must be word aligned - if not, use bcopy!
 */

#if defined(u3b2) && !defined(lint)

/*
 * Use the MOVBLW instruction on the 3b2.  
 */
asm	void
strbcpy(s, d, c)
{
%mem	s,d,c;
	
	MOVW	s,%r0
	MOVW	d,%r1
	MOVW	c,%r2
	ADDW2	&3,%r2
	LRSW3	&2,%r2,%r2
	MOVBLW
}

#else

#define	strbcpy(s, d, c)	bcopy(s, d, c)

#endif

/*
 * save the address of the calling function on the 3b2 to
 * enable tracking of who is allocating message blocks
 */

#if defined (u3b2) && !defined(lint)

asm	void
saveaddr(funcp)
{
%mem	funcp;

	MOVW	-36(%fp),*funcp
}

#else

#define saveaddr(funcp)

#endif

/*
 * macro to check pointer alignment
 * (true if alignment is sufficient for worst case)
 */
#ifdef u3b2

#define str_aligned(X)	(((uint)(X) & 03) == 0)

#else

#define str_aligned(X)	(((uint)(X) & (sizeof(int) - 1)) == 0)

#endif


#endif	/* _SYS_STRMDEP_H */
   070701000059f7000081240000000200000002000000012719347c00002528000000230000000c00000000000000000000001a00000000usr/include/sys/stropts.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STROPTS_H
#define _SYS_STROPTS_H

#ident	"@(#)/usr/include/sys/stropts.h.sl 1.1 4.0 10/15/90 31949 AT&T-SF"

/*
 * For sys/evecb.h
 */
#include <sys/types.h>

/*
 * For FMNAMESZ define.
 */
#include <sys/conf.h>

/*
 * For struct ecb (source compatibility).
 */
#include <sys/evecb.h>

/*
 * Write options.
 */
#define SNDZERO		0x001		/* send a zero length message */
#define SNDPIPE		0x002		/* send SIGPIPE on write and */
					/* putmsg if sd_werror is set */

/*
 * Read options
 */

#define RNORM		0x000		/* read msg norm */
#define RMSGD		0x001		/* read msg discard */
#define RMSGN		0x002		/* read msg no discard */

#define RMODEMASK	0x003		/* all above bits */

/*
 * These next three read options are added for the sake of
 * user-level transparency.  RPROTDAT will cause the stream head
 * to treat the contents of M_PROTO and M_PCPROTO message blocks
 * as data.  RPROTDIS will prevent the stream head from failing
 * a read with EBADMSG if an M_PROTO or M_PCPROTO message is on
 * the front of the stream head read queue.  Rather, the protocol
 * blocks will be silently discarded and the data associated with
 * the message (in linked M_DATA blocks), if any, will be delivered
 * to the user.  RPROTNORM sets the default behavior, where read
 * will fail with EBADMSG if an M_PROTO or M_PCPROTO are at the
 * stream head.
 */
#define RPROTDAT	0x004		/* read protocol messages as data */
#define RPROTDIS	0x008		/* discard protocol messages, but */
					/* read data portion */
#define RPROTNORM	0x010

#define RPROTMASK	0x01c		/* all RPROT bits */

/*
 * Flush options
 */

#define FLUSHR		0x01		/* flush read queue */
#define FLUSHW		0x02		/* flush write queue */
#define FLUSHRW		0x03		/* flush both queues */
#define FLUSHBAND	0x04		/* flush only band specified */
					/* in next byte */

/*
 * Events for which to be sent SIGPOLL signal and for which events
 * can be posted by the I_SETEV ioctl.
 */
#define S_INPUT		0x0001		/* any msg but hipri on read Q */
#define S_HIPRI		0x0002		/* high priority msg on read Q */
#define S_OUTPUT	0x0004		/* write Q no longer full */
#define S_MSG		0x0008		/* signal msg at front of read Q */
#define	S_ERROR		0x0010		/* error msg arrived at stream head */
#define	S_HANGUP	0x0020		/* hangup msg arrived at stream head */
#define S_RDNORM	0x0040		/* normal msg on read Q */
#define S_WRNORM	S_OUTPUT
#define	S_RDBAND	0x0080		/* out of band msg on read Q */
#define S_WRBAND	0x0100		/* can write out of band */
#define S_BANDURG	0x0200		/* modifier to S_RDBAND, to generate */
					/* SIGURG instead of SIGPOLL */

/*
 * Flags for getmsg() and putmsg() syscall arguments.
 * "RS" stands for recv/send.  The system calls were originally called
 * recv() and send(), but were renamed to avoid confusion with the BSD
 * calls of the same name.  A value of zero will cause getmsg() to return
 * the first message on the stream head read queue and putmsg() to send
 * a normal priority message.
 */
#define RS_HIPRI	0x01		/* send/recv high priority message */

/*
 * Flags for getpmsg() and putpmsg() syscall arguments.
 */

/*
 * These are settable by the user and will be set on return
 * to indicate the priority of message received.
 */
#define MSG_HIPRI	0x01		/* send/recv high priority message */
#define MSG_ANY		0x02		/* recv any messages */
#define MSG_BAND	0x04		/* recv messages from specified band */

/*
 * Flags returned as value of getmsg() and getpmsg() syscall.
 */
#define MORECTL		1		/* more ctl info is left in message */
#define MOREDATA	2		/* more data is left in message */

/*
 * Define to indicate that all multiplexors beneath a stream should
 * be unlinked.
 */
#define MUXID_ALL	(-1)

/*
 * Flag definitions for the I_ATMARK ioctl.
 */
#define ANYMARK		0x01
#define LASTMARK	0x02

/*
 *  Stream Ioctl defines
 */
#define	STR		('S'<<8)
/* (STR|000) in use */
#define I_NREAD		(STR|01)
#define I_PUSH		(STR|02)
#define I_POP		(STR|03)
#define I_LOOK		(STR|04)
#define I_FLUSH		(STR|05)
#define I_SRDOPT	(STR|06)
#define I_GRDOPT	(STR|07)
#define I_STR		(STR|010)
#define I_SETSIG	(STR|011)
#define I_GETSIG	(STR|012)
#define I_FIND		(STR|013)
#define I_LINK		(STR|014)
#define I_UNLINK	(STR|015)
/* (STR|016) in use */
#define I_PEEK		(STR|017)
#define I_FDINSERT	(STR|020)
#define I_SENDFD	(STR|021)
#if defined(_KERNEL)

#define I_RECVFD	(STR|022)
#define I_E_RECVFD	(STR|016)

#elif !defined(_STYPES)	/* user level definition */

#define I_RECVFD	(STR|016)	/* maps to kernel I_E_RECVFD */

#else

#define I_RECVFD	(STR|022)	/* non-EFT definition */

#endif /* defined(_KERNEL) */

#define I_SWROPT	(STR|023)
#define I_GWROPT	(STR|024)
#define I_LIST		(STR|025)
#define I_PLINK		(STR|026)
#define I_PUNLINK	(STR|027)
#define I_SETEV		(STR|030)
#define I_GETEV		(STR|031)
#define I_STREV		(STR|032)
#define I_UNSTREV	(STR|033)
#define I_FLUSHBAND	(STR|034)
#define I_CKBAND	(STR|035)
#define I_GETBAND	(STR|036)
#define I_ATMARK	(STR|037)
#define I_SETCLTIME	(STR|040)
#define I_GETCLTIME	(STR|041)
#define I_CANPUT	(STR|042)

						/* Same ioctl as O_MODESWITCH */
#define	X_STR			('S'<<8)	/* SCO XENIX Streams ioctl's */
#define	X_I_BASE		(X_STR|0200)
#define	X_I_NREAD		(X_STR|0201)
#define	X_I_PUSH		(X_STR|0202)
#define	X_I_POP			(X_STR|0203)
#define	X_I_LOOK		(X_STR|0204)
#define	X_I_FLUSH		(X_STR|0205)
#define	X_I_SRDOPT		(X_STR|0206)
#define	X_I_GRDOPT		(X_STR|0207)
#define	X_I_STR			(X_STR|0210)
#define	X_I_SETSIG		(X_STR|0211)
#define	X_I_GETSIG		(X_STR|0212)
#define	X_I_FIND		(X_STR|0213)
#define	X_I_LINK		(X_STR|0214)
#define	X_I_UNLINK		(X_STR|0215)
#define	X_I_PEEK		(X_STR|0217)
#define	X_I_FDINSERT		(X_STR|0220)
#define	X_I_SENDFD		(X_STR|0221)
#define	X_I_RECVFD		(X_STR|0222)

/*
 * User level ioctl format for ioctls that go downstream (I_STR)
 */
struct strioctl {
	int 	ic_cmd;			/* command */
	int	ic_timout;		/* timeout value */
	int	ic_len;			/* length of data */
	char	*ic_dp;			/* pointer to data */
};

/*
 * Value for timeouts (ioctl, select) that denotes infinity
 */
#define INFTIM		-1

/*
 * Stream buffer structure for putmsg and getmsg system calls
 */
struct strbuf {
	int	maxlen;			/* no. of bytes in buffer */
	int	len;			/* no. of bytes returned */
	char	*buf;			/* pointer to data */
};

/* 
 * Stream I_PEEK ioctl format
 */
struct strpeek {
	struct strbuf ctlbuf;
	struct strbuf databuf;
	long	      flags;
};

/*
 * Stream I_FDINSERT ioctl format
 */
struct strfdinsert {
	struct strbuf ctlbuf;
	struct strbuf databuf;
	long	      flags;
	int	      fildes;
	int	      offset;
};

/*
 * Receive file descriptor structure
 */

#if defined(_KERNEL)

struct o_strrecvfd {	/* SVR3 syscall structure */
	union {
		struct file *fp;
		int fd;
	} f;
	o_uid_t uid;		/* always ushort */
	o_gid_t gid;
	char fill[8];
};

/* Although EFT is enabled in the kernel we kept the following definition
** to support an EFT application on a 4.0 non-EFT system.
*/

struct e_strrecvfd {	/* SVR4 expanded syscall interface structure */
	union {
		struct file *fp;
		int fd;
	} f;
	uid_t uid;		/* always long */
	gid_t gid;
	char fill[8];
};

struct strrecvfd {	/* Kernel structure dependent on EFT definition */
	union {
		struct file *fp;
		int fd;
	} f;
#if !defined(_STYPES)
	uid_t uid;
	gid_t gid;
#else
	o_uid_t uid;
	o_gid_t gid;
#endif
	char fill[8];
};

#elif !defined(_STYPES) 	/* EFT user definition */

struct strrecvfd {
	int fd;
	uid_t uid;
	gid_t gid;
	char fill[8];
};

#else

/*
 * User compatibility mode. EOVERFLOW returned 
 * when uid/gid exceeds ushort limit.
 */
struct strrecvfd {
	int fd;
	o_uid_t uid;
	o_gid_t gid;
	char fill[8];
};

#endif	/* defined(_KERNEL) */

/*
 * For I_LIST ioctl.
 */
struct str_mlist {
	char l_name[FMNAMESZ+1];
};

struct str_list {
	int sl_nmods;
	struct str_mlist *sl_modlist;
};

/*
 * For I_STREV and I_UNSTREV ioctls: requesting
 * ET_DRIVER-type events from STREAMS modules and
 * drivers.
 */
struct str_event {
	long		ste_event;	/* the event (module-specific) */
	ecb_t		ste_ecb;	/* event control block */
	long		ste_evflags;	/* same as ev_flags */
	struct strbuf	ste_buf;	/* module-specific data */
};

/*
 * For I_SETEV ioctls: requesting ET_STREAM-type
 * events from the stream head.
 */
typedef struct str_sev {
	int	se_mask;	/* generate events for above S_XXX conditions */
	ecb_t	se_ecb;		/* the event control block */
	unchar	se_band;	/* band requested (ignored if does not apply) */
} str_sev_t;

/*
 * For I_GETEV ioctls: retrieve the events for
 * which stream head is generating events.
 */
typedef struct str_gev {
	int		ge_flags;	/* see below */
	str_sev_t	*ge_sep;	/* ptr to array of str_sev structs */
	int		ge_ses;		/* number of elements in ge_sep array */
} str_gev_t;


/*
 * Flags for ge_flags field.
 */
#define	GEF_PROC	0x0001	/* Get information only about	*/
				/* this process' requests.	*/
				/* Otherwise, all I_SETEV's for	*/
				/* the stream head will be	*/
				/* returned.			*/
#define	GEF_MORE	0x0002	/* Set on return if there were	*/
				/* more I_SETEVs to return than	*/
				/* would fit into the ge_sep	*/
				/* array the caller provided.	*/

/*
 * For I_FLUSHBAND ioctl.  Describes the priority
 * band for which the operation applies.
 */
struct bandinfo {
	unsigned char	bi_pri;
	int		bi_flag;
};

#endif	/* _SYS_STROPTS_H */
070701000059f8000081240000000200000002000000012719347c00000b96000000230000000c00000000000000000000001900000000usr/include/sys/strppc.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STRPPC_H
#define _SYS_STRPPC_H

#ident	"@(#)/usr/include/sys/strppc.h.sl 1.1 4.0 10/15/90 64698 AT&T-SF"

/*
 * b_state (board state) flags
 *
 *	ISSYSGEN:	board has been sysgen'ed and is operational
 *	CIOTYPE		common IO type command
 *	SYSGFAIL        indicated that SYSGEN has failed
 *	EXPRESS:	REQUEST EXPRESS entry "being used"
 */
#define ISSYSGEN	0x0001
#define CIOTYPE		0x0002
#define SYSGFAIL	0x0004
#define EXPRESS		0x8000


/*
 * t_dstat (special tty struc flags) flag definition
 *	SETOPT		a SET_OPTION command is in progress
 *	SPLITMSG	output message split into 64 byte chunks
 *	WENTRY		wait for xmit queue entry
 *      SUPBUF          have buffers been supplied for receive?
 *      WRTQDRAIN       Wait for write queues to drain to user's terminal
 *	CLDRAIN		wait for output to drain
 *	OPDRAIN		wait for output to drain
 *	WBREAK		wait for break send completion
 */
#define SETOPT		0x0001
#define SPLITMSG	0x0002
#define WENTRY 		0x0004
#define SUPBUF		0x0008
#define WRTQDRAIN       0x0010
#define CLDRAIN		0x0020
#define OPDRAIN		0x0040
#define WBREAK          0x0080

#define MAX_RBUF  17	/* 4 recv bufs/tty + 1 extra */
#define PPBUFSIZ 64	/* MAX. size of in/out buffer */

/*
 * Constants needed for determining the version
 * of the PORTS board, e. g. PORTS or HIPORTS
 *
 *	PPC_VERS	request version number of a ppc board (ioctl)
 *	O_VERS		oflag value for opening a board to read version number
 *	DEFAULTVER	default version number for boards without one
 *	HIPORTS		rom version number of the HIPORT board
 */

#define PPC_VERS (('v'<<8)|1)   
#define O_VERS  0200	       
#define DEFAULTVER 1           
#define HIPORTS  2              

struct pprbuf
{
	mblk_t *bp;	/* message block pointer */
	long sp;	/* PHYSICAL address of bp->b_datap->db_base */
	long ep;	/* PHYSICAL address of bp->b_datap->db_lim */
};

/*
 * PORTS board control block
 */
struct ppcboard {
	unsigned short b_state;	/* board state flags		     */
	short dcb;		/* desired nbr of cblocks for rqueue */
	short qcb;		/* actual nbr of allocated cblocks   */
	short retcode;		/* return code for lla commands	     */
 	short p_nbr[NUM_QUEUES];	/* bnr of entries in queue   */
	RQUEUE rqueue;
	CQUEUE cqueue;
	struct pprbuf rbp[MAX_RBUF];/* allocated recv buffers for PPC */
	};

#define BSTATE(b)	npp_board[b].b_state
#define PNBR(b,p)	npp_board[b].p_nbr[p]



/*
 * Variables allocated by the operating system
 */

extern int npp_cnt;
extern struct strtty npp_tty[];
extern char *npp_addr[];
extern struct ppcboard npp_board[];
extern int ncsbit[];
extern short nppcbid[];
extern short nppcpid[];

/*
 Variables allocated by the driver
 */

extern int npp_bnbr;

#endif	/* _SYS_STRPPC_H */
  070701000059fa000081240000000200000002000000012719347c00000691000000230000000c00000000000000000000001a00000000usr/include/sys/strstat.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STRSTAT_H
#define _SYS_STRSTAT_H

#ident	"@(#)/usr/include/sys/strstat.h.sl 1.1 4.0 10/15/90 61587 AT&T-SF"

/*
 * Streams Statistics header file.  This file
 * defines the counters which are maintained for statistics gathering
 * under Streams. 
 */

typedef struct {
	int use;	/* current item usage count */
	int total;	/* total item usage count */
	int max;	/* maximum item usage count */
	int fail;	/* count of allocation failures */
	} alcdat;

struct  strstat {
	alcdat stream;		/* stream allocation data */
	alcdat queue;		/* queue allocation data */
	alcdat msgblock;	/* message block allocation data */
	alcdat mdbblock;	/* mesg/data/buffer triplet allocation data */
	alcdat linkblk;		/* linkblk allocation data */
	alcdat strevent;	/* strevent allocation data */
	} ;


/* in the following macro, x is assumed to be of type alcdat */

#define BUMPUP(X)	{(X).use++;  (X).total++;\
			 if ((X).use > (X).max) (X).max = (X).use; }


/* per-module statistics structure */

struct module_stat {
	long ms_pcnt;		/* count of calls to put proc */
	long ms_scnt;		/* count of calls to service proc */
	long ms_ocnt;		/* count of calls to open proc */
	long ms_ccnt;		/* count of calls to close proc */
	long ms_acnt;		/* count of calls to admin proc */
	char *ms_xptr;		/* pointer to private statistics */
	short ms_xsize;		/* length of private statistics buffer */
	};


#endif	/* _SYS_STRSTAT_H */
   070701000059fb000081240000000200000002000000012719347c000032e0000000230000000c00000000000000000000001a00000000usr/include/sys/strsubr.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STRSUBR_H
#define _SYS_STRSUBR_H

#ident	"@(#)/usr/include/sys/strsubr.h.sl 1.1 4.0 10/15/90 10234 AT&T-SF"

/*
 * WARNING:
 * Everything in this file is private, belonging to the
 * STREAMS subsystem.  The only guarantee made about the
 * contents of this file is that if you include it, your
 * code will not port to the next release.
 */
#include <sys/vnode.h>
#include <sys/evecb.h>

/*
 * Header for a stream: interface to rest of system.
 */
typedef struct stdata {
	struct queue *sd_wrq;		/* write queue */
	struct msgb *sd_iocblk;		/* return block for ioctl */
	struct vnode *sd_vnode;		/* pointer to associated vnode */
	struct streamtab *sd_strtab;	/* pointer to streamtab for stream */
	long sd_flag;			/* state/flags */
	long sd_iocid;			/* ioctl id */
	ushort sd_iocwait;		/* count of procs waiting to do ioctl */
	struct pid *sd_sidp;		/* controlling session info */
	struct pid *sd_pgidp;		/* controlling process group info */
	ushort sd_wroff;		/* write offset */
	int sd_rerror;			/* read error to set u.u_error */
	int sd_werror;			/* write error to set u.u_error */
	int sd_pushcnt;			/* number of pushes done on stream */
	int sd_sigflags;		/* logical OR of all siglist events */
	struct strevent *sd_siglist;	/* pid linked list to rcv SIGPOLL sig */
	int sd_eventflags;		/* logical OR of all eventlist events */
	struct strevent *sd_eventlist;	/* linked list to rcv general events */
	struct pollhead sd_pollist;	/* list of all pollers to wake up */
	struct msgb *sd_mark;		/* "marked" message on read queue */
	int sd_closetime;		/* time to wait to drain q in close */
	clock_t sd_rtime;		/* time to release held message */
} stdata_t;

/*
 * stdata flag field defines
 */
#define	IOCWAIT		0x00000001	/* Someone wants to do ioctl */
#define RSLEEP		0x00000002	/* Someone wants to read/recv msg */
#define	WSLEEP		0x00000004	/* Someone wants to write */
#define STRPRI		0x00000008	/* An M_PCPROTO is at stream head */
#define	STRHUP		0x00000010	/* Device has vanished */
#define	STWOPEN		0x00000020	/* waiting for 1st open */
#define STPLEX		0x00000040	/* stream is being multiplexed */
#define STRISTTY	0x00000080	/* stream is a terminal */
#define RMSGDIS		0x00000100	/* read msg discard */
#define RMSGNODIS	0x00000200	/* read msg no discard */
#define STRDERR		0x00000400	/* fatal read error from M_ERROR */
#define STRTIME		0x00000800	/* used with timeout strtime */
#define STR2TIME	0x00001000	/* used with timeout str2time */
#define STR3TIME	0x00002000	/* used with timeout str3time */
#define STRCLOSE	0x00004000	/* wait for a close to complete */
#define SNDMREAD	0x00008000	/* used for read notification */
#define OLDNDELAY	0x00010000	/* use old TTY semantics for NDELAY
					/* reads and writes */
#define RDBUFWAIT	0x00020000	/* used with bufcall in strqbuf() */
#define STRSNDZERO	0x00040000	/* send 0-length msg. down pipe/FIFO */
#define STRTOSTOP	0x00080000	/* block background writes */
#define	RDPROTDAT	0x00100000	/* read M_[PC]PROTO contents as data */
#define RDPROTDIS	0x00200000	/* discard M_[PC]PROTO blocks and */
					/* retain data blocks */
#define STRMOUNT	0x00400000	/* stream is mounted */
#define STRSIGPIPE		0x00800000	/* controlling process not group */
#define STRDELIM	0x01000000	/* generate delimited messages */
#define STWRERR		0x02000000	/* fatal write error from M_ERROR */
#define STRHOLD		0x04000000	/* enable strwrite message coalescing */


/*
 * Structure of list of processes to be sent SIGSEL signal
 * on request, or for processes sleeping on select().  The valid 
 * SIGSEL events are defined in stropts.h, and the valid select()
 * events are defined in select.h.
 */
struct strevent {
	union {
		struct {
			struct proc	*procp;
			long		events;
		} e;	/* stream event */
		struct {
			void (*func)();
			long arg;
			int size;
		} b;	/* bufcall event */
		struct {
			vnode_t		*vp;
			ecb_t		 ecb;
			pid_t		 pid;
			hostid_t	 hostid;
			uid_t		 uid;
			long		 mask;
			unchar		 band;
		} g;	/* general events mechanism */
	} x;
	struct strevent *se_next;
};

#define se_procp	x.e.procp
#define se_events	x.e.events
#define se_func		x.b.func
#define se_arg		x.b.arg
#define se_size		x.b.size
#define se_vp		x.g.vp
#define se_kecb		x.g.ecb		/* name collision with struct str_sev */
#define se_pid		x.g.pid
#define se_hostid	x.g.hostid
#define se_uid		x.g.uid
#define se_kmask	x.g.mask	/* name collision with struct str_sev */
#define se_kband	x.g.band	/* name collision with struct str_sev */

#define SE_SLEEP	0	/* ok to sleep in allocation */
#define SE_NOSLP	1	/* don't sleep in allocation */

/*
 * bufcall list
 */
struct bclist {
	struct strevent	*bc_head;
	struct strevent	*bc_tail;
};

/*
 * Structure used to track mux links and unlinks.
 */
struct mux_node {
	long		 mn_imaj;	/* internal major device number */
	ushort		 mn_indegree;	/* number of incoming edges */
	struct mux_node *mn_originp;	/* where we came from during search */
	struct mux_edge *mn_startp;	/* where search left off in mn_outp */
	struct mux_edge *mn_outp;	/* list of outgoing edges */
	uint		 mn_flags;	/* see below */
};

/*
 * Flags for mux_nodes.
 */
#define VISITED	1

/*
 * Edge structure - a list of these is hung off the
 * mux_node to represent the outgoing edges.
 */
struct mux_edge {
	struct mux_node	*me_nodep;	/* edge leads to this node */
	struct mux_edge	*me_nextp;	/* next edge */
	int		 me_muxid;	/* id of link */
};

/*
 * Structure to keep track of resources that have been allocated
 * for streams - an array of these are kept, one entry per
 * resource.  This is used by crash to dump the data structures.
 */

struct strinfo {
	void	*sd_head;	/* head of in-use list */
	int	sd_cnt;		/* total # allocated */
};

#define DYN_STREAM	0	/* for stream heads */
#define DYN_QUEUE	1	/* for queues */
#define DYN_MSGBLOCK	2	/* for message blocks */
#define DYN_MDBBLOCK	3	/* for mesg/data/buffer triplets */
#define DYN_LINKBLK	4	/* for mux links */
#define DYN_STREVENT	5	/* for stream event cells */
#define DYN_QBAND	6	/* for qband structures */

#define NDYNAMIC	7	/* number of different data types that are */
				/* dynamically allocated */

/*
 * The following structures are mainly used to keep track of
 * the resources that have been allocated so crash can find
 * them (they are stored in a doubly-linked list with the head
 * of it stored in the Strinfo array.  Other data may be stored
 * away here too since this is private to streams.  Pointers
 * to these objects are returned by the allocating procedures,
 * which are later passed to the freeing routine.  The data
 * structure itself must appear first because the pointer is
 * overloaded to refer to both the structure itself or its
 * envelope, depending on context.
 */

/*
 * Stream head info
 */
struct shinfo {
	stdata_t	sh_stdata;	/* must be first */
	struct shinfo	*sh_next;	/* next in list */
	struct shinfo	*sh_prev;	/* previous in list */
};

/*
 * data block info
 */
#ifdef DEBUG
struct dbinfo {
	dblk_t	d_dblock;	/* the data block itself */
	struct dbinfo *d_next;	/* next data block */
	struct dbinfo *d_prev;	/* previous */
};

/*
 * message block info
 */
struct mbinfo {
	mblk_t	m_mblock;	/* the message block itself */
	struct mbinfo *m_next;	/* next message block */
	struct mbinfo *m_prev;	/* previous message block */
	void	(*m_func)();	/* address of allocation function */	
};
#else
/*
 * data block info
 */
struct dbinfo {
	dblk_t	d_dblock;
};
/*
 * message block info
 */
struct mbinfo {
	mblk_t	m_mblock;
	void	(*m_func)();
};
#endif



/* convenient power of 2 */
#define	FASTBUF	(128 - sizeof(struct mbinfo) - sizeof(struct dbinfo))

/*
 * triplet
 */
struct	mdbblock {
	struct	mbinfo	msgblk;
	struct	dbinfo	datblk;
	char	databuf[FASTBUF];
};


#ifdef DEBUG
#define _INSERT_MSG_INUSE(x)	insert_msg_inuse(x)
#define _INSERT_MDB_INUSE(y)	insert_mdb_inuse(y)
#define _DELETE_MSG_INUSE(x)	delete_msg_inuse(x)
#define _DELETE_MDB_INUSE(y)	delete_mdb_inuse(y)
#else
#define _INSERT_MSG_INUSE(x)
#define _INSERT_MDB_INUSE(y)
#define _DELETE_MSG_INUSE(x)
#define _DELETE_MDB_INUSE(y)
#endif


/*
 * Stream event info
 */
struct seinfo {
	struct strevent	s_strevent;	/* must be first */
	struct seinfo	*s_next;	/* next in list */
	struct seinfo	*s_prev;	/* previous in list */
};

/*
 * Queue info
 */
#ifdef _STYPES

struct queinfo {
	struct queue	qu_rqueue;	/* read queue - must be first */
	struct queue	qu_wqueue;	/* write queue - must be second */
	struct equeue	qu_requeue;	/* extended queue info (read) */
	struct equeue	qu_wequeue;	/* extended queue info (write) */
	struct queinfo	*qu_next;	/* next in list */
	struct queinfo	*qu_prev;	/* previous in list */
};

#else /* expanded struct */

struct queinfo {
	struct queue	qu_rqueue;	/* read queue - must be first */
	struct queue	qu_wqueue;	/* write queue - must be second */
	struct queinfo	*qu_next;	/* next in list */
	struct queinfo	*qu_prev;	/* previous in list */
};

#endif /* _STYPES */


/*
 * Multiplexed streams info
 */
struct linkinfo {
	struct linkblk	li_lblk;	/* must be first */
	struct file	*li_fpdown;	/* file pointer for lower stream */
	struct linkinfo	*li_next;	/* next in list */
	struct linkinfo *li_prev;	/* previous in list */
};

/*
 * Qband info
 */
struct qbinfo {
	struct qband	qbi_qband;	/* must be first */
	struct qbinfo	*qbi_next;	/* next in list */
	struct qbinfo	*qbi_prev;	/* previous in list */
};

/*
 * Miscellaneous parameters and flags.
 */

/*
 * Default timeout in seconds for ioctls and close
 */
#define STRTIMOUT 15

/*
 * Flag values for stream io waiting procedure (strwaitq)
 */
#define WRITEWAIT	0x1	/* waiting for write event */
#define READWAIT	0x2	/* waiting for read event */
#define NOINTR		0x4	/* error is not to be set for signal */
#define GETWAIT		0x8	/* waiting for getmsg event */

/*
 * Copy modes for tty and I_STR ioctls
 */
#define	U_TO_K 	01			/* User to Kernel */
#define	K_TO_K  02			/* Kernel to Kernel */

/*
 * canonical structure definitions
 */

#define STRLINK		"lli"
#define STRIOCTL	"iiil"
#define STRPEEK		"iiliill"
#define STRFDINSERT	"iiliillii"
#define O_STRRECVFD	"lssc8"
#define STRRECVFD	"lllc8"
#define STRNAME		"c0"
#define STRINT		"i"
#define STRTERMIO	"ssssc12"
#define STRTERMCB	"c6"
#define STRSGTTYB	"c4i"
#define STRTERMIOS	"llllc20"
#define STRLIST		"il"
#define STRSEV		"issllc1"
#define STRGEV		"ili"
#define STREVENT	"lssllliil"
#define STRLONG		"l"
#define STRBANDINFO	"ci"

#ifndef _STYPES
#define STRPIDT		"l"
#else
#define STRPIDT		"s"
#endif

/*
 * Tables we reference during open(2) processing.
 */
#define CDEVSW	0
#define FMODSW	1

/*
 * Mux defines.
 */
#define LINKNORMAL	0x01		/* normal mux link */
#define LINKPERSIST	0x02		/* persistent mux link */
#define LINKTYPEMASK	0x03		/* bitmask of all link types */
#define LINKCLOSE	0x04		/* unlink from strclose */
#define LINKIOCTL	0x08		/* unlink from strioctl */
#define LINKNOEDGE	0x10		/* no edge to remove from graph */

/*
 * Definitions of Streams macros and function interfaces.
 */

/*
 *  Queue scheduling macros
 */
#define setqsched()     qrunflag = 1	/* set up queue scheduler */
#define qready()	qrunflag	/* test if queues are ready to run */

/*
 * Macros dealing with mux_nodes.
 */
#define MUX_VISIT(X)	((X)->mn_flags |= VISITED)
#define MUX_CLEAR(X)	((X)->mn_flags &= (~VISITED)); \
			((X)->mn_originp = NULL)
#define MUX_DIDVISIT(X)	((X)->mn_flags & VISITED)

/*
 * Declarations of private routines.
 */
extern void strsendsig();
extern void strevpost();
extern void strdrpost();
extern int qattach();
extern void qdetach();
extern void strtime();
extern void str2time();
extern void str3time();
extern int putiocd();
extern int getiocd();
extern struct linkinfo *alloclink();
extern void lbfree();
extern int linkcycle();
extern struct linkinfo *findlinks();
extern queue_t *getendq();
extern int munlink();
extern int munlinkall();
extern int mux_addedge();
extern void mux_rmvedge();
extern void setq();
extern int strmakemsg();
extern int strwaitbuf();
extern void strunbcall();
extern int strwaitq();
extern void strqbuf();
extern int strctty();
extern int straccess();
extern int xmsgsize();
extern struct stdata *shalloc();
extern void shfree();
extern struct mdbblock *xmdballoc();
extern mblk_t *xmsgalloc();
extern queue_t *allocq();
extern void freeq();
extern qband_t *allocband();
extern void freeband();
extern struct strevent *sealloc();
extern void sefree();
extern void queuerun();
extern void runqueues();
extern int findmod();
extern caddr_t allocstrpage();
extern void adjfmtp();
extern int str2num();
extern void strclearpg();
extern void strclearsid();
extern void strclearctty();
extern void setqback();
extern int strcopyin();
extern int strcopyout();
extern void strsignal();
extern void strscan();

#endif	/* _SYS_STRSUBR_H */
070701000059fd000081240000000200000002000000012719347c00000c71000000230000000c00000000000000000000001900000000usr/include/sys/strtty.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_STRTTY_H
#define _SYS_STRTTY_H

#ident	"@(#)/usr/include/sys/strtty.h.sl 1.1 4.0 10/15/90 41909 AT&T-SF"
/*
 * header file for STREAMS TTY subsystem
 */


/*
 * The t_buf data structure holds information about a message
 * block and its associated data buffer.  One is used for received
 * blocks, and another is used for blocks to be transmitted to
 * a user terminal or a printer.
 */

struct t_buf
{
	mblk_t *bu_bp;	/* message block pointer */
	unsigned char *bu_ptr;	/* data buffer pointer */
	ushort bu_cnt;	/* data buffer character count */
};

/*
 * A tty structure is needed for each character device used for normal
 * tty I/O.  Each PORTS board supports 4 user terminals and 1 CENTRONICS-
 * TYPE printer.
 */

struct strtty
{
	struct t_buf t_in;	/* input buffer info */
	struct t_buf t_out;	/* output buffer info */
	queue_t *t_rdqp;	/* pointer to tty read queue */
	mblk_t  *t_ioctlp;	/* ioctl block pointer */
	mblk_t  *t_lbuf;	/* pointer to a large data buffer */
	int	t_dev;		/* tty minor device number */
	long	t_iflag;	/* input setting  flags */
	long	t_oflag;	/* output setting flags */
	long	t_cflag;	/* physical setting flags */
	long	t_lflag;	/* "line discipline" flags */
	short	t_state;	/* internal state */
	char	t_line;		/* active line discipline */
	char	t_dstat;	/* more internal state flags */
	unsigned char t_cc[NCCS];/* settable control chars */
};

/*
 * Size of internal ports data buffer, one per port
 */
#define LARGEBUFSZ	512

#define	TTIPRI	28
#define	TTOPRI	29

/* Internal state */
#define	TIMEOUT	01		/* Delay timeout in progress */
#define	WOPEN	02		/* Waiting for open to complete */
#define	ISOPEN	04		/* Device is open */
#define	TBLOCK	010
#define	CARR_ON	020		/* Software copy of carrier-present */
#define	BUSY	040		/* Output in progress */
#define	WIOC	0100		/* Wait for ioctl to complete */
#define	WGETTY	0200		/* opened by supergetty, waiting for getty */
#define	TTSTOP	0400		/* Output stopped by ctl-s */
#define	EXTPROC	01000		/* External processing */
#define	TACT	02000
#define	CLESC	04000		/* Last char escape */
#define	RTO	010000		/* Raw Timeout */
#define	TTIOW	020000
#define	TTXON	040000
#define	TTXOFF	0100000

/* l_output status */
#define	CPRES	0100000

/* device commands */
#define	T_OUTPUT	0
#define	T_TIME		1
#define	T_SUSPEND	2
#define	T_RESUME	3
#define	T_BLOCK		4
#define	T_UNBLOCK	5
#define	T_RFLUSH	6
#define	T_WFLUSH	7
#define	T_BREAK		8
#define	T_INPUT		9
#define T_DISCONNECT	10
#define	T_PARM		11
#define	T_SWTCH		12
/*
 * M_CTL message types.
 */
#define	MC_NO_CANON	0	/* module below saying it will canonicalize */
#define	MC_DO_CANON	1	/* module below saying it won't canonicalize */
#define	MC_CANONQUERY	2	/* module above asking whether module below canonicalizes */
#define	MC_PART_CANON	3	/* tell line discipline to do some canonicalization */
#define SXTSWTCH	'Z'	/* SXT switch character */

#endif	/* _SYS_STRTTY_H */
   07070100005a00000081240000000200000002000000012719347c0000152b000000230000000c00000000000000000000001700000000usr/include/sys/swap.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SWAP_H
#define _SYS_SWAP_H

#ident	"@(#)/usr/include/sys/swap.h.sl 1.1 4.0 10/15/90 29987 AT&T-SF"

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

/* The following are for the swapctl system call */

#define	SC_ADD		1	/* add a specified resource for swapping */
#define	SC_LIST		2	/* list all the swapping resources */
#define	SC_REMOVE	3	/* remove the specified swapping resource */
#define SC_GETNSWP	4	/* get number of swapping resources configued */

typedef struct swapres {
	char	*sr_name;	/* pathname of the resource specified */
	off_t	sr_start;	/* starting offset of the swapping resource */
	off_t 	sr_length;	/* length of the swap area */
} swapres_t;

typedef struct swapent {
	char 	*ste_path;	/* get the name of the swap file */
	off_t	ste_start;	/* starting block for swapping */
	off_t	ste_length;	/* length of swap area */
	long	ste_pages;	/* numbers of pages for swapping */
	long	ste_free;	/* numbers of ste_pages free */
	long	ste_flags;	/* see below */
} swapent_t;

/* ste_flags values */

#define	ST_INDEL	0x01		/* this file is in the process */
					/* of being deleted. Don't     */
					/* allocate from it. This can  */
					/* be turned of by swapadd'ing */
					/* this device again.          */
#define	ST_DOINGDEL	0x02		/* this file is in the process */
					/* of being deleted. Fail      */
					/* another deletion attempt    */
					/* if this flag is on.         */
#define	ST_DELETED	0x04		/* this file has been deleted  */
					/* but the data structures have*/
					/* not been freed up yet.      */

typedef struct	swaptable {
	int	swt_n;			/*number of swapents following */
	struct	swapent	swt_ent[1];	/* array of swt_n swapents */
} swaptbl_t;


/* obsolete sys3b system call structures */

typedef struct swapint {
	char	si_cmd;		/* One of the command codes	*/
				/* listed below.		*/
	char	*si_buf;	/* For an SI_LIST function, this*/
				/* is a pointer to a buffer of	*/
				/* sizeof(swpt_t)*MSFILES bytes.*/
				/* For the other cases, it is a	*/
				/* pointer to a pathname of a	*/
				/* swap file.			*/
	int	si_swplo;	/* The first block number of the*/
				/* swap file.  Used only for	*/
				/* SI_ADD and SI_DEL.		*/
	int	si_nblks;	/* The size of the swap file in	*/
				/* blocks.  Used only for an	*/
				/* SI_ADD request.		*/
} swpi_t;

/*	The following are the possible values for si_cmd. */

#define	SI_LIST		0	/* List the currently active	*/
				/* swap files.			*/
#define	SI_ADD		1	/* Add a new swap file.		*/
#define	SI_DEL		2	/* Delete one of the currently	*/
				/* active swap files.		*/


/*
 * The following structure contains the data describing a swap file
 * that is returned by the SI_LIST command.  
 */

typedef struct swaptab {
	o_dev_t		st_dev;		/* The swap device.		*/
	short		st_flags;	/* Flags defined below.		*/
	use_t		st_ucnt;	/* in use flag for compatibility*/
	int		pad1;		/* use_t	*st_next;	*/
	int		st_swplo;	/* First block number on device	*/
					/* to be used for swapping.	*/
	int		st_npgs;	/* Number of pages of swap	*/
					/* space on device.		*/
	int		st_nfpgs;	/* Nbr of free pages on device.	*/
	int		pad2;		/* struct vnode	*st_vp;		*/
	int		pad3;		/* Round size to 2^n.		*/
} swpt_t;

#ifdef _KERNEL
/*
 * VM - virtual swap device.
 */

struct	swapinfo {
	struct	vnode *si_vp;		/* vnode for this swap device */
	struct	vnode *si_svp;		/* svnode for this swap device */
	uint	si_soff;		/* starting offset (bytes) of file */
	uint	si_eoff;		/* ending offset (bytes) of file */
	struct	anon *si_anon;		/* pointer to anon array */
	struct	anon *si_eanon;		/* pointer to end of anon array */
	struct	anon *si_free;		/* anon free list for this vp */
	int	si_allocs;		/* # of conseq. allocs from this area */
	struct	swapinfo *si_next;	/* next swap area */
	short	si_flags;		/* flags defined below */
	ulong	si_npgs;		/* number of pages of swap space */
	ulong	si_nfpgs;		/* number of free pages of swap space */
	char 	*si_pname;		/* swap file name */
};

#define	IS_SWAPVP(vp)	(((vp)->v_flag & VISSWAP) != 0)

#if defined(__STDC__)
extern int swapfunc(swpi_t *);
extern int swap_init(struct vnode *);
extern void swap_free(struct anon *);
extern void swap_xlate(struct anon *, struct vnode **, uint *);
extern struct anon *swap_alloc(void);
extern struct anon *swap_anon(struct vnode *, uint);
#else
extern int swapfunc();
extern int swap_init();
extern void swap_free();
extern void swap_xlate();
extern struct anon *swap_alloc();
extern struct anon *swap_anon();
#endif	/* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _SYS_SWAP_H */
 07070100005a0d000081240000000200000002000000012719347c000008b9000000230000000c00000000000000000000001600000000usr/include/sys/sxt.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sys/sxt.h.sl 1.1 4.0 10/15/90 22062 AT&T-SF"

/*
 **	Multiplexed channels driver header
 */

#define	SXTRACE		1		/* 1 to include tracing */

#define	MAXLINKS	32
#define	CHAN(dev)	(dev&CHANMASK)
#define	LINK(dev)	((dev>>CHANBITS)&(0xff>>CHANBITS))
 

#if	(MAXPCHAN*MAXLINKS) > 256
	ERROR -- product cannot be greater than minor(dev)
#endif



struct Channel
{
	struct tty	tty;		/* Virtual tty for this channel */
};

typedef struct Channel *Ch_p;

struct Link
{
	struct tty *	line;		/* Real tty for this link */
	char		controllingtty;	/* the current top dog */
	char		old;		/* Old line discipline for line */
	char		nchans;		/* Number of channels allowed */
	unsigned char	chanmask;	/* Allowable channel bits */
	char		open;		/* Channel open bits */
	char		xopen;		/* Exclusive open bits */
	char		wpending;	/* pending writes/channel */
	char		iblocked;	/* channels blocked for input */
	char		oblocked;	/* channels blocked for output*/
	short		lwchan;		/* Last channel written bit */
	char		wrcnt;		/* Number of writes on last channel written */
	dev_t		dev;		/* major and minor device # */
	struct Channel	chans[1];	/* Array of channels for this link */
};

typedef	struct Link *	Link_p;

/*
**	Ioctl args
*/

#define	SXTIOCLINK	('b'<<8)
#define	SXTIOCTRACE	(SXTIOCLINK|1)
#define	SXTIOCNOTRACE	(SXTIOCLINK|2)
#define SXTIOCSWTCH	(SXTIOCLINK|3)
#define	SXTIOCWF	(SXTIOCLINK|4)
#define SXTIOCBLK	(SXTIOCLINK|5)
#define SXTIOCUBLK	(SXTIOCLINK|6)
#define SXTIOCSTAT	(SXTIOCLINK|7)



/* the following structure is used for the SXTIOCSTAT ioctl call */
struct sxtblock
{
	char	input;		/* channels blocked on input  */
	char	output;		/* channels blocked on output */
};



#define	t_link		t_dstat		/* Use dstat in real tty for linknumber */

#define	MAXPCHAN	8			/* Maximum channel number */
#define	CHANBITS	3			/* Bits for channel number */
#define	CHANMASK	07			/* 2**CHANBITS - 1 */
#define	SXTHOG		2			/* Channel consecutive write limit */
   07070100005a54000081240000000200000002000000012719347c00000aa7000000230000000c00000000000000000000001600000000usr/include/sys/sys.s #ifndef _SYS_SYS_S
#define _SYS_SYS_S

#ident	"@(#)/usr/include/sys/sys.s.sl 1.1 4.0 10/15/90 30658 AT&T-SF"

/*
 *	Definitions of Kernel Entry Call Gates - for i386
 *
 * Moved to head.sys from head.
 *
 * A forward pointer has been left in: usr/include/sys.s
 *	to include this file.
 *
 * Changed to map to a new 4.0 sys hdr, syscall.h
 *	These old defines are being maintained for reasons of
 *	backward compatability.
 *
 * The only thing actually required, here, is to define _SYS_SYS_S
 *	and then include sys/syscall.h.
 *
 * By convention, C-programs should include <sys/syscall.h>, directly,
 *	while Asm-programs should include <sys/sys.s> which will
 *	define _SYS_SYS_S so that only '#define's from <sys/syscall.h>
 *	will actually get included.
*/

#include <sys/syscall.h>

#define	SYSCALL	$0x7,$0
#define SIGCALL $0xF,$0

/*
 *	Definitions of System Call Entry Point Numbers
*/

#define	ACCESS	33
#define	ACCT	51
#define	ADVFS	70
#define	ALARM	27
#define	BREAK	17
#define	BRK	17
#define	CHDIR	12
#define	CHMOD	15
#define	CHOWN	16
#define	CHROOT	61
#define	CLOSE	6
#define	CREAT	8
#define	DUP	41
#define	EXEC	11
#define	EXECE	59
#define	EXIT	1
#define	FCNTL	62
#define	FORK	2
#define	FSTAT	28
#define	FSTATFS	38
#define	GETDENTS	81
#define	GETGID	47
#define	GETMSG	85
#define	GETPID	20
#define	GETUID	24
#define	GTTY	32
#define	IOCTL	54
#define	KILL	37
#define	LINK	9
#define	LOCK	45
#define	LSEEK	19
#define	MKDIR	80
#define	MKNOD	14
#define	MOUNT	21
#define	MSGSYS	49
#define	NICE	34
#define	OPEN	5
#define	PAUSE	29
#define	PIPE	42
#define	PLOCK	45
#define	POLL	87
#define	PROF	44
#define	PTRACE	26
#define	PUTMSG	86
#define	RDEBUG	76
#define	READ	3
#define	RFSTART	74
#define	RFSTOP	77
#define	RFSYS	78
#define	RMDIR	79
#define	RMOUNT	72
#define	RUMOUNT	73
#define	SEEK	19
#define	SEMSYS	53
#define	SETGID	46
#define	SETPGRP	39
#define	SETUID	23
#define	SHMSYS	52
#define	SIGNAL	48
#define	STAT	18
#define	STATFS	35
#define	STIME	25
#define	STTY	31
#define	SYNC	36
#define	SYS3B	50
#define SYSI86  50
#define	SYSACCT	51
#define	SYSFS	84
#define	TIME	13
#define	TIMES	43
#define	UADMIN	55
#define	ULIMIT	63
#define	UMASK	60
#define	UMOUNT	22
#define	UNADVFS	71
#define	UNLINK	10
#define	UTIME	30
#define	UTSSYS	57
#define	WAIT	7
#define	WRITE	4
#define CXENIX	40
#define XLOCKING	296
#define CREATSEM	552
#define OPENSEM		808
#define SIGSEM		1064
#define WAITSEM		1320
#define NBWAITSEM	1576
#define RDCHK		1832
#define CHSIZE		2600
#define FTIME		2856
#define NAP		3112
#define SDGET		3368
#define SDFREE		3624
#define SDENTER		3880
#define SDLEAVE		4136
#define SDGETV		4392
#define SDWAITV		4648
#define PROCTL		8232
#define EXECSEG		8488
#define UNEXECSEG	8744
#define CLOCAL		127

#endif	/* _SYS_SYS_S */
 07070100005a0e000081240000000200000002000000012719347c000015f3000000230000000c00000000000000000000001a00000000usr/include/sys/syscall.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SYSCALL_H
#define _SYS_SYSCALL_H

#ident	"@(#)/usr/include/sys/syscall.h.sl 1.1 4.0 10/15/90 10141 AT&T-SF"

/*
 *	system call numbers
 *		syscall(SYS_xxxx, ...)
 */

	/* syscall enumeration MUST begin with 1 */
#define	SYS_exit	1
#define	SYS_fork	2
#define	SYS_read	3
#define	SYS_write	4
#define	SYS_open	5
#define	SYS_close	6
#define	SYS_wait	7
#define	SYS_creat	8
#define	SYS_link	9
#define	SYS_unlink	10
#define	SYS_exec	11
#define	SYS_chdir	12
#define	SYS_time	13
#define	SYS_mknod	14
#define	SYS_chmod	15
#define	SYS_chown	16
#define	SYS_brk		17
#define	SYS_stat	18
#define	SYS_lseek	19
#define	SYS_getpid	20
#define	SYS_mount	21
#define	SYS_umount	22
#define	SYS_setuid	23
#define	SYS_getuid	24
#define	SYS_stime	25
#define	SYS_ptrace	26
#define	SYS_alarm	27
#define	SYS_fstat	28
#define	SYS_pause	29
#define	SYS_utime	30
#define	SYS_stty	31
#define	SYS_gtty	32
#define	SYS_access	33
#define	SYS_nice	34
#define	SYS_statfs	35
#define	SYS_sync	36
#define	SYS_kill	37
#define	SYS_fstatfs	38
#define	SYS_pgrpsys	39
	/* subcodes:
	 *	getpgrp()         :: syscall(39,0)
	 *	setpgrp()         :: syscall(39,1)
	 *	getsid(pid)       :: syscall(39,2,pid)
	 *	setsid()          :: syscall(39,3)
	 *	getpgid(pid)      :: syscall(39,4,pid)
	 *	setpgid(pid,pgid) :: syscall(39,5,pid,pgid)
	 */
#define	SYS_xenix	40
	/* subcodes:
	 *	syscall(40, code, ...)
	 */
#define	SYS_dup		41
#define	SYS_pipe	42
#define	SYS_times	43
#define	SYS_profil	44
#define	SYS_plock	45
#define	SYS_setgid	46
#define	SYS_getgid	47
#define	SYS_signal	48
	/* subcodes:
	 *	signal(sig, f) :: signal(sig, f)    ((sig&SIGNO_MASK) == sig)
	 *	sigset(sig, f) :: signal(sig|SIGDEFER, f)
	 *	sighold(sig)   :: signal(sig|SIGHOLD)
	 *	sigrelse(sig)  :: signal(sig|SIGRELSE)
	 *	sigignore(sig) :: signal(sig|SIGIGNORE)
	 *	sigpause(sig)  :: signal(sig|SIGPAUSE)
	 *	see <sys/signal.h>
	 */
#define	SYS_msgsys	49
	/* subcodes:
	 *	msgget(...) :: msgsys(0, ...)
	 *	msgctl(...) :: msgsys(1, ...)
	 *	msgrcv(...) :: msgsys(2, ...)
	 *	msgsnd(...) :: msgsys(3, ...)
	 *	see <sys/msg.h>
	 */
#define	SYS_sys3b	50
	/* subcodes:
	 *	sys3b(code, ...)
	 *	see <sys/sys3b.h>
	 */
#define	SYS_acct	51
#define	SYS_shmsys	52
	/* subcodes:
	 *	shmat (...) :: shmsys(0, ...)
	 *	shmctl(...) :: shmsys(1, ...)
	 *	shmdt (...) :: shmsys(2, ...)
	 *	shmget(...) :: shmsys(3, ...)
	 *	see <sys/shm.h>
	 */
#define	SYS_semsys	53
	/* subcodes:
	 *	semctl(...) :: semsys(0, ...)
	 *	semget(...) :: semsys(1, ...)
	 *	semop (...) :: semsys(2, ...)
	 *	see <sys/sem.h>
	 */
#define	SYS_ioctl	54
#define	SYS_uadmin	55
				/* 56 reserved for exch() */
#define	SYS_utssys	57
	/* subcodes (third argument):
	 *	uname(obuf)  (obsolete)   :: syscall(57, obuf, ign, 0)
	 *					subcode 1 unused
	 *	ustat(dev, obuf)          :: syscall(57, obuf, dev, 2)
	 *	fusers(path, flags, obuf) :: syscall(57, path, flags, 3, obuf)
	 *	see <sys/utssys.h>
	 */
#define	SYS_fsync	58
#define	SYS_execve	59
#define	SYS_umask	60
#define	SYS_chroot	61
#define	SYS_fcntl	62
#define	SYS_ulimit	63
				/* 64-69 reserved for UNIX PC */
				/* 70 not used, was advfs */
				/* 71 not used, was unadvfs */
				/* 72 not used, was rmount */
				/* 73 not used, was rumount */
				/* 74 not used, was rfstart */
				/* 75 not used */
				/* 76 not used, was rdebug */
				/* 77 not used, was rfstop */
#define	SYS_rfsys	78
	/* subcodes:
	 *	rfsys(code, ...)
	 *	see <sys/rf_sys.h>
	 */
#define	SYS_rmdir	79
#define	SYS_mkdir	80
#define	SYS_getdents	81
				/* 82 not used, was libattach */
				/* 83 not used, was libdetach */
#define	SYS_sysfs	84
	/* subcodes:
	 *	sysfs(code, ...)
	 *	see <sys/fstyp.h>
	 */
#define	SYS_getmsg	85
#define	SYS_putmsg	86
#define	SYS_poll	87

#define	SYS_lstat	88
#define	SYS_symlink	89
#define	SYS_readlink	90
#define	SYS_setgroups	91
#define	SYS_getgroups	92
#define	SYS_fchmod	93
#define	SYS_fchown	94
#define	SYS_sigprocmask	95
#define	SYS_sigsuspend	96
#define	SYS_sigaltstack	97
#define	SYS_sigaction	98
#define	SYS_sigpending	99
	/* subcodes:
	 *			subcode 0 unused
	 *	sigpending(...) :: syscall(99, 1, ...)
	 *	sigfillset(...) :: syscall(99, 2, ...)
	 */
#define	SYS_context	100
	/* subcodes:
	 *	getcontext(...) :: syscall(100, 0, ...)
	 *	setcontext(...) :: syscall(100, 1, ...)
	 */
#define	SYS_evsys	101
#define	SYS_evtrapret	102
#define	SYS_statvfs	103
#define	SYS_fstatvfs	104
				/* 105 reserved */
#define	SYS_nfssys	106
#define	SYS_waitsys	107
#define	SYS_sigsendsys	108
#define	SYS_hrtsys	109
#define	SYS_acancel	110
#define	SYS_async	111
#define	SYS_priocntlsys	112
#define	SYS_pathconf	113
#define	SYS_mincore	114
#define	SYS_mmap	115
#define	SYS_mprotect	116
#define	SYS_munmap	117
#define	SYS_fpathconf	118
#define	SYS_vfork	119
#define	SYS_fchdir	120
#define	SYS_readv	121
#define	SYS_writev	122
#define	SYS_xstat	123
#define	SYS_lxstat	124
#define	SYS_fxstat	125
#define	SYS_xmknod	126
#define	SYS_clocal	127
#define	SYS_setrlimit	128
#define	SYS_getrlimit	129
#define	SYS_lchown	130
#define	SYS_memcntl	131
#define	SYS_getpmsg	132
#define	SYS_putpmsg	133
#define	SYS_rename	134
#define	SYS_uname	135
#define	SYS_setegid	136
#define	SYS_sysconfig	137
#define	SYS_adjtime	138
#define	SYS_systeminfo	139
#define	SYS_seteuid	141

#ifndef _SYS_SYS_S

typedef struct {		/* syscall set type */
	unsigned long	word[16];
} sysset_t;

#endif	/* _SYS_SYS_S */

#endif	/* _SYS_SYSCALL_H */
 07070100005a0f000081240000000200000002000000012719347c0000039c000000230000000c00000000000000000000001c00000000usr/include/sys/sysconfig.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/sysconfig.h.sl 1.1 4.0 10/15/90 47276 AT&T-SF"

/* cmd values for _sysconfig system call. 
** WARNING: This is an undocumented system call,
** therefore future compatibility can not
** guaranteed. 
*/ 

#define	 UNUSED			1
#define _CONFIG_NGROUPS		2	/* number of configured supplemental groups */
#define _CONFIG_CHILD_MAX	3	/* max # of processes per uid session */
#define _CONFIG_OPEN_FILES	4	/* max # of open files per process */
#define _CONFIG_POSIX_VER	5	/* POSIX version */
#define _CONFIG_PAGESIZE	6	/* system page size */
#define _CONFIG_CLK_TCK		7	/* ticks per second */
#define _CONFIG_XOPEN_VER	8	/* XOPEN version */
07070100005a10000081240000000200000002000000012719347c00001f84000000230000000c00000000000000000000001900000000usr/include/sys/sysi86.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SYSI86_H
#define _SYS_SYSI86_H

#ident	"@(#)/usr/include/sys/sysi86.h.sl 1.1 4.0 10/15/90 37937 AT&T-SF"

#ifndef DIRSIZ
#define	DIRSIZ	14
#endif

/*
 * Commands for sysi86 system call (1-?)
 */

#define SI86SWPI        1       /* General swap interface.                */
#define SI86SYM         2       /* acquire boot-built symbol table        */
#define SI86CONF        4       /* acquire boot-built configuration table */
#define SI86BOOT        5       /* acquire timestamp and name of program  */
				/* booted                                 */
#define SI86AUTO        9       /* was an auto-config boot done?          */
#define SI86EDT         10      /* copy contents of EDT to user           */
#define SI86SWAP        12      /* Declare swap space                     */
#define SI86FPHW        40      /* what (if any?) floating-point hardware */

#define GRNON		52	/* set green light to solid on state */
#define GRNFLASH	53	/* start green light flashing */
#define STIME 		54	/* set internal time */
#define SETNAME		56	/* rename the system */
#define RNVR 		58	/* read NVRAM */
#define WNVR 		59	/* write NVRAM */
#define RTODC		60	/* read time of day clock */
#define CHKSER		61	/* check soft serial number */
#define SI86NVPRT       62      /* print an xtra_nvr structure */
#define SANUPD		63	/* sanity update of kernel buffers */
#define SI86KSTR        64      /* make a copy of a kernel string */
#define SI86MEM         65      /* return the memory size of system */
#define SI86TODEMON     66      /* Transfer control to firmware.        */
#define SI86CCDEMON     67      /* Control character access to demon.   */
#define SI86CACHE       68      /* Turn cache on and off.               */
#define SI86DELMEM      69      /* Delete available memory for testing. */
#define SI86ADDMEM      70      /* Add back deleted memory.             */
/* 71 through 74 reserved for VPIX */
#define SI86V86         71      /* V86 system calls (see v86.h)         */
#define	SI86SLTIME	72	/* Set local time correction		*/
#define SI86DSCR        75      /* Set a segment or gate descriptor     */
#define RDUBLK		76	/* Read U Block */
/* NFA entry point */
#define SI86NFA		77	/* make nfa_sys system call		*/
#define SI86VM86	81
#define SI86VMENABLE	82
#define SI86LIMUSER	91	/* liscense interface */
#define SI86RDID	92	/* ROM BIOS Machid ID */
#define SI86RDBOOT	93	/* Bootable Non-SCSI Hard Disk */
/* XENIX Support */
#define SI86SHFIL	100	/* map a file into addr space of a proc */
#define SI86PCHRGN	101	/* make globally visible change to a region */
#define SI86BADVISE	102	/* badvise subcommand - see below for   */
				/*	badvise subfunction definitions */
#define SI86SHRGN	103	/* enable/disable XENIX small model shared */
				/*	data context switching		   */ 
#define	SI86CHIDT	104	/* set user level int 0xf0, ... 0xff handlers */
#define	SI86EMULRDA	105	/* remove special emulator read access	*/

/*
 *	NOTE: Numbers 106 - 110 have been registered and are reserved
 *	for future use for AT&T hardware.
 */
#define SI86NCPU	106	/* return number of CPU's in system */

/*
 *  The SI86DSCR subcommand of the sysi86() system call
 *  sets a segment or gate descriptor in the kernel.
 *  The following descriptor types are accepted:
 *    - executable and data segments in the LDT at DPL 3
 *    - a call gate in the GDT at DPL 3 that points to a segment in the LDT
 *  The request structure declared below is used to pass the values
 *  to be placed in the descriptor.  A pointer to the structure is
 *  passed as the second argument of the system call.
 *  If acc1 is zero, the descriptor is cleared.
*/

/* request structure passed by user */
struct ssd {
	unsigned int sel;   /* descriptor selector */
	unsigned int bo;    /* segment base or gate offset */
	unsigned int ls;    /* segment limit or gate selector */
	unsigned int acc1;  /* access byte 5 */
	unsigned int acc2;  /* access bits in byte 6 or gate count */
};

/*
 *  The SI86SHFIL subcommand of the sysi86() system call
 *  maps a file into a region in user address space.
 *  The request structure declared below is used to pass the
 *  system call parameters.  A pointer to the structure is
 *  passed as the second argument of the system call.
 */
struct mmf {
	char *	mf_filename;	/* path name of file */
	long	mf_filesz;	/* Size in bytes of section of file	*/
				/* from which this region is mapped.	*/
	long	mf_regsz;	/* Size of region in bytes */
	short	mf_flags;	/* Either 0 or RG_NOSHARE */
};

/*
 *  The SI86PCHRGN subcommand of the sysi86() system call
 *  change the memory mapped image of a file.
 *  The request structure declared below is used to pass the values
 *  system call parameters.  A pointer to the structure is
 *  passed as the second argument of the system call.
*/
struct cmf {
	char *	cf_srcva;	/* modified image address */
	char *	cf_dstva;	/* location to patch */
	long	cf_count;	/* size of patch */
};

/*
 * The SI86BADVISE subcommand of the sysi86() system call specifies
 * XENIX variant behavior for certain system calls and kernel routines.
 * The 'arg' argument of sysi86() for SI86BADVISE is an integer.  Bits
 * 8..15 specify SI86B_SET or SI86B_GET.  Bits 0..7 contain
 * SI86B_PRE_SV, SI86B_XOUT, or SI86B_XSDSWTCH.  All these constants are 
 * defined below.  The 'arg' argument thus consists of either SI86B_SET 
 * OR'ed with zero or more of SI86B_PRE_SV, SI86B_XOUT, and SI86B_XSDSWTCH,
 * or of SI86B_GET. 
 */

#define SI86B_SET		0x0100	/* set badvise bits      */
#define SI86B_GET		0x0200	/* retrieve badvise bits */	

#define SI86B_PRE_SV		0x0008	/* follow pre-System V x.out behavior */
#define SI86B_XOUT		0x0010 	/* follow XENIX x.out behavior */
#define SI86B_XSDSWTCH		0x0080	/* XENIX small model shared data    */
					/*	context switching enabled   */
/*
 *   The request structure declared below is used by the XENIX 286 emulator
 *   (/bin/x286emul) in conjunction with the SI86SHRGN subcommand of sysi86().
 *   The SI86SHRGN subcommand is used by the XENIX 286 emulator to support
 *   XENIX shared data.  The second argument passed to sysi86() is a 
 *   pointer to an xsdbuf struct.
 *
 *   If the 'xsd_cmd' field of xsdbuf is SI86SHR_CP, the XENIX 286 emulator is 
 *   using the SI86SHRGN subcommand to set up XENIX small model shared data 
 *   context switching support for a given XENIX shared data segment.  In this 
 *   case, the xsdbuf struct contains the start addr for the shared data in 
 *   386 space, followed by the start addr for the shared data in the 286 
 *   executable's private data.  
 *
 *   If the 'xsd_cmd' field is SI86SHR_SZ, the XENIX 286 emulator is using the 
 *   SI86SHRGN subcommand to retrieve the size of an existing XENIX shared 
 *   data segment.  In this case, the xsdbuf struct contains the start addr
 *   for the shared data in 386 space.
 *   The size of the shared data segment starting at 'xsd_386vaddr' will
 *   be returned in the 'xsd_size' field by sysi86().
 */

#define SI86SHR_CP	0x1	/* SI86SHRGN used for XENIX sd context switch */
#define SI86SHR_SZ	0x2	/* SI86SHRGN used to get XENIX sd seg size */

struct xsdbuf {
	unsigned xsd_cmd;	/* SI86SHRGN subcommand, either SI86SHR_CP 
				 * 	or SI86SHR_SZ.
				 */ 	
	char	*xsd_386vaddr;	/* Addr of "real" XENIX shared data seg in 
				 * 	the emulator.
				 */
	union {
	   char	*xsd_286vaddr;	/* Addr of XENIX shared data seg in the
				 * 	286 data portion of the emulator.
				 */
	   unsigned long xsd_size;/* Size of XENIX shared data seg */
	} xsd_un;
};
/* End XENIX Support */

/*
 * Cascade defines
*/

#define DISKLESS	'D'
#define C2	'E'
#define C3	'F'
#define C4	'G'
#define C6	'K'
#define C2U	'L'
#define C5U	'M'
#define G3	'S'

/* Enterprise IDNO defines */
#define E8R1	'R'
#define E8R2	'Q'

#endif	/* _SYS_SYSI86_H */
07070100005a11000081240000000200000002000000012719347c0000128a000000230000000c00000000000000000000001a00000000usr/include/sys/sysinfo.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SYSINFO_H
#define _SYS_SYSINFO_H

#ident	"@(#)/usr/include/sys/sysinfo.h.sl 1.1 4.0 10/15/90 52018 AT&T-SF"

/*
 *	System Information.
 */

struct sysinfo {
	time_t	cpu[5];
#define	CPU_IDLE	0
#define	CPU_USER	1
#define	CPU_KERNEL	2
#define	CPU_WAIT	3
#define CPU_SXBRK	4
	time_t	wait[3];
#define	W_IO	0
#define	W_SWAP	1
#define	W_PIO	2
	long	bread;
	long	bwrite;
	long	lread;
	long	lwrite;
	long	phread;
	long	phwrite;
	long	swapin;
	long	swapout;
	long	bswapin;
	long	bswapout;
	long	pswitch;
	long	syscall;
	long	sysread;
	long	syswrite;
	long	sysfork;
	long	sysexec;
	long	runque;
	long	runocc;
	long	swpque;
	long	swpocc;
	long	iget;
	long	namei;
	long	dirblk;
	ulong	readch;
	ulong	writech;
	long	rcvint;
	long	xmtint;
	long	mdmint;
	long	rawch;
	long	canch;
	long	outch;
	long	msg;
	long	sema;
	long	pnpfault;
	long	wrtfault;
    long    s5ipage;
    long    s5inopage;
    long    ufsipage;
    long    ufsinopage;
    long    xxipage;
    long    xxinopage;
};

extern struct sysinfo sysinfo;

struct syswait {
	short	iowait;
	short	swap;
	short	physio;
};

struct minfo {
	unsigned long 	freemem[2]; 	/* freemem in pages */
					/* "double" long format	*/
					/* freemem[0] least significant */
	long	freeswap;	/* free swap space */
	long    vfault;  	/* translation fault */
	long    demand;		/*  demand zero and demand fill pages */
	long    swap;		/*  pages on swap */
	long    cache;		/*  pages in cache */
	long    file;		/*  pages on file */
	long    pfault;		/* protection fault */
	long    cw;		/*  copy on write */
	long    steal;		/*  steal the page */
	long    freedpgs;	/* pages are freed */
	long    vfpg; 		/* pages are freed by vhand*/
	long    sfpg;		/* pages are freed by sched*/
	long    vspg;		/* pages are freed/swapped by vhand */
	long    sspg;		/* pages are freed/swapped by sched */
	long    unmodsw;	/* getpages finds unmodified pages on swap */
	long	unmodfl;	/* getpages finds unmodified pages in file */ 
#ifdef	i386			/* psk */
	long    psoutok;        /* swapping out a process */
	long    psinfail;       /* swapping in a process failed */
	long    psinok;         /* swapping in a process succeeded */
	long    rsout;          /* swapping out a region */
	long    rsin;           /* swapping in a region */
#endif
};

typedef struct fsinfo {
	ulong fsireadch;
	ulong fsiwritech;
	ulong fsivop_open;
	ulong fsivop_close;
	ulong fsivop_read;
	ulong fsivop_write;
	ulong fsivop_lookup;
	ulong fsivop_create;
	ulong fsivop_readdir;
	ulong fsivop_getpage;
	ulong fsivop_putpage;
	ulong fsivop_other;
} fsinfo_t;

extern struct minfo minfo;

struct vminfo {
	ulong	v_pgrec;
	ulong	v_xsfrec;
	ulong	v_xifrec;
	ulong	v_pgin;
	ulong	v_pgpgin;
	ulong	v_pgout;
	ulong	v_pgpgout;
	ulong	v_swpout;
	ulong	v_pswpout;
	ulong	v_swpin;
	ulong	v_pswpin;
	ulong	v_dfree;
	ulong	v_scan;
	ulong	v_pfault;
	ulong	v_vfault;
	ulong	v_sftlock;
};

extern struct vminfo vminfo;
extern struct syswait syswait;

struct syserr {
	long	inodeovf;
	long	fileovf;
	long	textovf;
	long	procovf;
};

extern struct syserr syserr;

struct shlbinfo {
	long	shlbs;		/* Max # of libs a process can link in	*/
				/*   at one time.			*/
	long	shlblnks;	/* # of times processes that have used	*/
				/*   static shared libraries.		*/
	long	shlbovf;	/* # of processes needed more shlibs	*/
				/*   than the system imposed limit.	*/
	long	shlbatts;	/* # of times processes have attached	*/
				/*   run time libraries.		*/
};

extern struct shlbinfo shlbinfo;

struct bpbinfo {
	long	usr;		/* usr time for the co-processor	*/
	long	sys;		/* system time for the co-processor	*/
	long	idle;		/* idle time for the co-processor	*/
	long	syscall;	/* # of system calls since boot on the  */
				/*	co-processor			*/
};

extern struct bpbinfo bpbinfo[];

struct rtminfo {
	long	ev_post;		/* # of evpost operations since boot	*/
	long	ev_poll;		/* # of evpoll operations since boot	*/
	long	ev_trap;		/* # of evtrap operations since boot	*/
};
extern struct rtminfo rtminfo;

#define KMEM_NCLASS 3		/* # of KMEM request classes		*/
#define KMEM_SMALL  0		/* small KMEM request index		*/
#define KMEM_LARGE  1		/* large KMEM request index		*/
#define KMEM_OSIZE  2		/* outsize KMEM request index		*/

struct kmeminfo {
	ulong	km_mem[KMEM_NCLASS];	/* amount of memory owned by KMEM  */
	ulong	km_alloc[KMEM_NCLASS];  /* amount of memory allocated	   */
	ulong	km_fail[KMEM_NCLASS];	/* # of failed requests		   */
};
extern struct kmeminfo kmeminfo;

#endif	/* _SYS_SYSINFO_H */
  07070100005a13000081240000000200000002000000012719347c0000183c000000230000000c00000000000000000000001c00000000usr/include/sys/sysmacros.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SYSMACROS_H
#define _SYS_SYSMACROS_H

#ident	"@(#)/usr/include/sys/sysmacros.h.sl 1.1 4.0 10/15/90 41192 AT&T-SF"

#include <sys/param.h>

/* Core clicks to page tables and vice versa */
/* This is still called ctos, etc to avoid large scale
 * changes in the code. "Segment" here means the
 * memory spanned by a page table.
 */

#define ctos(x)		(((x) + (NCPPT-1)) >> CPPTSHIFT)
#define	ctost(x)	((x) >> CPPTSHIFT)
#define	stoc(x)		((x) * NCPPT)

/* Core clicks to segments and vice versa */
#define	ctod(x) ((x)*NDPC)

/*
 * Disk blocks (sectors) and bytes.
 */
#define	dtob(DD)	((DD) << SCTRSHFT)
#define	btod(BB)	(((BB) + NBPSCTR - 1) >> SCTRSHFT)
#define	btodt(BB)	((BB) >> SCTRSHFT)

/*
 * Disk blocks (sectors) and pages.
 */
#define NDPP		8	/* Number of disk blocks per page */
#define DPPSHFT		3	/* Shift for disk blocks per page. */
#define	ptod(PP)	((PP) << DPPSHFT)
#define	dtop(DD)	(((DD) + NDPP - 1) >> DPPSHFT)
#define dtopt(DD)	((DD) >> DPPSHFT)

/* clicks to bytes */
#ifdef BPCSHIFT
#define	ctob(x)	((x)<<BPCSHIFT)
#else
#define	ctob(x)	((x)*NBPC)
#endif

/* bytes to clicks */
#ifdef BPCSHIFT
#define	btoc(x)	(((unsigned)(x)+(NBPC-1))>>BPCSHIFT)
#define	btoct(x)	((unsigned)(x)>>BPCSHIFT)
#else
#define	btoc(x)	(((unsigned)(x)+(NBPC-1))/NBPC)
#define	btoct(x)	((unsigned)(x)/NBPC)
#endif

/* common macros */

#define MIN(a, b)	((a) < (b) ? (a) : (b))
#define MAX(a, b)	((a) < (b) ? (b) : (a))

/* WARNING: The device number macros defined here should not be used by device 
** drivers or user software. Device drivers should use the device functions
** defined in the DDI/DKI interface (see also ddi.h). Application software should 
** make use of the library routines available in makedev(3). A set of new device 
** macros are provided to operate on the expanded device number format supported
** in SVR4. Macro versions of the DDI device functions are provided for use by
** kernel proper routines only. Macro routines bmajor(), major(), minor(),
** emajor(), eminor(), and makedev() will be removed or their definitions 
** changed at the next major release following SVR4.
*/

#define O_BITSMAJOR	7	/* # of SVR3 major device bits */
#define O_BITSMINOR	8	/* # of SVR3 minor device bits */
#define O_MAXMAJ	0x7f	/* SVR3 max major value */
#define O_MAXMIN	0xff	/* SVR3 max major value */


#define L_BITSMAJOR	14	/* # of SVR4 major device bits */
#define L_BITSMINOR	18	/* # of SVR4 minor device bits */
#define L_MAXMAJ	0xff	/* Although 14 bits are reserved, 
				** the 3b2 major number is restricted
				** to 8 bits. 
				*/

#define L_MAXMIN	0x3ffff	/* MAX minor for 3b2 software drivers.
				** For 3b2 hardware devices the minor is
				** restricted to 256 (0-255)
				*/

#if _KERNEL && u3b2

/* major part of a device internal to the kernel */
#define NMAJORENTRY	256	/* Number of entries in major/minor array */

extern char MAJOR[NMAJORENTRY];
#define	major(x)	(int)(MAJOR[(unsigned)((x)>>O_BITSMINOR) & O_MAXMAJ])
#define	bmajor(x)	(int)(MAJOR[(unsigned)((x)>>O_BITSMINOR) & O_MAXMAJ])

/* get internal major part of expanded device number */

#define getmajor(x) (int)(MAJOR[(unsigned)((x)>>L_BITSMINOR) & L_MAXMAJ])

/* minor part of a device internal to the kernel */
extern char MINOR[256];
#define	minor(x)	(int)(MINOR[(unsigned)((x)>>O_BITSMINOR)&O_MAXMAJ]+((x)&O_MAXMIN))

/* get internal minor part of expanded device number */

#define getminor(x) (int)(MINOR[(unsigned)((x)>>L_BITSMINOR)&L_MAXMAJ]+((x)&L_MAXMIN))

#else

/* major part of a device external from the kernel (same as emajor below) */
#define	major(x)	(int)(((unsigned)x>>O_BITSMINOR)&O_MAXMAJ)
#define	bmajor(x)	(int)(((unsigned)x>>O_BITSMINOR)&O_MAXMAJ)


/* minor part of a device external from the kernel  (same as eminor below)*/
#define	minor(x)	(int)(x&O_MAXMIN)

#endif	/* _KERNEL && u3b2 */

/* create old device number */

#define	makedev(x,y)	(unsigned short)(((x)<<O_BITSMINOR) | (y&O_MAXMIN))

/* make an new device number */
			
#define makedevice(x,y)	(unsigned long)(((x)<<L_BITSMINOR) | ((y)&L_MAXMIN))


/*
 *   emajor() allows kernel/driver code to print external major numbers
 *   eminor() allows kernel/driver code to print external minor numbers
 */
#define emajor(x)   (int)((((unsigned long)(x)>>O_BITSMINOR) > O_MAXMAJ) ? \
			NODEV : (((unsigned long)(x)>>O_BITSMINOR)&O_MAXMAJ))
#define eminor(x)	(int)((x)&O_MAXMIN)

/* get external major and minor device 
** components from expanded device number
*/
#define getemajor(x)    (int)((((unsigned long)(x)>>L_BITSMINOR) > L_MAXMAJ) ? \
			NODEV : (((unsigned long)(x)>>L_BITSMINOR)&L_MAXMAJ))
#define geteminor(x)	(int)((x)&L_MAXMIN)


/* convert to old dev format */

#define cmpdev(x) 	(unsigned long)((((x)>>L_BITSMINOR) > O_MAXMAJ || \
				((x)&L_MAXMIN) > O_MAXMIN) ? NODEV : \
				((((x)>>L_BITSMINOR)<<O_BITSMINOR)|((x)&O_MAXMIN)))

/* convert to new dev format */

#define expdev(x) 	(unsigned long)(((((x)>>O_BITSMINOR)&O_MAXMAJ)<<L_BITSMINOR) \
				| ((x)&O_MAXMIN))

/*
 *  Evaluate to true if the process is an RFS server.
 */
#define	RF_SERVER()	(u.u_procp->p_sysid != 0)

/* machine dependent operations - defined for RFS and STREAMS */

#ifdef	pdp11
#define	SALIGN(p)		(char *)(((int)p+1) & ~1)
#define	IALIGN(p)		(char *)(((int)p+1) & ~1)
#define LALIGN(p)		(char *)(((int)p+1) & ~3)
#endif
#if	vax | i386
#define	SALIGN(p)		(char *)(((int)p+1) & ~1)
#define	IALIGN(p)		(char *)(((int)p+3) & ~3)
#define	LALIGN(p)		(char *)(((int)p+3) & ~3)
#endif
#ifdef	u3b2
#define	SALIGN(p)		(char *)(((int)p+1) & ~1)
#define	IALIGN(p)		(char *)(((int)p+3) & ~3)
#define	LALIGN(p)		(char *)(((int)p+3) & ~3)
#endif

#define SNEXT(p)		(char *)((int)p + sizeof (short))
#define INEXT(p)		(char *)((int)p + sizeof (int))
#define LNEXT(p)		(char *)((int)p + sizeof (long))

/*
 * Macros for counting and rounding.
 */
#define howmany(x, y)	(((x)+((y)-1))/(y))
#define roundup(x, y)	((((x)+((y)-1))/(y))*(y))

#endif	/* _SYS_SYSMACROS_H */
07070100005a14000081240000000200000002000000012719347c0000025a000000230000000c00000000000000000000001900000000usr/include/sys/sysmsg.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/sysmsg.h.sl 1.1 4.0 10/15/90 43935 AT&T-SF"

#define SMSGIOC		('U' << 8)
#define	SMSG_GETFLAGS	SMSGIOC | 200
#define	SMSG_SETFLAGS	SMSGIOC | 201

struct smsg_flags
{
	int	static_cmf;
	int	dynamic_cmf;
	int	static_rcmf;
	int	dynamic_rcmf;
	int	acef;
	int	rcef;
	int	cmos_acef;
	int	ac_baud;
	int	rc_baud;
};
  07070100005a15000081240000000200000002000000012719347c0000053b000000230000000c00000000000000000000001d00000000usr/include/sys/systeminfo.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/systeminfo..sl 1.1 4.0 10/15/90 64371 AT&T-SF"

extern char architecture[];
extern char hw_serial[];
extern char hw_provider[];
extern char srpc_domain[SYS_NMLN];


/*
 * Commands to sysinfo()
 */

#define SI_SYSNAME		1	/* return name of operating system */
#define SI_HOSTNAME		2	/* return name of node */
#define SI_RELEASE 		3	/* return release of operating system */
#define SI_VERSION		4	/* return version field of utsname */
#define SI_MACHINE		5	/* return kind of machine */
#define SI_ARCHITECTURE		6	/* return instruction set arch */
#define SI_HW_SERIAL		7	/* return hardware serial number */
#define SI_HW_PROVIDER		8	/* return hardware manufacturer */
#define SI_SRPC_DOMAIN		9	/* return secure RPC domain */
/*
 * These commands are unpublished interfaces to sysinfo().
 */
#define SI_SET_HOSTNAME		258	/* set name of node */
					/*  -unpublished option */
#define SI_SET_SRPC_DOMAIN	265	/* set secure RPC domain */
					/* -unpublished option */

#if defined(__STDC__) && !defined(_KERNEL)
int sysinfo(int, char *, long);
#endif
 07070100005a16000081240000000200000002000000012719347c00002152000000230000000c00000000000000000000001800000000usr/include/sys/systm.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_SYSTM_H
#define _SYS_SYSTM_H

#ident	"@(#)/usr/include/sys/systm.h.sl 1.1 4.0 10/15/90 60607 AT&T-SF"
/*
 * Random set of variables used by more than one routine.
 */

#ifdef _KERNEL
extern struct vnode *rootdir;	/* pointer to vnode of root directory */
extern short cputype;		/* type of cpu = 40, 45, 70, 780, 0x3b15 */
extern clock_t lbolt;		/* time in HZ since last boot */
extern int Dstflag;     /* configurable timezone */
extern int Timezone;        /* configurable DST flag */
extern int Hz;          /* Ticks/second of the clock */


extern char runin;		/* scheduling flag */
extern char runout;		/* scheduling flag */

extern int	maxmem;		/* max available memory (clicks) */
extern int	physmem;	/* physical memory (clicks) on this CPU */
extern int	maxclick;	/* Highest physical click + 1.		*/
extern int	nswap;		/* size of swap space in blocks*/
extern dev_t	rootdev;	/* device of the root */
extern dev_t	swapdev;	/* swapping device */
extern dev_t    dumpdev;    /* dump device */
extern char	*panicstr;	/* panic string pointer */
extern int	blkacty;	/* active block devices */
extern int	pwr_cnt, pwr_act;
extern int 	(*pwr_clr[])();

extern	int	rstchown;	/* 1 ==> restrictive chown(2) semantics */

#if defined(__STDC__)
extern void iomove(caddr_t, int, int);
extern int is32b(void);
extern void wakeprocs(caddr_t, int);
extern void wakeup(caddr_t);
extern int sleep(caddr_t, int);
extern void trap_ret(void);
extern int grow(int *);
extern int timeout(void (*)(), caddr_t, long);
extern int untimeout(int);
extern int nodev(void);
extern int nulldev(void);
extern int getudev(void);
extern int bcmp(char *, char *, size_t);
extern int memlow(void);
extern int stoi(char **);
extern void numtos(u_long, char *);
extern char *strncpy(char *, char *, size_t);
extern char *strcat(char *, char *);
extern char *strncat(char *, char *, size_t);
extern int strcmp(char *, char *);
extern int strncmp(char *, char *, size_t);
extern int copyin(caddr_t, caddr_t, size_t);
extern int lcopyin(caddr_t, caddr_t, size_t);
extern int copyout(caddr_t, caddr_t, size_t);
extern int lcopyout(caddr_t, caddr_t, size_t);
extern int copyinstr(char *, char *, size_t, size_t *);
extern int copystr(char *, char *, size_t, size_t *);
extern void bcopy(caddr_t, caddr_t, size_t);
extern void ovbcopy(char *, char *, size_t);
extern void fbcopy(int *, int *, size_t);
extern void bzero(caddr_t, size_t);
extern void bzeroa(caddr_t, size_t);
extern void bzeroba(caddr_t, size_t);
extern int upath(caddr_t, caddr_t, size_t);
extern int spath(caddr_t, caddr_t, size_t);
extern int fubyte(caddr_t);
extern int lfubyte(caddr_t);
extern int fuword(int *);
extern int lfuword(int *);
extern int subyte(caddr_t, char);
extern int suword(int *, int);
extern int setjmp(label_t *);
extern void longjmp(label_t *);
extern void xrele(struct vnode *);
extern int arglistsz(caddr_t *, int *, int *, int);
extern int copyarglist(int, caddr_t *, int, caddr_t *, caddr_t, int);
extern int userstrlen(caddr_t);
#else
extern void iomove();
extern int is32b();
extern void wakeprocs();
extern void wakeup();
extern int sleep();
extern void trap_ret();
extern int grow();
extern int timeout();
extern int untimeout();
extern int nodev();
extern int nulldev();
extern int getudev();
extern int bcmp();
extern int memlow();
extern int stoi();
extern void numtos();
extern char *strncpy();
extern char *strcat();
extern char *strncat();
extern int strcmp();
extern int strncmp();
extern int copyin();
extern int lcopyin();
extern int copyout();
extern int lcopyout();
extern int copyinstr();
extern int copystr();
extern void bcopy();
extern void ovbcopy();
extern void fbcopy();
extern void bzero();
extern void bzeroa();
extern void bzeroba();
extern int upath();
extern int spath();
extern int fubyte();
extern int lfubyte();
extern int fuword();
extern int lfuword();
extern int subyte();
extern int suword();
extern int setjmp();
extern void longjmp();
extern void xrele();
extern int arglistsz();
extern int copyarglist();
extern int userstrlen();

#endif

/*
 * Arguments to wakeprocs() to specify preemptive vs.
 * non-preemptive wakeup
 */
#define	NOPRMPT	0
#define	PRMPT	1

extern struct proc *old_curproc;    /* previous curproc */
extern struct proc *oldproc;        /* previous proc that exited */

#endif /* _KERNEL */

/*
 * Structure of the system-entry table.
 */
extern struct sysent {
	char	sy_narg;		/* total number of arguments */
	char	sy_flags;		/* various flags as defined below */
	int	(*sy_call)();		/* handler */
} sysent[];

extern unsigned	sysentsize;

/* Various flags in sy_flags */

#define	SETJUMP	0x01			/* when set, indicate that systrap */
					/* should do a setjmp()		   */
#define	ASYNC	0x02			/* async extension is allowed	   */
#define IOSYS	0x04			/* an I/O system call, the first   */
					/* arg. passed is file descriptor  */

/*
 * Structure of the return-value parameter passed by reference to
 * system entries.
 */
union rval {
	struct	{
		int	r_v1;
		int	r_v2;
	} r_v;
	off_t	r_off;
	time_t	r_time;
};
#define r_val1	r_v.r_v1
#define r_val2	r_v.r_v2
	
typedef union rval rval_t;

extern int Dstflag;
extern int Timezone;

#ifdef	KPERF

/*	This is the structure for the  kernel performance		*/ 
/*	measurement code.                                      		*/
/*                                                      		*/
#define NUMRC 512
#define NUMPHASE 64
#define PFCHAR 10

#define KPFCHILDSLP 35
#define KPFTRON    36
#define KPFTRON2    37
#define KPFTROFF    38

/*	The following structure describes the records written
**	by the kernel performance measurement code.
**
**	Not all fields of the structure have meaningful values for
**	records types.
*/
typedef struct kernperf {
	unsigned char	kp_type;	/* the record type as defined below */
	unsigned char	kp_level;	/* A priority level.		*/
	pid_t 		kp_pid;		/* A process id.	*/
	clock_t 	kp_time;	/* A relative time in 10 	*/
					/* microseconds units		*/
	unsigned long	kp_pc;		/* A pc (kernel address).	*/
} kernperf_t;

/* the possible record types are as follows.
*/

#define KPT_SYSCALL	0	/* System call - pc determines which	*/
				/* one.					*/
#define KPT_INTR	1	/* An interrupt - pc determines which 	*/
				/* one.					*/
#define KPT_TRAP_RET	2	/* Return from trap to user level	*/

#define KPT_INT_KRET	3	/* Return from interrupt to kernel	*/
				/* level.				*/
#define	KPT_INT_URET	4	/* Return from interrupt to user level	*/

#define	KPT_SLEEP	5	/* Call to "sleep" - pc is caller. The  */
				/* pid is that of the caller		*/
#define	KPT_WAKEUP	6	/* Call of "wakeup" - pc is caller. The	*/
				/* pid is that of process being		*/
				/* awakened.				*/ 
#define	KPT_PSWTCH	7	/* Process switch.  The pid is the new	*/
				/* process about to be run		*/
#define	KPT_SPL		8	/* Change of priority level.  The pc is	*/
				/* that of the caller.  The level is 	*/
				/* the new priority level.		*/
#define	KPT_CSERVE	9	/* Call of a streams service procedure.	*/
				/* the pc tells which one.		*/
#define	KPT_RSERVE	10	/* Return from a streams service 	*/
				/* procedure.  the pc tells which one.	*/
#define KPT_UXMEMF	11	/* memory fault because of paging	*/
				/* or stack exception.			*/
#define KPT_SWTCH	12	/* call to swtch			*/
#define KPT_QSWTCH	13	/* call to qswtch			*/
#define KPT_STKBX	14	/* stack boundary exceptions		*/
#define KPT_END		15	/* end of trace				*/
#define KPT_IDLE	16	/* in scheduler sitting idle		*/
#define KPT_PREEMPT	17	/* hit a preemption point		*/
				/* however preemption did not occur	*/
#define KPT_P_QSWTCH	18	/* reached a preemption point, and will */
				/* Qswtch				*/
#define KPT_LAST	19	/* last record of a proc                */

#define swtch() \
{\
	if (kpftraceflg) {\
		asm(" MOVAW 0(%pc),Kpc"); \
		kperf_write(KPT_SWTCH,Kpc,curproc); \
	} \
	if (kpftraceflg && exitflg) {\
		kperf_write(KPT_LAST,Kpc,curproc); \
		exitflg = 0; \
	} \
	KPswtch(); \
}
extern int kpchildslp;
extern int pre_trace;
extern int kpftraceflg;
extern int takephase;
extern int putphase;
extern int outbuf;
/* extern int out_of_tbuf; */
extern int numrc;
extern int numrccount;
extern int Kpc;
extern int KPF_opsw;
extern kernperf_t kpft[];
extern int exitflg;

#else

extern void swtch();

#endif	/* KPERF */

#endif	/* _SYS_SYSTM_H */
  07070100005a17000081240000000200000002000000012719347c00000d5b000000230000000c00000000000000000000001a00000000usr/include/sys/t_kuser.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef	_T_KUSER_H
#define	_T_KUSER_H

#ident	"@(#)/usr/include/sys/t_kuser.h.sl 1.1 4.0 10/15/90 40480 AT&T-SF"

/*	@(#)t_kuser.h 1.1 88/12/12 SMI	*/

/*
 *  		PROPRIETARY NOTICE (Combined)
 *  
 *  This source code is unpublished proprietary information
 *  constituting, or derived under license from AT&T's Unix(r) System V.
 *  In addition, portions of such source code were derived from Berkeley
 *  4.3 BSD under license from the Regents of the University of
 *  California.
 *  
 *  
 *  
 *  		Copyright Notice 
 *  
 *  Notice of copyright on this source code product does not indicate 
 *  publication.
 *  
 *  	(c) 1986,1987,1988,1989  Sun Microsystems, Inc.
 *  	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 *  	          All rights reserved.
 */

/* Note this structure will need to be expanded to handle data
 * related to connection orientated transports. 
 */
typedef struct tiuser {
	struct	file *fp;
	struct	t_info tp_info;	/* Transport provider Info. */
	int	flags;
} TIUSER;
#define		TIUSERSZ	sizeof(TIUSER)

struct knetbuf {
	mblk_t   *udata_mp;	/* current receive streams block */
	unsigned int maxlen;
	unsigned int len;
	char     *buf;
};

struct t_kunitdata {
	struct netbuf addr;
	struct netbuf opt;
	struct knetbuf udata;
};

#ifdef DEBUG
extern int	ktli_log();
extern int	ktlilog;

#define		KTLILOG(A, B, C) ((void)((ktlilog) && ktli_log((A), (B), (C))))
#else
#define		KTLILOG(A, B, C)
#endif

/* flags
 */
#define		TIME_UP		0x01

extern int	t_kalloc();
extern int	t_kbind();
extern int	t_kclose();
extern int	t_kconnect();
extern int	t_kfree();
extern int	t_kgetstate();
extern int	t_kopen();
extern int	t_krcvudata();
extern int	t_ksndudata();
extern int	t_kspoll();
extern int	t_kunbind();
extern int	tli_send();
extern int	tli_recv();
extern int	get_ok_ack();

/* these make life a lot easier
 */
#define		TCONNREQSZ	sizeof(struct T_conn_req)
#define		TCONNRESSZ	sizeof(struct T_conn_res)
#define		TDISCONREQSZ	sizeof(struct T_discon_req)
#define		TDATAREQSZ	sizeof(struct T_data_req)
#define		TEXDATAREQSZ	sizeof(struct T_exdata_req)
#define		TINFOREQSZ	sizeof(struct T_info_req)
#define		TBINDREQSZ	sizeof(struct T_bind_req)
#define		TUNBINDREQSZ	sizeof(struct T_unbind_req)
#define		TUNITDATAREQSZ	sizeof(struct T_unitdata_req)
#define		TOPTMGMTREQSZ	sizeof(struct T_optmgmt_req)
#define		TORDRELREQSZ	sizeof(struct T_ordrel_req)
#define		TCONNINDSZ	sizeof(struct T_conn_ind)
#define		TCONNCONSZ	sizeof(struct T_conn_con)
#define		TDISCONINDSZ	sizeof(struct T_discon_ind)
#define		TDATAINDSZ	sizeof(struct T_data_ind)
#define		TEXDATAINDSZ	sizeof(struct T_exdata_ind)
#define		TINFOACKSZ	sizeof(struct T_info_ack)
#define		TBINDACKSZ	sizeof(struct T_bind_ack)
#define		TERRORACKSZ	sizeof(struct T_error_ack)
#define		TOKACKSZ	sizeof(struct T_ok_ack)
#define		TUNITDATAINDSZ	sizeof(struct T_unitdata_ind)
#define		TUDERRORINDSZ	sizeof(struct T_uderror_ind)
#define		TOPTMGMTACKSZ	sizeof(struct T_optmgmt_ack)
#define		TORDRELINDSZ	sizeof(struct T_ordrel_ind)
#define		TPRIMITIVES	sizeof(struct T_primitives)

/******************************************************************************/

#endif	/* _T_KUSER_ */
 07070100005a18000081240000000200000002000000012719347c0000081a000000230000000c00000000000000000000001700000000usr/include/sys/tape.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TAPE_H
#define _SYS_TAPE_H

/*	Copyright (c) 1986, 1987  Intel Corporation	*/
/*	All Rights Reserved	*/

#ident	"@(#)/usr/include/sys/tape.h.sl 1.1 4.0 10/15/90 25613 AT&T-SF"

/* 
 * Standard Tape ioctl commands.  
 */

#define T_BASE		('t' << 8)
#define T_RETENSION	(T_BASE | 001) 	/* Retension Tape */
#define T_RWD		(T_BASE | 002)	/* Rewind Tape */
#define T_ERASE		(T_BASE | 003)	/* Erase Tape */
#define T_WRFILEM	(T_BASE | 004)	/* Write Filemark */
#define T_RST		(T_BASE | 005)
#define T_RDSTAT	(T_BASE | 006)
#define T_SFF		(T_BASE | 007)	/* Space Filemark Forward */
#define T_SBF		(T_BASE | 010)	/* Space Block Forward */
#define T_LOAD		(T_BASE | 011)	/* Load Tape */
#define T_UNLOAD	(T_BASE | 012)	/* Unload Tape */
#define T_SFREC		(T_BASE | 013)	/* For Kennedy Drives, now not supported
									 * according to INTEL
									 */
#define T_SBREC 	(T_BASE | 014)	/* For Kennedy Drives, now not supported
									 * according to INTEL
									 */
#define T_TINIT 	(T_BASE | 015)

/*
 *	9 track support ioctls -- 
*/

#define	T_RDBLKLEN	(T_BASE | 016)	/* Read block size		*/
#define	T_WRBLKLEN	(T_BASE | 017)	/* Set block size		*/
#define	T_PREVMV	(T_BASE | 020)	/* Prevent media removal	*/
#define	T_ALLOMV	(T_BASE | 021)	/* Allow media removal		*/

/*
 * Additional tape ioctls.
 * NOTE: these are NOT supported byt the AT&T Wangtek tape driver,
 * but are included here for compatibility with other manufacturers'
 * products.
 */

#define	T_SBB	(T_BASE | 022)	/* Space Block Backwards */
#define	T_SFB	(T_BASE | 023)	/* Space Filemark Backwards */
#define	T_EOD	(T_BASE | 024)	/* Space to End Of Data */
#define	T_SSFB	(T_BASE | 025)	/* Space Sequential Filemarks Backwards */
#define	T_SFFF	(T_BASE | 026)	/* Space Sequential Filemarks Forwards */

#endif	/* _SYS_TAPE_H */
  07070100005a19000081240000000200000002000000012719347c000008a8000000230000000c00000000000000000000001900000000usr/include/sys/termio.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ifndef _SYS_TERMIO_H
#define _SYS_TERMIO_H

#ident	"@(#)/usr/include/sys/termio.h.sl 1.1 4.0 10/15/90 60622 AT&T-SF"

#include <sys/termios.h>


/* all the ioctl codes and flags are now in termios.h */

/*
 * Ioctl control packet
 */
struct termio {
	unsigned short	c_iflag;	/* input modes */
	unsigned short	c_oflag;	/* output modes */
	unsigned short	c_cflag;	/* control modes */
	unsigned short	c_lflag;	/* line discipline modes */
	char	c_line;		/* line discipline */
	unsigned char	c_cc[NCC];	/* control chars */
};

#define	IOCTYPE	0xff00


/*
 * structure of ioctl arg for LDGETT and LDSETT
 */
struct	termcb	{
	char	st_flgs;	/* term flags */
	char	st_termt;	/* term type */
	char	st_crow;	/* gtty only - current row */
	char	st_ccol;	/* gtty only - current col */
	char	st_vrow;	/* variable row */
	char	st_lrow;	/* last row */
};

#ifndef u3b15
#define	SSPEED	7	/* default speed: 300 baud */
#else
#define SSPEED	9	/* default speed: 1200 baud */
#endif

#ifdef u3b15
#define TTYTYPE (TIOC|8)
#endif
#define	TCDSET	(TIOC|32)

/*
 * Terminal types
 */
#define	TERM_NONE	0	/* tty */
#define	TERM_TEC	1	/* TEC Scope */
#define	TERM_V61	2	/* DEC VT61 */
#define	TERM_V10	3	/* DEC VT100 */
#define	TERM_TEX	4	/* Tektronix 4023 */
#define	TERM_D40	5	/* TTY Mod 40/1 */
#define	TERM_H45	6	/* Hewlitt-Packard 45 */
#define	TERM_D42	7	/* TTY Mod 40/2B */

/*
 * Terminal flags
 */
#define TM_NONE		0000	/* use default flags */
#define TM_SNL		0001	/* special newline flag */
#define TM_ANL		0002	/* auto newline on column 80 */
#define TM_LCF		0004	/* last col of last row special */
#define TM_CECHO	0010	/* echo terminal cursor control */
#define TM_CINVIS	0020	/* do not send esc seq to user */
#define TM_SET		0200	/* must be on to set/res flags */

/*
 * structure of ioctl arg for AIOCSETSS (defined is asy.h)
 */

struct	termss {
	char	ss_start; 	/* output start char */
	char 	ss_stop;	/* output stop char */
};


#endif	/* _SYS_TERMIO_H */
07070100005a1a000081240000000200000002000000012719347c00003232000000230000000c00000000000000000000001a00000000usr/include/sys/termios.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


/*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ifndef _SYS_TERMIOS_H
#define _SYS_TERMIOS_H

#ident	"@(#)/usr/include/sys/termios.h.sl 1.1 4.0 10/15/90 48566 AT&T-SF"

#if !defined(_POSIX_SOURCE) 
#include <sys/ttydev.h>
#endif /* !defined(_POSIX_SOURCE) */ 

#include <sys/types.h>

#ifndef _POSIX_VDISABLE
#define _POSIX_VDISABLE 0 /* Disable special character functions */
#endif

#if !defined(_POSIX_SOURCE) 
#define	CTRL(c)	((c)&037)
#define IBSHIFT 16

/* required by termio.h and VCEOF/VCEOL */
#define	NCC	8
#endif /* !defined(_POSIX_SOURCE) */ 

/* some defines required by POSIX */
#define	NCCS	19

/*
 * types defined by POSIX. These are better off in types.h, but 
 * the standard says that they have to be in termios.h.
 */
typedef unsigned long tcflag_t;
typedef unsigned char cc_t;
typedef unsigned long speed_t;

/*
 * Ioctl control packet
 */
struct termios {
	tcflag_t	c_iflag;	/* input modes */
	tcflag_t	c_oflag;	/* output modes */
	tcflag_t	c_cflag;	/* control modes */
	tcflag_t	c_lflag;	/* line discipline modes */
	cc_t		c_cc[NCCS];	/* control chars */
};

/* 
 * POSIX termios functions
 * These functions get mapped into ioctls.
 */

#ifndef _KERNEL

#if defined(__STDC__)

extern speed_t cfgetospeed (const struct termios *);
extern int cfsetospeed (struct termios *, speed_t);
extern speed_t cfgetispeed (const struct termios *);
extern int cfsetispeed (struct termios *, speed_t);
extern int tcgetattr (int, struct termios *);
extern int tcsetattr (int, int, const struct termios *);
extern int tcsendbreak (int, int);
extern int tcdrain (int);
extern int tcflush (int, int);
extern int tcflow (int, int);

#else

extern speed_t cfgetospeed ();
extern int cfsetospeed ();
extern speed_t cfgetispeed ();
extern int cfsetispeed ();
extern int tcgetattr ();
extern int tcsetattr ();
extern int tcsendbreak ();
extern int tcdrain ();
extern int tcflush ();
extern int tcflow ();

#endif /* __STDC__ */

#if !defined(_POSIX_SOURCE) 

#if defined(__STDC__)
extern pid_t tcgetsid (int);
#else
extern pid_t tcgetsid ();
#endif /* __STDC__ */

#endif /* !defined(_POSIX_SOURCE) */ 

#endif

/* control characters */
#define	VINTR	0
#define	VQUIT	1
#define	VERASE	2
#define	VKILL	3
#define	VEOF	4
#define	VEOL	5
#if !defined(_POSIX_SOURCE) 
#define	VEOL2	6
#endif /* !defined(_POSIX_SOURCE) */ 
#define	VMIN	4
#define	VTIME	5
#if !defined(_POSIX_SOURCE) 
#define	VSWTCH	7
#endif /* !defined(_POSIX_SOURCE) */ 
#define	VSTART		8
#define	VSTOP		9
#define	VSUSP		10
#if !defined(_POSIX_SOURCE) 
#define	VDSUSP		11
#define	VREPRINT	12
#define	VDISCARD	13
#define	VWERASE		14
#define	VLNEXT		15
/* 16 thru 19 reserved for future use */

/*
 * control characters form Xenix termio.h
 */
#define	VCEOF	NCC		/* RESERVED true EOF char (V7 compatability) */
#define	VCEOL	(NCC + 1)	/* RESERVED true EOL char */

#define	CNUL	0
#define	CDEL	0377

/* S5 default control chars */
#define	CESC	'\\'
#define	CINTR	0177	/* DEL */
#define	CQUIT	034	/* FS, cntl | */
#define	CERASE	'#'
#define	CKILL	'@'
#define CEOT	04
#define CEOL	0
#define CEOL2	0
#define	CEOF	04	/* cntl d */
#define	CSTART	021	/* cntl q */
#define	CSTOP	023	/* cntl s */
#define	CSWTCH	032	/* cntl z */
#define	CNSWTCH	0
#define	CSUSP	CTRL('z')
#define	CDSUSP	CTRL('y')
#define	CRPRNT	CTRL('r')
#define	CFLUSH	CTRL('o')
#define	CWERASE	CTRL('w')
#define	CLNEXT	CTRL('v')
#endif /* !defined(_POSIX_SOURCE) */ 


/* input modes */
#define	IGNBRK	0000001
#define	BRKINT	0000002
#define	IGNPAR	0000004
#define	PARMRK	0000010
#define	INPCK	0000020
#define	ISTRIP	0000040
#define	INLCR	0000100
#define	IGNCR	0000200
#define	ICRNL	0000400
#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	IUCLC	0001000
#endif /* !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) */ 
#define	IXON	0002000
#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	IXANY	0004000
#endif /* !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) */ 
#define	IXOFF	0010000
#if !defined(_POSIX_SOURCE) 
#define IMAXBEL 0020000
#define DOSMODE	0100000  /* for 386 compatibility */
#endif /* !defined(_POSIX_SOURCE) */ 

/* output modes */
#define	OPOST	0000001
#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	OLCUC	0000002
#define	ONLCR	0000004
#define	OCRNL	0000010
#define	ONOCR	0000020
#define	ONLRET	0000040
#define	OFILL	0000100
#define	OFDEL	0000200
#define	NLDLY	0000400
#define	NL0	0
#define	NL1	0000400
#define	CRDLY	0003000
#define	CR0	0
#define	CR1	0001000
#define	CR2	0002000
#define	CR3	0003000
#define	TABDLY	0014000
#define	TAB0	0
#define	TAB1	0004000
#define	TAB2	0010000
#define	TAB3	0014000
#endif /* !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) */ 
#if !defined(_POSIX_SOURCE) 
#define XTABS	0014000
#endif /* !defined(_POSIX_SOURCE) */ 
#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	BSDLY	0020000
#define	BS0	0
#define	BS1	0020000
#define	VTDLY	0040000
#define	VT0	0
#define	VT1	0040000
#define	FFDLY	0100000
#define	FF0	0
#define	FF1	0100000
#endif /* !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) */ 
#if !defined(_POSIX_SOURCE) 
#define PAGEOUT 0200000
#define WRAP	0400000

/* control modes */
#define	CBAUD	0000017
#endif /* !defined(_POSIX_SOURCE) */ 
#define	CSIZE	0000060
#define	CS5	0
#define	CS6	0000020
#define	CS7	0000040
#define	CS8	0000060
#define	CSTOPB	0000100
#define	CREAD	0000200
#define	PARENB	0000400
#define	PARODD	0001000
#define	HUPCL	0002000
#define	CLOCAL	0004000
#if !defined(_POSIX_SOURCE) 
#define RCV1EN	0010000
#define	XMT1EN	0020000
#define	LOBLK	0040000
#define	XCLUDE	0100000		/* *V7* exclusive use coming fron XENIX */
#define CIBAUD	03600000
#define PAREXT	04000000
#endif /* !defined(_POSIX_SOURCE) */ 

/* line discipline 0 modes */
#define	ISIG	0000001
#define	ICANON	0000002
#if !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) 
#define	XCASE	0000004
#endif /* !defined(_POSIX_SOURCE) || defined(_XOPEN_SOURCE) */ 
#define	ECHO	0000010
#define	ECHOE	0000020
#define	ECHOK	0000040
#define	ECHONL	0000100
#define	NOFLSH	0000200
#define	TOSTOP	0000400
#if !defined(_POSIX_SOURCE) 
#define	ECHOCTL	0001000
#define	ECHOPRT	0002000
#define	ECHOKE	0004000
#define	DEFECHO	0010000
#define	FLUSHO	0020000
#define	PENDIN	0040000
#endif /* !defined(_POSIX_SOURCE) */ 
#define	IEXTEN	0100000  /* POSIX flag - enable POSIX extensions */

#if !defined(_POSIX_SOURCE) 
#define	TIOC	('T'<<8)

#define	TCGETA	(TIOC|1)
#define	TCSETA	(TIOC|2)
#define	TCSETAW	(TIOC|3)
#define	TCSETAF	(TIOC|4)
#define	TCSBRK	(TIOC|5)
#define	TCXONC	(TIOC|6)
#define	TCFLSH	(TIOC|7)

/* Slots reserved for 386/XENIX compatibility - keyboard control */

#ifndef _KB_386 /* These are also defined in kd.h   */
#define _KB_386
#define TIOCKBON	(TIOC|8)
#define TIOCKBOF 	(TIOC|9)
#define KBENABLED 	(TIOC|10)
#endif  /* _KB_386 */

#ifndef IOCTYPE
#define	IOCTYPE	0xff00
#endif

#define	TCDSET	(TIOC|32)
#define	RTS_TOG	(TIOC|33)	/* 386 - "RTS" toggle define 8A1 protocol */


/* MERGE386 scancode input flag bits */
#define KB_RESERVED1    1
#define KB_RESERVED2    2
#define KB_XSCANCODE    4   /* Translate scancode to ascii */
#define KB_ISSCANCODE   8   /* TTY sends scancodes */
/* OBSOLETE MERGE386 DEFINES -- HERE JUST INCASE FILES ACCESS THEM */


#define TIOCGWINSZ (TIOC|104)
#define TIOCSWINSZ (TIOC|103)


/* termios ioctls */

#define TCGETS		(TIOC|13)
#define TCSETS		(TIOC|14)
#endif /* !defined(_POSIX_SOURCE) */ 
#define TCSANOW		(('T'<<8)|14) /* same as TCSETS */
#if !defined(_POSIX_SOURCE) 
#define TCSETSW		(TIOC|15)
#endif /* !defined(_POSIX_SOURCE) */ 
#define TCSADRAIN	(('T'<<8)|15) /* same as TCSETSW */
#if !defined(_POSIX_SOURCE) 
#define	TCSETSF		(TIOC|16)
#endif /* !defined(_POSIX_SOURCE) */ 
#define	TCSAFLUSH	(('T'<<8)|16) /* same as TCSETSF */

/* termios option flags */

#define TCIFLUSH	0  /* flush data received but not read */
#define TCOFLUSH	1  /* flush data written but not transmitted */
#define TCIOFLUSH	2  /* flush both data both input and output queues */	

#define TCOOFF		0  /* suspend output */
#define TCOON		1  /* restart suspended output */
#define TCIOFF		2  /* suspend input */
#define TCION		3  /* restart suspended input */

/* TIOC ioctls for BSD, ptys, job control and modem control */

#if !defined(_POSIX_SOURCE) 
#define	tIOC	('t'<<8)
#endif /* !defined(_POSIX_SOURCE) */ 


/* Slots for 386/XENIX compatibility */
/* BSD includes these ioctls in ttold.h */

#ifndef _SYS_TTOLD_H

#if !defined(_POSIX_SOURCE) 
#define TIOCGETD	(tIOC|0)
#define TIOCSETD	(tIOC|1)
#define TIOCHPCL	(tIOC|2)
#define TIOCGETP	(tIOC|8)
#define TIOCSETP  	(tIOC|9)
#define TIOCSETN	(tIOC|10)
#define TIOCEXCL	(tIOC|13)
#define TIOCNXCL	(tIOC|14)
#define TIOCFLUSH	(tIOC|16)
#define TIOCSETC	(tIOC|17)
#define TIOCGETC	(tIOC|18)
/*
 * BSD ioctls that are not the same as XENIX are included here.
 * There are also some relevant ioctls from SUN/BSD sys/ttycom.h
 * BSD pty ioctls like TIOCPKT are not supported in SVR4.
 */

#define	TIOCLBIS	(tIOC|127)	/* bis local mode bits */
#define	TIOCLBIC	(tIOC|126)	/* bic local mode bits */
#define	TIOCLSET	(tIOC|125)	/* set entire local mode word */
#define	TIOCLGET	(tIOC|124)	/* get local modes */
#define	TIOCSBRK	(tIOC|123)	/* set break bit */
#define	TIOCCBRK	(tIOC|122)	/* clear break bit */
#define	TIOCSDTR	(tIOC|121)	/* set data terminal ready */
#define	TIOCCDTR	(tIOC|120)	/* clear data terminal ready */
#define	TIOCSLTC	(tIOC|117)	/* set local special chars */
#define	TIOCGLTC	(tIOC|116)	/* get local special chars */
#define	TIOCOUTQ	(tIOC|115)	/* driver output queue size */
#define	TIOCNOTTY	(tIOC|113)	/* void tty association */
#define	TIOCSTOP	(tIOC|111)	/* stop output, like ^S */
#define	TIOCSTART	(tIOC|110)	/* start output, like ^Q */
#endif /* !defined(_POSIX_SOURCE) */ 

#endif /* end _SYS_TTOLD_H */

/* POSIX job control ioctls */

#if !defined(_POSIX_SOURCE) 
#define	TIOCGPGRP	(tIOC|20)	/* get pgrp of tty */
#define	TIOCSPGRP	(tIOC|21)	/* set pgrp of tty */
#define	TIOCGSID	(tIOC|22)	/* get session id on ctty*/
#define	TIOCSSID	(tIOC|24)	/* set session id on ctty*/

/* Miscellanous */
#define	TIOCSTI		(tIOC|23)	/* simulate terminal input */

/* Modem control */
#define	TIOCMSET	(tIOC|26)	/* set all modem bits */
#define	TIOCMBIS	(tIOC|27)	/* bis modem bits */
#define	TIOCMBIC	(tIOC|28)	/* bic modem bits */
#define	TIOCMGET	(tIOC|29)	/* get all modem bits */
#define		TIOCM_LE	0001		/* line enable */
#define		TIOCM_DTR	0002		/* data terminal ready */
#define		TIOCM_RTS	0004		/* request to send */
#define		TIOCM_ST	0010		/* secondary transmit */
#define		TIOCM_SR	0020		/* secondary receive */
#define		TIOCM_CTS	0040		/* clear to send */
#define		TIOCM_CAR	0100		/* carrier detect */
#define		TIOCM_CD	TIOCM_CAR
#define		TIOCM_RNG	0200		/* ring */
#define		TIOCM_RI	TIOCM_RNG
#define		TIOCM_DSR	0400		/* data set ready */

/* pseudo-tty */

#define	TIOCREMOTE	(tIOC|30)	/* remote input editing */
#define TIOCSIGNAL	(tIOC|31)	/* pty: send signal to slave */


/* Some more 386 xenix stuff */

#define	LDIOC	('D'<<8)

#define	LDOPEN	(LDIOC|0)
#define	LDCLOSE	(LDIOC|1)
#define	LDCHG	(LDIOC|2)
#define	LDGETT	(LDIOC|8)
#define	LDSETT	(LDIOC|9)

/* Slots for 386 compatibility */

#define	LDSMAP		(LDIOC|10)
#define	LDGMAP		(LDIOC|11)
#define	LDNMAP		(LDIOC|12)

/*
 * These are retained for 386/XENIX compatibility.
 */

#define	DIOC	('d'<<8)
#define DIOCGETP        (DIOC|8)                /* V7 */
#define DIOCSETP        (DIOC|9)                /* V7 */

/*
 * Returns a non-zero value if there
 * are characters in the input queue.
 */
#define FIORDCHK        (('f'<<8)|3)            /* V7 */
#endif /* !defined(_POSIX_SOURCE) */ 

/*
 * Speeds
 */
#define B0	0
#define B50	1
#define B75	2
#define B110	3
#define B134	4
#define B150	5
#define B200	6
#define B300	7
#define B600	8
#define B1200	9
#define	B1800	10
#define B2400	11
#define B4800	12
#define B9600	13
#define B19200	14
#define B38400	15

#ifndef _SYS_TTOLD_H
#ifndef _SYS_PTEM_H

#if !defined(_POSIX_SOURCE) 
/* Windowing structure to support JWINSIZE/TIOCSWINSZ/TIOCGWINSZ */
struct winsize {
	unsigned short ws_row;       /* rows, in characters*/
	unsigned short ws_col;       /* columns, in character */
	unsigned short ws_xpixel;    /* horizontal size, pixels */
	unsigned short ws_ypixel;    /* vertical size, pixels */
};
#endif /* !defined(_POSIX_SOURCE) */ 

#endif /* end _SYS_PTEM_H */
#endif /* end _SYS_TTOLD_H */

#endif	/* _SYS_TERMIOS_H */
  07070100005a1b000081240000000200000002000000012719347c00001129000000230000000c00000000000000000000001a00000000usr/include/sys/termiox.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef	_SYS_TERMIOX_H
#define	_SYS_TERMIOX_H

#ident	"@(#)/usr/include/sys/termiox.h.sl 1.1 4.0 10/15/90 61276 AT&T-SF"

/* This structure provides an extended terminal interface. */
/* Features of this interface are optional and may not be */
/* implemented on all machines. */


#define NFF	5

/* hardware flow control modes */

#define RTSXOFF  0000001 /* Enable RTS hardware flow control on input */
#define CTSXON   0000002 /* Enable CTS hardware flow control on output */
#define DTRXOFF  0000004 /* Enable DTR hardware flow control on input */
#define CDXON    0000010 /* Enable CD hardware flow control on output */
#define ISXOFF   0000020 /* Enable isochronous hardware flow control on input */
          
/* clock modes */

#define XMTCLK    0000007 /* Transmit Clock Source: */
#define XCIBRG    0000000 /* Get transmit clock from */
                          /* internal baud rate generator */
#define XCTSET    0000001 /* Get transmit clock from */
                          /* transmitter signal element */
                          /* timing (DCE source) lead, */
                          /* CCITT V.24 circuit 114, */
                          /* EIA-232-D pin 15 */
#define XCRSET    0000002 /* Get transmit clock from */
                          /* receiver signal element */
                          /* timing (DCE source) lead, */
                          /* CCITT V.24 circuit 115, */
                          /* EIA-232-D pin 17 */

#define RCVCLK    0000070 /* Receive Clock Source: */
#define RCIBRG    0000000 /* get receive clock from internal */
                          /* baud rate generator */
#define RCTSET    0000010 /* Get receive clock from */
                          /* transmitter signal element */
                          /* timing (DCE source) lead, */
                          /* CCITT V.24 circuit 114, */
                          /* EIA-232-D pin 15 */
#define RCRSET    0000020 /* Get receive clock from */
                          /* receiver signal element */
                          /* timing (DCE source) lead, */
                          /* CCITT V.24 circuit 115, */
                          /* EIA-232-D pin 17 */

#define TSETCLK   0000700 /* Transmitter Signal Element */
                          /* timing (DTE source) lead, */
                          /* CCITT V.24 circuit 113, */
                          /* EIA-232-D pin 24, clock source: */
#define TSETCOFF  0000000 /* TSET clock not provided */
#define TSETCRBRG 0000100 /* Output receive baud rate generator */
                          /* on circuit 113 */
#define TSETCTBRG 0000200 /* Output transmit baud rate generator */
                          /* on circuit 113 */
#define TSETCTSET 0000300 /* Output transmitter signal element */
                          /* timing (DCE source) on circuit 113 */
#define TSETCRSET 0000400 /* Output receiver signal element */
                          /* timing (DCE source) on circuit 113 */

#define RSETCLK   0007000 /* Receiver Signal Element */
                          /* timing (DTE source) lead, */
                          /* CCITT V.24 circuit 128, */
                          /* no EIA-232-D pin, clock source: */
#define RSETCOFF  0000000 /* RSET clock not provided */
#define RSETCRBRG 0001000 /* Output receive baud rate generator */
                          /* on circuit 128 */
#define RSETCTBRG 0002000 /* Output transmit baud rate generator */
                          /* on circuit 128 */
#define RSETCTSET 0003000 /* Output transmitter signal element */
                          /* timing (DCE source) on circuit 128 */
#define RSETCRSET 0004000 /* Output receiver signal element */
                          /* timing (DCE source) on circuit 128 */


struct termiox {
	unsigned short x_hflag;		/* hardware flow control modes */
	unsigned short x_cflag;		/* clock modes */
	unsigned short x_rflag[NFF];	/* reserved modes*/
	unsigned short x_sflag;		/* spare modes */
};

#define XIOC    ('X'<<8)
#define TCGETX  (XIOC|1)
#define TCSETX  (XIOC|2)
#define TCSETXW (XIOC|3)
#define TCSETXF (XIOC|4)

#endif	/* _SYS_TERMIOX_H */
   07070100005a1c000081240000000200000002000000012719347c00001df9000000230000000c00000000000000000000001900000000usr/include/sys/ticlts.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ticlts.h.sl 1.1 4.0 10/15/90 57745 AT&T-SF"
/*
 *	ticlts provider-dependent info
 *	(provider-independent applications must not include this header file)
 */

/*
 *	unitdata error codes (see t_rcvuderr())
 */
#define TCL_BADADDR		1		/* bad addr specification */
#define TCL_BADOPT		2		/* bad option specification */
#define TCL_NOPEER		3		/* dest addr is unbound */
#define TCL_PEERBADSTATE	4		/* peer in wrong state */

/*
 *	options (flattened linked-list of flattened C-structures)
 */
#define TCL_OPT_NOHDR		0		/* invalid nexthdr offset (end of list) */

#define TCL_OPT_NOOP		1		/* no-op opt -- default */
#define TCL_OPT_SETID		2		/* set ident */
#define TCL_OPT_GETID		3		/* get ident */
#define TCL_OPT_UID		4		/* uid info */
#define TCL_OPT_GID		5		/* gid info */
#define TCL_OPT_RUID		6		/* ruid info */
#define TCL_OPT_RGID		7		/* rgid info */

#define TCL_IDFLG_UID		0x1		/* uid flag */
#define TCL_IDFLG_GID		0x2		/* gid flag */
#define TCL_IDFLG_RUID		0x4		/* ruid flag */
#define TCL_IDFLG_RGID		0x8		/* rgid flag */

/* header for maintaining list of opts; one for each opt in list;
   offsets are measured from beginning of options buffer;
   headers must occur in increasing order, to avoid loops */
struct tcl_opt_hdr {
	long			hdr_thisopt_off;	/* offset to current opt */
	long			hdr_nexthdr_off;	/* offset to next hdr */
};

/* no-op opt -- the default */
struct tcl_opt_noop {
	long			noop_type;	/* TCL_OPT_NOOP; must be first */
};

/* set ident opt -- subsequent t_rcvudata()'s
   (i.e., T_UNITDATA_IND) will contain peer's ident info */
struct tcl_opt_setid {
	long			setid_type;	/* TCL_OPT_SETID; must be first */
	long			setid_flg;	/* which id opts to set */
};

/* get ident opt */
struct tcl_opt_getid {
	long			getid_type;	/* TCL_OPT_GETID; must be first */
	long			getid_flg;	/* which id opts are set */
};

/* uid info opt */
struct tcl_opt_uid {
	long			uid_type;	/* TCL_OPT_UID; must be first */
	uid_t			uid_val;	/* effective user id */
};

/* gid info opt */
struct tcl_opt_gid {
	long			gid_type;	/* TCL_OPT_GID; must be first */
	gid_t			gid_val;	/* effective group id */
};

/* ruid info opt */
struct tcl_opt_ruid {
	long			ruid_type;	/* TCL_OPT_RUID; must be first */
	uid_t			ruid_val;	/* real user id */
};

/* rgid info opt */
struct tcl_opt_rgid {
	long			rgid_type;	/* TCL_OPT_RGID; must be first */
	gid_t			rgid_val;	/* real group id */
};

/* union of all the opts */
union tcl_opt {
	long			opt_type;	/* opt type; must be first */
	struct tcl_opt_noop	opt_noop;	/* noop opt */
	struct tcl_opt_setid	opt_setid;	/* set ident opt */
	struct tcl_opt_getid	opt_getid;	/* get ident opt */
	struct tcl_opt_uid	opt_uid;	/* uid info opt */
	struct tcl_opt_gid	opt_gid;	/* gid info opt */
	struct tcl_opt_ruid	opt_ruid;	/* ruid info opt */
	struct tcl_opt_rgid	opt_rgid;	/* rgid info opt */
};

/******************************************************************************/

#ifdef _KERNEL

/*
 *	transport endpoint structure
 */
struct tcl_endpt {
	struct tcl_endpt	*te_folist;	/* forw ptr, list of open endpts */
	struct tcl_endpt	*te_bolist;	/* back ptr, list of open endpts */
	queue_t			*te_rq;		/* stream read queue */
	queue_t			*te_backwq;	/* back q on WR side for flow cntl */
	struct tcl_addr		*te_addr;	/* address bound to this endpt */
	minor_t			te_min;		/* minor number */
	char			te_state;	/* state of interface */
	char			te_flg;		/* internal flags */
	long			te_idflg;	/* ident flags */
	uid_t			te_uid;		/* uid */
	gid_t			te_gid;		/* gid */
	uid_t			te_ruid;	/* ruid */
	gid_t			te_rgid;	/* rgid */
};
typedef struct tcl_endpt	tcl_endpt_t;

/*
 *	transport addr structure
 */
struct tcl_addr {
	struct tcl_addr		*ta_falist;	/* forw ptr, list of bound addrs */
	struct tcl_addr		*ta_balist;	/* back ptr, list of bound addrs */
	struct tcl_endpt	*ta_blist;	/* list (<= 1) of endpts bound to this addr */
	unsigned short		ta_ahash;	/* addr hash bucket */
	long			ta_alen;	/* length of abuf */
	char			*ta_abuf;	/* the addr itself */
};
typedef struct tcl_addr		tcl_addr_t;

/* M_CTL types.
 */
#define		TCL_IOCTL	('T'<<8)
#define		TCL_LINK	(TCL_IOCTL|101)
#define		TCL_UNLINK	(TCL_IOCTL|102)

/* Socket link M_CTL structure.
 */
struct tcl_sictl {
	long	type;
	long	ADDR_offset;
	long	ADDR_len;
};

/*
 *	registered id
 */
#define TCL_ID			10001

/*
 *	macro to change state
 *	NEXTSTATE(event, current state)
 */
#define NEXTSTATE(X,Y)		ti_statetbl[X][Y]	/* should be standardized */
#define NR 			127	/* unreachable state */	/* should be standardized */

/*
 *	basic constants
 */
#define TCL_NENDPT		(OMAXMIN+1)
#define TCL_SERVTYPE		T_CLTS
#define TCL_TIDUSZ		(4*1024)		/* max packet size */
#define TCL_DEFAULTADDRSZ	4			/* default addr sz */
/* can't make the following 2 sizes -1 (unlimited), because of bug in TLI/TPI specs:
   unlimited data can be sent but cannot received in a well-specified way
   (receiver doesn't know how big to make buffer, and T_MORE flag can't be used) */
#define TCL_ADDRSZ		(256-24)		/* 24 = sizeof(struct T_bind_req) + 8
							      = sizeof(struct T_bind_ack) + 8
							      = sizeof(struct T_unitdata_req) + 4
							      = sizeof(struct T_uderror_ind) */
#define TCL_OPTSZ		(TCL_TIDUSZ-24)		/* 24 = sizeof(struct T_optmgmt_req) + 8
							      = sizeof(struct T_optmgmt_ack) + 8
							      = sizeof(struct T_unitdata_req) + 4
							      = sizeof(struct T_uderror_ind) */
#define TCL_CDATASZ		-2			/* connectionless */
#define TCL_DDATASZ		-2			/* connectionless */
#define TCL_TSDUSZ		TCL_TIDUSZ		/* connectionless */
#define TCL_ETSDUSZ		-2			/* connectionless */
#define TCL_MINPSZ		0
#define TCL_MAXPSZ		TCL_TIDUSZ
#define TCL_LOWAT		(TCL_TIDUSZ/4)
#define TCL_HIWAT		(4*TCL_TIDUSZ)

/*
 *	te_flg
 */
#define TCL_ZOMBIE		0x1			/* fatal error on endpoint */

/*
 *	pass/fail indicators
 */
#define TCL_PASS		0
#define TCL_FAIL		(!TCL_PASS)
#define TCL_REALOPT		0x01			/* for tcl_ckopt() */
#define TCL_NOOPOPT		0x02			/* for tcl_ckopt() */
#define TCL_BADFORMAT		0x04			/* for tcl_ckopt() */
#define TCL_BADTYPE		0x08			/* for tcl_ckopt() */
#define TCL_BADVALUE		0x10			/* for tcl_ckopt() */
#define UNIX_PASS		0			/* should be standardized */
#define UNIX_FAIL		(!UNIX_PASS)		/* should be standardized */

/*
 *	internal defines
 */
#define TCL_BIND		1
#define TCL_DEST		2
#define TCL_OPEN		3
#define TCL_IDFLG_ALL		(TCL_IDFLG_UID | TCL_IDFLG_GID | TCL_IDFLG_RUID | TCL_IDFLG_RGID)
#define TCL_MHASH		5
#define TCL_NMHASH		(1 << TCL_MHASH)	/* num of hash buckets in open endpt table */
#define TCL_MMASK		(TCL_NMHASH - 1)
#define TCL_AHASH		5			/* must be <= NBBY*sizeof(tcl_addr.ta_ahash) */
#define TCL_NAHASH		(1 << TCL_AHASH)	/* num of hash buckets in bound addr table */
#define TCL_AMASK		(TCL_NAHASH - 1)

/*
 *	some useful macros
 */
#define tcl_min(TE)		((TE)->te_min)
#define tcl_mkmhash(TE)		((unsigned)(tcl_min(TE)) & TCL_MMASK)
#define tcl_mhash(TE)		tcl_mkmhash(TE)
#define tcl_alen(TA)		((TA)->ta_alen)
#define tcl_abuf(TA)		((TA)->ta_abuf)
#define tcl_mkahash(TA)		((unsigned)(tcl_sumbytes(tcl_abuf(TA),tcl_alen(TA)) & TCL_AMASK))
#define tcl_ahash(TA)		((unsigned)(TA)->ta_ahash)
#define tcl_eqabuf(TA,TB)	((tcl_alen(TA) == tcl_alen(TB)) \
				 && tcl_bequal(tcl_abuf(TA),tcl_abuf(TB),tcl_alen(TA)))

/*
 *	STRLOG tracing levels:
 *
 *	0 = urgent
 *	1 = fatal
 *	2 = errack, uderr
 *	3 = interesting stuff
 *	4 = chit-chat
 */

#endif /* _KERNEL */
   07070100005a1d000081240000000200000002000000012719347c00002364000000230000000c00000000000000000000001900000000usr/include/sys/ticots.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ticots.h.sl 1.1 4.0 10/15/90 10735 AT&T-SF"
/*
 *	ticots provider-dependent info
 *	(provider-independent applications must not include this header file)
 */

/*
 *	disconnect reason codes	 (see t_rcvdis())
 */
#define TCO_NOPEER	 	ECONNREFUSED	/* no listener on dest addr */
#define TCO_PEERNOROOMONQ	ECONNREFUSED	/* peer has no room on incoming queue */
#define TCO_PEERBADSTATE	ECONNREFUSED	/* peer in wrong state */
#define TCO_PEERINITIATED 	ECONNRESET	/* peer-initiated disconnect */
#define TCO_PROVIDERINITIATED 	ECONNABORTED	/* provider-initiated disconnect */

/*
 *	options (flattened linked-list of flattened C-structures)
 */
#define TCO_OPT_NOHDR		0		/* invalid nexthdr offset (end of list) */

#define TCO_OPT_NOOP		1		/* no-op opt -- default */
#define TCO_OPT_SETID		2		/* set ident */
#define TCO_OPT_GETID		3		/* get ident */
#define TCO_OPT_UID		4		/* uid info */
#define TCO_OPT_GID		5		/* gid info */
#define TCO_OPT_RUID		6		/* ruid info */
#define TCO_OPT_RGID		7		/* rgid info */

#define TCO_IDFLG_UID		0x1		/* uid flag */
#define TCO_IDFLG_GID		0x2		/* gid flag */
#define TCO_IDFLG_RUID		0x4		/* ruid flag */
#define TCO_IDFLG_RGID		0x8		/* rgid flag */

/* header for maintaining list of opts; one for each opt in list;
   offsets are measured from beginning of options buffer;
   headers must occur in increasing order, to avoid loops */
struct tco_opt_hdr {
	long			hdr_thisopt_off;	/* offset to current opt */
	long			hdr_nexthdr_off;	/* offset to next hdr */
};

/* no-op opt -- the default */
struct tco_opt_noop {
	long			noop_type;	/* TCO_OPT_NOOP; must be first */
};

/* set ident opt -- subsequent t_rcvudata()'s
   (i.e., T_UNITDATA_IND) will contain peer's ident info */
struct tco_opt_setid {
	long			setid_type;	/* TCO_OPT_SETID; must be first */
	long			setid_flg;	/* which id opts to set */
};

/* get ident opt */
struct tco_opt_getid {
	long			getid_type;	/* TCO_OPT_GETID; must be first */
	long			getid_flg;	/* which id opts are set */
};

/* uid info opt */
struct tco_opt_uid {
	long			uid_type;	/* TCO_OPT_UID; must be first */
	uid_t			uid_val;	/* effective user id */
};

/* gid info opt */
struct tco_opt_gid {
	long			gid_type;	/* TCO_OPT_GID; must be first */
	gid_t			gid_val;	/* effective group id */
};

/* ruid info opt */
struct tco_opt_ruid {
	long			ruid_type;	/* TCO_OPT_RUID; must be first */
	uid_t			ruid_val;	/* real user id */
};

/* rgid info opt */
struct tco_opt_rgid {
	long			rgid_type;	/* TCO_OPT_RGID; must be first */
	gid_t			rgid_val;	/* real group id */
};

/* union of all the opts */
union tco_opt {
	long			opt_type;	/* opt type; must be first */
	struct tco_opt_noop	opt_noop;	/* noop opt */
	struct tco_opt_setid	opt_setid;	/* set ident opt */
	struct tco_opt_getid	opt_getid;	/* get ident opt */
	struct tco_opt_uid	opt_uid;	/* uid info opt */
	struct tco_opt_gid	opt_gid;	/* gid info opt */
	struct tco_opt_ruid	opt_ruid;	/* ruid info opt */
	struct tco_opt_rgid	opt_rgid;	/* rgid info opt */
};

/******************************************************************************/

#ifdef _KERNEL

/*
 *	transport endpoint structure
 */
struct tco_endpt {
	struct tco_endpt	*te_folist;	/* forw ptr, list of open endpts */
	struct tco_endpt	*te_bolist;	/* back ptr, list of open endpts */
	struct tco_endpt	*te_frqlist;	/* forw ptr, te_rq list */
	struct tco_endpt	*te_brqlist;	/* back ptr, te_rq list */
	struct tco_endpt	*te_fblist;	/* forw ptr, list of endpts bound to addr */
	struct tco_endpt	*te_bblist;	/* back ptr, list of endpts bound to addr */
	queue_t			*te_rq;		/* stream read queue */
	struct tco_addr		*te_addr;	/* addr bound to this endpt */
	minor_t			te_min;		/* minor number */
	unsigned short		te_rqhash;	/* te_rq hash bucket */
	char 			te_state;	/* state of interface */
	char			te_flg;		/* internal flags */
	long			te_idflg;	/* ident flags */
	unsigned char		te_qlen;	/* max incoming connect reqs pending */
	unsigned char		te_nicon;	/* num of incoming connect reqs pending */
#define TCO_MAXQLEN		8		/* must be <= (1 << (NBBY*sizeof(te_nicon))) */
	struct tco_endpt	*te_icon[TCO_MAXQLEN];	/* incoming connect requests pending */
	struct tco_endpt	*te_ocon;	/* outgoing connect request pending */
	struct tco_endpt	*te_con;	/* connected endpt */
	uid_t			te_uid;		/* uid */
	gid_t			te_gid;		/* gid */
	uid_t			te_ruid;	/* ruid */
	gid_t			te_rgid;	/* rgid */
};
typedef struct tco_endpt	tco_endpt_t;

/*
 *	transport addr structure
 */
struct tco_addr {
	struct tco_addr		*ta_falist;	/* forw ptr, list of bound addrs */
	struct tco_addr		*ta_balist;	/* back ptr, list of bound addrs */
	struct tco_endpt	*ta_hblist;	/* head ptr, list of endpts bound to this addr */
	struct tco_endpt	*ta_tblist;	/* tail ptr, list of endpts bound to this addr */
	unsigned short 		ta_ahash;	/* addr hash bucket */
	long			ta_alen;	/* length of abuf */
	char			*ta_abuf;	/* the addr itself */
};
typedef struct tco_addr		tco_addr_t;

/*
 *	registered id
 */
#ifdef TICOTS
#define TCO_ID			10002
#endif
#ifdef TICOTSORD
#define	TCO_ID			10003
#endif

/*
 *	macro to change state
 *	NEXTSTATE(event,current state)
 */
#define NEXTSTATE(X,Y)		ti_statetbl[X][Y]	/* should be standardized */
#define NR 			127	/* unreachable state */	/* should be standardized */

/*
 *	basic constants
 */
#define TCO_NENDPT		(OMAXMIN+1)
#ifdef TICOTS
#define TCO_SERVTYPE		T_COTS
#endif
#ifdef TICOTSORD
#define TCO_SERVTYPE		T_COTS_ORD
#endif
#define TCO_TIDUSZ		(4*1024)		/* max packet size */
#define TCO_DEFAULTADDRSZ	4			/* default addr sz */
/* can't make the following 4 sizes -1 (unlimited), because of bug in TLI/TPI specs:
   unlimited data can be sent but cannot received in a well-specified way
   (receiver doesn't know how big to make buffer, and T_MORE flag can't be used) */
#define TCO_ADDRSZ		(256-16)		/* 16 = sizeof(struct T_bind_req)
							      = sizeof(struct T_bind_ack) */
#define TCO_OPTSZ		(TCO_TIDUSZ-16)		/* 16 = sizeof(struct T_optmgmt_req)
							      = sizeof(struct T_optmgmt_ack) */
#define TCO_CDATASZ		(TCO_TIDUSZ-24)		/* 24 = sizeof(struct T_conn_req) + 4
							      = sizeof(struct T_conn_ind)
							      = sizeof(struct T_conn_res) + 4
							      = sizeof(struct T_conn_con) + 4 */
#define TCO_DDATASZ		(TCO_TIDUSZ-12)		/* 8 = sizeof(struct T_discon_req) + 4
							     = sizeof(struct T_discon_ind) */
#define TCO_TSDUSZ		-1			/* unlimited */
#define TCO_ETSDUSZ		-1			/* unlimited */
#define TCO_MINPSZ		0
#define TCO_MAXPSZ		TCO_TIDUSZ
#define TCO_LOWAT		(TCO_TIDUSZ/4)
#define TCO_HIWAT		(4*TCO_TIDUSZ)

/*
 *	te_flg
 */
#define TCO_ZOMBIE		0x1			/* fatal error on endpoint */

/*
 *	pass/fail indicators
 */
#define TCO_PASS		0
#define TCO_FAIL		(!TCO_PASS)
#define TCO_REALOPT		0x01			/* for tco_ckopt() */
#define TCO_NOOPOPT		0x02			/* for tco_ckopt() */
#define TCO_BADFORMAT		0x04			/* for tco_ckopt() */
#define TCO_BADTYPE		0x08			/* for tco_ckopt() */
#define TCO_BADVALUE		0x10			/* for tco_ckopt() */
#define UNIX_PASS		0			/* should be standardized */
#define UNIX_FAIL		(!UNIX_PASS)		/* should be standardized */
#define BADSEQNUM		((long)(-1))		/* should be standardized */

/*
 *	internal defines
 */
#define TCO_BIND		1
#define TCO_CONN		2
#define TCO_OPEN		3
#define TCO_RQ			4
#define TCO_IDFLG_ALL		(TCO_IDFLG_UID | TCO_IDFLG_GID | TCO_IDFLG_RUID | TCO_IDFLG_RGID)
#define TCO_MHASH		5
#define TCO_NMHASH		(1 << TCO_MHASH)	/* num of hash buckets in open endpt table */
#define TCO_MMASK		(TCO_NMHASH - 1)
#define TCO_RQHASH		5			/* must be <= NBBY*sizeof(te_rqhash) */
#define TCO_NRQHASH		(1 << TCO_RQHASH)	/* num of hash buckets in te_rq table */
#define TCO_RQMASK		(TCO_NRQHASH - 1)
/* following magic number and shift factor for fibonacci hash function */
#define TCO_RQMAGIC		0x9ce14b36
#define TCO_RQSHIFT		(NBBY*sizeof(int) - TCO_RQHASH)
#define TCO_AHASH		5			/* must be <= NBBY*sizeof(ta_ahash) */
#define TCO_NAHASH		(1 << TCO_AHASH)	/* num of hash buckets in bound addr table */
#define TCO_AMASK		(TCO_NAHASH - 1)

/*
 *	some useful macros
 */
#define tco_min(TE)		((TE)->te_min)
#define tco_mkmhash(TE)		((unsigned)(tco_min(TE)) & TCO_MMASK)
#define tco_mhash(TE)		tco_mkmhash(TE)
#define tco_mkrqhash(TE)	(((((unsigned)((TE)->te_rq))*TCO_RQMAGIC) >> TCO_RQSHIFT) & TCO_RQMASK)
#define tco_rqhash(TE)		((unsigned)(TE)->te_rqhash)
#define tco_alen(TA)		((TA)->ta_alen)
#define tco_abuf(TA)		((TA)->ta_abuf)
#define tco_ahash(TA)		((unsigned)(TA)->ta_ahash)
#define tco_mkahash(TA)		((unsigned)(tco_sumbytes(tco_abuf(TA),tco_alen(TA)) & TCO_AMASK))
#define tco_eqabuf(TA,TB)	((tco_alen(TA) == tco_alen(TB)) \
				 && tco_bequal(tco_abuf(TA),tco_abuf(TB),tco_alen(TA)))

/*
 *	STRLOG tracing levels:
 *
 *	0 = urgent
 *	1 = fatal
 *	2 = errack
 *	3 = interesting stuff
 *	4 = chit-chat
 */

#endif /* _KERNEL */
07070100005a1e000081240000000200000002000000012719347c000023d3000000230000000c00000000000000000000001c00000000usr/include/sys/ticotsord.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ticotsord.h.sl 1.1 4.0 10/15/90 47516 AT&T-SF"
/*
 *	ticotsord provider-dependent info
 *	(provider-independent applications must not include this header file)
 */

/*
 *	disconnect reason codes	 (see t_rcvdis())
 */
#define TCOO_NOPEER	 	1		/* no listener on dest addr */
#define TCOO_PEERNOROOMONQ	2		/* peer has no room on incoming queue */
#define TCOO_PEERBADSTATE	3		/* peer in wrong state */
#define TCOO_PEERINITIATED 	4		/* peer-initiated disconnect */
#define TCOO_PROVIDERINITIATED 	5		/* provider-initiated disconnect */

/*
 *	options (flattened linked-list of flattened C-structures)
 */
#define TCOO_OPT_NOHDR		0		/* invalid nexthdr offset (end of list) */

#define TCOO_OPT_NOOP		1		/* no-op opt -- default */
#define TCOO_OPT_SETID		2		/* set ident */
#define TCOO_OPT_GETID		3		/* get ident */
#define TCOO_OPT_UID		4		/* uid info */
#define TCOO_OPT_GID		5		/* gid info */
#define TCOO_OPT_RUID		6		/* ruid info */
#define TCOO_OPT_RGID		7		/* rgid info */

#define TCOO_IDFLG_UID		0x1		/* uid flag */
#define TCOO_IDFLG_GID		0x2		/* gid flag */
#define TCOO_IDFLG_RUID		0x4		/* ruid flag */
#define TCOO_IDFLG_RGID		0x8		/* rgid flag */

/* header for maintaining list of opts; one for each opt in list;
   offsets are measured from beginning of options buffer;
   headers must occur in increasing order, to avoid loops */
struct tcoo_opt_hdr {
	long			hdr_thisopt_off;	/* offset to current opt */
	long			hdr_nexthdr_off;	/* offset to next hdr */
};

/* no-op opt -- the default */
struct tcoo_opt_noop {
	long			noop_type;	/* TCOO_OPT_NOOP; must be first */
};

/* set ident opt -- subsequent t_rcvudata()'s
   (i.e., T_UNITDATA_IND) will contain peer's ident info */
struct tcoo_opt_setid {
	long			setid_type;	/* TCOO_OPT_SETID; must be first */
	long			setid_flg;	/* which id opts to set */
};

/* get ident opt */
struct tcoo_opt_getid {
	long			getid_type;	/* TCOO_OPT_GETID; must be first */
	long			getid_flg;	/* which id opts are set */
};

/* uid info opt */
struct tcoo_opt_uid {
	long			uid_type;	/* TCOO_OPT_UID; must be first */
	uid_t			uid_val;	/* effective user id */
};

/* gid info opt */
struct tcoo_opt_gid {
	long			gid_type;	/* TCOO_OPT_GID; must be first */
	gid_t			gid_val;	/* effective group id */
};

/* ruid info opt */
struct tcoo_opt_ruid {
	long			ruid_type;	/* TCOO_OPT_RUID; must be first */
	uid_t			ruid_val;	/* real user id */
};

/* rgid info opt */
struct tcoo_opt_rgid {
	long			rgid_type;	/* TCOO_OPT_RGID; must be first */
	gid_t			rgid_val;	/* real group id */
};

/* union of all the opts */
union tcoo_opt {
	long			opt_type;	/* opt type; must be first */
	struct tcoo_opt_noop	opt_noop;	/* noop opt */
	struct tcoo_opt_setid	opt_setid;	/* set ident opt */
	struct tcoo_opt_getid	opt_getid;	/* get ident opt */
	struct tcoo_opt_uid	opt_uid;	/* uid info opt */
	struct tcoo_opt_gid	opt_gid;	/* gid info opt */
	struct tcoo_opt_ruid	opt_ruid;	/* ruid info opt */
	struct tcoo_opt_rgid	opt_rgid;	/* rgid info opt */
};

/******************************************************************************/

#ifdef _KERNEL

/*
 *	transport endpoint structure
 */
struct tcoo_endpt {
	struct tcoo_endpt	*te_folist;	/* forw ptr, list of open endpts */
	struct tcoo_endpt	*te_bolist;	/* back ptr, list of open endpts */
	struct tcoo_endpt	*te_frqlist;	/* forw ptr, te_rq list */
	struct tcoo_endpt	*te_brqlist;	/* back ptr, te_rq list */
	struct tcoo_endpt	*te_fblist;	/* forw ptr, list of endpts bound to addr */
	struct tcoo_endpt	*te_bblist;	/* back ptr, list of endpts bound to addr */
	queue_t			*te_rq;		/* stream read queue */
	struct tcoo_addr		*te_addr;	/* addr bound to this endpt */
	minor_t			te_min;		/* minor number */
	unsigned short		te_rqhash;	/* te_rq hash bucket */
	char 			te_state;	/* state of interface */
	char			te_flg;		/* internal flags */
	long			te_idflg;	/* ident flags */
	unsigned char		te_qlen;	/* max incoming connect reqs pending */
	unsigned char		te_nicon;	/* num of incoming connect reqs pending */
#define TCOO_MAXQLEN		8		/* must be <= (1 << (NBBY*sizeof(te_nicon))) */
	struct tcoo_endpt	*te_icon[TCOO_MAXQLEN];	/* incoming connect requests pending */
	struct tcoo_endpt	*te_ocon;	/* outgoing connect request pending */
	struct tcoo_endpt	*te_con;	/* connected endpt */
	uid_t			te_uid;		/* uid */
	gid_t			te_gid;		/* gid */
	uid_t			te_ruid;	/* ruid */
	gid_t			te_rgid;	/* rgid */
};
typedef struct tcoo_endpt	tcoo_endpt_t;

/*
 *	transport addr structure
 */
struct tcoo_addr {
	struct tcoo_addr		*ta_falist;	/* forw ptr, list of bound addrs */
	struct tcoo_addr		*ta_balist;	/* back ptr, list of bound addrs */
	struct tcoo_endpt	*ta_hblist;	/* head ptr, list of endpts bound to this addr */
	struct tcoo_endpt	*ta_tblist;	/* tail ptr, list of endpts bound to this addr */
	unsigned short 		ta_ahash;	/* addr hash bucket */
	long			ta_alen;	/* length of abuf */
	char			*ta_abuf;	/* the addr itself */
};
typedef struct tcoo_addr		tcoo_addr_t;

/*
 *	registered id
 */
#ifdef TICOTS
#define TCOO_ID			10002
#endif
#ifdef TICOTSORD
#define	TCOO_ID			10003
#endif

/*
 *	macro to change state
 *	NEXTSTATE(event,current state)
 */
#define NEXTSTATE(X,Y)		ti_statetbl[X][Y]	/* should be standardized */
#define NR 			127	/* unreachable state */	/* should be standardized */

/*
 *	basic constants
 */
#define TCOO_NENDPT		(OMAXMIN+1)
#ifdef TICOTS
#define TCOO_SERVTYPE		T_COTS
#endif
#ifdef TICOTSORD
#define TCOO_SERVTYPE		T_COTS_ORD
#endif
#define TCOO_TIDUSZ		(4*1024)		/* max packet size */
#define TCOO_DEFAULTADDRSZ	4			/* default addr sz */
/* can't make the following 4 sizes -1 (unlimited), because of bug in TLI/TPI specs:
   unlimited data can be sent but cannot received in a well-specified way
   (receiver doesn't know how big to make buffer, and T_MORE flag can't be used) */
#define TCOO_ADDRSZ		(256-16)			/* 16 = sizeof(struct T_bind_req)
							      = sizeof(struct T_bind_ack) */
#define TCOO_OPTSZ		(TCOO_TIDUSZ-16)		/* 16 = sizeof(struct T_optmgmt_req)
							      = sizeof(struct T_optmgmt_ack) */
#define TCOO_CDATASZ		(TCOO_TIDUSZ-24)		/* 24 = sizeof(struct T_conn_req) + 4
							      = sizeof(struct T_conn_ind)
							      = sizeof(struct T_conn_res) + 4
							      = sizeof(struct T_conn_con) + 4 */
#define TCOO_DDATASZ		(TCOO_TIDUSZ-12)		/* 8 = sizeof(struct T_discon_req) + 4
							     = sizeof(struct T_discon_ind) */
#define TCOO_TSDUSZ		-1			/* unlimited */
#define TCOO_ETSDUSZ		-1			/* unlimited */
#define TCOO_MINPSZ		0
#define TCOO_MAXPSZ		TCOO_TIDUSZ
#define TCOO_LOWAT		(TCOO_TIDUSZ/4)
#define TCOO_HIWAT		(4*TCOO_TIDUSZ)

/*
 *	te_flg
 */
#define TCOO_ZOMBIE		0x1			/* fatal error on endpoint */

/*
 *	pass/fail indicators
 */
#define TCOO_PASS		0
#define TCOO_FAIL		(!TCOO_PASS)
#define TCOO_REALOPT		0x01			/* for tcoo_ckopt() */
#define TCOO_NOOPOPT		0x02			/* for tcoo_ckopt() */
#define TCOO_BADFORMAT		0x04			/* for tcoo_ckopt() */
#define TCOO_BADTYPE		0x08			/* for tcoo_ckopt() */
#define TCOO_BADVALUE		0x10			/* for tcoo_ckopt() */
#define UNIX_PASS		0			/* should be standardized */
#define UNIX_FAIL		(!UNIX_PASS)		/* should be standardized */
#define BADSEQNUM		((long)(-1))		/* should be standardized */

/*
 *	internal defines
 */
#define TCOO_BIND		1
#define TCOO_CONN		2
#define TCOO_OPEN		3
#define TCOO_RQ			4
#define TCOO_IDFLG_ALL		(TCOO_IDFLG_UID | TCOO_IDFLG_GID | TCOO_IDFLG_RUID | TCOO_IDFLG_RGID)
#define TCOO_MHASH		5
#define TCOO_NMHASH		(1 << TCOO_MHASH)	/* num of hash buckets in open endpt table */
#define TCOO_MMASK		(TCOO_NMHASH - 1)
#define TCOO_RQHASH		5			/* must be <= NBBY*sizeof(te_rqhash) */
#define TCOO_NRQHASH		(1 << TCOO_RQHASH)	/* num of hash buckets in te_rq table */
#define TCOO_RQMASK		(TCOO_NRQHASH - 1)
/* following magic number and shift factor for fibonacci hash function */
#define TCOO_RQMAGIC		0x9ce14b36
#define TCOO_RQSHIFT		(NBBY*sizeof(int) - TCOO_RQHASH)
#define TCOO_AHASH		5			/* must be <= NBBY*sizeof(ta_ahash) */
#define TCOO_NAHASH		(1 << TCOO_AHASH)	/* num of hash buckets in bound addr table */
#define TCOO_AMASK		(TCOO_NAHASH - 1)

/*
 *	some useful macros
 */
#define tcoo_min(TE)		((TE)->te_min)
#define tcoo_mkmhash(TE)		((unsigned)(tcoo_min(TE)) & TCOO_MMASK)
#define tcoo_mhash(TE)		tcoo_mkmhash(TE)
#define tcoo_mkrqhash(TE)	(((((unsigned)((TE)->te_rq))*TCOO_RQMAGIC) >> TCOO_RQSHIFT) & TCOO_RQMASK)
#define tcoo_rqhash(TE)		((unsigned)(TE)->te_rqhash)
#define tcoo_alen(TA)		((TA)->ta_alen)
#define tcoo_abuf(TA)		((TA)->ta_abuf)
#define tcoo_ahash(TA)		((unsigned)(TA)->ta_ahash)
#define tcoo_mkahash(TA)		((unsigned)(tcoo_sumbytes(tcoo_abuf(TA),tcoo_alen(TA)) & TCOO_AMASK))
#define tcoo_eqabuf(TA,TB)	((tcoo_alen(TA) == tcoo_alen(TB)) \
				 && tcoo_bequal(tcoo_abuf(TA),tcoo_abuf(TB),tcoo_alen(TA)))

/*
 *	STRLOG tracing levels:
 *
 *	0 = urgent
 *	1 = fatal
 *	2 = errack
 *	3 = interesting stuff
 *	4 = chit-chat
 */

#endif /* _KERNEL */
 07070100005a1f000081240000000200000002000000012719347c00002ebe000000230000000c00000000000000000000001800000000usr/include/sys/tihdr.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TIHDR_H
#define _SYS_TIHDR_H

#ident	"@(#)/usr/include/sys/tihdr.h.sl 1.1 4.0 10/15/90 10213 AT&T-SF"

/*
 * The following is all the information
 * needed by the Transport Service Interface.
 */



/* 
 * The following are the definitions of the Transport
 * Service Interface primitives.
 */

/* 
 * Primitives that are initiated by the transport user.
 */

#define	T_CONN_REQ	0	/* connection request     */
#define T_CONN_RES	1	/* connection response    */
#define T_DISCON_REQ	2	/* disconnect request     */
#define T_DATA_REQ	3	/* data request	          */
#define T_EXDATA_REQ	4	/* expedited data request */
#define T_INFO_REQ	5	/* information request    */
#define T_BIND_REQ	6	/* bind request		  */
#define T_UNBIND_REQ	7	/* unbind request	  */
#define T_UNITDATA_REQ	8	/* unitdata request       */
#define T_OPTMGMT_REQ   9	/* manage options req     */
#define T_ORDREL_REQ   10       /* orderly release req    */

/* 
 * Primitives that are initiated by the transport provider.
 */

#define T_CONN_IND	11	/* connection indication      */
#define T_CONN_CON	12	/* connection confirmation    */
#define T_DISCON_IND	13	/* disconnect indication      */
#define T_DATA_IND	14	/* data indication	      */
#define T_EXDATA_IND	15	/* expeditied data indication */
#define T_INFO_ACK	16	/* information acknowledgment */
#define T_BIND_ACK	17	/* bind acknowledment	      */
#define T_ERROR_ACK	18	/* error acknowledgment       */
#define T_OK_ACK	19	/* ok acknowledgment          */
#define T_UNITDATA_IND	20	/* unitdata indication	      */
#define T_UDERROR_IND	21	/* unitdata error indication  */
#define T_OPTMGMT_ACK   22      /* manage options ack         */
#define T_ORDREL_IND    23      /* orderly release ind 	      */

/*
 * The following are the events that drive the state machine
 */
/* Initialization events */
#define TE_BIND_REQ	0	/* bind request		  		*/
#define TE_UNBIND_REQ	1	/* unbind request	  		*/
#define TE_OPTMGMT_REQ  2	/* manage options req     		*/
#define TE_BIND_ACK	3	/* bind acknowledment	      		*/
#define TE_OPTMGMT_ACK  4       /* manage options ack         		*/
#define TE_ERROR_ACK	5	/* error acknowledgment       		*/
#define TE_OK_ACK1	6	/* ok ack  seqcnt == 0 		  	*/
#define TE_OK_ACK2	7	/* ok ack  seqcnt == 1, q == resq      	*/
#define TE_OK_ACK3	8	/* ok ack  seqcnt == 1, q != resq       */
#define TE_OK_ACK4	9	/* ok ack  seqcnt > 1        		*/

/* Connection oriented events */
#define	TE_CONN_REQ	10	/* connection request     		*/
#define TE_CONN_RES	11	/* connection response    		*/
#define TE_DISCON_REQ	12	/* disconnect request     		*/
#define TE_DATA_REQ	13	/* data request	          		*/
#define TE_EXDATA_REQ	14	/* expedited data request 		*/
#define TE_ORDREL_REQ   15      /* orderly release req    		*/
#define TE_CONN_IND	16	/* connection indication      		*/
#define TE_CONN_CON	17	/* connection confirmation    		*/
#define TE_DATA_IND	18	/* data indication	      		*/
#define TE_EXDATA_IND	19	/* expedited data indication 		*/
#define TE_ORDREL_IND   20      /* orderly release ind 	      		*/
#define TE_DISCON_IND1	21	/* disconnect indication seq == 0      	*/
#define TE_DISCON_IND2	22	/* disconnect indication seq == 1   	*/
#define TE_DISCON_IND3	23	/* disconnect indication seq > 1  	*/
#define TE_PASS_CONN	24	/* pass connection 	      		*/

/* Unit data events */
#define TE_UNITDATA_REQ	25	/* unitdata request       		*/
#define TE_UNITDATA_IND	26	/* unitdata indication	      		*/
#define TE_UDERROR_IND	27	/* unitdata error indication  		*/

#define TE_NOEVENTS	28
/*
 * The following are the possible states of the Transport
 * Service Interface
 */

#define TS_UNBND		0	/* unbound	                */
#define	TS_WACK_BREQ		1	/* waiting ack of BIND_REQ      */
#define TS_WACK_UREQ		2	/* waiting ack of UNBIND_REQ    */
#define TS_IDLE			3	/* idle 		        */
#define TS_WACK_OPTREQ		4	/* wait ack options request     */
#define TS_WACK_CREQ		5	/* waiting ack of CONN_REQ      */
#define TS_WCON_CREQ		6	/* waiting confirm of CONN_REQ  */
#define	TS_WRES_CIND		7	/* waiting response of CONN_IND */
#define TS_WACK_CRES		8	/* waiting ack of CONN_RES      */
#define TS_DATA_XFER		9	/* data transfer		*/
#define TS_WIND_ORDREL	 	10	/* releasing rd but not wr      */
#define TS_WREQ_ORDREL		11      /* wait to release wr but not rd*/
#define TS_WACK_DREQ6		12	/* waiting ack of DISCON_REQ    */
#define TS_WACK_DREQ7		13	/* waiting ack of DISCON_REQ    */
#define TS_WACK_DREQ9		14	/* waiting ack of DISCON_REQ    */
#define TS_WACK_DREQ10		15	/* waiting ack of DISCON_REQ    */
#define TS_WACK_DREQ11		16	/* waiting ack of DISCON_REQ    */

#define TS_NOSTATES		17


/* 
 * The following structure definitions define the format of the
 * stream message block of the above primitives.
 * (everything is declared long to ensure proper alignment
 *  across different machines)
 */

/* connection request */

struct T_conn_req {
	long	PRIM_type;	/* always T_CONN_REQ  */
	long	DEST_length;	/* dest addr length   */
	long	DEST_offset;	/* dest addr offset   */
	long	OPT_length;	/* options length     */
	long	OPT_offset;	/* options offset     */
};

/* connect response */

struct T_conn_res {
	long    PRIM_type;	/* always T_CONN_RES       */
	queue_t *QUEUE_ptr;	/* responding queue ptr    */
	long    OPT_length;	/* options length          */
	long	OPT_offset;	/* options offset          */
	long    SEQ_number;	/* sequence number          */
};

/* disconnect request */

struct T_discon_req {
	long    PRIM_type;	/* always T_DISCON_REQ */
	long    SEQ_number;	/* sequnce number      */
};

/* data request */

struct T_data_req {
	long	PRIM_type;	/* always T_DATA_REQ */
	long	MORE_flag;	/* more data	     */
};

/* expedited data request */

struct T_exdata_req {
	long	PRIM_type;	/* always T_EXDATA_REQ */
	long	MORE_flag;	/* more data	       */
#define	MORE_type	MORE_flag	/* 3.2 source compatibility */
};

/* information request */

struct T_info_req {
	long	PRIM_type;	/* always T_INFO_REQ */
};

/* bind request */

struct T_bind_req {
	long		PRIM_type;	/* always T_BIND_REQ            */
	long		ADDR_length;	/* addr length	                */
	long		ADDR_offset;	/* addr offset	                */
	unsigned long	CONIND_number;	/*connect indications requested */
};

/* unbind request */

struct T_unbind_req {
	long	PRIM_type;	/* always T_UNBIND_REQ */
};

/* unitdata request */

struct T_unitdata_req {
	long	PRIM_type;	/* always T_UNITDATA_REQ  */
	long	DEST_length;	/* dest addr length       */
	long	DEST_offset;	/* dest addr offset       */
	long	OPT_length;	/* options length         */
	long	OPT_offset;	/* options offset         */
};

/* manage options request */

struct T_optmgmt_req {
	long	PRIM_type;	/* always T_OPTMGMT_REQ   */
	long	OPT_length;	/* options length         */
	long	OPT_offset;	/* options offset         */
	long    MGMT_flags;	/* options flags          */
};

/* orderly release request */

struct T_ordrel_req {
	long	PRIM_type;	/* always T_ORDREL_REQ */
};

/* connect indication */

struct T_conn_ind {
	long	PRIM_type;	/* always T_CONN_IND */
	long	SRC_length;	/* src addr length   */
	long	SRC_offset;	/* src addr offset   */
	long	OPT_length;	/* option length     */
	long    OPT_offset;	/* option offset     */
	long    SEQ_number;	/* sequnce number    */
};

/* connect confirmation */

struct T_conn_con {
	long	PRIM_type;	/* always T_CONN_CON      */
	long	RES_length;	/* responding addr length */
	long	RES_offset;	/* responding addr offset */
	long	OPT_length;	/* option length          */
	long    OPT_offset;	/* option offset          */
};

/* disconnect indication */

struct T_discon_ind {
	long	PRIM_type;	/* always T_DISCON_IND 	*/
	long	DISCON_reason;	/* disconnect reason	*/
	long    SEQ_number;	/* sequnce number       */
};

/* data indication */

struct T_data_ind {
	long 	PRIM_type;	/* always T_DATA_IND */
	long	MORE_flag;	/* more data 	     */
};

/* expedited data indication */

struct T_exdata_ind {
	long	PRIM_type;	/* always T_EXDATA_IND */
	long	MORE_flag;	/* more data           */
};

/* information acknowledgment */

struct T_info_ack {
	long	PRIM_type;	/* always T_INFO_ACK     */
	long	TSDU_size;	/* max TSDU size         */
	long	ETSDU_size;	/* max ETSDU size        */
	long	CDATA_size;	/* max connect data size */
	long	DDATA_size;	/* max discon data size  */
	long	ADDR_size;	/* address size		 */
	long	OPT_size;	/* options size		 */
	long    TIDU_size;	/* max TIDU size         */
	long    SERV_type;	/* provider service type */
	long    CURRENT_state;  /* current state         */
	long    PROVIDER_flag;  /* provider flags        */
};

/* bind acknowledgment */

struct T_bind_ack {
	long		PRIM_type;	/* always T_BIND_ACK        */
	long		ADDR_length;	/* addr length              */
	long		ADDR_offset;	/* addr offset              */
	unsigned long	CONIND_number;	/* connect ind to be queued */
};

/* error acknowledgment */

struct T_error_ack { 
	long 	PRIM_type;	/* always T_ERROR_ACK  */
	long	ERROR_prim;	/* primitive in error  */
	long	TLI_error;	/* TLI error code      */
	long	UNIX_error;	/* UNIX error code     */
};

/* ok acknowledgment */

struct T_ok_ack {
	long 	PRIM_type;	/* always T_OK_ACK   */
	long	CORRECT_prim;	/* correct primitive */
};

/* unitdata indication */

struct T_unitdata_ind {
	long	PRIM_type;	/* always T_UNITDATA_IND  */
	long	SRC_length;	/* source addr length     */
	long	SRC_offset;	/* source addr offset     */
	long	OPT_length;	/* options length         */
	long	OPT_offset;	/* options offset         */
};

/* unitdata error indication */

struct T_uderror_ind {
	long	PRIM_type;	/* always T_UDERROR_IND   */
	long	DEST_length;	/* dest addr length       */
	long	DEST_offset;	/* dest addr offset       */
	long	OPT_length;	/* options length         */
	long	OPT_offset;	/* options offset         */
	long	ERROR_type;	/* error type	          */
};

/* manage options ack */

struct T_optmgmt_ack {
	long	PRIM_type;	/* always T_OPTMGMT_ACK   */
	long	OPT_length;	/* options length         */
	long	OPT_offset;	/* options offset         */
	long    MGMT_flags;	/* managment flags        */
};

/* orderly release indication */

struct T_ordrel_ind {
	long	PRIM_type;	/* always T_ORDREL_IND */
};

/*
 * The following is a union of the primitives
 */
union T_primitives {
	long			type;		/* primitive type     */
	struct T_conn_req	conn_req;	/* connect request    */
	struct T_conn_res	conn_res;	/* connect response   */
	struct T_discon_req	discon_req;	/* disconnect request */
	struct T_data_req	data_req;	/* data request       */
	struct T_exdata_req	exdata_req;	/* expedited data req */
	struct T_info_req	info_req;	/* information req    */
	struct T_bind_req	bind_req;	/* bind request       */
	struct T_unbind_req	unbind_req;	/* unbind request     */
	struct T_unitdata_req	unitdata_req;	/* unitdata requset   */
	struct T_optmgmt_req	optmgmt_req;	/* manage opt req     */
	struct T_ordrel_req	ordrel_req;	/* orderly rel req    */
	struct T_conn_ind	conn_ind;	/* connect indication */
	struct T_conn_con	conn_con;	/* connect corfirm    */
	struct T_discon_ind	discon_ind;	/* discon indication  */
	struct T_data_ind	data_ind;	/* data indication    */
	struct T_exdata_ind	exdata_ind;	/* expedited data ind */
	struct T_info_ack	info_ack;	/* info ack	      */
	struct T_bind_ack	bind_ack;	/* bind ack	      */
	struct T_error_ack	error_ack;	/* error ack	      */
	struct T_ok_ack		ok_ack;		/* ok ack	      */
	struct T_unitdata_ind	unitdata_ind;	/* unitdata ind       */
	struct T_uderror_ind	uderror_ind;	/* unitdata error ind */
	struct T_optmgmt_ack	optmgmt_ack;	/* manage opt ack     */
	struct T_ordrel_ind	ordrel_ind;	/* orderly rel ind    */
};


#endif	/* _SYS_TIHDR_H */
  07070100005a20000081240000000200000002000000012719347c00000a74000000230000000c00000000000000000000001700000000usr/include/sys/time.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TIME_H
#define _SYS_TIME_H

#ident	"@(#)/usr/include/sys/time.h.sl 1.1 4.0 10/15/90 44432 AT&T-SF"

/*
 * Structure returned by gettimeofday(2) system call,
 * and used in other calls.
 */

#include <sys/types.h>

#if !defined(_POSIX_SOURCE) 
struct timeval {
	long	tv_sec;		/* seconds */
	long	tv_usec;	/* and microseconds */
};

struct timezone {
	int	tz_minuteswest;	/* minutes west of Greenwich */
	int	tz_dsttime;	/* type of dst correction */
};
#define	DST_NONE	0	/* not on dst */
#define	DST_USA		1	/* USA style dst */
#define	DST_AUST	2	/* Australian style dst */
#define	DST_WET		3	/* Western European dst */
#define	DST_MET		4	/* Middle European dst */
#define	DST_EET		5	/* Eastern European dst */
#define	DST_CAN		6	/* Canada */
#define	DST_GB		7	/* Great Britain and Eire */
#define	DST_RUM		8	/* Rumania */
#define	DST_TUR		9	/* Turkey */
#define	DST_AUSTALT	10	/* Australian style with shift in 1986 */

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define	timerisset(tvp)		((tvp)->tv_sec || (tvp)->tv_usec)
#define	timercmp(tvp, uvp, cmp)	\
	((tvp)->tv_sec cmp (uvp)->tv_sec || \
	 (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define	timerclear(tvp)		(tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */
#define	ITIMER_REAL	0
#define	ITIMER_VIRTUAL	1
#define	ITIMER_PROF	2

struct	itimerval {
	struct	timeval it_interval;	/* timer interval */
	struct	timeval it_value;	/* current value */
};

/*
 * Time expressed in seconds and nanoseconds
 */
#endif /* !defined(_POSIX_SOURCE) */ 

typedef struct 	timestruc {
	time_t 		tv_sec;		/* seconds */
	long		tv_nsec;	/* and nanoseconds */
} timestruc_t;

#ifdef _KERNEL
/*
 * Bump a timestruc by a small number of nsec
 */

#define	BUMPTIME(t, nsec, flag) { \
	register timestruc_t	*tp = (t); \
\
	tp->tv_nsec += (nsec); \
	if (tp->tv_nsec >= 1000000000) { \
		tp->tv_nsec -= 1000000000; \
		tp->tv_sec++; \
		flag = 1; \
	} \
}

extern	timestruc_t	hrestime;
#endif

#if !defined(_KERNEL) && !defined(_POSIX_SOURCE)
#if defined(__STDC__)
int adjtime(struct timeval *, struct timeval *);
int getitimer(int, struct itimerval *);
int setitimer(int, struct itimerval *, struct itimerval *);
#endif /* __STDC__ */
#if !defined(_XOPEN_SOURCE)
#include <time.h>
#endif
#endif /* _KERNEL */


#endif	/* _SYS_TIME_H */
07070100005a21000081240000000200000002000000012719347c000004fb000000230000000c00000000000000000000001800000000usr/include/sys/timeb.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef	_SYS_TIMEB_H
#define	_SYS_TIMEB_H

#ident	"@(#)/usr/include/sys/timeb.h.sl 1.1 4.0 10/15/90 6826 AT&T-SF"
/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */


/*
 *	@(#) timeb.h 1.2 88/08/30 head.sys:timeb.h
 */




/*
 * THIS FILE CONTAINS CODE WHICH IS DESIGNED TO BE
 * PORTABLE BETWEEN DIFFERENT MACHINE ARCHITECTURES
 * AND CONFIGURATIONS. IT SHOULD NOT REQUIRE ANY
 * MODIFICATIONS WHEN ADAPTING XENIX TO NEW HARDWARE.
 */


#if defined(__STDC__)
  #pragma pack(2)
#endif

/*
 * Structure returned by ftime system call
 */
struct timeb {
	time_t	time;		/* time, seconds since the epoch */
	unsigned short	millitm;/* 1000 msec of additional accuracy */
	short	timezone;	/* timezone, minutes west of GMT */
	short	dstflag;	/* daylight savings when appropriate? */
};

#if defined(__STDC__)
  #pragma pack()
#endif

#endif	/*	_SYS_TIMEB_H */
 07070100005a22000081240000000200000002000000012719347c00000306000000230000000c00000000000000000000001800000000usr/include/sys/times.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TIMES_H
#define _SYS_TIMES_H

#ident	"@(#)/usr/include/sys/times.h.sl 1.1 4.0 10/15/90 30723 AT&T-SF"

#include <sys/types.h>

/*
 * Structure returned by times()
 */
struct tms {
	clock_t	tms_utime;		/* user time */
	clock_t	tms_stime;		/* system time */
	clock_t	tms_cutime;		/* user time, children */
	clock_t	tms_cstime;		/* system time, children */
};

#if !defined(_KERNEL)
#if defined(__STDC__)
clock_t times(struct tms *);
#else
clock_t times();
#endif
#endif

#endif	/* _SYS_TIMES_H */
  07070100005a23000081240000000200000002000000012719347c00000eec000000230000000c00000000000000000000001800000000usr/include/sys/timod.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TIMOD_H
#define _SYS_TIMOD_H

#ident	"@(#)/usr/include/sys/timod.h.sl 1.1 4.0 10/15/90 27503 AT&T-SF"

/* Internal flags */
#define USED		0x0001	/* data structure in use          */
#define FATAL		0x0002	/* fatal error M_ERROR occurred   */
#define WAITIOCACK	0x0004	/* waiting for info for ioctl act */
#define MORE		0x0008	/* more data */
#define EXPEDITED	0x0010	/* processing expedited TSDU */
#define CLTS		0x0020	/* connectionless transport */
#define COTS		0x0040	/* connection-oriented transport */
#define OPENWAIT	0x0080	/* sleeping in open routine */
#define CONNWAIT	0x0100	/* waiting for connect confirmation */
#define LOCORDREL	0x0200	/* local end has orderly released */
#define REMORDREL	0x0400	/* remote end had orderly released */
#define NAMEPROC	0x0800	/* processing a NAME ioctl */
#define SENDZERO	0x1000	/* provider supports 0-length msg */
#define	TRSERVICE	0x80000000 /* put routine should putq */
#define	TWSERVICE	0x40000000 /* put routine should putq */

/* Internal buffer size (in bytes) pre-allocated for address fields */
#define PRADDRSZ	128

/* Sleep timeout in open */
#define TIMWAIT	(1*HZ)

/* Timod ioctls */
#define		TIMOD 		('T'<<8)
#define		TI_GETINFO	(TIMOD|140)
#define		TI_OPTMGMT	(TIMOD|141)
#define		TI_BIND		(TIMOD|142)
#define		TI_UNBIND	(TIMOD|143)
#define		TI_GETMYNAME	(TIMOD|144)
#define		TI_GETPEERNAME	(TIMOD|145)
#define		TI_SETMYNAME	(TIMOD|146)
#define		TI_SETPEERNAME	(TIMOD|147)


/* TI interface user level structure - one per open file */

struct _ti_user {
	ushort	ti_flags;	/* flags              */
	int	ti_rcvsize;	/* rcv buffer size    */
	char   *ti_rcvbuf;	/* rcv buffer         */
	int	ti_ctlsize;	/* ctl buffer size    */
	char   *ti_ctlbuf;	/* ctl buffer         */
	char   *ti_lookdbuf;	/* look data buffer   */
	char   *ti_lookcbuf;	/* look ctl buffer    */
	int	ti_lookdsize;  /* look data buf size */
	int	ti_lookcsize;  /* look ctl buf size  */
	int	ti_maxpsz;	/* TIDU size          */
	long	ti_servtype;	/* service type       */
	int     ti_lookflg;	/* buffered look flag */
	int	ti_state;	/* user level state   */
	int	ti_ocnt;	/* # outstanding connect indications */
};

/* Old TI interface user level structure - needed for compatibility */

struct _oldti_user {
	ushort	ti_flags;	/* flags              */
	int	ti_rcvsize;	/* rcv buffer size    */
	char   *ti_rcvbuf;	/* rcv buffer         */
	int	ti_ctlsize;	/* ctl buffer size    */
	char   *ti_ctlbuf;	/* ctl buffer         */
	char   *ti_lookdbuf;	/* look data buffer   */
	char   *ti_lookcbuf;	/* look ctl buffer    */
	int	ti_lookdsize;  /* look data buf size */
	int	ti_lookcsize;  /* look ctl buf size  */
	int	ti_maxpsz;	/* TIDU size          */
	long	ti_servtype;	/* service type       */
	int     ti_lookflg;	/* buffered look flag */
};


/* This should be replaced */
#define OPENFILES     ulimit(4, 0)

extern long ulimit();

/*
 * Routine to be used by transport providers to process
 * TI_GETMYNAME and TI_GETPEERNAME ioctls.
 */
extern int ti_doname();

/*
 * Return values for ti_doname.
 */
#define DONAME_FAIL	0	/* failing ioctl (done) */
#define DONAME_DONE	1	/* done processing */
#define DONAME_CONT	2	/* continue proceesing (not done yet)*/

/*
 *	Must include stream.h, since queue_t is typedef'd there.
 */
#include <sys/stream.h>

struct tim_tim {
	long 	 tim_flags;
	queue_t	*tim_rdq;
	mblk_t  *tim_iocsave;
	int	 tim_mymaxlen;
	int	 tim_mylen;
	caddr_t	 tim_myname;
	int	 tim_peermaxlen;
	int	 tim_peerlen;
	caddr_t	 tim_peername;
	mblk_t	*tim_consave;
};

#endif	/* _SYS_TIMOD_H */
07070100005a24000081240000000200000002000000012719347c000001e9000000230000000c00000000000000000000001900000000usr/include/sys/tirdwr.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TIRDWR_H
#define _SYS_TIRDWR_H

#ident	"@(#)/usr/include/sys/tirdwr.h.sl 1.1 4.0 10/15/90 53567 AT&T-SF"

struct trw_trw {
	long 	 trw_flags;
	queue_t	*trw_rdq;
	mblk_t  *trw_mp;
};

#endif	/* _SYS_TIRDWR_H */
   07070100005a25000081240000000200000002000000012719347c00001b2b000000230000000c00000000000000000000001900000000usr/include/sys/tiuser.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TIUSER_H
#define _SYS_TIUSER_H

#ident	"@(#)/usr/include/sys/tiuser.h.sl 1.1 4.0 10/15/90 58468 AT&T-SF"


/*
 * The following are the error codes needed by both the kernel
 * level transport providers and the user level library.
 */

#define	TBADADDR		1	/* incorrect addr format         */
#define	TBADOPT			2	/* incorrect option format       */
#define	TACCES			3	/* incorrect permissions         */
#define TBADF			4	/* illegal transport fd	         */
#define TNOADDR			5	/* couldn't allocate addr        */
#define TOUTSTATE	        6	/* out of state                  */
#define TBADSEQ		        7       /* bad call sequnce number       */
#define TSYSERR			8	/* system error              */
#define TLOOK		        9	/* event requires attention  */
#define TBADDATA	       10	/* illegal amount of data    */
#define TBUFOVFLW	       11       /* buffer not large enough   */
#define TFLOW		       12 	/* flow control		     */
#define	TNODATA		       13	/* no data		     */
#define TNODIS		       14	/* discon_ind not found on q */
#define TNOUDERR	       15	/* unitdata error not found  */
#define TBADFLAG	       16       /* bad flags                 */
#define TNOREL		       17       /* no ord rel found on q     */
#define TNOTSUPPORT	       18       /* primitive not supported   */
#define TSTATECHNG	       19	/* state is in process of changing */

/* 
 * The following are the events returned by t_look
 */
#define T_LISTEN	0x0001 	/* connection indication received */
#define T_CONNECT	0x0002	/* connect confirmation received  */
#define T_DATA		0x0004	/* normal data received           */
#define	T_EXDATA	0x0008	/* expedited data received        */
#define T_DISCONNECT	0x0010	/* disconnect received            */
#define T_ERROR		0x0020	/* fatal error occurred		  */
#define T_UDERR	 	0x0040	/* data gram error indication     */
#define T_ORDREL	0x0080	/* orderly release indication     */
#define T_EVENTS	0x00ff	/* event mask	                  */

/*
 * The following are the flag definitions needed by the
 * user level library routines.
 */

#define T_MORE		0x001		/* more data        */
#define T_EXPEDITED	0x002		/* expedited data   */
#define T_NEGOTIATE	0x004		/* set opts         */
#define T_CHECK		0x008		/* check opts       */
#define T_DEFAULT	0x010		/* get default opts */
#define T_SUCCESS	0x020		/* successful       */
#define T_FAILURE	0x040		/* failure          */

/*
 * protocol specific service limits
 */

struct t_info {
	long addr;	/* size of protocol address                */
	long options;	/* size of protocol options                */
	long tsdu;	/* size of max transport service data unit */
	long etsdu;	/* size of max expedited tsdu              */
	long connect;	/* max data for connection primitives      */
	long discon;	/* max data for disconnect primitives      */
	long servtype;	/* provider service type		   */
};

/* 
 * Service type defines
 */
#define T_COTS	   01	/* connection oriented transport service  */
#define T_COTS_ORD 02	/* connection oriented w/ orderly release */
#define T_CLTS	   03	/* connectionless transport service       */

/*
 * netbuf structure
 */

struct netbuf {
	unsigned int maxlen;
	unsigned int len;
	char *buf;
};

/*
 * t_bind - format of the addres and options arguments of bind 
 */

struct t_bind {
	struct netbuf	addr;
	unsigned	qlen;
};

/* 
 * options management
 */
struct t_optmgmt {
	struct netbuf	opt;
	long		flags;
};

/*
 * disconnect structure
 */
struct t_discon {
	struct netbuf udata;		/* user data          */
	int reason;			/* reason code        */
	int sequence;			/* sequence number    */
};

/*
 * call structure
 */
struct t_call {
	struct netbuf addr;		/*  address           */
	struct netbuf opt;		/* options	      */
	struct netbuf udata;		/* user data          */
	int sequence;			/* sequence number    */
};

/*
 * data gram structure
 */
struct t_unitdata {
	struct netbuf addr;		/*  address           */
	struct netbuf opt;		/* options	      */
	struct netbuf udata;		/* user data          */
};

/*
 * unitdata error
 */
struct t_uderr {
	struct netbuf addr;		/* address		*/
	struct netbuf opt;		/* options 		*/
	long	      error;		/* error code		*/
};

/*
 * The following are structure types used when dynamically
 * allocating the above structures via t_structalloc().
 */
#define T_BIND		1		/* struct t_bind	*/
#define T_OPTMGMT	2		/* struct t_optmgmt	*/
#define T_CALL		3		/* struct t_call	*/
#define T_DIS		4		/* struct t_discon	*/
#define T_UNITDATA	5		/* struct t_unitdata	*/
#define T_UDERROR	6		/* struct t_uderr	*/
#define T_INFO		7		/* struct t_info	*/

/*
 * The following bits specify which fields of the above
 * structures should be allocated by t_structalloc().
 */
#define T_ADDR	0x01			/* address   */
#define T_OPT	0x02			/* options   */
#define T_UDATA	0x04			/* user data */
#define T_ALL	0x07			/* all the above */


/* 
 * the following are the states for the user
 */

#define T_UNINIT	0		/* uninitialized  		*/
#define T_UNBND		1		/* unbound 	      		*/
#define T_IDLE		2		/* idle				*/
#define	T_OUTCON	3		/* outgoing connection pending 	*/
#define T_INCON		4		/* incoming connection pending  */
#define T_DATAXFER	5		/* data transfer		*/
#define T_OUTREL        6               /* outgoing release pending     */
#define T_INREL		7		/* incoming release pending     */
#define T_FAKE		8		/* fake state used when state   */
					/* cannot be determined		*/
#define T_HACK		12		/* needed to maintain compatibility !!!
					 * (used by switch statement in 
					 * t_getstate.c)
					 * DO NOT REMOVE UNTIL _spec FILE
					 * REORDERED!!!!
					 */

#define T_NOSTATES 	9


#define ROUNDUP(X)	((X + 0x03)&~0x03)

/*
 * The following are TLI user level events which cause
 * state changes.
 */

#define T_OPEN 		0
#define T_BIND		1
#define T_OPTMGMT	2
#define T_UNBIND	3
#define T_CLOSE		4
#define T_SNDUDATA	5
#define T_RCVUDATA	6
#define T_RCVUDERR	7
#define T_CONNECT1	8
#define T_CONNECT2	9
#define T_RCVCONNECT	10
#define T_LISTN		11
#define T_ACCEPT1	12
#define T_ACCEPT2	13
#define	T_ACCEPT3	14
#define T_SND		15
#define T_RCV		16
#define T_SNDDIS1	17
#define T_SNDDIS2	18
#define T_RCVDIS1	19
#define T_RCVDIS2	20
#define T_RCVDIS3	21
#define T_SNDREL	22
#define T_RCVREL	23
#define T_PASSCON	24

#define T_NOEVENTS	25

#define nvs 	127 	/* not a valid state change */

extern char tiusr_statetbl[T_NOEVENTS][T_NOSTATES];

/* macro to change state */
/* TLI_NEXTSTATE(event, current state) */
#define TLI_NEXTSTATE(X,Y)	tiusr_statetbl[X][Y]

/*
 * Flags for t_getname.
 */
#define LOCALNAME	0
#define REMOTENAME	1

/*
 * Band definitions for data flow.
 */
#define TI_NORMAL	0
#define TI_EXPEDITED	1

#endif	/* _SYS_TIUSER_H */
 07070100005a26000081240000000200000002000000012719347c00000238000000230000000c00000000000000000000001800000000usr/include/sys/trace.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TRACE_H
#define _SYS_TRACE_H

#ident	"@(#)/usr/include/sys/trace.h.sl 1.1 4.0 10/15/90 19287 AT&T-SF"
/*
 * Per trace structure
 */
struct trace {
	struct 	clist tr_outq;
	short	tr_state;
	short	tr_chbits;
	short	tr_rcnt;
	unsigned char	tr_chno;
	char	tr_ct;
};

#endif	/* _SYS_TRACE_H */
07070100005a27000081240000000200000002000000012719347c0000063d000000230000000c00000000000000000000001700000000usr/include/sys/trap.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TRAP_H
#define _SYS_TRAP_H

#ident	"@(#)/usr/include/sys/trap.h.sl 1.1 4.0 10/15/90 28942 AT&T-SF"

/*
 * Trap type values
 */

#define	DIVERR		0	/* divide by 0 error		*/
#define	SGLSTP		1	/* single step			*/
#define	NMIFLT		2	/* NMI				*/
#define	BPTFLT		3	/* breakpoint fault		*/
#define	INTOFLT		4	/* INTO overflow fault		*/
#define	BOUNDFLT	5	/* BOUND instruction fault	*/
#define	INVOPFLT	6	/* invalid opcode fault		*/
#define	NOEXTFLT	7	/* extension not available fault*/
#define	DBLFLT		8	/* double fault			*/
#define	EXTOVRFLT	9	/* extension overrun fault	*/
#define	INVTSSFLT	10	/* invalid TSS fault		*/
#define	SEGNPFLT	11	/* segment not present fault	*/
#define	STKFLT		12	/* stack fault			*/
#define	GPFLT		13	/* general protection fault	*/
#define	PGFLT		14	/* page fault			*/
#define	EXTERRFLT	16	/* extension error fault	*/
#define	ENDPERR		33	/* emulated extension error flt	*/
#define	ENOEXTFLT	32	/* emulated ext not present	*/

/*
 *  Values of error code on stack in case of page fault 
 */

#define	PF_ERR_MASK	0x01	/* Mask for error bit */
#define PF_ERR_PAGE	0	/* page not present */
#define PF_ERR_PROT	1	/* protection error */
#define PF_ERR_WRITE	2	/* fault caused by write (else read) */
#define PF_ERR_USER	4	/* processor was in user mode
					(else supervisor) */
#endif	/* _SYS_TRAP_H */
   07070100005a28000081240000000200000002000000012719347c00000855000000230000000c00000000000000000000001500000000usr/include/sys/ts.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TS_H
#define _SYS_TS_H

#ident	"@(#)/usr/include/sys/ts.h.sl 1.1 4.0 10/15/90 61148 AT&T-SF"
/*
 * time-sharing dispatcher parameter table entry
 */
typedef struct tsdpent {
	int	ts_globpri;	/* global (class independent) priority */
	long	ts_quantum;	/* time quantum given to procs at this level */
	short	ts_tqexp;	/* ts_umdpri assigned when proc at this level */
				/*   exceeds its time quantum */
	short	ts_slpret;	/* ts_umdpri assigned when proc at this level */
				/*  returns to user mode after sleeping */
	short	ts_maxwait;	/* bumped to ts_lwait if more than ts_maxwait */
				/*  secs elapse before receiving full quantum */
	short	ts_lwait;	/* ts_umdpri assigned if ts_dispwait exceeds  */
				/*  ts_maxwait */				
} tsdpent_t;


/*
 * time-sharing class specific proc structure
 */
typedef struct tsproc {
	long	ts_timeleft;	/* time remaining in procs quantum */
	short	ts_cpupri;	/* system controlled component of ts_umdpri */
	short	ts_uprilim;	/* user priority limit */
	short	ts_upri;	/* user priority */
	short	ts_umdpri;	/* user mode priority within ts class */
	char	ts_nice;	/* nice value for compatibility */
	unsigned char ts_flags;	/* flags defined below */
	short	ts_dispwait;	/* number of wall clock seconds since start */
				/*   of quantum (not reset upon preemption) */
	struct proc *ts_procp;	/* pointer to proc table entry */
	char	*ts_pstatp;	/* pointer to p_stat */
	int	*ts_pprip;	/* pointer to p_pri */
	uint	*ts_pflagp;	/* pointer to p_flag */
	struct tsproc *ts_next;	/* link to next tsproc on list */
	struct tsproc *ts_prev;	/* link to previous tsproc on list */
} tsproc_t;


/* flags */
#define	TSKPRI	0x01		/* proc at kernel mode priority */
#define	TSBACKQ	0x02		/* proc goes to back of disp q when preempted */
#define	TSFORK	0x04		/* proc has forked, so don't reset full quantum */

#endif	/* _SYS_TS_H */
   07070100005a29000081240000000200000002000000012719347c0000041b000000230000000c00000000000000000000001d00000000usr/include/sys/tspriocntl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TSPRIOCNTL_H
#define _SYS_TSPRIOCNTL_H

#ident	"@(#)/usr/include/sys/tspriocntl..sl 1.1 4.0 10/15/90 6773 AT&T-SF"
/*
 * Time-sharing class specific structures for the priocntl system call.
 */

typedef struct tsparms {
	short	ts_uprilim;	/* user priority limit */
	short	ts_upri;	/* user priority */
} tsparms_t;


typedef struct tsinfo {
	short	ts_maxupri;	/* configured limits of user priority range */
} tsinfo_t;

#define	TS_NOCHANGE	-32768

/*
 * The following is used by the dispadmin(1M) command for
 * scheduler administration and is not for general use.
 */

typedef struct tsadmin {
	struct tsdpent	*ts_dpents;
	short		ts_ndpents;
	short		ts_cmd;
} tsadmin_t;

#define	TS_GETDPSIZE	1
#define	TS_GETDPTBL	2
#define	TS_SETDPTBL	3


#endif	/* _SYS_TSPRIOCNTL_H */
 07070100005a2a000081240000000200000002000000012719347c0000056f000000230000000c00000000000000000000001900000000usr/include/sys/tsproc.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TSPROC_H
#define _SYS_TSPROC_H

#ident	"@(#)/usr/include/sys/tsproc.h.sl 1.1 4.0 10/15/90 3140 AT&T-SF"
/* time-sharing class specific proc structure */

typedef struct tsproc {
	long	ts_timeleft;	/* time remaining in procs quantum */
	short	ts_umdpri;	/* user mode priority within ts class */
	short	ts_upri;	/* user priority */
	short	ts_upovrflw;	/* user requested priority which was out */
				/*  of defined range by this amount */
	char	ts_nice;	/* nice value for compatibility */
	short	ts_dispwait;	/* number of wall clock seconds since start */
				/*   of quantum (not reset upon preemption */
	ushort	ts_flags;	/* flags defined below */
	struct proc *ts_procp;	/* pointer to proc table entry */
	char	*ts_pstatp;	/* pointer to p_stat */
	int	*ts_pprip;	/* pointer to p_pri */
	uint	*ts_pflagp;	/* pointer to p_flag */
	char	*ts_ptimep;	/* pointer to p_time */
	struct cred **ts_pcredpp;	/* pointer to p_cred */
} tsproc_t;

extern tsproc_t	ts_proc[];

/* flags */
#define	TSINUSE	0x0001		/* ts_proc entry in use */
#define	TSKPRI	0x0002		/* proc at kernel mode priority */

#endif	/* _SYS_TSPROC_H */
 07070100005a2b000081240000000200000002000000012719347c00000932000000230000000c00000000000000000000001600000000usr/include/sys/tss.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TSS_H
#define _SYS_TSS_H

#ident	"@(#)/usr/include/sys/tss.h.sl 1.1 4.0 10/15/90 52879 AT&T-SF"

/* Flags Register */

typedef struct flags {
	uint	fl_cf	:  1,		/* carry/borrow */
			:  1,		/* reserved */
		fl_pf	:  1,		/* parity */
			:  1,		/* reserved */
		fl_af	:  1,		/* carry/borrow */
			:  1,		/* reserved */
		fl_zf	:  1,		/* zero */
		fl_sf	:  1,		/* sign */
		fl_tf	:  1,		/* trace */
		fl_if	:  1,		/* interrupt enable */
		fl_df	:  1,		/* direction */
		fl_of	:  1,		/* overflow */
		fl_iopl :  2,		/* I/O privilege level */
		fl_nt	:  1,		/* nested task */
			:  1,		/* reserved */
		fl_rf	:  1,		/* reset */
		fl_vm	:  1,		/* virtual 86 mode */
		fl_res	: 14;		/* reserved */
} flags_t;

#define	PS_C		0x0001		/* carry bit			*/
#define	PS_P		0x0004		/* parity bit			*/
#define	PS_AC		0x0010		/* auxiliary carry bit		*/
#define	PS_Z		0x0040		/* zero bit			*/
#define	PS_N		0x0080		/* negative bit			*/
#define	PS_T		0x0100		/* trace enable bit		*/
#define	PS_IE		0x0200		/* interrupt enable bit		*/
#define	PS_D		0x0400		/* direction bit		*/
#define	PS_V		0x0800		/* overflow bit			*/
#define	PS_IOPL		0x3000		/* I/O privilege level		*/
#define	PS_NT		0x4000		/* nested task flag		*/
#define	PS_RF		0x10000		/* Reset flag			*/
#define	PS_VM		0x20000		/* Virtual 86 mode flag		*/

/*
 * Maximum I/O address that will be in TSS bitmap
 */
#define	MAXTSSIOADDR	0x3ff

/*
 * 386 TSS definition
 */

struct tss386 {
	unsigned long t_link;
	unsigned long t_esp0;
	unsigned long t_ss0;
	unsigned long t_esp1;
	unsigned long t_ss1;
	unsigned long t_esp2;
	unsigned long t_ss2;
	paddr_t	      t_cr3;
	unsigned long t_eip;
	unsigned long t_eflags;
	unsigned long t_eax;
	unsigned long t_ecx;
	unsigned long t_edx;
	unsigned long t_ebx;
	unsigned long t_esp;
	unsigned long t_ebp;
	unsigned long t_esi;
	unsigned long t_edi;
	unsigned long t_es;
	unsigned long t_cs;
	unsigned long t_ss;
	unsigned long t_ds;
	unsigned long t_fs;
	unsigned long t_gs;
	unsigned long t_ldt;
	unsigned long t_bitmapbase;
};

#define		PS_USER		3
#define		PS_KERNEL	0

#endif	/* _SYS_TSS_H */
  07070100005a2c000081240000000200000002000000012719347c000007fb000000230000000c00000000000000000000001b00000000usr/include/sys/ttcompat.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ttcompat.h.sl 1.1 4.0 10/15/90 11786 AT&T-SF"

/*
 * BSD/XENIX/V7 ttcompat module header file
 */

/*
 * Old-style terminal state.
 */
typedef struct {
	int	t_flags;		/* flags */
	char	t_ispeed, t_ospeed;	/* speeds */
	char	t_erase;		/* erase last character */
	char	t_kill;			/* erase entire line */
	char	t_intrc;		/* interrupt */
	char	t_quitc;		/* quit */
	char	t_startc;		/* start output */
	char	t_stopc;		/* stop output */
	char	t_eofc;			/* end-of-file */
	char	t_brkc;			/* input delimiter (like nl) */
	char	t_suspc;		/* stop process signal */
	char	t_dsuspc;		/* delayed stop process signal */
	char	t_rprntc;		/* reprint line */
	char	t_flushc;		/* flush output (toggles) */
	char	t_werasc;		/* word erase */
	char	t_lnextc;		/* literal next character */
	int	t_xflags;		/* XXX extended flags */
} compat_state_t;

/*
 * Per-tty structure.
 */
typedef struct {
	mblk_t	*t_savbp;
	mblk_t	*t_iocpending;		/* ioctl pending successful allocation */
	compat_state_t t_curstate;	/* current emulated state */
	struct sgttyb t_new_sgttyb;	/* new sgttyb from TIOCSET[PN] */
	struct tchars t_new_tchars;	/* new tchars from TIOCSETC */
	struct ltchars t_new_ltchars;	/* new ltchars from TIOCSLTC */
	int	t_new_lflags;		/* new lflags from TIOCLSET/LBIS/LBIC */
	int	t_state;		/* state bits */
	int	t_iocid;		/* ID of "ioctl" we handle specially */
	int	t_ioccmd;		/* ioctl code for that "ioctl" */
} ttcompat_state_t;


#define TS_FREE	 0x00	/* not in use */
#define TS_INUSE 0x01	/* allocated */
#define TS_W_IN	 0x02	/* waiting for an M_IOCDATA response to an M_COPYIN request */
#define TS_W_OUT 0x04	/* waiting for an M_IOCDATA response to an M_COPYOUT request */
#define TS_IOCWAIT 0x08	/* waiting for an M_IOCACK/M_IOCNAK from downstream */

 07070100005a2d000081240000000200000002000000012719347c000021da000000230000000c00000000000000000000001800000000usr/include/sys/ttold.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TTOLD_H
#define _SYS_TTOLD_H

#ident	"@(#)/usr/include/sys/ttold.h.sl 1.1 4.0 10/15/90 24224 AT&T-SF"

/*
 * NOTE: if this file is included in the same program as sys/termios.h,
 * then termios.h MUST be included before this one to avoid symbol
 * redefinition warnings.
 */

/* All the ioctls (BSD, V7, XENIX, S5) defines are in termios.h */
/* this file has mostly BSD structures and flags */

/* BSD special characters. Structure for TIOCSTC/TIOCGTC */
struct tchars {
	char	t_intrc;	/* interrupt */
	char	t_quitc;	/* quit */
	char	t_startc;	/* start output */
	char	t_stopc;	/* stop output */
	char	t_eofc;		/* end-of-file */
	char	t_brkc;		/* input delimiter (like nl) */
};

/* note xenix defines tchars as tc */
struct tc {
	unsigned char	t_intrc;	/* interrupt */
	unsigned char	t_quitc;	/* quit */
	unsigned char	t_startc;	/* start output */
	unsigned char	t_stopc;	/* stop output */
	unsigned char	t_eofc;		/* end-of-file */
	unsigned char	t_brkc;		/* input delimiter (like nl) */
};

#ifdef i386
#pragma pack()
#endif

#ifndef _SGTTY_H
/*
 * Structure for TIOCGETP and TIOCSETP ioctls.
 */


/*  sg_flags value changed from short (in SUN/BSD) to int in System V to */
/*  match sgtty.h definition */
struct	sgttyb {
	unsigned char	sg_ispeed;		/* input speed */
	unsigned char	sg_ospeed;		/* output speed */
	unsigned char	sg_erase;		/* erase character */
	unsigned char	sg_kill;		/* kill character */
	int	sg_flags;		/* mode flags */
};
/* BSD local special chars. Structure for TIOCSLTC/TIOCGLTC */
struct ltchars {
    char    t_suspc;    /* stop process signal */
    char    t_dsuspc;   /* delayed stop process signal */
    char    t_rprntc;   /* reprint line */
    char    t_flushc;   /* flush output (toggles) */
    char    t_werasc;   /* word erase */
    char    t_lnextc;   /* literal next character */
};

#endif /* _SGTTY_H */

/*
 * 4.3BSD/XENIX tty ioctl commands that are either:
 *  1) deprecated
 *  2) not implemented (and never were implemented)
 *  3) implemented on top of new-style "ioctl"s.
 */

/*
 * These ioctls are also defined in termios.h.
 * because XENIX expects to see them in termio.h
 */

#ifndef tIOC
#define	tIOC	('t'<<8)
#endif

#ifndef _SYS_TERMIOS_H
/* defined in termios.h also so that all the ioctl codes are visible*/

#define TIOCGETD	(tIOC|0)
#define TIOCSETD	(tIOC|1)
#ifndef _SGTTY_H
#define TIOCHPCL	(tIOC|2)
#define TIOCGETP	(tIOC|8)
#define TIOCSETP  	(tIOC|9)
#endif /* _SGTTY_H */
#define TIOCSETN	(tIOC|10)
#ifndef _SGTTY_H
#define TIOCEXCL	(tIOC|13)
#define TIOCNXCL	(tIOC|14)
#endif /* _SGTTY_H */
#define	TIOCOUTQ	(tIOC|115)  /* driver output queue size */
#define TIOCFLUSH	(tIOC|16)
#define TIOCSETC	(tIOC|17)
#define TIOCGETC	(tIOC|18)

/* BSD ioctls that are not the same as XENIX */
#define	TIOCLBIS	(tIOC|127)	/* bis local mode bits */
#define	TIOCLBIC	(tIOC|126)	/* bic local mode bits */
#define	TIOCLSET	(tIOC|125)	/* set entire local mode word */
#define	TIOCLGET	(tIOC|124)	/* get local modes */
#define	TIOCSBRK	(tIOC|123)	/* set break bit */
#define	TIOCCBRK	(tIOC|122)	/* clear break bit */
#define	TIOCSDTR	(tIOC|121)	/* set data terminal ready */
#define	TIOCCDTR	(tIOC|120)	/* clear data terminal ready */
#define	TIOCSLTC	(tIOC|117)	/* set local special chars */
#define	TIOCGLTC	(tIOC|116)	/* get local special chars */
#define	TIOCNOTTY	(tIOC|113)	/* void tty association */
#define	TIOCSTOP	(tIOC|111)	/* stop output, like ^S */
#define	TIOCSTART	(tIOC|110)	/* start output, like ^Q */

#define	TIOCREMOTE	(tIOC|30)	/* remote input editing */

/* windowing ioctls and structure also defined in termios.h */

#define	TIOC	('T'<<8)

#define TIOCGWINSZ (TIOC|104)
#define TIOCSWINSZ (TIOC|103)

#ifndef _SYS_PTEM_H
/* Windowing structure to support TIOCSWINSZ/TIOCGWINSZ */
struct winsize {
	unsigned short ws_row;       /* rows, in characters*/
	unsigned short ws_col;       /* columns, in character */
	unsigned short ws_xpixel;    /* horizontal size, pixels */
	unsigned short ws_ypixel;    /* vertical size, pixels */
};

#endif /* end _SYS_PTEM_H */
#endif /* end _SYS_TERMIOS_H */

/* Old SVR3.0 flags - should be removed if there is no problem */
/* note they are commented out */

#define O_HUPCL 01
#define O_NOAL  004000

#if 0

#define O_CBREAK    02
#define	O_XTABS	02
#define	O_LCASE	04   /* simulate lower case */
#define	O_ECHO	010  /* echo input */
#define	O_CRMOD	020  /* map \r to \r\n on output */
#define	O_RAW	040  /* no i/o processing */
#define	O_ODDP	0100 /* get/send odd parity */
#define	O_EVENP	0200 /* get/send even parity */
#define	O_NLDELAY	001400	/* \n delay */
#define	O_NL1	000400
#define	O_NL2	001000
#define	O_TBDELAY	002000	/* horizontal tab delay */
#define	O_CRDELAY	030000	/* \r delay */
#define	O_CR1	010000
#define	O_CR2	020000
#define	O_VTDELAY	040000	/* vertical tab delay */
#define	O_BSDELAY	0100000 /* \b delay */

#endif

/* 4.3 BSD additions. These are new codes  and some of the
 * flags that were there in SVR3.2 ttold.h have been given
 * new codes. Otherwise they will not fit in a word.
 */ 

#define		O_TANDEM	0x00000001	/* send stopc on out q full */
#define		O_CBREAK	0x00000002	/* half-cooked mode */
#define		O_LCASE		0x00000004	/* simulate lower case */
#define		O_ECHO		0x00000008	/* echo input */
#define		O_CRMOD		0x00000010	/* map \r to \r\n on output */
#define		O_RAW		0x00000020	/* no i/o processing */
#define		O_ODDP		0x00000040	/* get/send odd parity */
#define		O_EVENP		0x00000080	/* get/send even parity */
#define		O_ANYP		0x000000c0	/* get any parity/send none */
#define		O_NLDELAY	0x00000300	/* \n delay */
#define			O_NL0	0x00000000
#define			O_NL1	0x00000100	/* tty 37 */
#define			O_NL2	0x00000200	/* vt05 */
#define			O_NL3	0x00000300
#define		O_TBDELAY	0x00000c00	/* horizontal tab delay */
#define			O_TAB0	0x00000000
#define			O_TAB1	0x00000400	/* tty 37 */
#define			O_TAB2	0x00000800
#define		O_XTABS		0x00000c00	/* expand tabs on output */
#define		O_CRDELAY	0x00003000	/* \r delay */
#define			O_CR0	0x00000000
#define			O_CR1	0x00001000	/* tn 300 */
#define			O_CR2	0x00002000	/* tty 37 */
#define			O_CR3	0x00003000	/* concept 100 */
#define		O_VTDELAY	0x00004000	/* vertical tab delay */
#define			O_FF0	0x00000000
#define			O_FF1	0x00004000	/* tty 37 */
#define		O_BSDELAY	0x00008000	/* \b delay */
#define			O_BS0	0x00000000
#define			O_BS1	0x00008000
#define 	O_ALLDELAY	(O_NLDELAY|O_TBDELAY|O_CRDELAY|O_VTDELAY|O_BSDELAY)
#define		O_CRTBS		0x00010000	/* do backspacing for crt */
#define		O_PRTERA	0x00020000	/* \ ... / erase */
#define		O_CRTERA	0x00040000	/* " \b " to wipe out char */
#define		O_TILDE		0x00080000	/* hazeltine tilde kludge */
#define		O_MDMBUF	0x00100000	/* start/stop output on carrier intr */
#define		O_LITOUT	0x00200000	/* literal output */
#define		O_TOSTOP	0x00400000	/* SIGSTOP on background output */
#define		O_FLUSHO	0x00800000	/* flush output to terminal */
#define		O_NOHANG	0x01000000	/* no SIGHUP on carrier drop */
#define		O_L001000	0x02000000
#define		O_CRTKIL	0x04000000	/* kill line with " \b " */
#define		O_PASS8		0x08000000
#define		O_CTLECH	0x10000000	/* echo control chars as ^X */
#define		O_PENDIN	0x20000000	/* tp->t_rawq needs reread */
#define		O_DECCTQ	0x40000000	/* only ^Q starts after ^S */
#define		O_NOFLSH	0x80000000	/* no output flush on signal */

/* more BSD flags */
#define		LCRTBS		(O_CRTBS>>16)
#define		LPRTERA		(O_PRTERA>>16)
#define		LCRTERA		(O_CRTERA>>16)
#define		LTILDE		(O_TILDE>>16)
#define		LMDMBUF		(O_MDMBUF>>16)
#define		LLITOUT		(O_LITOUT>>16)
#define		LTOSTOP		(O_TOSTOP>>16)
#define		LFLUSHO		(O_FLUSHO>>16)
#define		LNOHANG		(O_NOHANG>>16)
#define		LCRTKIL		(O_CRTKIL>>16)
#define		LPASS8		(O_PASS8>>16)
#define		LCTLECH		(O_CTLECH>>16)
#define		LPENDIN		(O_PENDIN>>16)
#define		LDECCTQ		(O_DECCTQ>>16)
#define		LNOFLSH		(O_NOFLSH>>16)


#define		NOPOST		0x00000001	/* no processing on output (LITOUT with 7 bits + parity) */
#define		NOISIG		0x00000002	/* disable all signal-generating characters */
#define		STOPB		0x00000004	/* two stop bits */

#define	OTTYDISC	0		/* old, v7 std tty driver */
#define	NETLDISC	1		/* line discip for berk net */
#define	NTTYDISC	2		/* new tty discipline */
#define	TABLDISC	3		/* hitachi tablet discipline */
#define	NTABLDISC	4		/* gtco tablet discipline */
#define	MOUSELDISC	5		/* mouse discipline */
#define	KBDLDISC	6		/* up/down keyboard trans (console) */

#endif	/* _SYS_TTOLD_H */
  07070100005a2e000081240000000200000002000000012719347c0000140f000000230000000c00000000000000000000001600000000usr/include/sys/tty.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TTY_H
#define _SYS_TTY_H

#ident	"@(#)/usr/include/sys/tty.h.sl 1.1 4.0 10/15/90 42864 AT&T-SF"
/*
 * A clist structure is the head of a linked list queue of characters.
 * The routines getc* and putc* manipulate these structures.
 */

struct clist {
	int	c_cc;		/* character count */
	struct cblock *c_cf;	/* pointer to first */
	struct cblock *c_cl;	/* pointer to last */
};

/* Macro to find clist structure given pointer into it	*/
#define CMATCH(pointer)		(char *)(cfree + (pointer - cfree))

/* Character control block for interrupt level control	*/

struct ccblock {
	caddr_t	c_ptr;		/* buffer address	*/
	ushort	c_count;	/* character count	*/
	ushort	c_size;		/* buffer size		*/
};

/*
 * A tty structure is needed for each UNIX character device that
 * is used for normal terminal IO.
 */
#define	NCC	8
struct tty {
	struct	clist t_rawq;	/* raw input queue */
	struct	clist t_canq;	/* canonical queue */
	struct	clist t_outq;	/* output queue */
	struct	ccblock	t_tbuf;	/* tx control block */
	struct	ccblock t_rbuf;	/* rx control block */
	int	(* t_proc)();	/* routine for device functions */
	ushort	t_iflag;	/* input modes */
	ushort	t_oflag;	/* output modes */
	ushort	t_cflag;	/* control modes */
	ushort	t_lflag;	/* line discipline modes */
	short	t_state;	/* internal state */
	o_pid_t	t_pgrp;		/* process group name */
	char	t_line;		/* line discipline */
	char	t_delct;	/* delimiter count */
	char	t_term;		/* terminal type */	
	char	t_tmflag;	/* terminal flags */
	char	t_col;		/* current column */
	char	t_row;		/* current row */
	char	t_vrow;		/* variable row */
	char	t_lrow;		/* last physical row */
	char	t_hqcnt;	/* no. high queue packets on t_outq */	
	char	t_dstat;	/* used by terminal handlers
						and line disciplines */
	unsigned char	t_cc[NCC+2];	/* settable control chars */
	char	t_mstate;	/* emapping state */
	unsigned char	t_mchar;/* saved emapping char */
	char	t_merr;		/* emapping error flag */
	char	t_xstate;	/* extended state */
	struct emap	*t_mp;	/* emapping table */
	unsigned char	t_schar;/* save timeout char instead of using lflag */
	char	t_yyy[3];	/* reserved */
};

/*
 * The structure of a clist block
 */
#define	CLSIZE	64
struct cblock {
	struct cblock *c_next;
	unsigned char	c_first;
	unsigned char	c_last;
	unsigned char	c_data[CLSIZE];
};

extern struct cblock	*cfree;
extern struct cblock	*getcb();
extern struct cblock	*getcf();
extern struct clist	ttnulq;
extern int		cfreecnt;

struct chead {
	struct cblock *c_next;
	int	c_size;
	int	c_flag;
};
extern struct chead cfreelist;

struct inter {
	int	cnt;
};

#define	QESC	0200	/* queue escape */
#define	HQEND	01	/* high queue end */

#define	TTIPRI	28
#define	TTOPRI	29

#ifdef u3b15
/* following defs allow for job control in both vpm and stand-alone
   tty environments */
#define VPMTTY	1
#define SATTY	2
#endif

/* limits */
extern int ttlowat[], tthiwat[];
#define	TTYHOG	256
#define	TTXOLO	132
#define	TTXOHI	180

/* Hardware bits */
#define	DONE	0200
#define	IENABLE	0100
#define	OVERRUN	040000
#define	FRERROR	020000
#define	PERROR	010000

/* Internal state */
#define	TIMEOUT	01		/* Delay timeout in progress */
#define	WOPEN	02		/* Waiting for open to complete */
#define	ISOPEN	04		/* Device is open */
#define	TBLOCK	010
#define	CARR_ON	020		/* Software copy of carrier-present */
#define	BUSY	040		/* Output in progress */
#define	OASLP	0100		/* Wakeup when output done */
#define	IASLP	0200		/* Wakeup when input done */
#define	TTSTOP	0400		/* Output stopped by ctl-s */
#define	EXTPROC	01000		/* External processing */
#define	TACT	02000
#define	CLESC	04000		/* Last char escape */
#define	RTO	010000		/* Raw Timeout */
#define	TTIOW	020000
#define	TTXON	040000
#define	TTXOFF	0100000

/* l_output status */
#define	CPRES	0100000

/* device commands */
#define	T_OUTPUT	0
#define	T_TIME		1
#define	T_SUSPEND	2
#define	T_RESUME	3
#define	T_BLOCK		4
#define	T_UNBLOCK	5
#define	T_RFLUSH	6
#define	T_WFLUSH	7
#define	T_BREAK		8
#define	T_INPUT		9
#define T_DISCONNECT	10
#define	T_PARM		11
#define	T_SWTCH		12

/*
 * Terminal flags (set in t_tmflgs).
 */

#define SNL	1		/* non-standard new-line needed */
#define ANL	2		/* automatic new-line */
#define LCF	4		/* Special treatment of last col, row */
#define TERM_CTLECHO	010	/* Echo terminal control characters */
#define TERM_INVIS	020	/* do not send escape sequences to user */
#define QLOCKB		040	/* high queue locked for base level */
#define QLOCKI		0100	/* high queue locked for interrupts */
#define	TERM_BIT 0200		/* Bit reserved for terminal drivers. */
				/* Usually used to indicate that an esc*/
				/* character has arrived and that the  */
				/* next character is special.          */
				/* This bit is the same as the TM_SET  */
				/* bit which may never be set by a user*/
/*
 *	device reports
 */
#define	L_BUF		0
#define	L_BREAK		3

#endif	/* _SYS_TTY_H */
 07070100005a2f000081240000000200000002000000012719347c00000644000000230000000c00000000000000000000001b00000000usr/include/sys/ttychars.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TTYCHARS_H
#define _SYS_TTYCHARS_H

#ident	"@(#)/usr/include/sys/ttychars.h.sl 1.1 4.0 10/15/90 44256 AT&T-SF"

/*	@(#)ttychars.h 2.5 88/02/08 SMI; from UCB 4.6 83/07/01	*/

/*
 * User visible structures and constants
 * related to terminal handling.
 */

struct ttychars {
	char	tc_erase;	/* erase last character */
	char	tc_kill;	/* erase entire line */
	char	tc_intrc;	/* interrupt */
	char	tc_quitc;	/* quit */
	char	tc_startc;	/* start output */
	char	tc_stopc;	/* stop output */
	char	tc_eofc;	/* end-of-file */
	char	tc_brkc;	/* input delimiter (like nl) */
	char	tc_suspc;	/* stop process signal */
	char	tc_dsuspc;	/* delayed stop process signal */
	char	tc_rprntc;	/* reprint line */
	char	tc_flushc;	/* flush output (toggles) */
	char	tc_werasc;	/* word erase */
	char	tc_lnextc;	/* literal next character */
};

#ifndef _SYS_TERMIOS_H

#define	CTRL(c)	((c)&037)

/* default BSD special characters */
#define	CERASE	0177
#define	CKILL	CTRL('u')
#define	CINTR	CTRL('c')
#define	CQUIT	034		/* FS, ^\ */
#define	CSTART	CTRL('q')
#define	CSTOP	CTRL('s')
#define	CEOF	CTRL('d')
#define	CEOT	CEOF
#define	CBRK	0377
#define	CSUSP	CTRL('z')
#define	CDSUSP	CTRL('y')
#define	CRPRNT	CTRL('r')
#define	CFLUSH	CTRL('o')
#define	CWERASE	CTRL('w')
#define	CLNEXT	CTRL('v')

#endif /*_SYS_TERMIOS_H*/

#endif /*_SYS_TTYCHARS_H*/
07070100005a30000081240000000200000002000000012719347c00000428000000230000000c00000000000000000000001900000000usr/include/sys/ttydev.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TTYDEV_H
#define _SYS_TTYDEV_H

#ident	"@(#)/usr/include/sys/ttydev.h.sl 1.1 4.0 10/15/90 27730 AT&T-SF"

/*	@(#)ttydev.h 2.6 88/02/08 SMI; from UCB 4.3 83/05/18	*/

/*
 * Terminal definitions related to underlying hardware.
 */

/*
 * Speeds
 */
#define B0	0
#define B50	1
#define B75	2
#define B110	3
#define B134	4
#define B150	5
#define B200	6
#define B300	7
#define B600	8
#define B1200	9
#define	B1800	10
#define B2400	11
#define B4800	12
#define B9600	13
#define B19200	14
#define B38400	15
#define EXTA	14
#define EXTB	15

#if 0
/*
 * Hardware bits.
 * SHOULD NOT BE HERE.
 */
#define	DONE	0200
#define	IENABLE	0100

/*
 * Modem control commands.
 */
#define	DMSET		0
#define	DMBIS		1
#define	DMBIC		2
#define	DMGET		3

#endif /* end if 0 comment */

#endif /*_SYS_TTYDEV_H */
07070100005a31000081240000000200000002000000012719347c00000699000000230000000c00000000000000000000001b00000000usr/include/sys/tuneable.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TUNEABLE_H
#define _SYS_TUNEABLE_H

#ident	"@(#)/usr/include/sys/tuneable.h.sl 1.1 4.0 10/15/90 37437 AT&T-SF"

typedef struct tune {
	int	t_gpgslo;	/* If freemem < t_getpgslow, then start	*/
				/* to steal pages from processes.	*/
	int	t_gpgshi;	/* Once we start to steal pages, don't	*/
				/* stop until freemem > t_getpgshi.	*/
	int	t_padd;		/* Padding for driver compatibility	*/
	int	t_notused;	/* Not used				*/
	int	t_ageinterval;	/* Age process every so many seconds	*/
	int	t_padd1[3];	/* Padding for driver compatibility 	*/
	int	t_fsflushr;	/* The rate at which fsflush is run in	*/
				/* seconds.				*/
	int	t_minarmem;	/* The minimum available resident (not	*/
				/* swapable) memory to maintain in 	*/
				/* order to avoid deadlock.  In pages.	*/
	int	t_minasmem;	/* The minimum available swapable	*/
				/* memory to maintain in order to avoid	*/
				/* deadlock.  In pages.			*/
	int	t_dmalimit;	/* Last (exclusive) Dmaable Page No.	*/
	int t_flckrec;		/* max number of active frlocks */
	int	t_minakmem;	/* Threshhold of the minimum number of  */
				/* pages reserved as the soft kmem_alloc*/
				/* threshold to avoid deadlock 		*/
} tune_t;

extern tune_t	tune;

/*	The following is the default value for t_gpgsmsk.  It cannot be
 *	defined in /etc/master or /etc/system due to limitations of the
 *	config program.
 */

#define	GETPGSMSK	PG_REF|PG_NDREF

#endif	/* _SYS_TUNEABLE_H */
   07070100005a32000081240000000200000002000000012719347c000016cd000000230000000c00000000000000000000001800000000usr/include/sys/types.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_TYPES_H
#define _SYS_TYPES_H

#ident	"@(#)/usr/include/sys/types.h.sl 1.1 4.0 10/15/90 3052 AT&T-SF"


/* POSIX Extensions */

typedef	unsigned char	uchar_t;
typedef	unsigned short	ushort_t;
typedef	unsigned int	uint_t;
typedef	unsigned long	ulong_t;


/* For BSD compatibility */
typedef char *		addr_t; /* ?<core address> type */

typedef	char *		caddr_t;	/* ?<core address> type */
typedef	long		daddr_t;	/* <disk address> type */
typedef	long		off_t;		/* ?<offset> type */
typedef	short		cnt_t;		/* ?<count> type */
typedef struct _label { int val[6]; } label_t;
typedef	ulong_t paddr_t;	/* <physical address> type */
typedef	uchar_t use_t;		/* use count for swap.  */
typedef	short		sysid_t;
typedef	short		index_t;
typedef	short		lock_t;		/* lock work for busy wait */
typedef enum boolean { B_FALSE, B_TRUE } boolean_t;
/*
 * New type from XENIX
 */
typedef char *      faddr_t;    /* same as caddr_t for 8086/386 */


typedef ulong_t k_sigset_t;	/* kernel signal set type */
typedef ulong_t k_fltset_t;	/* kernel fault set type */

/*
 * The following type is for various kinds of identifiers.  The
 * actual type must be the same for all since some system calls
 * (such as sigsend) take arguments that may be any of these
 * types.  The enumeration type idtype_t defined in sys/procset.h
 * is used to indicate what type of id is being specified.
 */

typedef long		id_t;		/* A process id,	*/
					/* process group id,	*/
					/* session id, 		*/
					/* scheduling class id,	*/
					/* user id, or group id.*/


/* Typedefs for dev_t components */

typedef ulong_t	major_t;	/* major part of device number */
typedef ulong_t	minor_t;	/* minor part of device number */


/*
 * For compatilbility reasons the following typedefs (prefixed o_) 
 * can't grow regardless of the EFT definition. Although,
 * applications should not explicitly use these typedefs
 * they may be included via a system header definition.
 * WARNING: These typedefs may be removed in a future
 * release. 
 *		ex. the definitions in s5inode.h remain small 
 *			to preserve compatibility in the S5
 *			file system type.
 */
typedef	ushort_t o_mode_t;		/* old file attribute type */
typedef short	o_dev_t;		/* old device type	*/
typedef	ushort_t o_uid_t;		/* old UID type		*/
typedef	o_uid_t	o_gid_t;		/* old GID type		*/
typedef	short	o_nlink_t;		/* old file link type	*/
typedef short	o_pid_t;		/* old process id type */
typedef ushort_t o_ino_t;		/* old inode type	*/


/* POSIX and XOPEN Declarations */

typedef	int		key_t;		/* IPC key type */
typedef	ulong_t	mode_t;			/* file attribute type	*/
typedef	long	uid_t;			/* UID type		*/
typedef	uid_t	gid_t;			/* GID type		*/
typedef	ulong_t nlink_t;		/* file link type	*/
typedef ulong_t	dev_t;		/* expanded device type */
typedef ulong_t	ino_t;		/* expanded inode type */
typedef long	pid_t;			/* process id type	*/

#ifndef _SIZE_T
#define _SIZE_T
typedef	uint_t	size_t;		/* len param for string funcs */
#endif
typedef ushort_t      sel_t;      /* Selector type */

#ifndef _TIME_T
#define _TIME_T
typedef	long		time_t;		/* time of day in seconds */
#endif	/* END _TIME_T */

#ifndef _CLOCK_T
#define _CLOCK_T
typedef	long		clock_t; /* relative time in a specified resolution */
#endif	/* ifndef _CLOCK_T */


#if (defined(_KERNEL) || !defined(_POSIX_SOURCE))

typedef	struct { int r[1]; } *	physadr;
typedef	unsigned char	unchar;
typedef	unsigned short	ushort;
typedef	unsigned int	uint;
typedef	unsigned long	ulong;




#if defined(_KERNEL)

#define SHRT_MIN        -32768          /* min value of a "short int" */
#define SHRT_MAX        32767           /* max value of a "short int" */
#define USHRT_MAX       65535		/* max value of an "unsigned short int" */
#define INT_MIN         (-2147483647-1)     /* min value of an "int" */
#define INT_MAX         2147483647      /* max value of an "int" */
#define UINT_MAX        4294967295	/* max value of an "unsigned int" */
#define LONG_MIN        (-2147483647-1)		/* min value of a "long int" */
#define LONG_MAX        2147483647      /* max value of a "long int" */
#define ULONG_MAX       4294967295 	/* max value of an "unsigned long int" */

#endif	/* defined(_KERNEL) */


#define	P_MYPID	((pid_t)0)

/*
 * The following is the value of type id_t to use to indicate the
 * caller's current id.  See procset.h for the type idtype_t
 * which defines which kind of id is being specified.
 */

#define	P_MYID	(-1)
#define NOPID (pid_t)(-1)

#ifndef NODEV
#define NODEV (dev_t)(-1)
#endif

/*
 * A host identifier is used to uniquely define a particular node
 * on an rfs network.  Its type is as follows.
 */

typedef	long	hostid_t;

/*
 * The following value of type hostid_t is used to indicate the
 * current host.  The actual hostid for each host is in the
 * kernel global variable rfs_hostid.
 */

#define	P_MYHOSTID	(-1)

typedef unsigned char	u_char;
typedef unsigned short	u_short;
typedef unsigned int	u_int;
typedef unsigned long	u_long;
typedef struct _quad { long val[2]; } quad;	/* used by UFS */


/*
 * Nested include for BSD/sockets source compatibility.
 * (The select macros used to be defined here).
 */
#include <sys/select.h>

#endif /* END (defined(_KERNEL) || !defined(_POSIX_SOURCE)) */

/*
 * These were added to allow non-ANSI compilers to compile the system.
 */

#ifdef __STDC__

#ifndef _VOID
#define _VOID	void
#endif

	/* End of ANSI section */

#else

#ifndef _VOID
#define _VOID	char
#endif

#ifndef const
#define const
#endif

#ifndef volatile
#define volatile
#endif

#endif /* of non-ANSI section */

#endif	/* _SYS_TYPES_H */
   07070100005a33000081240000000200000002000000012719347c000002d9000000230000000c00000000000000000000001900000000usr/include/sys/uadmin.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_UADMIN_H
#define _SYS_UADMIN_H

#ident	"@(#)/usr/include/sys/uadmin.h.sl 1.1 4.0 10/15/90 32649 AT&T-SF"

#define	A_REBOOT	1
#define	A_SHUTDOWN	2
#define	A_REMOUNT	4
#define A_CLOCK		8
#define A_SWAPCTL	16
#define A_SETCONFIG	128

#define	AD_HALT		0
#define	AD_BOOT		1
#define	AD_IBOOT	2

/*
 * fcn's for A_SETCONFIG
 */
#define AD_PANICBOOT	1

#if defined(__STDC__) && !defined(_KERNEL)
int uadmin(int, int, int);
#endif

#endif	/* _SYS_UADMIN_H */
   07070100005a34000081240000000200000002000000012719347c00000685000000230000000c00000000000000000000001b00000000usr/include/sys/ucontext.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_UCONTEXT_H
#define _SYS_UCONTEXT_H

#ident	"@(#)/usr/include/sys/ucontext.h.sl 1.1 4.0 10/15/90 36610 AT&T-SF"

#include <sys/types.h>
#include <sys/regset.h>
#include <sys/signal.h>
#include <sys/user.h>

typedef struct {
	gregset_t	gregs;	/* general register set */
	fpregset_t 	fpregs;	/* floating point register set */
} mcontext_t;

typedef struct ucontext {
	u_long		uc_flags;
	struct ucontext	*uc_link;
	sigset_t   	uc_sigmask;
	stack_t 	uc_stack;
	mcontext_t 	uc_mcontext;
	long		uc_filler[5];	/* pad structure to 512 bytes */
} ucontext_t;

#define GETCONTEXT	0
#define SETCONTEXT	1

/* 
 * values for uc_flags
 * these are implementation dependent flags, that should be hidden
 * from the user interface, defining which elements of ucontext
 * are valid, and should be restored on call to setcontext
 */

#define	UC_SIGMASK	001
#define	UC_STACK	002
#define	UC_CPU		004
#define	UC_FP		010

#ifdef WEITEK
#define UC_WEITEK	020
#endif /* WEITEK */


#ifdef WEITEK
#define UC_MCONTEXT (UC_CPU|UC_FP|UC_WEITEK)
#else
#define UC_MCONTEXT (UC_CPU|UC_FP)
#endif /* WEITEK */



/* 
 * UC_ALL specifies the default context
 */

#define UC_ALL		(UC_SIGMASK|UC_STACK|UC_MCONTEXT)

#ifdef _KERNEL

#if defined(__STDC__)
void savecontext(ucontext_t *, k_sigset_t);
void restorecontext(ucontext_t *);
#else
void savecontext();
void restorecontext();
#endif

#endif
#endif /* _SYS_UCONTEXT_H */
   07070100005a35000081240000000200000002000000012719347c00000568000000230000000c00000000000000000000001600000000usr/include/sys/uio.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_UIO_H
#define _SYS_UIO_H

#ident	"@(#)/usr/include/sys/uio.h.sl 1.1 4.0 10/15/90 47437 AT&T-SF"

/*
 * I/O parameter information.  A uio structure describes the I/O which
 * is to be performed by an operation.  Typically the data movement will
 * be performed by a routine such as uiomove(), which updates the uio
 * structure to reflect what was done.
 */

typedef struct iovec {
	caddr_t	iov_base;
	int	iov_len;
} iovec_t;

typedef struct uio {
	iovec_t	*uio_iov;	/* pointer to array of iovecs */
	int	uio_iovcnt;	/* number of iovecs */
	off_t	uio_offset;	/* file offset */
	short	uio_segflg;	/* address space (kernel or user) */
	short	uio_fmode;	/* file mode flags */
	daddr_t	uio_limit;	/* u-limit (maximum "block" offset) */
	int	uio_resid;	/* residual count */
} uio_t;

/*
 * I/O direction.
 */
typedef enum uio_rw { UIO_READ, UIO_WRITE } uio_rw_t;

/*
 * Segment flag values.
 */
typedef enum uio_seg { UIO_USERSPACE, UIO_SYSSPACE, UIO_USERISPACE } uio_seg_t;

int	uiomove();
int	ureadc();	/* should be errno_t in future */
int	uwritec();
int	uiomvuio();
void	uioskip();

#endif	/* _SYS_UIO_H */
07070100005a36000081240000000200000002000000012719347c000005c5000000230000000c00000000000000000000001900000000usr/include/sys/ulimit.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_ULIMIT_H
#define _SYS_ULIMIT_H

#ident	"@(#)/usr/include/sys/ulimit.h.sl 1.1 4.0 10/15/90 56189 AT&T-SF"
/*	Copyright (c) 1987, 1988 Microsoft Corporation	*/
/*	  All Rights Reserved	*/

/*	This Module contains Proprietary Information of Microsoft  */
/*	Corporation and should be treated as Confidential.	   */


/*
 *	@(#) ulimit.h 1.2 88/05/04 head.sys:ulimit.h
 */

/*
 * THIS FILE CONTAINS CODE WHICH IS DESIGNED TO BE
 * PORTABLE BETWEEN DIFFERENT MACHINE ARCHITECTURES
 * AND CONFIGURATIONS. IT SHOULD NOT REQUIRE ANY
 * MODIFICATIONS WHEN ADAPTING XENIX TO NEW HARDWARE.
 */

/*
 * The following are codes which can be
 * passed to the ulimit system call. (Xenix compatible.)
 */

#define UL_GFILLIM	1	/* get file limit */
#define UL_SFILLIM	2	/* set file limit */
#define UL_GMEMLIM	3	/* get process size limit */
#define UL_GDESLIM	4	/* get file descriptor limit */
#define UL_GTXTOFF	64	/* get text offset */

/*
 * The following are symbolic constants required for
 * X/Open Conformance.   They are the equivalents of
 * the constants above.
 */

#define UL_GETFSIZE	UL_GFILLIM	/* get file limit */
#define UL_SETFSIZE	UL_SFILLIM	/* set file limit */

#endif        /* _SYS_ULIMIT_H */
   07070100005c76000081240000000200000002000000012719347c000004ff000000230000000c00000000000000000000001900000000usr/include/sys/unistd.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/unistd.h.sl 1.1 4.0 10/15/90 13537 AT&T-SF"
/* WARNING: This is an implementation-specific header,
** its contents are not guaranteed. Applications
** should include <unistd.h> and not this header.
*/

#ifndef _SYS_UNISTD_H
#define _SYS_UNISTD_H


/* command names for POSIX sysconf */

#define _SC_ARG_MAX	1
#define _SC_CHILD_MAX	2
#define _SC_CLK_TCK	3
#define _SC_NGROUPS_MAX 4
#define _SC_OPEN_MAX	5
#define _SC_JOB_CONTROL 6
#define _SC_SAVED_IDS	7
#define _SC_VERSION	8
#define _SC_PASS_MAX	9
#define _SC_LOGNAME_MAX	10
#define _SC_PAGESIZE	11
#define _SC_XOPEN_VERSION 12

/* command names for POSIX pathconf */

#define _PC_LINK_MAX	1
#define _PC_MAX_CANON	2
#define _PC_MAX_INPUT	3
#define _PC_NAME_MAX	4
#define _PC_PATH_MAX	5
#define _PC_PIPE_BUF	6
#define _PC_NO_TRUNC	7
#define _PC_VDISABLE	8
#define _PC_CHOWN_RESTRICTED	9

#ifndef _POSIX_VERSION
#define _POSIX_VERSION	198808L
#endif

#ifndef _XOPEN_VERSION
#define _XOPEN_VERSION 3
#endif


#endif	/* _SYS_UNISTD_H */
 07070100005876000081240000000200000002000000012719347c000036a2000000230000000c00000000000000000000001700000000usr/include/sys/user.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_USER_H
#define _SYS_USER_H

#ident	"@(#)/usr/include/sys/user.h.sl 1.1 4.0 10/15/90 29765 AT&T-SF"

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signal.h> /* XXX - only needed for MAXSIG */
#include <sys/siginfo.h>
#include <sys/tss.h>
#include <sys/seg.h>
#include <sys/resource.h>
#include <sys/exec.h>

/*
 * The user structure; one allocated per process.  Contains all the
 * per-process data that doesn't need to be referenced while the
 * process is swapped.
 *
 * The user block is USIZE*click bytes long; resides at virtual kernel
 * address 0xE0000000 on the 386; contains the system stack per user;
 * is cross referenced with the proc structure for the same process.
 *
 *			NOTE  --  NOTE
 *
 * 	WHEN THIS HEADER CHANGES, BOTH ml/misc.s AND ml/ttrap.s MUST BE
 *	   EXAMINED FOR ANY DEPENDENCIES UPON OFFSETS WITHIN THE UBLOCK.
 *	   IN PARTICULAR - .SET's ARE DONE ON:
 *				pr_base,
 *				pr_size,
 *				pr_off, and
 *				pr_scale
 *
 **********************************************************************
 * 
 */

/*
 * User file descriptors are allocate dynamically, in multiples
 * of NFPCHUNK.  WARNING: ml/misc.s:vstart_s knows about the
 * size of struct ufchunk.  If this changes, or in NFPCHUNK is
 * changed, remember to update misc.s.
 */

#define NFPCHUNK 24

struct ufchunk {
	struct file *uf_ofile[NFPCHUNK];
	char uf_pofile[NFPCHUNK];
	struct ufchunk *uf_next;
};

#define UF_FDLOCK	0x2	/* file descriptor locked (SysV-style) */

#define MAXSYSARGS	8	/* Maximum # of arguments passed to a syscall */ 
#define PSARGSZ		80	/* Space for exec arguments (used by ps(1)) */ 

#define	PSCOMSIZ	14

#define KSTKSZ		3712

typedef struct {		/* kernel syscall set type */
	long	word[16];
} k_sysset_t;

/* flags for u_sigflag field */
#define SOMASK 		0x001	/* use u_sigoldmask on return from signal */

typedef	struct	user {
	char	u_stack[KSTKSZ];/* kernel stack */
	char	u_stack_filler_1[2];
	/* floating point support variables */
	char    u_fpvalid;              /* flag if saved state is valid     */
	char    u_weitek;               /* flag if process uses weitek chip */
	union {
		struct  fpstate         /* floating point extension state   */
		{
			int     state[27];/* 287/387 saved state           */
			int     status;   /* status word saved at exception */
		} u_fpstate;
		struct	fp_emul
		{
			char	fp_emul[246];  /* (extras for emulator) */
			char	fp_epad[2];
		} fp_emul;
	} u_fps;
	long	u_weitek_reg[33];	/* bits needed to save weitek state */
					/* NOTE: If the WEITEK is actually  */
					/* present, only 32 longs will be   */
					/* used, but if it is not, the      */
					/* emulator will need 33.           */

	/* NOTE: The second page of the uarea must begin here.
	   That is, the offset at this point must be NBPP. */

	struct tss386 *u_tss;	/* pointer to user TSS */
	ushort	u_sztss;	/* size of tss (including bit map) */

	char	u_sigfault;	/* catch general protection violations
				   caused by user modifying his stack
				   where the old state info is kept */
	char	u_usigfailed;	/* allows the user to know that he caused
				   a general protection violation by
				   modifying his register save area used
				   when the user was allowed to do his own
				   signal processing */

	ulong	u_sub;		/* stack upper bound.
				   The address of the first byte of
				   the first page of user stack
				   allocated so far */
#ifdef DEBUG
	long	u_aoutstamp;
	char	u_filler1[8];
#else
     	char	u_filler1[12];
#endif

	/* the addr/size of locked memory for the raw disk async i/o */
	caddr_t	u_raioaddr;
	uint	u_raiosize;

	caddr_t	u_escbug;	/* address of 2nd page of hung ESC instruction;
				   used in workaround for 80386 B1 stepping
				   errata 17 */

	/* Segment descriptors for quick-loading */
	struct seg_desc	u_tss_desc;
	struct seg_desc	u_ldt_desc;

	/*
	 * Pointer to function to handle user-space external
	 * memory faults encountered in the kernel.
	 */
	int	u_caddrflt;

	/*
	 * Number of shared-memory segments currently attached.
	 */
	char	u_nshmseg;

	/*
	 * The following for RFS.  u_srchan is needed because ioctls on
	 * the server can hit RF_SERVER() hooks in copyin and copyout,
	 * and rcopying/rcopyout need the implicit parameter.
	 */
	ushort		rfs_pad0;
	ushort 		rfs_pad1;
	int 		u_syscall;	/* system call number */
	struct sndd	*u_srchan;	/* server channel back to client */
	long		rfs_pad2;
	ulong		u_userstack;

	long	u_bsize;		/* block size of device */

	struct execsw	*u_execsw;	/* pointer into execsw[] for the
					   current executable */

	int	u_ageinterval;		/* pageing ageing countdown counter */
	char 	u_psargs[PSARGSZ];	/* arguments from exec */	
	char	*u_tracepc;		/* Return PC if tracing enabled */

	int	u_arg[MAXSYSARGS];	/* arguments to current system call */
	label_t	u_qsav;			/* longjmp label for quits and intrs */

	/*
	 * The following (u_segflg and u_error) are obsolete.
	 */
	char	u_segflg;		/* 0=user D, 1=system, 2=user I */
	char	u_error;		/* return error code */

	/*
	 * The following four fields are for backward compatibility
	 * with old device drivers; the actual user credentials are
	 * found through p_cred in struct proc. These fields may
	 * not support valid uid's or gid's when the system is
	 * configured with large user id's.
	 */

	o_uid_t	u_uid;		/* effective user id */
	o_gid_t	u_gid;		/* effective group id */
	o_uid_t	u_ruid;		/* real user id */
	o_gid_t	u_rgid;		/* real group id */

	proc_t *u_procp;		/* pointer to proc structure */

	int	*u_ap;			/* pointer to arglist */

	/*
	 * The following (u_r through u_rablock) are all obsolete.
	 */
	union {
		struct	{
			int	r_v1;
			int	r_v2;
		} r_reg;
		off_t	r_off;
		time_t	r_time;
	} u_r;
	caddr_t	u_base;			/* base address for IO */
	unsigned u_count;		/* bytes remaining for IO */
	off_t	u_offset;		/* offset in file for IO */
	short	u_fmode;		/* file mode for IO */
	ushort	u_pbsize;		/* Bytes in block for IO */
	ushort	u_pboff;		/* offset in block for IO */
	short	u_errcnt;		/* syscall error count */
	daddr_t	u_rablock;		/* read ahead block address */

	int	u_sysabort;		/* Debugging: if set, abort syscall */
	k_sysset_t u_entrymask;		/* syscall stop-on-entry mask */
	k_sysset_t u_exitmask;		/* syscall stop-on-exit mask */

	struct vnode *u_cdir;		/* current directory */

	struct vnode *u_rdir;		/* root directory */

	struct rlimit u_rlimit[RLIM_NLIMITS];     /* resource usage limits */

	uint	u_tsize;		/* text size (clicks) */
	uint	u_dsize;		/* data size (clicks) */
	uint	u_ssize;		/* stack size (clicks) */

	k_siginfo_t u_siginfo;		/* debugger interface: stop-on-fault */

	int	u_systrap;		/* Are any syscall mask bits set? */ 

	int	u_execid;
	long	u_execsz;


		/* WARNING: the definitions for u_ttyp and
		** u_ttyd will be deleted at the next major
		** release following SVR4.
		*/

	o_pid_t  *u_ttyp;		/* for binary compatibility only ! */
	o_dev_t  u_ttyd;		/* for binary compatibility only -
					** NODEV will be assigned for large
					** controlling terminal devices.
					*/

	/*
	 * Flag to indicate there is a signal or event pending to
	 * the current process.  Used to make a quick check just
	 * prior to return from kernel to user mode.
	 */
	char	u_sigevpend;


	/*
	 * u_utime, u_stime, u_cutime, u_cstime have been moved to proc table
	 */

	clock_t	u_uservirt;		/* User virtual time */
	clock_t	u_procvirt;		/* Process virtual time */

	int	*u_ar0;			/* address of user's saved R0 */

	int	u_sigflag;		/* per-process signal flags */
	struct ucontext *u_oldcontext;	/* previous user context */
	stack_t u_sigaltstack;		/* sp & on-stack state variable */
	k_sigset_t u_signodefer;	/* signals defered when caught */
	k_sigset_t u_sigonstack;	/* signals taken on alternate stack */
	k_sigset_t u_sigresethand;	/* signals reset when caught */
	k_sigset_t u_sigrestart;	/* signals that restart system calls */
	k_sigset_t u_sigoldmask;	/* for sigsuspend */
	k_sigset_t u_sigmask[MAXSIG];	/* signals held while in catcher */
	void	(*u_signal[MAXSIG])();	/* Disposition of signals */
	void	(*u_sigreturn)();	/* for cleanup (signal/sigset handlers)*/

	/*
	 * These offsets must be reflected in ttrap.s and misc.s.
	 */

	struct prof {			/* profile arguments */
		short	*pr_base;	/* buffer base */
		unsigned pr_size;	/* buffer size */
		unsigned pr_off;	/* pc offset */
		unsigned pr_scale;	/* pc scaling */
	} u_prof;

	/* XENIX SUPPORT */

	ulong	u_renv;			/* runtime environment. 	  */
					/*   for meaning of bits:	  */
					/*     0-15  see x_renv (x.out.h) */
					/*    16-23  see x_cpu  (x.out.h) */
					/*    24-31  see below		  */

	/* End XENIX Support */

	/*
	 * Executable file info.
	 */
	struct exdata {
		struct    vnode  *vp;
		size_t    ux_tsize;	/* text size */
		size_t    ux_dsize;	/* data size */
		size_t    ux_bsize;	/* bss size */
		size_t    ux_lsize;  	/* lib size */
		long      ux_nshlibs; 	/* number of shared libs needed */
		short     ux_mag;   	/* magic number MUST be here */
		off_t     ux_toffset;	/* file offset to raw text */
		off_t     ux_doffset;	/* file offset to raw data */
		off_t     ux_loffset;	/* file offset to lib sctn */
		caddr_t   ux_txtorg;	/* start addr of text in mem */
		caddr_t   ux_datorg;	/* start addr of data in mem */
		caddr_t	  ux_entloc;	/* entry location */
		ulong	  ux_renv;	/* runtime environment */
	} u_exdata;

	char	u_comm[PSCOMSIZ];

	time_t	u_start;
	clock_t	u_ticks;
	long	u_mem;
	long	u_ior;
	long	u_iow;
	long	u_iosw;
	long	u_ioch;
	char	u_acflag;
	mode_t	u_cmask;		/* mask for file creation */

	k_sigset_t	u_oldsig;	/* signals using old-style handlers
					   (i.e. set by signal() or sigset()) */

	/*
	 * Pointer to function to handle kernel-space external
	 * memory faults encountered in the kernel.
	 */
	int	u_kernflt;		/* on fault, jumped to with
					   fault code in %eax */

	char	u_filler2[124];		/* unused */

	int     u_fpintgate[2];         /* fp intr gate descriptor image   */

	/* i286 emulation variables */
	int    *u_callgatep;            /* pointer to call gate in gdt  */
	int     u_callgate[2];          /* call gate descriptor image   */
	int     u_ldtmodified;          /* if set, LDT was modified     */
	ushort	u_ldtlimit;		/* current size (index) of ldt */

	/* Flag single-step of lcall for a system call. */
	/* The signal is delivered after the system call*/
	char    u_debugpend;            /* SIGTRAP pending for this proc */

	/* debug registers, accessible by ptrace(2) but monitored by kernel */
	char    u_debugon;              /* Debug registers in use, set by kernel */
	int     u_debugreg[8];
	short	u_lock;			/* process/text locking flags */

	int u_nofiles;			/* number of open file slots */
	struct ufchunk u_flist;		/* open file list */
} user_t;

extern struct user u;

/* floating u area support */
#define KERNSTACK	KSTKSZ
struct seguser {
	union {
		char segu_stack[KERNSTACK];
		struct user segu_u;
	} segusr;
};
#define KUSER(seg)	(&((seg)->segusr.segu_u))


#define	u_rval1	u_r.r_reg.r_v1
#define	u_rval2	u_r.r_reg.r_v2
#define	u_roff	u_r.r_off
#define	u_rtime	u_r.r_time

#define	u_cred	u_procp->p_cred


/* ioflag values: Read/Write, User/Kernel, Ins/Data */

#define	U_WUD	0
#define	U_RUD	1
#define	U_WKD	2
#define	U_RKD	3

/* defines for Weitek */

#define	WEITEK_CONTEXT	0
#define	WEITEK_CAE	0xFFFFFF00	/* clear accum. exception byte	*/

/* XENIX SUPPORT */

/*
 * defines for bits 24-31 of u_renv and various macros for accessing
 * fields of u_renv.  All bits not currently defined are reserved
 * for future expansion.
 */
#define U_ISCOFF	0x1000000
#define U_ISELF		0x2000000
#define	U_RENVMASK	0x3000000	/* runtime environment bits */

#define	U_CPUTYPE	(XC_CPU << 16)
#define	U_IS386		(XC_386 << 16)
#define	U_ISWSWAP	(XC_WSWAP << 16)

/* binary types */
#define	isCOFF		((u.u_renv & U_RENVMASK) == U_ISCOFF)	/* 386 COFF */
#define	isXOUT		((u.u_renv & U_RENVMASK) == 0)		/* 386 x.out */

#define	IS386()		(((u.u_renv >> 16) & XC_CPU) == XC_386)

/*
 * The following define is used to indicate that the program being
 * exec'd is one of the 286 emulators.  This bit is set in u_renv.
 */
#define	UE_EMUL		0x4000000	/* 286 emulator */
#define	is286EMUL	((u.u_renv & UE_EMUL) == UE_EMUL)

/*
 * Defines for badvise bits of u_renv and various macros for accessing
 * these bits.  
 */

#define UB_PRE_SV	0x8000000	/* badvise pre-System V */
#define UB_XOUT		0x10000000	/* badvise x.out */
#define UB_LOCKING	0x20000000	/* badvise locking() system call  */
					/*      (for kernel use only)     */
#define UB_FCNTL	0x40000000	/* badvise fcntl() system call    */
					/*      (for kernel use only)     */
#define UB_XSDSWTCH	0x80000000	/* badvise XENIX shared data context */
					/*	switching		     */

				/* badvise indicates x.out behavior */
#define BADVISE_XOUT	((u.u_renv & UB_XOUT) == UB_XOUT)

				/* badvise indicates pre-System V behavior */
#define BADVISE_PRE_SV	((u.u_renv & UB_PRE_SV) == UB_PRE_SV)
				/* badvise indicates XENIX locking() call */
#define ISLOCKING	((u.u_renv & UB_LOCKING) == UB_LOCKING)
				/* badvise indicates fcntl() call */
#define ISFCNTL		((u.u_renv & UB_FCNTL) == UB_FCNTL)
				/* badvise indicates XENIX shared data
				 * 	context switching is enabled
				 */
#define BADVISE_XSDSWTCH ((u.u_renv & UB_XSDSWTCH) == UB_XSDSWTCH)
				/* x.out binary or badvise indicates x.out */
#define VIRTUAL_XOUT	(isXOUT || BADVISE_XOUT)

/* End XENIX Support */
/* flag values for NFA */
#define NFA_SERVER	0x4000	/* the NFA network server */
#define NFA_CASELESS	0x8000	/* caseless support for DOS */


#ifdef _KERNEL

#if defined(__STDC__)
extern void addupc(void(*)(), struct prof *, int);
#else
extern void addupc();
#endif	/* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _SYS_USER_H */

  07070100005a39000081240000000200000002000000012719347c00000318000000230000000c00000000000000000000001800000000usr/include/sys/ustat.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ustat.h.sl 1.1 4.0 10/15/90 51894 AT&T-SF"

/* WARNING: The ustat system call will become obsolete in the
** next major release following SVR4. Application code should
** migrate to the replacement system call statvfs(2).
*/

#ifndef _SYS_USTAT_H
#define _SYS_USTAT_H

#include <sys/types.h>


struct  ustat {
	daddr_t	f_tfree;	/* total free */
	o_ino_t	f_tinode;	/* total inodes free */
	char	f_fname[6];	/* filsys name */
	char	f_fpack[6];	/* filsys pack name */
};



#endif /* _SYS_USTAT_H */
07070100005a3a000081240000000200000002000000012719347c00000234000000230000000c00000000000000000000001800000000usr/include/sys/utime.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/* utimbuf is used by utime(2) */

#ifndef _SYS_UTIME_H
#define _SYS_UTIME_H

#ident	"@(#)/usr/include/sys/utime.h.sl 1.1 4.0 10/15/90 61003 AT&T-SF"
#include <sys/types.h>

struct utimbuf {
	time_t actime;		/* access time */
	time_t modtime;		/* modification time */
};

#endif	/* _SYS_UTIME_H */
07070100005a3b000081240000000200000002000000012719347c00000aa0000000230000000c00000000000000000000001a00000000usr/include/sys/utsname.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_UTSNAME_H
#define _SYS_UTSNAME_H

#ident	"@(#)/usr/include/sys/utsname.h.sl 1.1 4.0 10/15/90 28517 AT&T-SF"

/*
 * If you are compiling the kernel, the value used in initializing
 * the utsname structure in the master.d/kernel file better be the
 * same as SYS_NMLN.
 */
#if (defined (_POSIX_SOURCE) || defined(_XOPEN_SOURCE)) && !defined(_KERNEL)

#if !defined(_STYPES)
#define _SYS_NMLN	257	/* 4.0 size of utsname elements.*/
				/* Must be at least 257 to 	*/
				/* support Internet hostnames.  */
#else
#define _SYS_NMLN	9	/* old size of utsname elements */
#endif	/* _STYPES */


struct utsname {
	char	sysname[_SYS_NMLN];
	char	nodename[_SYS_NMLN];
	char	release[_SYS_NMLN];
	char	version[_SYS_NMLN];
	char	machine[_SYS_NMLN];
};

#else /*!defined(POSIX_SOURCE) && !defined(_XOPEN_SOURCE) || defined(_KERNEL)*/

#if !defined(_STYPES)
#define SYS_NMLN	257	/* 4.0 size of utsname elements.*/
				/* Must be at least 257 to 	*/
				/* support Internet hostnames.  */
#else
#define SYS_NMLN	9	/* old size of utsname elements */
#endif	/* _STYPES */

struct utsname {
	char	sysname[SYS_NMLN];
	char	nodename[SYS_NMLN];
	char	release[SYS_NMLN];
	char	version[SYS_NMLN];
	char	machine[SYS_NMLN];
};


#define XSYS_NMLN   9   /* size of utsname elements for XENIX */
struct xutsname {
    char    sysname[XSYS_NMLN];
    char    nodename[XSYS_NMLN];
    char    release[XSYS_NMLN];
    char    version[XSYS_NMLN];
    char    machine[XSYS_NMLN];
    char    reserved[15];
    unsigned short sysorigin;   /* original supplier of the system */
    unsigned short sysoem;      /* OEM for this system */
    long    sysserial;      /* serial number of this system */
};

extern struct xutsname xutsname;

#endif /* defined (_POSIX_SOURCE) || defined(_XOPEN_SOURCE) */

#if !defined(_POSIX_SOURCE) 
extern struct utsname utsname;
#endif /* !defined(_POSIX_SOURCE) */

#if !defined(_KERNEL)
#if defined(__STDC__)

#if !defined(_STYPES)
static int uname(struct utsname *);
#else 
int uname(struct utsname *);
#endif /* !defined(_STYPES) */

int nuname(struct utsname *);
#else

#if !defined(_STYPES)
static int uname();
#else 
int uname();
#endif /* !defined(_STYPES) */

int nuname();
#endif	/* (__STDC__) */
#endif	/* !(KERNEL) */

#if !defined(_KERNEL) && !defined(_STYPES)
static int
uname(buf)
struct utsname *buf;
{
	int ret;

	ret = nuname(buf);
	return ret;
}
#endif /* !defined(_KERNEL) && !defined(_STYPES) */

#endif	/* _SYS_UTSNAME_H */
07070100005a3c000081240000000200000002000000012719347c0000038a000000230000000c00000000000000000000001900000000usr/include/sys/utssys.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/utssys.h.sl 1.1 4.0 10/15/90 21494 AT&T-SF"

/*
 * Definitions related to the utssys() system call. 
 */

/*
 * "commands" of utssys
 */
#define UTS_UNAME	0x0
#define UTS_USTAT	0x2	/* 1 was umask */
#define UTS_FUSERS	0x3

/*
 * Flags to UTS_FUSERS
 */
#define F_FILE_ONLY	0x1
#define F_CONTAINED	0x2

/*
 * structure yielded by UTS_FUSERS
 */
typedef struct f_user {
	pid_t	fu_pid;
	int	fu_flags;	/* see below */
	uid_t	fu_uid;	
} f_user_t;

/*
 * fu_flags values
 */
#define F_CDIR		0x1
#define F_RDIR		0x2
#define F_TEXT		0x4
#define F_MAP		0x8
#define F_OPEN		0x10
#define F_TRACE		0x20
#define F_TTY		0x40
  07070100005a3d000081240000000200000002000000012719347c000032fb000000230000000c00000000000000000000001600000000usr/include/sys/v86.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_V86_H
#define _SYS_V86_H

#ident	"@(#)/usr/include/sys/v86.h.sl 1.1 4.0 10/15/90 58979 AT&T-SF"

/*
 * LIM 4.0 changes:
 * Dual-Mode Floating Point support:
 * Selectable OPcode emulation hook:
 * Copyright (c) 1989 Phoenix Technologies Ltd.
 * All Rights Reserved.
*/

#include	<sys/seg.h>

typedef	unsigned char	uchar;

#define NV86TASKS       20              /* Maximum number of V86 tasks  */

#define V86VIRTSIZE     0x0100  /* Size of virtual 8086 in pages ( 1M bytes)*/
#define V86WRAPSIZE     0x0010  /* Size of copy/wrap in pages    (64K bytes)*/
#define V86SIZE         0x0400  /* Max size of v86 segment       ( 4M bytes)*/

/*
 * Definitions for Lotus/Intel/Microsoft Expanded Memory Emulation
*/
#define V86EMM_PGSIZE       0x4000  /* Size of Expanded memory page         */
#define V86EMM_LBASE    0x00200000  /* Expected lowest EMM logical page addr*/
#define V86EMM_LENGTH   0x00200000  /* Expected size EMM logical pages      */

/*
 * LIM 3 definitions -- for backward compatibility.
*/
#define V86EMM_PBASE    0x000D0000  /* EMM physical page address            */
#define V86EMM_PBASE0   0x000D0000  /* EMM physical page address            */
#define V86EMM_PBASE1   0x000D4000  /* EMM physical page address            */
#define V86EMM_PBASE2   0x000D8000  /* EMM physical page address            */
#define V86EMM_PBASE3   0x000DC000  /* EMM physical page address            */
#define V86EMM_NUMPGS	4	    /* # LIM 3 EMM physical pages           */

/*
 *  General definitions for a dual mode process
*/

#define XTSSADDR        ((caddr_t)0x110000L)    /* XTSS addr in user mem*/
#define ARPL            0x63            /* ARPL inst, V86 invalid opcode*/
#define V86_RCS         0xF000          /* Reset CS for V86 mode        */
#define V86_RIP         0xFFF0          /* Reset IP for V86 mode        */
#define V86_DELTA_NICE  10              /* Preferential nice for v86    */
#define V86_TIMER_BOUND 10              /* Pending ticks limit for ECT  */

#define V86_SLICE       25              /* Default timeslice, >1 v86proc*/
#define V86_SLICE_SHIFT 3               /* Max shift for time slice     */

#define	V86_PRI_NORM	0		/* Normal priority state	*/
#define	V86_PRI_LO	1		/* Low priority state, busywait	*/
#define	V86_PRI_HI	2		/* Hi priority state, pseudorupt*/
#define V86_PRI_XHI     3               /* Extra high, urgent pseudorupt*/
#define	V86_SHIFT_NORM	0		/* Timeslice shift for norm pri	*/
#define	V86_SHIFT_LO	V86_SLICE_SHIFT	/* Timeslice shift for lo   pri */
#define	V86_SHIFT_HI	V86_SLICE_SHIFT	/* Timeslice shift for hi   pri */

/*  The maximum number of arguments that can be used for v86() system
**  call is dependent on the maximum number of arguments allowed for
**  the sysi86 call in sysent.c. Since the v86() system call is a sub-
**  function (SI86V86) of the sysi86 call and v86() itself has sub-
**  functions, the maximum arguments for each sub-function of the v86()
**  system call is two less than the maximum allowed for the sysi86
**  system call. The value defined here is assumed in the library.
*/

#define V86SC_MAXARGS   3               /* Includes sub-func # of v86() */

/*  SI86V86 is a sub system call of the system call "sysi86". The following
**  definitions are sub system calls for SI86V86 and are processed in v86.c
*/

#define V86SC_INIT      1               /* v86init() system call        */
#define V86SC_SLEEP     2               /* v86sleep() system call       */
#define V86SC_MEMFUNC   3               /* v86memfunc() system call     */
#define V86SC_IOPL      4               /* v86iopriv () system call     */
/*
**  The V86 timer has a frequency of 18.2 times a second. The Unix
**  timer has a frequency of 100 times a second. So the following
**  value ensures that the ECT gets an interrupt at least as often
**  as it needs one.
*/

#define V86TIMER        5               /* Every 50 ms (20 times a second) */

/*  Software Interrupt mask bit array definitions
*/

#define V86_IMASKSIZE   256             /* Max number of software INTs  */
#define V86_IMASKBITS   ((V86_IMASKSIZE + 31) / 32)
					/* # of bits for software INTs  */

/*  The offsets of members "xt_viflag", "xt_signo" and "xt_hdlr" are
**  hard coded in the file "v86enter.s". So any changes to the struc-
**  that changes these offsets have to be reflected in this file.
**  This file is part of the ECT.
**
**  NOTE: The value of "xt_intr_pin" should be 0xFF or 0.
*/

typedef struct v86xtss
{   struct tss386 xt_tss;               /* Normal TSS structure         */
    unsigned int *xt_vflptr;		/* Ptr to 8086 virtual flags	*/
    unsigned char xt_magictrap;         /* Saved byte of virt intr      */
    unsigned char xt_magicstat;         /* Status of magic byte         */
    unsigned char xt_tslice_shft;       /* Time slice shift requested   */
    unsigned char xt_intr_pin;          /* Interrupt to virtual machine */
    time_t xt_lbolt;                    /* Lightning bolt value         */
    unsigned int xt_viflag;             /* Virtual interrupt flag       */
    unsigned int xt_vimask;             /* Mask for virtual interrupts  */
    unsigned int xt_signo;              /* Sig number on V86VI_SIGHDL   */
    int (* xt_hdlr)();                  /* Sig handler for V86VI_SIGHDL */
    unsigned int xt_timer_count;        /* Number of pending timer ticks*/
    unsigned int xt_timer_bound;        /* Ticks before forcing ECT in  */
    uint xt_imaskbits[V86_IMASKBITS];   /* Bit map for software INTs    */
    unsigned int xt_oldbitmap[32];      /* For I/O bitmap on old ECTs   */
    unsigned char xt_magic[4];          /* XTSS version indicator       */
    unsigned int xt_viurgent;           /* Mask for urgent interrupts   */
    unsigned int xt_vitoect;            /* Mask for interrupts to ECT   */
    ushort xt_vp_relcode;		/* VP/ix release code number    */
    ushort xt_oemcode;			/* OEM code number              */
    ushort xt_op_emul;			/* OPcode emulation enable mask */
    ushort xt_rsvd0;			/* Reserved for future expansion*/
    unsigned int xt_reserved[8];        /* Reserved for future expansion*/
}   xtss_t;

/*
 * VP/ix release code (refers to kernel,
 * but non-driver based, supported functionality).
 *
 * 1 = D-M FP + LIM 4.0
 * 2 = Ver.1 + OPcode emulation xtss hook.
 *
 * set into xt_vp_relcode in vx/v86.c:v86init()
*/
#define	VP_RELCODE	2

/* OPcode emulation bit defines (one bit/OPcode). */
#define EN_VTR		0x0001		/* CGA status port read */

/* DEFINE for CGA status emulation table (allocated in vx/space.c) */
#define CS_MAX		32

/*  Definitions for the field "xt_magicstat". The location "xt_magictrap"
**  is valid only when "xt_magicstat" field is set to XT_MSTAT_OPSAVED.
*/

#define XT_MSTAT_NOPROCESS      0       /* Do not process virtual intr  */
#define XT_MSTAT_PROCESS        1       /* Process virtual intr         */
#define XT_MSTAT_OPSAVED        2       /* v86 program opcode saved     */
#define XT_MSTAT_POSTING        3       /* Phoenix defined              */

struct v86parm
{   xtss_t   *xtssp;                    /* Ptr to XTSS in user data     */
    unsigned long szxtss;               /* Length in bytes of XTSS      */
    unsigned char magic[4];             /* XTSS version indicator       */
    unsigned long szbitmap;             /* Length in bytes of I/O bitmap*/
};

typedef struct v86memory
{   int      vmem_cmd;                  /* Sub command for screen func  */
    paddr_t  vmem_physaddr;             /* Physical memory base for map */
    caddr_t  vmem_membase;              /* Screen memory base           */
    int      vmem_memlen;               /* Length of screen memory      */
} v86memory_t;

/*  Definitions for the field "vmem_cmd".
*/

#define V86MEM_MAP      1               /* Map virt addr to physical    */
#define V86MEM_TRACK    2               /* Track memory modifications   */
#define V86MEM_UNTRACK  3               /* Untrack memory modifications */
#define V86MEM_UNMAP    4               /* Unmap virt addr              */
#define V86MEM_EMM      5               /* LIM expanded memory emulation*/
#define V86MEM_GROW     6               /* Grow Lim expanded memory     */

typedef struct v86dat
{
    proc_t  *vp_procp;                  /* Ptr to process's proc struc  */
    sel_t    vp_oldtr;                  /* Old task register            */
    unsigned short vp_szxtss;           /* Size of XTSS in user space   */
    xtss_t  *vp_xtss;                   /* Address of nailed XTSS       */
    v86memory_t vp_mem;                 /* Memory map/track definitions */
    char     vp_wakeup;                 /* Wakeup process on virt intr  */
    char     vp_slice_shft;             /* Last slice shift from xtss   */
    char     vp_nice;                   /* Requested nice from sys call */
    char     vp_hpnice;                 /* Nice value for high priority */
    char     vp_new_nice;		/* New nice value from v86setint*/
    char     vp_pri_state;		/* Priority state = hi,norm,lo	*/
					/* Virtual86 task fp save area  */
    uchar    vp_fpvalid;		/* Flag if saved state is valid */
    uchar    vp_fpproc;			/* Which task used the floating */
					/* point last.                  */
    union {
    	struct	vfpstate {		/* floating point extension state */
    		int	state[27];	/* 287/387 saved state */
    		int	status;		/* status word saved at exception */
    	} vp_fpstate;
    	struct	vfpemul {		/* FP emulator state */
    		char	fp_emul[246];	/* (extras for emulator) */
    		char	fp_epad[2];
    	} vp_fpemul;
    } vp_fpu;
    struct seg_desc	vp_xtss_desc;	/* Segment descriptor for xtss  */
}   v86_t;

/*
 * vp_fpvalid and vp_fpproc flag defines.
*/
#define	V86FPV_NOTVALID	0x00		/* V86 fp save area is not valid */
#define	V86FPV_VALID	0x01		/* V86 fp save area is valid */
#define	V86FPP_V86LAST	0x01		/* V86 task last to use FPU */
#define	V86FPP_ECTLAST	0x02		/* ECT task last to use FPU */

/*  Virtual interrupt bit definitions for the field "vp_viflag".
**  The low order 16 bits reflect the setting of the AT hardware
**  interrupts. The high order 16 bits are used for other inter-
**  rupts.
**
**  NOTE: The value of V86VI_SIGHDL is hard coded in the file
**  "v86enter.s". Any change to this value has to reflected in
**  this file. This file is part of the ECT.
*/

#define V86VI_NONE      0x00000000      /* No interrupts                */
#define V86VI_TIMER     0x00000001      /* Virtual timer interrupt      */
#define V86VI_KBD       0x00000002      /* Scancode rcvd when buf empty */
#define V86VI_SLAVE     0x00000004      /* Can be reused when needed    */
#define V86VI_SERIAL1   0x00000008      /* Serial port 1 state change   */
#define V86VI_SERIAL0   0x00000010      /* Serial port 0 state change   */
#define V86VI_PRL1      0x00000020      /* Parallel port 1 state change */
#define V86VI_MOUSE     0x00000020      /* Microsoft mouse              */
#define V86VI_DISK      0x00000040      /* Fixed and floppy disk        */
#define V86VI_PRL0      0x00000080      /* Parallel port 0 state change */

#define V86VI_RCLOCK    0x00000100      /* Realtime Clock interrupt     */
#define V86VI_NET       0x00000200      /* Network interrupts           */
#define V86VI_RSVD_1    0x00000400      /* Reserved 1                   */
#define V86VI_RSVD_2    0x00000800      /* Reserved 2                   */
#define V86VI_RSVD_3    0x00001000      /* Reserved 3                   */
#define V86VI_COPROC    0x00002000      /* Coprocessor interrupt        */
#define V86VI_FDISK     0x00004000      /* Fixed disk controller        */
#define V86VI_RSVD_4    0x00008000      /* Reserved 4                   */

#define V86VI_DIV0      0x00010000      /* Divide by 0 (vector 0)       */
#define V86VI_SGLSTP    0x00020000      /* Single step intr (vector 1)  */
#define V86VI_BRKPT     0x00040000      /* Break point intr (vector 3)  */
#define V86VI_OVERFLOW  0x00080000      /* Overflow fault (vector 4)    */
#define V86VI_BOUND     0x00100000      /* Bound exception (vector 5)   */
#define V86VI_INVOP     0x00200000      /* Invalid opcode (vector 6)    */
#define V86VI_SIGHDL    0x00400000      /* Virtual signal hdlr interrupt*/
#define V86VI_MEMORY    0x00800000      /* Tracking memory has changed  */
#define V86VI_LBOLT     0x01000000      /* Lbolt value has changed      */

/* Virtual interrupt subcodes for V86VI_SERIAL[01] interrupts.  These values
** appear in  the fields "xt_s[01]flag".
*/
#define V86SI_DATA      0x00000001      /* New data available from kbd  */
#define V86SI_MODEM     0x00000002      /* Modem status line[s] changed */

#define V86_MAGIC0      'X'             /* Byte for XTSS magic[0]       */
#define V86_MAGIC1      'T'             /* Byte for XTSS magic[1]       */

#endif	/*  _SYS_V86_H */

 07070100005a3e000081240000000200000002000000012719347c0000076b000000230000000c00000000000000000000001600000000usr/include/sys/var.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_VAR_H
#define _SYS_VAR_H

#ident	"@(#)/usr/include/sys/var.h.sl 1.1 4.0 10/15/90 58842 AT&T-SF"

/*
 * System Configuration Information
 */
struct var {
	int	v_buf;		/* Nbr of I/O buffers.			*/
	int	v_call;		/* Nbr of callout (timeout) entries.	*/
    int v_proc;     /* Max nbr of processes system wide */
    int v_filler;   /* (unused)             */
	int	v_nglobpris;	/* Nbr of global sched prios configured	*/
	int	v_maxsyspri;	/* Max global pri used by sys class.	*/
	int	v_clist;	/* Nbr of clists allocated.		*/
	int	v_maxup;	/* Max number of processes per user.	*/
	int	v_hbuf;		/* Nbr of hash buffers to allocate.	*/
	int	v_hmask;	/* Hash mask for buffers.		*/
	int	v_pbuf;		/* Nbr of physical I/O buffers.		*/
	int	v_sptmap;	/* Size of system virtual space		*/
				/* allocation map.			*/
	int	v_maxpmem;	/* The maximum physical memory to use.	*/
				/* If v_maxpmem == 0, then use all	*/
				/* available physical memory.		*/
				/* Otherwise, value is amount of mem to	*/
				/* use specified in pages.		*/
	int	v_autoup;	/* The age a delayed-write buffer must	*/
				/* be in seconds before bdflush will	*/
				/* write it out.			*/
	int	v_bufhwm;	/* high-water-mark of buffer cache	*/
				/* memory usage, in units of K Bytes
	/* XENIX Support */
	int 	v_scrn;		/* number of multi-screens. (XENIX) 	*/
	int 	v_emap;		/* number of i/o mappings (XENIX) 	*/
	int 	v_sxt;		/* number sxt's for shell layers (XENIX)*/
	int	v_xsdsegs;	/* Number of XENIX shared data segs     */
	int	v_xsdslots;	/* Number of slots in xsdtab[] per seg  */
	/* End XENIX Support */
};

extern struct var v;

#endif	/* _SYS_VAR_H */
 07070100005a3f000081240000000200000002000000012719347c00000406000000230000000c00000000000000000000001600000000usr/include/sys/vdc.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/vdc.h.sl 1.1 4.0 10/15/90 40950 AT&T-SF"

#ifndef	_SYS_VDC_H
#define	_SYS_VDC_H

struct vdc_info {
	int	v_type;
	unchar	v_switch,
		v_mode2sel;
	struct	kd_vdctype
		v_info;
};

#define VTYPE(x)	(Vdc.v_type & (x))	/* Type of VDC card (if any) */
#define VSWITCH(x)	(Vdc.v_switch & (x))	/* VDC switch settings */

#define V400	1
#define V750	2
#define V600	4
#define CAS2	8 	/* indicates a Cascade 2 w/ on-board VGA */
#ifdef	EVC
#define VEVC	0x10	/* Olivetti EVC-1 is installed */
#endif	/*EVC*/
#ifdef EVGA
#define VEVGA   0x20    /* Extended VGA type board */
#endif	/*EVGA*/

#define V750_IDADDR	0xc0009
#define V600_IDADDR	0xc0035
#define CAS2_IDADDR	0xe0010

#define ATTCGAMODE	0x01
#define ATTDISPLAY	0x02

#endif /* SYS_VDC_H */
  07070100005a40000081240000000200000002000000012719347c00001447000000230000000c00000000000000000000001600000000usr/include/sys/vfs.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_VFS_H
#define _SYS_VFS_H

#ident	"@(#)/usr/include/sys/vfs.h.sl 1.1 4.0 10/15/90 22612 AT&T-SF"

/*
 * Data associated with mounted file systems.
 */

/*
 * File system identifier. Should be unique (at least per machine).
 */
typedef struct {
	long val[2];			/* file system id type */
} fsid_t;

/*
 * File identifier.  Should be unique per filesystem on a single
 * machine.  This is typically called by a stateless file server
 * in order to generate "file handles".
 */
#define	MAXFIDSZ	16
#define	freefid(fidp) \
  kmem_free((caddr_t)(fidp), sizeof (struct fid) - MAXFIDSZ + (fidp)->fid_len)

typedef struct fid {
	u_short		fid_len;		/* length of data in bytes */
	char		fid_data[MAXFIDSZ];	/* data (variable length) */
} fid_t;

/*
 * Structure per mounted file system.  Each mounted file system has
 * an array of operations and an instance record.  The file systems
 * are kept on a singly linked list headed by "rootvfs" and terminated
 * by NULL.
 */
typedef struct vfs {
	struct vfs	*vfs_next;		/* next VFS in VFS list */
	struct vfsops	*vfs_op;		/* operations on VFS */
	struct vnode	*vfs_vnodecovered;	/* vnode mounted on */
	u_long		vfs_flag;		/* flags */
	u_long		vfs_bsize;		/* native block size */
	int		vfs_fstype;		/* file system type index */
	fsid_t		vfs_fsid;		/* file system id */
	caddr_t		vfs_data;		/* private data */
	dev_t		vfs_dev;		/* device of mounted VFS */
	u_long		vfs_bcount;		/* I/O count (accounting) */
	u_short		vfs_nsubmounts;		/* immediate sub-mount count */
} vfs_t;

/*
 * VFS flags.
 */
#define VFS_RDONLY	0x01		/* read-only vfs */
#define VFS_MLOCK	0x02		/* lock vfs so that subtree is stable */
#define VFS_MWAIT	0x04		/* someone is waiting for lock */
#define VFS_NOSUID	0x08		/* setuid disallowed */
#define VFS_REMOUNT	0x10		/* modify mount options only */
#define VFS_NOTRUNC	0x20		/* does not truncate long file names */
#define VFS_UNLINKABLE	0x40		/* unlink(2) can be applied to root */
#define VFS_BADBLOCK	0x80		/* disk based fs has bad block */

/*
 * Argument structure for mount(2).
 */
struct mounta {
	char	*spec;
	char	*dir;
	int	flags;
	char	*fstype;
	char	*dataptr;
	int	datalen;
};

/*
 * Operations supported on virtual file system.
 */
typedef struct vfsops {
	int	(*vfs_mount)();		/* mount file system */
	int	(*vfs_unmount)();	/* unmount file system */
	int	(*vfs_root)();		/* get root vnode */
	int	(*vfs_statvfs)();	/* get file system statistics */
	int	(*vfs_sync)();		/* flush fs buffers */
	int	(*vfs_vget)();		/* get vnode from fid */
	int	(*vfs_mountroot)();	/* mount the root filesystem */
	int	(*vfs_swapvp)();	/* return vnode for swap */
	int	(*vfs_filler[8])();	/* for future expansion */
} vfsops_t;

#define VFS_MOUNT(vfsp, mvp, uap, cr) \
	(*(vfsp)->vfs_op->vfs_mount)(vfsp, mvp, uap, cr)
#define VFS_UNMOUNT(vfsp, cr)	(*(vfsp)->vfs_op->vfs_unmount)(vfsp, cr)
#define VFS_ROOT(vfsp, vpp)	(*(vfsp)->vfs_op->vfs_root)(vfsp, vpp)
#define	VFS_STATVFS(vfsp, sp)	(*(vfsp)->vfs_op->vfs_statvfs)(vfsp, sp)
#define VFS_SYNC(vfsp, flag, cr) \
		(*(vfsp)->vfs_op->vfs_sync)(vfsp, flag, cr)
#define VFS_VGET(vfsp, vpp, fidp) \
		(*(vfsp)->vfs_op->vfs_vget)(vfsp, vpp, fidp)
#define VFS_MOUNTROOT(vfsp, init) \
		 (*(vfsp)->vfs_op->vfs_mountroot)(vfsp, init)
#define VFS_SWAPVP(vfsp, vpp, nm) \
		(*(vfsp)->vfs_op->vfs_swapvp)(vfsp, vpp, nm)

/*
 * Filesystem type switch table.
 */
typedef struct vfssw {
	char		*vsw_name;	/* type name string */
	int		(*vsw_init)();	/* init routine */
	struct vfsops	*vsw_vfsops;	/* filesystem operations vector */
	long		vsw_flag;	/* flags */
} vfssw_t;

/*
 * Public operations.
 */
extern void	vfs_mountroot();	/* mount the root */
extern void	vfs_add();		/* add a new vfs to mounted vfs list */
extern void	vfs_remove();		/* remove a vfs from mounted vfs list */
extern int	vfs_lock();		/* lock a vfs */
extern void	vfs_unlock();		/* unlock a vfs */
extern vfs_t 	*getvfs();		/* return vfs given fsid */
extern vfs_t 	*vfs_devsearch();	/* find vfs given device */
extern vfssw_t 	*vfs_getvfssw();	/* find vfssw ptr given fstype name */
extern u_long	vf_to_stf();		/* map VFS flags to statfs flags */
extern int	dounmount();		/* unmount a vfs */

#define VFS_INIT(vfsp, op, data)	{ \
	(vfsp)->vfs_next = (struct vfs *)0; \
	(vfsp)->vfs_op = (op); \
	(vfsp)->vfs_flag = 0; \
	(vfsp)->vfs_data = (data); \
	(vfsp)->vfs_nsubmounts = 0; \
}

/*
 * Globals.
 */
extern struct vfs *rootvfs;		/* ptr to root vfs structure */
extern struct vfssw vfssw[];		/* table of filesystem types */
extern char rootfstype[];		/* name of root fstype */
extern int nfstype;			/* # of elements in vfssw array */

/*
 * Reasons for calling the vfs_mountroot() operation.
 */

enum whymountroot { ROOT_INIT, ROOT_REMOUNT, ROOT_UNMOUNT };
typedef enum whymountroot whymountroot_t;

/*
 * VFS_SYNC flags.
 */
#define SYNC_ATTR	0x01		/* sync attributes only */
#define SYNC_CLOSE	0x02		/* close open file */

#endif	/* _SYS_VFS_H */
 07070100005a41000081240000000200000002000000012719347c00000675000000230000000c00000000000000000000001900000000usr/include/sys/vfstab.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#define	VFSTAB	"/etc/vfstab"
#define	VFS_LINE_MAX	1024
#ident	"@(#)/usr/include/sys/vfstab.h.sl 1.1 4.0 10/15/90 55351 AT&T-SF"

#define	VFS_TOOLONG	1	/* entry exceeds VFS_LINE_MAX */
#define	VFS_TOOMANY	2	/* too many fields in line */
#define	VFS_TOOFEW	3	/* too few fields in line */

#define	vfsnull(vp)	((vp)->vfs_special = (vp)->vfs_fsckdev =\
			 (vp)->vfs_mountp = (vp)->vfs_fstype =\
			 (vp)->vfs_fsckpass = (vp)->vfs_automnt =\
			 (vp)->vfs_mntopts = NULL)

#define	putvfsent(fd, vp)\
	fprintf((fd), "%s\t%s\t%s\t%s\t%s\t%s\t%s\n",\
		(vp)->vfs_special ? (vp)->vfs_special : "-",\
		(vp)->vfs_fsckdev ? (vp)->vfs_fsckdev : "-",\
		(vp)->vfs_mountp ? (vp)->vfs_mountp : "-",\
		(vp)->vfs_fstype ? (vp)->vfs_fstype : "-",\
		(vp)->vfs_fsckpass ? (vp)->vfs_fsckpass : "-",\
		(vp)->vfs_automnt ? (vp)->vfs_automnt : "-",\
		(vp)->vfs_mntopts ? (vp)->vfs_mntopts : "-")

struct vfstab {
	char	*vfs_special;
	char	*vfs_fsckdev;
	char	*vfs_mountp;
	char	*vfs_fstype;
	char	*vfs_fsckpass;
	char	*vfs_automnt;
	char	*vfs_mntopts;
};

#ifdef __STDC__
extern int	getvfsent(FILE *, struct vfstab *);
extern int	getvfsspec(FILE *, struct vfstab *, char *);
extern int	getvfsfile(FILE *, struct vfstab *, char *);
extern int	getvfsany(FILE *, struct vfstab *, struct vfstab *);
#else
extern int	getvfsent();
extern int	getvfsspec();
extern int	getvfsfile();
extern int	getvfsany();
#endif
   07070100005a42000081240000000200000002000000012719347c000004c6000000230000000c00000000000000000000001600000000usr/include/sys/vid.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/vid.h.sl 1.1 4.0 10/15/90 24053 AT&T-SF"

#ifndef _SYS_VID_H
#define	_SYS_VID_H

#define ATYPE(x, y)	(x.w_vstate.v_cmos == y)
#define DTYPE(x, y)	(x.w_vstate.v_type == y)
#define CMODE(x, y)	(x.w_vstate.v_cvmode == y)	/* Current disp. mode */
#define DMODE(x, y)	(x.w_vstate.v_dvmode == y)

#define KD_RDVMEM	0
#define KD_WRVMEM	1

struct modeinfo {
	ushort	m_cols,		/* Number of character columns */
		m_rows,		/* Number of character rows */
		m_xpels,	/* Number of pels on x axis */
		m_ypels;	/* Number of pels on y axis */
	unchar	m_color;	/* Non-zero value indicates color mode */
	paddr_t	m_base;		/* Physical address of screen memory */
	ulong	m_size;		/* Size of screen memory */
	unchar	m_font,		/* Default font (0 indicates grahpics mode) */
		m_params,	/* Parameter location: BIOS or static table */
		m_offset,	/* offset with respect to m_params */
		m_ramdac;	/* RAMDAC table offset */
};

#endif /* _SYS_VID_H */
  07070100005a43000081240000000200000002000000012719347c000001ef000000230000000c00000000000000000000001500000000usr/include/sys/vm.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_VM_H
#define _SYS_VM_H

#ident	"@(#)/usr/include/sys/vm.h.sl 1.1 4.0 10/15/90 29436 AT&T-SF"

#include <sys/vmparam.h>
#include <sys/vmmac.h>
#include <sys/vmmeter.h>
#include <sys/vmsystm.h>

#endif	/* _SYS_VM_H */
 07070100005a44000081240000000200000002000000012719347c000002a5000000230000000c00000000000000000000001800000000usr/include/sys/vmmac.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_VMMAC_H
#define _SYS_VMMAC_H

#ident	"@(#)/usr/include/sys/vmmac.h.sl 1.1 4.0 10/15/90 14227 AT&T-SF"

#include <sys/sysmacros.h>


/* Average new into old with aging factor time */
#define	ave(smooth, cnt, time) \
	smooth = ((time - 1) * (smooth) + (cnt)) / (time)

/* XXX - this doesn't really belong here */
#define	outofmem()	wakeprocs((caddr_t)proc_pageout, PRMPT);

#endif	/* _SYS_VMMAC_H */
   07070100005a45000081240000000200000002000000012719347c00001181000000230000000c00000000000000000000001a00000000usr/include/sys/vmmeter.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _SYS_VMMETER_H
#define _SYS_VMMETER_H

#ident	"@(#)/usr/include/sys/vmmeter.h.sl 1.1 4.0 10/15/90 28463 AT&T-SF"

/*
 * Virtual memory related instrumentation
 */

/*
 * Note that all the vmmeter entries between v_first and v_last
 *  must be unsigned [int], as they are used as such in vmmeter().
 */
struct vmmeter {
#define	v_first	v_swtch
	unsigned v_swtch;	/* context switches */
	unsigned v_trap;	/* calls to trap */
	unsigned v_syscall;	/* calls to syscall() */
	unsigned v_intr;	/* device interrupts */
	unsigned v_pdma;	/* pseudo-dma interrupts XXX: VAX only */
	unsigned v_pswpin;	/* pages swapped in */
	unsigned v_pswpout;	/* pages swapped out */
	unsigned v_pgin;	/* pageins */
	unsigned v_pgout;	/* pageouts */
	unsigned v_pgpgin;	/* pages paged in */
	unsigned v_pgpgout;	/* pages paged out */
	unsigned v_intrans;	/* intransit blocking page faults */
	unsigned v_pgrec;	/* total page reclaims (includes pageout) */
	unsigned v_xsfrec;	/* found in free list rather than on swapdev */
	unsigned v_xifrec;	/* found in free list rather than in filsys */
	unsigned v_exfod;	/* pages filled on demand from executables */
			/* XXX: above entry currently unused */
	unsigned v_zfod;	/* pages zero filled on demand */
	unsigned v_vrfod;	/* fills of pages mapped by vread() */
			/* XXX: above entry currently unused */
	unsigned v_nexfod;	/* number of exfod's created */
			/* XXX: above entry currently unused */
	unsigned v_nzfod;	/* number of zfod's created */
			/* XXX: above entry currently unused */
	unsigned v_nvrfod;	/* number of vrfod's created */
			/* XXX: above entry currently unused */
	unsigned v_pgfrec;	/* page reclaims from free list */
	unsigned v_faults;	/* total page faults taken */
	unsigned v_scan;	/* page examinations in page out daemon */
	unsigned v_rev;		/* revolutions of the paging daemon hand */
	unsigned v_seqfree;	/* pages taken from sequential programs */
			/* XXX: above entry currently unused */
	unsigned v_dfree;	/* pages freed by daemon */
	unsigned v_fastpgrec;	/* fast reclaims in locore XXX: VAX only */
#define	v_last v_fastpgrec
	unsigned v_swpin;	/* swapins */
	unsigned v_swpout;	/* swapouts */
};

#ifdef _KERNEL
/*
 *	struct	v_first to v_last		v_swp*
 *	------	-----------------		------
 *	cnt	1 second interval accum		5 second interval accum
 *	rate	5 second average		previous interval
 *	sum			free running counter
 */
struct	vmmeter cnt, rate, sum;
#endif

/*
 * Systemwide totals computed every five seconds.
 * All these are snapshots, except for t_free.
 */
struct vmtotal {
	short	t_rq;		/* length of the run queue */
	short	t_dw;		/* jobs in ``disk wait'' (neg priority) */
	short	t_pw;		/* jobs in page wait */
	short	t_sl;		/* ``active'' jobs sleeping in core */
	short	t_sw;		/* swapped out ``active'' jobs */
	int	t_vm;		/* total virtual memory */
			/* XXX: above entry currently unused */
	int	t_avm;		/* active virtual memory */
			/* XXX: above entry currently unused */
	short	t_rm;		/* total real memory in use */
	short	t_arm;		/* active real memory */
	int	t_vmtxt;	/* virtual memory used by text */
			/* XXX: above entry currently unused */
	int	t_avmtxt;	/* active virtual memory used by text */
			/* XXX: above entry currently unused */
	short	t_rmtxt;	/* real memory used by text */
			/* XXX: above entry currently unused */
	short	t_armtxt;	/* active real memory used by text */
			/* XXX: above entry currently unused */
	short	t_free;		/* free memory pages (60 second average) */
};

#ifdef _KERNEL
struct	vmtotal total;
#endif

#endif	/* _SYS_VMMETER_H */
   07070100005a46000081240000000200000002000000012719347c0000088a000000230000000c00000000000000000000001a00000000usr/include/sys/vmparam.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _SYS_VMPARAM_H
#define _SYS_VMPARAM_H

#ident	"@(#)/usr/include/sys/vmparam.h.sl 1.1 4.0 10/15/90 11 AT&T-SF"


/*
 * Machine dependent constants 
 */

#define	SSIZE		1			/* initial stack size */
#define	SINCR		1			/* increment of stack */


/*
 * DISKRPM is used to estimate the number of paging i/o operations
 * which one can expect from a single disk controller.
 */
#define	DISKRPM		60

/*
 * Paging thresholds (see vm_pageout.c).
 * Strategy of 3/17/83:
 *	lotsfree is 256k bytes, but at most 1/8 of memory
 *	desfree is 100k bytes, but at most 1/16 of memory
 *	minfree is 32k bytes, but at most 1/2 of desfree
 */
#define	LOTSFREE	(256 * 1024)
#define	LOTSFREEFRACT	8
#define	DESFREE		(100 * 1024)
#define	DESFREEFRACT	16
#define	MINFREE		(32 * 1024)
#define	MINFREEFRACT	2

/*
 * There are two clock hands, initially separated by HANDSPREAD bytes
 * (but at most all of user memory).  The amount of time to reclaim
 * a page once the pageout process examines it increases with this
 * distance and decreases as the scan rate rises.
 */
#define	HANDSPREAD	(2 * 1024 * 1024)

/*
 * Paged text files that are less than PGTHRESH bytes
 * may be "prefaulted in" instead of demand paged.
 */
#define PGTHRESH	(32 * 1024)

#endif	/* _SYS_VMPARAM_H */
  07070100005a47000081240000000200000002000000012719347c000008f6000000230000000c00000000000000000000001a00000000usr/include/sys/vmsystm.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _SYS_VMSYSTM_H
#define _SYS_VMSYSTM_H

#ident	"@(#)/usr/include/sys/vmsystm.h.sl 1.1 4.0 10/15/90 20598 AT&T-SF"

/*
 * Miscellaneous virtual memory subsystem variables and structures.
 */

#ifdef _KERNEL
int	freemem;		/* remaining blocks of free memory */
int	avefree;		/* moving average of remaining free blocks */
int	avefree30;		/* 30 sec (avefree is 5 sec) moving average */
int	deficit;		/* estimate of needs of new swapped in procs */
int	nscan;			/* number of scans in last second */
int	desscan;		/* desired pages scanned per second */

/* writable copies of tunables */
int	maxpgio;		/* max paging i/o per sec before start swaps */
int	lotsfree;		/* max free before clock freezes */
int	minfree;		/* minimum free pages before swapping begins */
int	desfree;		/* no of pages to try to keep free via daemon */
#endif

#ifdef _KERNEL

#if defined(__STDC__)
extern void vmtotal(void);
extern int valid_va_range(addr_t *, u_int *, u_int, int);
extern int valid_usr_range(addr_t, size_t);
extern int useracc(caddr_t, uint, int);
extern int page_deladd(int, int, rval_t *);
extern void map_addr(addr_t *, u_int, off_t, int);
#else
extern void vmtotal();
extern int valid_va_range();
extern int valid_usr_range();
extern int useracc();
extern int page_deladd();
extern void map_addr();
#endif	/* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _SYS_VMSYSTM_H */
  07070100005a48000081240000000200000002000000012719347c00002b04000000230000000c00000000000000000000001800000000usr/include/sys/vnode.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _SYS_VNODE_H
#define _SYS_VNODE_H

#ident	"@(#)/usr/include/sys/vnode.h.sl 1.1 4.0 10/15/90 225 AT&T-SF"

#include <sys/time.h>

/*
 * The vnode is the focus of all file activity in UNIX.
 * A vnode is allocated for each active file, each current
 * directory, each mounted-on file, and the root.
 */

/*
 * vnode types.  VNON means no type.  These values are unrelated to
 * values in on-disk inodes.
 */
typedef enum vtype {
	VNON	= 0,
	VREG	= 1,
	VDIR	= 2,
	VBLK	= 3,
	VCHR	= 4,
	VLNK	= 5,
	VFIFO	= 6,
	VXNAM	= 7,
	VBAD	= 8
} vtype_t;

typedef struct vnode {
	u_short		v_flag;			/* vnode flags (see below) */
	u_short		v_count;		/* reference count */
	struct vfs	*v_vfsmountedhere;	/* ptr to vfs mounted here */
	struct vnodeops	*v_op;			/* vnode operations */
	struct vfs	*v_vfsp;		/* ptr to containing VFS */
	struct stdata	*v_stream;		/* associated stream */
	struct page	*v_pages;		/* vnode pages list */
	enum vtype	v_type;			/* vnode type */
	dev_t		v_rdev;			/* device (VCHR, VBLK) */
	caddr_t		v_data;			/* private data for fs */
	struct filock	*v_filocks;		/* ptr to filock list */
	long		v_filler[8];		/* padding */
} vnode_t;

/*
 * vnode flags.
 */
#define	VROOT	0x01	/* root of its file system */
#define VNOMAP	0x04	/* file cannot be mapped/faulted */
#define	VDUP	0x08	/* file should be dup'ed rather then opened */
#define VNOMOUNT 0x20   /* file cannot be covered by mount */
#define VNOSWAP	0x10	/* file cannot be used as virtual swap device */
#define VISSWAP	0x40	/* vnode is part of virtual swap device */
/* XENIX Support */
#define VXLOCKED 0x8000	/* Xenix frlock */
/* End XENIX Support */

/*
 * Operations on vnodes.
 */
typedef struct vnodeops {
	int	(*vop_open)();
	int	(*vop_close)();
	int	(*vop_read)();
	int	(*vop_write)();
	int	(*vop_ioctl)();
	int	(*vop_setfl)();
	int	(*vop_getattr)();
	int	(*vop_setattr)();
	int	(*vop_access)();
	int	(*vop_lookup)();
	int	(*vop_create)();
	int	(*vop_remove)();
	int	(*vop_link)();
	int	(*vop_rename)();
	int	(*vop_mkdir)();
	int	(*vop_rmdir)();
	int	(*vop_readdir)();
	int	(*vop_symlink)();
	int	(*vop_readlink)();
	int	(*vop_fsync)();
	void	(*vop_inactive)();
	int	(*vop_fid)();
	void	(*vop_rwlock)();
	void	(*vop_rwunlock)();
	int	(*vop_seek)();
	int	(*vop_cmp)();
	int	(*vop_frlock)();
	int	(*vop_space)();
	int	(*vop_realvp)();
	int	(*vop_getpage)();
	int	(*vop_putpage)();
	int	(*vop_map)();
	int	(*vop_addmap)();
	int	(*vop_delmap)();
	int	(*vop_poll)();
	int	(*vop_dump)();
	int	(*vop_pathconf)();
	int	(*vop_filler[32])();
} vnodeops_t;

#define	VOP_OPEN(vpp, mode, cr) (*(*(vpp))->v_op->vop_open)(vpp, mode, cr)
#define	VOP_CLOSE(vp, f, c, o, cr) (*(vp)->v_op->vop_close)(vp, f, c, o, cr)
#define	VOP_READ(vp,uiop,iof,cr) (*(vp)->v_op->vop_read)(vp,uiop,iof,cr)
#define	VOP_WRITE(vp,uiop,iof,cr) (*(vp)->v_op->vop_write)(vp,uiop,iof,cr)
#define	VOP_IOCTL(vp,cmd,a,f,cr,rvp) (*(vp)->v_op->vop_ioctl)(vp,cmd,a,f,cr,rvp)
#define	VOP_SETFL(vp, f, a, cr) (*(vp)->v_op->vop_setfl)(vp, f, a, cr)
#define	VOP_GETATTR(vp, vap, f, cr) (*(vp)->v_op->vop_getattr)(vp, vap, f, cr)
#define	VOP_SETATTR(vp, vap, f, cr) (*(vp)->v_op->vop_setattr)(vp, vap, f, cr)
#define	VOP_ACCESS(vp, mode, f, cr) (*(vp)->v_op->vop_access)(vp, mode, f, cr)
#define	VOP_LOOKUP(vp,cp,vpp,pnp,f,rdir,cr) \
		(*(vp)->v_op->vop_lookup)(vp,cp,vpp,pnp,f,rdir,cr)
#define	VOP_CREATE(dvp,p,vap,ex,mode,vpp,cr) \
		(*(dvp)->v_op->vop_create)(dvp,p,vap,ex,mode,vpp,cr)
#define	VOP_REMOVE(dvp,p,cr) (*(dvp)->v_op->vop_remove)(dvp,p,cr)
#define	VOP_LINK(tdvp,fvp,p,cr) (*(tdvp)->v_op->vop_link)(tdvp,fvp,p,cr)
#define	VOP_RENAME(fvp,fnm,tdvp,tnm,cr) \
		(*(fvp)->v_op->vop_rename)(fvp,fnm,tdvp,tnm,cr)
#define	VOP_MKDIR(dp,p,vap,vpp,cr) (*(dp)->v_op->vop_mkdir)(dp,p,vap,vpp,cr)
#define	VOP_RMDIR(dp,p,cdir,cr) (*(dp)->v_op->vop_rmdir)(dp,p,cdir,cr)
#define	VOP_READDIR(vp,uiop,cr,eofp) (*(vp)->v_op->vop_readdir)(vp,uiop,cr,eofp)
#define	VOP_SYMLINK(dvp,lnm,vap,tnm,cr) \
		(*(dvp)->v_op->vop_symlink) (dvp,lnm,vap,tnm,cr)
#define	VOP_READLINK(vp, uiop, cr) (*(vp)->v_op->vop_readlink)(vp, uiop, cr)
#define	VOP_FSYNC(vp, cr) (*(vp)->v_op->vop_fsync)(vp, cr)
#define	VOP_INACTIVE(vp, cr) (*(vp)->v_op->vop_inactive)(vp, cr)
#define	VOP_FID(vp, fidpp) (*(vp)->v_op->vop_fid)(vp, fidpp)
#define	VOP_RWLOCK(vp) (*(vp)->v_op->vop_rwlock)(vp)
#define	VOP_RWUNLOCK(vp) (*(vp)->v_op->vop_rwunlock)(vp)
#define	VOP_SEEK(vp, ooff, noffp) (*(vp)->v_op->vop_seek)(vp, ooff, noffp)
#define	VOP_CMP(vp1, vp2) (*(vp1)->v_op->vop_cmp)(vp1, vp2)
#define	VOP_FRLOCK(vp,cmd,a,f,o,cr) (*(vp)->v_op->vop_frlock)(vp,cmd,a,f,o,cr)
#define	VOP_SPACE(vp,cmd,a,f,o,cr) (*(vp)->v_op->vop_space)(vp,cmd,a,f,o,cr)
#define	VOP_REALVP(vp1, vp2) (*(vp1)->v_op->vop_realvp)(vp1, vp2)
#define	VOP_GETPAGE(vp,of,sz,pr,pl,ps,sg,a,rw,cr)\
		(*(vp)->v_op->vop_getpage) (vp,of,sz,pr,pl,ps,sg,a,rw,cr)
#define	VOP_PUTPAGE(vp,of,sz,fl,cr) (*(vp)->v_op->vop_putpage)(vp,of,sz,fl,cr)
#define	VOP_MAP(vp,of,as,a,sz,p,mp,fl,cr) \
		(*(vp)->v_op->vop_map) (vp,of,as,a,sz,p,mp,fl,cr)
#define	VOP_ADDMAP(vp,of,as,a,sz,p,mp,fl,cr) \
		(*(vp)->v_op->vop_addmap) (vp,of,as,a,sz,p,mp,fl,cr)
#define	VOP_DELMAP(vp,of,as,a,sz,p,mp,fl,cr) \
		(*(vp)->v_op->vop_delmap) (vp,of,as,a,sz,p,mp,fl,cr)
#define	VOP_POLL(vp, events, anyyet, reventsp, phpp) \
		(*(vp)->v_op->vop_poll)(vp, events, anyyet, reventsp, phpp)
#define	VOP_DUMP(vp,addr,bn,count) (*(vp)->v_op->vop_dump)(vp,addr,bn,count)
#define	VOP_PATHCONF(vp, cmd, valp, cr) \
		(*(vp)->v_op->vop_pathconf)(vp, cmd, valp, cr)

/*
 * I/O flags for VOP_READ and VOP_WRITE.
 */
#define IO_APPEND	0x01	/* append write (VOP_WRITE) */
#define IO_SYNC		0x02	/* sync I/O (VOP_WRITE) */

/*
 * Flags for VOP_LOOKUP.
 */
#define LOOKUP_DIR	0x01	/* want parent dir vp */

/*
 * Vnode attributes.  A bit-mask is supplied as part of the
 * structure to indicate the attributes the caller wants to
 * set (setattr) or extract (getattr).
 */
typedef struct vattr {
	long		va_mask;	/* bit-mask of attributes */
	vtype_t		va_type;	/* vnode type (for create) */
	mode_t		va_mode;	/* file access mode */
	uid_t		va_uid;		/* owner user id */
	gid_t		va_gid;		/* owner group id */
	dev_t		va_fsid;	/* file system id (dev for now) */
	ino_t		va_nodeid;	/* node id */
	nlink_t		va_nlink;	/* number of references to file */
	u_long		va_size0;	/* file size pad (for future use) */
	u_long		va_size;	/* file size in bytes */
	timestruc_t	va_atime;	/* time of last access */
	timestruc_t	va_mtime;	/* time of last modification */
	timestruc_t	va_ctime;	/* time file ``created'' */
	dev_t		va_rdev;	/* device the file represents */
	u_long		va_blksize;	/* fundamental block size */
	u_long		va_nblocks;	/* # of blocks allocated */
	u_long		va_vcode;	/* version code */
	long		va_filler[8];	/* padding */
} vattr_t;

/*
 * Attributes of interest to the caller of setattr or getattr.
 */
#define	AT_TYPE		0x0001
#define	AT_MODE		0x0002
#define	AT_UID		0x0004
#define	AT_GID		0x0008
#define	AT_FSID		0x0010
#define	AT_NODEID	0x0020
#define	AT_NLINK	0x0040
#define	AT_SIZE		0x0080
#define	AT_ATIME	0x0100
#define	AT_MTIME	0x0200
#define	AT_CTIME	0x0400
#define	AT_RDEV		0x0800
#define AT_BLKSIZE	0x1000
#define AT_NBLOCKS	0x2000
#define AT_VCODE	0x4000

#define	AT_ALL	(AT_TYPE|AT_MODE|AT_UID|AT_GID|AT_FSID|AT_NODEID|\
		AT_NLINK|AT_SIZE|AT_ATIME|AT_MTIME|AT_CTIME|\
		AT_RDEV|AT_BLKSIZE|AT_NBLOCKS|AT_VCODE)

#define	AT_STAT	(AT_MODE|AT_UID|AT_GID|AT_FSID|AT_NODEID|AT_NLINK|\
		AT_SIZE|AT_ATIME|AT_MTIME|AT_CTIME|AT_RDEV)

#define	AT_TIMES (AT_ATIME|AT_MTIME|AT_CTIME)

#define	AT_NOSET (AT_NLINK|AT_RDEV|AT_FSID|AT_NODEID|AT_TYPE|\
		 AT_BLKSIZE|AT_NBLOCKS|AT_VCODE)
	
/*
 *  Modes.  Some values same as S_xxx entries from stat.h for convenience.
 */
#define	VSUID		04000		/* set user id on execution */
#define	VSGID		02000		/* set group id on execution */
#define VSVTX		01000		/* save swapped text even after use */

/*
 * Permissions.
 */
#define	VREAD		00400
#define	VWRITE		00200
#define	VEXEC		00100

#define	MODEMASK	07777		/* mode bits plus permission bits */
#define	PERMMASK	00777		/* permission bits */

/*
 * Check whether mandatory file locking is enabled.
 */

/* XENIX Support */
#define MANDLOCK(vp, mode)	\
	((vp)->v_type == VREG && ((((mode) & (VSGID|(VEXEC>>3))) == VSGID) \
	  || ((vp)->v_flag & VXLOCKED) == VXLOCKED))
/* End XENIX Support */

/*
 * Public vnode manipulation functions.
 */
extern int vn_open();
extern int vn_create();
extern int vn_rdwr();
extern int vn_close();
extern void vn_rele();
extern int vn_link();
extern int vn_rename();
extern int vn_remove();
extern vnode_t *specvp();
extern vnode_t *makespecvp();

/* XENIX Support */
extern int fifo_rdchk();
extern int spec_rdchk();
/* End XENIX Support */

#define VN_HOLD(vp)	{ \
	(vp)->v_count++; \
}

#define VN_RELE(vp)	{ \
	vn_rele(vp); \
}

#define VN_INIT(vp, vfsp, type, dev)	{ \
	(vp)->v_flag = 0; \
	(vp)->v_count = 1; \
	(vp)->v_vfsp = (vfsp); \
	(vp)->v_type = (type); \
	(vp)->v_rdev = (dev); \
	(vp)->v_pages = NULL; \
	(vp)->v_stream = NULL; \
}

/*
 * Compare two vnodes for equality.  In general this macro should be used
 * in preference to calling VOP_CMP directly.
 */
#define VN_CMP(VP1,VP2)	((VP1) == (VP2) ? 1 : 	\
	((VP1) && (VP2) && ((VP1)->v_op == (VP2)->v_op) ? VOP_CMP(VP1,VP2) : 0))

/*
 * Flags for vnode operations.
 */
enum rm		{ RMFILE, RMDIRECTORY };	/* rm or rmdir (remove) */
enum symfollow	{ NO_FOLLOW, FOLLOW };		/* follow symlinks (or not) */
enum vcexcl	{ NONEXCL, EXCL };		/* (non)excl create */
enum create	{ CRCREAT, CRMKNOD, CRMKDIR, CRCORE }; /* reason for create */

typedef enum rm		rm_t;
typedef enum symfollow	symfollow_t;
typedef enum vcexcl	vcexcl_t;
typedef enum create	create_t;

/*
 * Flags to VOP_SETATTR/VOP_GETATTR.
 */
#define	ATTR_UTIME	0x01	/* non-default utime(2) request */
#define	ATTR_EXEC	0x02	/* invocation from exec(2) */
#define	ATTR_COMM	0x04	/* yield common vp attributes */

/*
 * Generally useful macros.
 */
#define	VBSIZE(vp)	((vp)->v_vfsp->vfs_bsize)
#define	NULLVP		((struct vnode *)0)
#define	NULLVPP		((struct vnode **)0)

#ifdef _KERNEL
extern int lookupname();
#endif

#endif	/* _SYS_VNODE_H */
07070100005a49000081240000000200000002000000012719347c00000dc7000000230000000c00000000000000000000001500000000usr/include/sys/vt.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_VT_H
#define _SYS_VT_H

#ident	"@(#)/usr/include/sys/vt.h.sl 1.1 4.0 10/15/90 6414 AT&T-SF"

/*
 * definitions for PC AT virtual terminal driver
 */

#define	VTINDEX(dev)	((dev & 0xff) % 15)
#define	VTMAX	0x0f

#define	VT_FORCE	1	/* flag to force a vt switch */
#define	VT_NOFORCE	0	/* dont force a vt switch */
#define	VT_NOSAVE	2	/* On close - don't save screen */

/*
 * Bits in vtty flags word.
 */
#define	VT_ACTIVE	0x0001	/* set if this is the active vt */
#define	VT_PROCMOD	0x0002	/* set if vt has process control mode set */
#define	VT_WAIT		0x0004	/* set if writes to hang if not active vt */
#define	VT_HIDDEN	0x0008	/* set if vt on ring is to be skipped */
#define VT_WAITACT	0x0010	/* set if vt needs wakeup when switched to */

/*
 * all vttys for a device should be circularly linked via the
 * link field of the structure, active vttys are doubly circularly
 * linked via the next and prev fields.
 */
struct vtty {	/* virtual terminal structure */
	struct vtty	*link;	/* next vtty on device */
	struct vtty	*prev;	/* previous vtty in ring */
	struct vtty	*next;	/* next vtty in ring */
	struct vtty	*switchto;	/* vtty to be activated */
	struct	tty	*tp;	/* tty associated with this vtty */
	caddr_t		dsp;	/* device specific info for this vtty */
	struct proc	*procp;	/* ptr to process controlling this vtty */
	short	pid;		/* pid of process controlling this vtty */
	ushort	flags;		/* flags for this vtty */
	char	opencnt;	/* number of opens on this vtty */
	char	vtno;		/* vt index number of this vtty */
	short	relsig;		/* signal to send to request release */
	short	acqsig;		/* signal to send to signal acquisition */
	short	frsig;		/* signal to send on forced removal */
	int	timeid;		/* timeout id for this vtty */
	int	(*dsactivate)(); /* device specific activation routine */
	int	(*dsrefuse)();	/* device specific release refused routine */
	int	(*dsautomode)(); /* device specific switch to auto mode */
};

/*
 * IOCTLs supported by the VT
 */
#define VTIOC		('v'<<8)
#define VT_OPENQRY	(VTIOC|1)	/* inquires if this vt already open */
#define	VT_SETMODE	(VTIOC|2)	/* set vt into auto or process mode */
#define	VT_GETMODE	(VTIOC|3)	/* returns mode vt is currently in */
#define	VT_RELDISP	(VTIOC|4)	/* tells vt when display released */
#define	VT_ACTIVATE	(VTIOC|5)	/* activates specified vt */
#define VT_WAITACTIVE	(VTIOC|6)	/* wait for vt to be activated */
#define VT_GETSTATE	(VTIOC|100)	/* return active and open vts */
#define VT_SENDSIG	(VTIOC|101)	/* send signal to specified vts */

struct vt_mode {
	char	mode;	/* mode to set vt into */
	char	waitv;	/* if != 0, vt hangs on writes when not active */
	short	relsig;	/* signal to use for release request */
	short	acqsig;	/* signal to use for display acquired */
	short	frsig;	/* signal to use for forced release */
};

#define	VT_AUTO		0	/* this vt's switching is automatic */
#define	VT_PROCESS	1	/* this vt's switching controlled by process */
#define VT_ACKACQ	2	/* ack form v86 acquire routine */

/*
 * IOCTL supported by xterm to get vt name
 */
#define TIOCVTNAME	(('T' << 8) | 250)
#define VTNAMESZ	32

/*
 * structure used by VT_GETSTATE and VT_SENDSIG ioctls
 */

struct vt_stat {
	ushort	v_active,
		v_signal,
		v_state;
} ;

#endif	/* _SYS_VT_H */
 07070100005a4a000081240000000200000002000000012719347c00002452000000230000000c00000000000000000000001700000000usr/include/sys/vtoc.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_VTOC_H
#define _SYS_VTOC_H

#ident	"@(#)/usr/include/sys/vtoc.h.sl 1.1 4.0 10/15/90 42702 AT&T-SF"
/*
 * VTOC.H
 */

#define V_NUMPAR 		16		/* The number of partitions */
#define VTOC_SEC       	29      /* VTOC sector number on disk */

#define VTOC_SANE		0x600DDEEE	/* Indicates a sane VTOC */
#define V_VERSION		0x01		/* layout version number */

/* Partition identification tags */
#define V_BOOT		0x01		/* Boot slice */
#define V_ROOT		0x02		/* Root filesystem */
#define V_SWAP		0x03		/* Swap filesystem */
#define V_USR		0x04		/* Usr filesystem */
#define V_BACKUP	0x05		/* full disk */
#define V_ALTS          0x06            /* alternate sector space */
#define V_OTHER         0x07            /* non-unix space */
#define V_ALTTRK	0x08		/* alternate track space */
#define V_STAND		0x09		/* Stand slice */
#define V_VAR		0x0a		/* Var slice */
#define V_HOME		0x0b		/* Home slice */
#define V_DUMP		0x0c		/* dump slice */

/* Partition permission flags */
#define V_UNMNT		0x01		/* Unmountable partition */
#define V_RONLY		0x10		/* Read only */
#define V_OPEN          0x100           /* Partition open (for driver use) */
#define V_VALID         0x200           /* Partition is valid to use */
#define V_VOMASK        0x300           /* mask for open and valid */

/* driver ioctl() commands */
#define VIOC		('V'<<8)
#define V_CONFIG        (VIOC|1)        /* Configure Drive */
#define V_REMOUNT       (VIOC|2)        /* Remount Drive */
#define V_ADDBAD        (VIOC|3)        /* Add Bad Sector */
#define V_GETPARMS      (VIOC|4)        /* Get drive/partition parameters */
#define V_FORMAT        (VIOC|5)        /* Format track(s) */
#define	V_PDLOC		(VIOC|6)	/* Ask driver where pdinfo is on disk */
#define	V_GETERR	(VIOC|7)	/* Get last error */
#define V_EXERR		(VIOC|8)	/* Save extended errors */
#define V_NOEXERR	(VIOC|9)	/* Don't save extended errors (def) */
#define V_RDABS		(VIOC|10)	/* Read a sector at an absolute addr */
#define V_WRABS		(VIOC|11)	/* Write a sector to absolute addr */
#define V_VERIFY	(VIOC|12)	/* Read verify sector(s)           */
#define V_XFORMAT	(VIOC|13)	/* Selectively mark sectors as bad */

/* SCSI driver ioctl() commands */
#define V_PREAD		(VIOC|14)	/* Physical Read */
#define V_PWRITE	(VIOC|15)	/* Physical Write */
#define V_PDREAD	(VIOC|16)	/* Read of Physical Description Area */
#define V_PDWRITE	(VIOC|17)	/* Write of Physical Description Area */
#define	V_CHK_CNTL	(VIOC|18)	/* check for DPT HA a primary cntlr */


/* SCSI ioctl() error return codes */
#define V_BADREAD		0x01
#define V_BADWRITE		0x02

/* Sanity word for the physical description area */
#define VALID_PD		0xCA5E600D

struct partition	{
	ushort p_tag;			/*ID tag of partition*/
	ushort p_flag;			/*permision flags*/
	daddr_t p_start;		/*start sector no of partition*/
	long p_size;			/*# of blocks in partition*/
};

struct vtoc {
	unsigned long v_sanity;			/*to verify vtoc sanity*/
	unsigned long v_version;		/*layout version*/
	char v_volume[8];			/*volume name*/
	ushort v_nparts;			/*number of partitions*/
	ushort  v_pad;                          /*pad for 286 compiler*/
	unsigned long v_reserved[10];		/*free space*/
	struct partition v_part[V_NUMPAR];	/*partition headers*/
	time_t timestamp[V_NUMPAR];		/* SCSI time stamp */
};

struct pdinfo	{
	unsigned long driveid;		/*identifies the device type*/
	unsigned long sanity;		/*verifies device sanity*/
	unsigned long version;		/*version number*/
	char serial[12];		/*serial number of the device*/
	unsigned long cyls;		/*number of cylinders per drive*/
	unsigned long tracks;		/*number tracks per cylinder*/
	unsigned long sectors;		/*number sectors per track*/
	unsigned long bytes;		/*number of bytes per sector*/
	unsigned long logicalst;	/*sector address of logical sector 0*/
	unsigned long errlogst;		/*sector address of error log area*/
	unsigned long errlogsz;		/*size in bytes of error log area*/
	unsigned long mfgst;		/*sector address of mfg. defect info*/
	unsigned long mfgsz;		/*size in bytes of mfg. defect info*/
	unsigned long defectst;		/*sector address of the defect map*/
	unsigned long defectsz;		/*size in bytes of defect map*/
	unsigned long relno;		/*number of relocation areas*/
	unsigned long relst;		/*sector address of relocation area*/
	unsigned long relsz;		/*size in sectors of relocation area*/
	unsigned long relnext;		/*address of next avail reloc sector*/
/* the previous items are left intact from AT&T's 3b2 pdinfo.  Following
   are added for the 80386 port */
	unsigned long vtoc_ptr;         /*byte offset of vtoc block*/
	unsigned short vtoc_len;        /*byte length of vtoc block*/
	unsigned short vtoc_pad;        /* pad for 16-bit machine alignment */
	unsigned long alt_ptr;          /*byte offset of alternates table*/
	unsigned short alt_len;         /*byte length of alternates table*/
};

union   io_arg {
	struct  {
		ushort  ncyl;           /* number of cylinders on drive */
		unsigned char nhead;    /* number of heads/cyl */
		unsigned char nsec;     /* number of sectors/track */
		ushort  secsiz;         /* number of bytes/sector */
		} ia_cd;                /* used for Configure Drive cmd */
	struct  {
		ushort  flags;          /* flags (see below) */
		daddr_t bad_sector;     /* absolute sector number */
		daddr_t new_sector;     /* RETURNED alternate sect assigned */
		} ia_abs;               /* used for Add Bad Sector cmd */
	struct  {
		ushort  start_trk;      /* first track # */
		ushort  num_trks;       /* number of tracks to format */
		ushort  intlv;          /* interleave factor */
		} ia_fmt;               /* used for Format Tracks cmd */
	struct	{
		ushort	start_trk;	/* first track	*/
		char    *intlv_tbl;	/* interleave table */
		} ia_xfmt;		/* used for the V_XFORMAT ioctl */

};

/*
 * Data structure for the V_VERIFY ioctl
 */
union	vfy_io	{
	struct	{
		daddr_t abs_sec;	/* absolute sector number        */
		ushort  num_sec;	/* number of sectors to verify   */
		ushort  time_flg;	/* flag to indicate time the operation */
		}vfy_in;
	struct	{
		time_t  deltatime;	/* duration of operation */
		ushort  err_code;	/* reason for failure    */
		}vfy_out;
};

/* Flags for Add Bad Sector command */
#define V_ABS_NEAR      1       /* Assign closest alternate available */


/* data structure returned by the Get Parameters ioctl: */

struct  disk_parms {
	char    dp_type;                /* Disk type (see below) */
	unchar  dp_heads;               /* Number of heads */
	ushort  dp_cyls;                /* Number of cylinders */
	unchar  dp_sectors;             /* Number of sectors/track */
	ushort  dp_secsiz;              /* Number of bytes/sector */
					/* for this partition: */
	ushort  dp_ptag;                /* Partition tag */
	ushort  dp_pflag;               /* Partition flag */
	daddr_t dp_pstartsec;           /* Starting absolute sector number */
	daddr_t dp_pnumsec;             /* Number of sectors */
	};

/* Disk types for disk_parms.dp_type: */
#define DPT_WINI        1               /* Winchester disk */
#define DPT_FLOPPY      2               /* Floppy */
#define DPT_OTHER       3               /* Other type of disk */
#define DPT_NOTDISK     0               /* Not a disk device */
#define DPT_SCSI_HD	4               /* SCSI hard disk device */
#define DPT_SCSI_OD	5               /* SCSI optical disk device */
#define DPT_ESDI_HD	0x11            /* ESDI hard disk device */

/* Data structure for V_RDABS/V_WRABS ioctl's */
struct absio {
	daddr_t	abs_sec;		/* Absolute sector number (from 0) */
	char	*abs_buf;		/* Sector buffer */
};

/* Data structure for SCSI physical read/write ioctl's */
struct phyio {
	int retval;			/* Return value			*/
	unsigned long sectst;		/* Sector address		*/
	unsigned long memaddr;		/* Buffer address		*/
	unsigned long datasz;		/* Transfer size in bytes	*/
};

#ifdef	IOCTL_ERROR
/* Errors which may be retrieved with an ioctl when IOCTL_ERROR is used.  */

/* Error message types */

#define	FD_NOARGS	0		/* No arguments are applicable */
#define	FD_TRKERR	1		/* Track number is applicable */
#define	FD_BLKERR	2		/* Block number is applicable */

#define	FD_ENOERROR	0		/* No error */
#define	FD_ECMDTIMEOUT	1		/* command timeout */
#define	FD_ESTATIMEOUT	2		/* status timeout */
#define	FD_EBUSY	3		/* busy */
#define	FD_EMISSDADDR	4		/* Missing data address mark */
#define	FD_EBADCYL	5		/* Cylinder marked bad */
#define	FD_EWRONGCYL	6		/* Seek error (wrong cylinder) */
#define	FD_ECANTREAD	7		/* Uncorrectable data read */
#define	FD_EBADSECTOR	8		/* Sector marked bad */
#define	FD_EMISSHADDR	9		/* Missing header address mark */
#define	FD_EWRITEPROT	10		/* Write protected */
#define	FD_ESECNOTFND	11		/* Sector not found */
#define	FD_EDATAOVRUN	12		/* Data overrun */
#define	FD_EHCANTREAD	13		/* Header read error */
#define	FD_ILLSECT	14		/* Illegal sector */
#define	FD_EDOOROPEN	15		/* Door open */

typedef	struct lasterr_t {
	char	number;
	char	type;
	union	{
		int	trk;
		int	blk;
	} arg1;
} lasterr_t;
#endif	/* IOCTL_ERROR */

#endif	/* _SYS_VTOC_H */
  07070100005a4b000081240000000200000002000000012719347c00000a12000000230000000c00000000000000000000001700000000usr/include/sys/wait.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_WAIT_H
#define _SYS_WAIT_H

#include <sys/types.h>
#include <sys/siginfo.h>
#if !defined(_POSIX_SOURCE) 
#include <sys/procset.h>
#endif /* !defined(_POSIX_SOURCE) */


#ident	"@(#)/usr/include/sys/wait.h.sl 1.1 4.0 10/15/90 31421 AT&T-SF"

/*
 * arguments to wait functions
 */

#if !defined(_POSIX_SOURCE) 
#define WEXITED		0001	/* wait for processes that have exited	*/
#define WTRAPPED	0002	/* wait for processes stopped while tracing */
#define WSTOPPED	0004	/* wait for processes stopped by signals */
#define WCONTINUED	0010	/* wait for processes continued */
#endif /* !defined(_POSIX_SOURCE) */

#define WUNTRACED	0004	/* for POSIX */

#define WNOHANG		0100	/* non blocking form of wait	*/

#if !defined(_POSIX_SOURCE) 
#define WNOWAIT		0200	/* non destructive form of wait */

#define WOPTMASK	(WEXITED|WTRAPPED|WSTOPPED|WCONTINUED|WNOHANG|WNOWAIT)

/*
 * macros for stat return from wait functions
 */

#define WCONTFLG		0177777
#define WCOREFLG		0200

#define WWORD(stat)		((int)((stat))&0177777)
#endif /* !defined(_POSIX_SOURCE) */

#if !defined(_POSIX_SOURCE) 
#define WSTOPFLG		0177
#define WSIGMASK		0177
#define WLOBYTE(stat)		((int)((stat)&0377))
#define WHIBYTE(stat)		((int)(((stat)>>8)&0377))
#endif /* !defined(_POSIX_SOURCE) */ 

#define WIFEXITED(stat)		(((int)((stat)&0377))==0)
#define WIFSIGNALED(stat)	(((int)((stat)&0377))>0&&((int)(((stat)>>8)&0377))==0)
#define WIFSTOPPED(stat)	(((int)((stat)&0377))==0177&&((int)(((stat)>>8)&0377))!=0)

#if !defined(_POSIX_SOURCE) 
#define WIFCONTINUED(stat)	(WWORD(stat)==WCONTFLG)
#endif /* !defined(_POSIX_SOURCE) */

#define WEXITSTATUS(stat)	((int)(((stat)>>8)&0377))
#define WTERMSIG(stat)		(((int)((stat)&0377))&0177)
#define WSTOPSIG(stat)		((int)(((stat)>>8)&0377))

#if !defined(_POSIX_SOURCE) 
#define WCOREDUMP(stat)		((stat)&WCOREFLG)
#endif /* !defined(_POSIX_SOURCE) */



#if !defined(_KERNEL)
#if defined(__STDC__)

extern pid_t wait(int *);
extern pid_t waitpid(pid_t, int *, int);

#if !defined(_POSIX_SOURCE) 
extern int waitid(idtype_t, id_t, siginfo_t *, int);
#endif /* !defined(_POSIX_SOURCE) */

#else

extern pid_t wait();
extern pid_t waitpid();

#if !defined(_POSIX_SOURCE) 
extern int waitid();
#endif /* !defined(_POSIX_SOURCE) */

#endif	/* __STDC__ */
#endif	/* _KERNEL */

#endif	/* _SYS_WAIT_H */
  07070100005a4c000081240000000200000002000000012719347c00000b44000000230000000c00000000000000000000001900000000usr/include/sys/weitek.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_WEITEK_H
#define _SYS_WEITEK_H

#ident	"@(#)/usr/include/sys/weitek.h.sl 1.1 4.0 10/15/90 21952 AT&T-SF"

/*
 * Weitek floating point processor definitions
 */

#define WEITEK_VADDR 0xFFC00000
#define WEITEK_ADDRS 0xFFFF0000
#define WEITEK_SIZE  0x00010000
#define WEITEK_MAXADDR (WEITEK_VADDR + WEITEK_SIZE - 1)

/*
 * masks for accumulated exception byte
 */
#define	WFPDE	0x00000080	/* data chain exception			*/
#define	WFPUOE	0x00000040	/* unimplemented opcode			*/
#define	WFPPE	0x00000020	/* precision				*/
#define	WFPUE	0x00000010	/* underflow				*/
#define	WFPOE	0x00000008	/* overflow				*/
#define	WFPZE	0x00000004	/* zero divide				*/
#define	WFPEE	0x00000002	/* enabled exception			*/
#define WFPIE	0x00000001	/* invalid operation			*/

/*
 * Define all of the execption bits and the number of bits to left-shift
 * to turn exception bits into exception mask bits.
 */
#define	WFPAE		0x000000FD
#define	WFPAEEM_SHFT	16

/*
 *  masks for process context register exception mask byte
 */
#define	WFPDM	0x00800000	/* data chain exception	*/
#define	WFPUOM	0x00400000	/* unimplemented opcode	*/
#define	WFPPM	0x00200000	/* precision		*/
#define	WFPUM	0x00100000	/* underflow		*/
#define	WFPOM	0x00080000	/* overflow		*/
#define	WFPZM	0x00040000	/* zero divide		*/
#define	WFPIM	0x00010000	/* invalid operation	*/
#define WFPB17	0x00020000	/* bit 17 always set	*/

/*
 *  rounding modes for process context register
 */
#define	WFPRN	0x00000000	/* round to nearest value		*/
#define	WFPRZ	0x04000000	/* round toward zero			*/
#define	WFPRP	0x08000000	/* round toward positive infinity	*/
#define	WFPRM	0x0C000000	/* round toward negative infinity	*/
#define WFPRIS	0x00000000	/* round to integer based on RND	*/
#define WFPRIZ	0x02000000	/* round integer to zero always		*/
#define WFPB24	0x01000000      /* bit 24 always set                    */

extern char		weitek_kind;
#define	WEITEK_NO	0	/* no chip support	*/
#define	WEITEK_HW	1	/* chip present		*/
#define	WEITEK_SW	2	/* emulator present	*/

extern struct proc	*weitek_proc;
extern unsigned long	weitek_paddr;
extern void		save_weitek();
extern void		restore_weitek();
extern int		weitek_debug;

/* Definitions for the Weitek emulator */

#define PCR_INTR  0x00000002l

struct ctxt_type {
   long REGISTERS[32]; /* The 1167 register file */
   long PCR;           /* The current PCR register */
};

/* Short hand defines to access the registers and pcr from the structure */
#define registers ctxt -> REGISTERS
#define pcr       ctxt -> PCR

/* global mapping to weitek physical space */
extern int	weitek_pt;

#endif	/* _SYS_WEITEK_H */
070701000028d2000041ed0000000200000002000000022719347c00000000000000230000000c00000000000000000000001300000000usr/include/sys/ws    070701000028cd000081240000000200000002000000012719347c000002be000000230000000c00000000000000000000001a00000000usr/include/sys/ws/8042.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ws/8042.h.sl 1.1 4.0 10/15/90 35901 AT&T-SF"

/* defines for i8042_program() */
#define	P8042_KBDENAB	1
#define	P8042_KBDDISAB	2
#define	P8042_AUXENAB	3
#define	P8042_AUXDISAB	4

/* defines for i8042_send_cmd */
#define	P8042_TO_KBD	1
#define	P8042_TO_AUX	2


extern void	i8042_acquire();
extern void 	i8042_release();
extern int	i8042_send_cmd();
extern void	i8042_program();
extern int	i8042_aux_port();

  070701000028ce000081240000000200000002000000012719347c00000c70000000230000000c00000000000000000000001a00000000usr/include/sys/ws/chan.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ws/chan.h.sl 1.1 4.0 10/15/90 15836 AT&T-SF"

#ifndef	_SYS_WS_CHAN_H
#define	_SYS_WS_CHAN_H

/*
 * Channel protocol definitions for the IWE. All control/special data messages
 * exchanged between IWE modules/drivers are of this format.
 */

struct ch_protocol {
	long	chp_type,	/* type of message */
		chp_tstmp,	/* timestamp of message */
		chp_stype,	/* message sub-type (used for control msgs) */
		chp_stype_cmd,	/* message sub-type cmd (for control msgs) */
		chp_stype_arg,	/* message sub-type arg (for control msgs) */
		chp_chan;	/* channel ID -- will be set by CHANMUX
				 *    and is write-side only */
};

typedef struct ch_protocol ch_proto_t;

/* chp_type ID */
#define CH_DATA	1	/* ch_protocol data message identifier */
#define CH_CTL	2	/* ch_protocol control message identifier */

/* messages from CHANMUX to principal stream; chp_stype CH_CHAN and
 * its chp_stype_cmds. chp_type should be CH_CTL
 */
#define CH_CHAN	( ('C'<<16) | ('H'<<8) | ('N') )
#define CH_CHANCLOSE	1
#define CH_CHANOPEN	2

/* chp_stype CH_MSE to indicate mouse events; chp_type should be CH_DATA */
#define CH_MSE	( ('M'<<16) | ('S'<<8) | ('E') )

/* chp_stype CH_NOSCAN to indicate already-scanned data. The attached message
 * block is raw data suitable to be forwarded on the read side to upper
 * modules of the STREAMS TTY sub-system. chp_type is CH_DATA
 */
#define CH_NOSCAN	( ('N'<<16) | ('S'<<8) | ('C') )

/* messages to the CHANMUX driver from the principal stream;
 * chp_stype CH_PRINCSTRM and its chp_stype_cmds. chp_type should be CH_CTL
 */
#define CH_PRINC_STRM	( ('P'<<16) | ('S'<<8) | ('T') )
#define CH_CHANGE_CHAN	1
#define CH_CLOSE_ACK	2
#define CH_OPEN_RESP	3

/* CH_CTL messages for CHAR module; chp_stype CH_CHR and its chp_stype_cmds */
#define CH_CHR	( ('C' << 16) | ('H' << 8) | 'R')
#define CH_CHRMAP	( ('C'<<24) | ('M'<<16) | ('A'<<8) | 'P' )
#define CH_SCRMAP	( ('S'<<24) | ('M'<<16) | ('A'<<8) | 'P' )
#define CH_LEDSTATE	('L' << 8 | 'D')
#ifdef MERGE386
#define CH_SETMVPI	( ('M'<<24) | ('3'<<16) | ('8'<<8) | '6' )
#define CH_DELMVPI	( ('3'<<24) | ('8'<<16) | ('6'<<8) | 'M' )
#endif /* MERGE386 */

/* chp_stype CH_TCL; its stype_cmds are in sys/ws/tcl.h. These commands
 * come from the ANSI module or its equivalent. All are ch_type CH_CTL
 */
#define CH_TCL ( ('T' << 16) | ('C' << 8) | 'L')

/* chp_stype CH_XQ and its chp_stype_cmds. They are part of the X queue handling
 * message protocol and are exchanged between the principal stream and CHAR or
 * its equivalent. All are of ch_type CH_CTL */

#define CH_XQ ( ('X' << 8) | 'Q')
#define	CH_XQENAB	1	/* from principal stream to CHAR */
#define CH_XQDISAB	2	/* from principal stream to CHAR */
#define CH_XQENAB_ACK	3	/* from CHAR to principal stream */
#define CH_XQENAB_NACK	4	/* from CHAR to principal stream */
#define CH_XQDISAB_ACK	5	/* from CHAR to principal stream */
#endif /* _SYS_WS_CHAN_H */
070701000028cf000081240000000200000002000000012719347c000006ed000000230000000c00000000000000000000001900000000usr/include/sys/ws/tcl.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ws/tcl.h.sl 1.1 4.0 10/15/90 64350 AT&T-SF"

#ifndef	_SYS_WS_TCL_H
#define	_SYS_WS_TCL_H


/* Terminal control language defines for use in the
 * Integrated Workstation Environment
 */


#define CH_TCL ( ('T' << 16) | ('C' << 8) | 'L')

#define	TCL_BELL	0
#define	TCL_BACK_SPCE	1
#define	TCL_NEWLINE	2
#define	TCL_CRRGE_RETN	3
#define	TCL_H_TAB	4
#define	TCL_V_TAB	5
#define	TCL_BACK_H_TAB	6

#define	TCL_KEYCLK_ON	10
#define	TCL_KEYCLK_OFF	11
#define	TCL_CLR_TAB	12
#define	TCL_CLR_TABS	13
#define	TCL_SET_TAB	14
#define	TCL_SHFT_FT_OU	15
#define	TCL_SHFT_FT_IN	16
#define	TCL_ADD_STR	17

#define	TCL_SCRL_UP	20
#define	TCL_SCRL_DWN	21
#define	TCL_SEND_SCR	22
#define	TCL_LCK_KB	23
#define	TCL_UNLCK_KB	24
#define	TCL_SET_ATTR	25
#define	TCL_POS_CURS	26
#define	TCL_DISP_CLR	27
#define	TCL_DISP_RST	28
#define	TCL_CURS_TYP	29

#define	TCL_ERASCR_CUR2END	30
#define	TCL_ERASCR_BEG2CUR	31
#define	TCL_ERASCR_BEG2END	32
#define	TCL_ERALIN_CUR2END	33
#define	TCL_ERALIN_BEG2CUR	34
#define	TCL_ERALIN_BEG2END	35

#define	TCL_INSRT_LIN	40
#define	TCL_DELET_LIN	41
#define	TCL_INSRT_CHR	42
#define	TCL_DELET_CHR	43

#define	TCL_FLOWCTL	50

#define	TCL_POSABS	0
#define	TCL_POSREL	1

#define	TCL_FLOWOFF	0
#define	TCL_FLOWON	1

union tcl_data {
	struct tcl_mv_cur {
		short delta_x;
		short delta_y;
		unchar x_type;
		unchar y_type;
	} mv_curs;

	struct tcl_add_str {
		short len;
		short keynum;
	} add_str;

} tcl_un;

typedef union tcl_data tcl_data_t;

#endif /* _SYS_WS_TCL_H */
   070701000028d0000081240000000200000002000000012719347c00001b6b000000230000000c00000000000000000000001800000000usr/include/sys/ws/ws.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/ws/ws.h.sl 1.1 4.0 10/15/90 65219 AT&T-SF"

#ifndef	_SYS_WS_WS_H
#define	_SYS_WS_WS_H

/*
 * Definitions for the IWE.
 */

#ifdef _KERNEL
struct map_info {
	int	m_cnt;	/* count of the number of memory locations mapped */
	struct proc	*m_procp;	/* process with display mapped */
	pid_t	m_pid;
	int m_chan; /* channel that owns the map currently */
	struct kd_memloc	m_addr[10]; /* display mapping info */
};

#define	T_ANSIMVBASE	0x00001
#define	T_BACKBRITE	0x00002

typedef struct {
	int	t_flags;	/* terminal state flags -- see above */
	unchar	t_font,		/* selected font */
		t_curattr,	/* current attribute */
		t_normattr,	/* normal character attribute */
		t_undstate;	/* underline state */
	ushort	t_rows,		/* number of characters vertically */
		t_cols,		/* number of characters horizontally */
		t_scrsz,	/* number of characters (ch_cols * ch_rows) */
		t_origin,	/* upper left corner of screen in buffer */
		t_cursor,	/* cursor position (0-based) */
		t_curtyp,	/* cursor type 1 == block, 0 == underline */
		t_row,		/* current row */
		t_col,		/* current column */
		t_sending,	/* sending screen */
		t_sentrows,	/* rows sent */
		t_sentcols;	/* cols sent */
	unchar	t_pstate,	/* parameter parsing state */
		t_ppres;	/* does output ESC sequence have a param */
	ushort	t_pcurr,	/* value of current param */
		t_pnum,		/* current param # of ESC sequence */
		t_ppar[5];	/* parameters of ESC sequence */
	struct attrmask
		*t_attrmskp;	/* pointer to attribute mask array */
	unchar	t_nattrmsk,	/* size of attribute mask array */
		t_ntabs,	/* number of tab stops set */
		*t_tabsp;	/* list of tab stops */
} termstate_t;

typedef struct {
	unchar	v_cmos,		/* cmos video controller value */
		v_type,		/* video controller type */
		v_cvmode,	/* current video mode */
		v_dvmode,	/* default video mode */
		v_font,		/* current font loaded */
		v_colsel,	/* color select register byte */
		v_modesel,	/* mode register byte */
		v_undattr,	/* underline attribute */
		v_uline,	/* underline status (on or off) */
		v_nfonts,	/* number of fonts */
		v_border;	/* border attribute */
	ushort	v_scrmsk,	/* mask for placing text in screen memory */
		v_regaddr;	/* address of corresponding M6845 or EGA */
	unchar	**v_parampp;	/* pointer to video parameters table */
	struct font_info
		*v_fontp;	/* pointer to font information */
	caddr_t	v_rscr;		/* "real" address of screen memory */
	ushort	*v_scrp;	/* pointer to video memory */
	int	v_modecnt;	/* number of modes supported */
	struct modeinfo
		*v_modesp;	/* pointer to video mode information table */
	ushort	v_ioaddrs[MKDIOADDR];	/* valid I/O addresses */
} vidstate_t;

typedef struct {
	unchar	kb_sysrq,	/* true if last character was K_SRQ */
		kb_srqscan,	/* scan code of K_SRQ */
		kb_lasthot,	/* last hot-key character */
		kb_prevscan;	/* previous scancode */
	ushort	kb_state,	/* keyboard shift/ctrl/alt state */
		kb_sstate,	/* saved keyboard shift/ctrl/alt state */
		kb_togls;	/* caps/num/scroll lock toggles state */
	int	kb_extkey,	/* extended key enable state */
		kb_altseq;	/* used to build extended codes */
} kbstate_t;

typedef unchar	extkeys_t[NUM_KEYS+1][NUMEXTSTATES];
typedef unchar	esctbl_t[ESCTBLSIZ][2];

struct pfxstate {
	unchar val;
	unchar type;
};

typedef struct pfxstate pfxstate_t[K_PFXL - K_PFXF + 1];

typedef struct charmap {
	keymap_t
		*cr_keymap_p;	/* scancode to character set mapping */
	extkeys_t
		*cr_extkeyp;	/* extended code mapping */
	esctbl_t
		*cr_esctblp;	/* 0xe0 prefixed scan code mapping */
	strmap_t
		*cr_strbufp;	/* function key mapping */
	srqtab_t
		*cr_srqtabp;	/* sysrq key mapping */
	stridx_t
		*cr_strmap_p;	/* string buffer */
	pfxstate_t
		*cr_pfxstrp;
	struct charmap
		*cr_defltp;	/* pointer to default information for ws */
} charmap_t;


typedef struct scrn {
	scrnmap_t	*scr_map_p;
	struct scrn	*scr_defltp;
} scrn_t;


struct channel_info {
	queue_t	*ch_qp;		/* channel read queue pointer */
	int	ch_opencnt,	/* number of opens */
		ch_closing,	/* indicates the channel is closing */
		ch_id,		/* channel id number */
		ch_slpaddr,	/* address to sleep on */
		ch_flags;	/* channel flags */
	struct proc
		*ch_procp;
	int	ch_pid,
		ch_timeid;	/* timeout id for channel switching */
	short	ch_relsig,	/* release signal */
		ch_acqsig,	/* acquire signal */
		ch_frsig;	/* free signal */
	unchar	ch_dmode;	/* current display mode */
	struct wstation 
		*ch_wsp;
	kbstate_t
		ch_kbstate;	/* keyboard state information */
	charmap_t
		*ch_charmap_p;	/* character mapping tables */
	scrn_t
		ch_scrn;
	vidstate_t
		ch_vstate;	/* channel video state information */
	termstate_t
		ch_tstate;	/* terminal state structure for this channel */
	struct strtty
		ch_strtty;
	xqInfo	ch_xque;
	struct channel_info
		*ch_nextp,	/* next channel in linked list */
		*ch_prevp;	/* previous channel in linked list */
#ifdef MERGE386
	struct mcon *ch_merge;	/* pointer to merge console structure */
#endif
};

typedef struct channel_info	channel_t;

typedef struct wstation {
	int	w_init,		/* workstation has been initialized */
		w_intr,		/* indicates interrupt processing */
		w_active,	/* active channel */
		w_nchan,	/* number of channels */
		w_ticks,	/* used for BELL functionality */
		w_tone,
		w_flags,
		w_noacquire,
		w_wsid,
		w_forcechan,
		w_forcetimeid,
		w_lkstate,
		w_clkstate;
	unchar	w_kbtype,
		w_dmode;
	queue_t	*w_qp;		/* pointer to queue for this minor device */
	mblk_t	*w_mp;		/* pointer to current message block */
	int	w_timeid;	/* id for pending timeouts */
	caddr_t	w_private;	/* used for any workstation specific info */
	channel_t
		**w_chanpp,
		*w_switchto;
	ushort	**w_scrbufpp;
	scrn_t	w_scrn;
	vidstate_t
		w_vstate;	/* workstation video state information */
	termstate_t
		w_tstate;
	struct map_info
		w_map;
	charmap_t
		w_charmap;	/* default charmap for workstation */
	int	(*w_stchar)(),
		(*w_clrscr)(),
		(*w_setbase)(),
		(*w_activate)(),
		(*w_setcursor)(),
		(*w_bell)(),
		(*w_shiftset)(),
		(*w_mvword)(),
		(*w_undattr)(), 
		(*w_rel_refuse)(),
		(*w_acq_refuse)(),
		(*w_scrllck)(),
		(*w_cursortype)(),
		(*w_unmapdisp)();
} wstation_t;

#define	WSCMODE(x)	((struct modeinfo *)x->v_modesp + x->v_cvmode)
#define WSMODE(x, n)	((struct modeinfo *)x->v_modesp + n)
#define WSNTIM	-1

#define HOTKEY	0x10000

#define	WS_NOMODESW	0x01
#define WS_NOCHANSW	0x02
#define WS_LOCKED	0x04
#define WS_KEYCLICK	0x08

#define CHN_UMAP	0x001
#define CHN_XMAP	0x002
#define CHN_QRSV	0x004
#define CHN_ACTV	0x008
#define CHN_PROC	0x010
#define CHN_WAIT	0x020
#define CHN_HIDN	0x040
#define CHN_WACT	0x080
#define CHN_KILLED	0x100

#define CHN_MAPPED	(CHN_UMAP | CHN_XMAP)

#define CHNFLAG(x, y)	(x->ch_flags & y)
#endif /* _KERNEL */

#define	WS_MAXCHAN	15

#endif	/* _SYS_WS_WS_H */
 07070100005a4d000081240000000200000002000000012719347c00003bd9000000230000000c00000000000000000000001800000000usr/include/sys/x.out.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_X_OUT_H
#define _SYS_X_OUT_H

#ident	"@(#)/usr/include/sys/x.out.h.sl 1.1 4.0 10/15/90 26889 AT&T-SF"

/*
 *	<a.out.h> - Object file structure declarations.
 *
 *	M_386	Modified for 386 XENIX by Martin Dunsmuir, Dec 1985.
 */


/*
 *	The main and extended header structures.
 *	For x.out segmented (XE_SEG):
 *	    1) fields marked with (s) must contain sums of xs_psize for
 *		non-memory images, or xs_vsize for memory images.
 *	    2) the contents of fields marked with (u) are undefined.
 */

/*
 *	For the 386 all these fields assume their full 32 bit meaning
 *	
 *	This is still sufficient for 386 large model so long as the
 *	sum of the virtual sizes of the segments does not exceed 4Gb.
 *	
 *	The linker must generate some new data here, specifically:
 *	
 *		x_cpu == XC_386 
 *		x_renv	has new bits interpretations controlled by
 *			the -V option of the linker (see below).
 */	

struct xexec {			    /* x.out header */
	unsigned short	x_magic;	/* magic number */
	unsigned short	x_ext;		/* size of header extension */
	long		x_text;		/* size of text segment (s) */
	long		x_data;		/* size of initialized data (s) */
	long		x_bss;		/* size of uninitialized data (s) */
	long		x_syms;		/* size of symbol table (s) */
	long		x_reloc;	/* relocation table length (s) */
	long		x_entry;	/* entry point, machine dependent */
	char		x_cpu;		/* cpu type & byte/word order */
	char		x_relsym;	/* relocation & symbol format (u) */
	unsigned short	x_renv;		/* run-time environment */
};

/*
 *	For the 386 the following fields are affected:
 *
 *	xe_pagesize	set by the linker option -R this
 *			is currently 0 and should be set to the pagesize
 *			of the 386 XENIX implementation modulo 512.
 */

struct xext {			    /* x.out header extension */
	/* The following 4 fields are UNUSED currently */
	long		xe_trsize;	/* size of text relocation (s) */
	long		xe_drsize;	/* size of data relocation (s) */
	long		xe_tbase;	/* text relocation base (u) */
	long		xe_dbase;	/* data relocation base (u) */
	/* End of unused fields */
	long		xe_stksize;	/* stack size (if XE_FS set) */
				/* the following must be present if XE_SEG */
	long		xe_segpos;	/* segment table position */
	long		xe_segsize;	/* segment table size */
	long		xe_mdtpos;	/* machine dependent table position */
	long		xe_mdtsize;	/* machine dependent table size */
	char		xe_mdttype;	/* machine dependent table type */
	char		xe_pagesize;	/* file pagesize, in multiples of 512 */
	char		xe_ostype;	/* operating system type */
	char		xe_osvers;	/* operating system version */
	unsigned short	xe_eseg;	/* entry segment, machine dependent */
	unsigned short	xe_sres;	/* reserved */
};


/*
 *	for the 386:
 *
 *	xs_filpos	set to a multiple of xe_pagesize*512 to allow
 *			demand loading from the file system.
 *	xs_rbase	modulo xe_pagesize*512 and set using the -D and
 *			-T options of the linker.
 */

struct xseg {			    /* x.out segment table entry */
	unsigned short	xs_type;	/* segment type */
	unsigned short	xs_attr;	/* segment attributes */
	unsigned short	xs_seg;		/* segment number */
	char		xs_align;	/* log base 2 of alignment */
	char		xs_cres;	/* unused */
	long		xs_filpos;	/* file position */
	long		xs_psize;	/* physical size (in file) */
	long		xs_vsize;	/* virtual size (in core) */
	long		xs_rbase;	/* relocation base address/offset */
	unsigned short	xs_noff;	/* segment name string table offset */
	unsigned short	xs_sres;	/* unused */
	long		xs_lres;	/* unused */
};


struct xiter {			    /* x.out iteration record */
	long		xi_size;	/* source byte count */
	long		xi_rep;		/* replication count */
	long		xi_offset;	/* destination offset in segment */
};


struct xlist { 			    /* xlist structure for xlist(3). */
	unsigned short	xl_type;	/* symbol type */
	unsigned short	xl_seg;		/* file segment table index */
	long		xl_value;	/* symbol value */
	char		*xl_name;	/* pointer to asciz name */
};


/*
 *      Definitions for xexec.x_magic, HEX (short).
 */

#define ARCMAGIC	0xff65	/* 0177545, archive, same as always */
#define X_MAGIC		0x0206	/* indicates x.out header */


/*
 *      Definitions for xexec.x_cpu, cpu type (char).
 *
 *	b       	set if high byte first in short
 *	 w              set if low word first in long
 *	  cccccc	cpu type
 */

	/* bytes/words are "swapped" if not stored in pdp11 ordering */
#define XC_BSWAP	0x80	/* bytes swapped */
#define XC_WSWAP	0x40	/* words swapped */

#define XC_NONE		0x00	/* none */
#define XC_PDP11	0x01	/* pdp11 */
#define XC_23		0x02	/* 23fixed from pdp11 */
#define XC_Z8K		0x03	/* Z8000 */
#define XC_8086		0x04	/* I8086 */
#define XC_68K		0x05	/* M68000 */
#define XC_Z80		0x06	/* Z80 */
#define XC_VAX		0x07	/* VAX 780/750 */
#define XC_16032	0x08	/* NS16032 */
#define XC_286		0x09	/* iAPX 80286 */
#define XC_286V		0x29	/* iAPX 80286, use xe_osver for version */
#define XC_386		0x0a	/* iAPX 80386 */
#define XC_186		0x0b	/* iAPX 80186 */
#define XC_CPU		0x3f	/* cpu mask */


/*
 *	Definitions for xexec.x_relsym (char), valid only if !XE_SEG.
 *
 *	rrrr            relocation table format
 *	    ssss        symbol table format
 */

	/* relocation table format */
#define XR_RXOUT	0x00	/* x.out long form, linkable */
#define XR_RXEXEC	0x10	/* x.out short form, executable */
#define XR_RBOUT	0x20	/* b.out format */
#define XR_RAOUT	0x30	/* a.out format */
#define XR_R86REL	0x40	/* 8086 relocatable format */
#define XR_R86ABS	0x50	/* 8086 absolute format */
#define XR_R286ABS	0x60	/* 80286 absolute format */
#define XR_R286REL	0x70	/* 80286 relocatable format */
#define XR_REL		0xf0	/* relocation format mask */

	/* symbol table format */
#define XR_SXOUT	0x00	/* trailing string, struct sym */
#define XR_SBOUT	0x01	/* trailing string, struct bsym */
#define XR_SAOUT	0x02	/* struct asym (nlist) */
#define XR_S86REL	0x03	/* 8086 relocatable format */
#define XR_S86ABS	0x04	/* 8086 absolute format */
#define XR_SUCBVAX	0x05	/* separate string table */
#define XR_S286ABS	0x06	/* 80286 absolute format */
#define XR_S286REL	0x07	/* 80286 relocatable format */
#define XR_SXSEG	0x08	/* segmented format */
#define XR_SYM		0x0f	/* symbol format mask */


/*
 *      Definitions for xexec.x_renv (short).
 *
 *	vv                  version compiled for
 *	  xx                extra (zero)
 *	    s               set if segmented x.out
 *	     a              set if absolute (set up for physical address)
 *	      i             set if segment table contains iterated text/data
 *	       v            set if virtual kernel module or shared library
 *				   was (h) but this was never used.
 *	        f           set if floating point hardware required
 *	         t          set if large model text
 *	          d         set if large model data
 *	           o        set if text overlay
 *	            f       set if fixed stack
 *	             p      set if text pure
 *	              s     set if separate I & D
 *	               e    set if executable
 */

/*
 * 	On the 386 the validity of a module and its type
 *	is determined by the settings of the XE_ABS, XE_VMOD and XE_EXEC
 *	bits as follows:
 *
 *	XE_ABS	XE_VMOD	XE_EXEC			Meaning
 *	  0	   0       0		BAD x.out (error in linking)
 *	  0	   0	   1		Old x.out, no shared libraries used.
 *	  0	   1	   0		Shared Library Module.
 *	  0	   1	   1		x.out executable that uses shared libs.
 *	  1	   0	   0		BAD (not possible)
 *	  1	   0	   1		Standalone Program (e.g. kernel)
 *	  1	   1	   0		Virtual Kernel Module (e.g. IDD)
 *	  1	   1	   1		BAD (not possible)
 *
 *	The setting of the XE_VMOD bit is controlled by the -V option of
 * 	the linker.
 */

#define XE_V2		0x4000		/* version 2.x */
#define XE_V3		0x8000		/* version 3.x */
#define XE_OSV		0xc000		/* if XE_SEG use xe_osvers ... */
#define XE_V5		XE_OSV		/* else assume v5.x */
#define XE_VERS		0xc000		/* version mask */

#define XE_res1		0x2000		/* reserved */
#define XE_res2		0x1000		/* reserved */
#define XE_SEG		0x0800		/* segment table present */
#define XE_ABS		0x0400		/* absolute memory image (standalone) */
#define XE_ITER		0x0200		/* iterated text/data present */
/* #define XE_HDATA	0x0100		/* huge model data (never used) */
#define XE_VMOD		0x0100		/* virtual module */
#define XE_FPH		0x0080		/* floating point hardware required */
#define XE_LTEXT	0x0040		/* large model text */
#define XE_LDATA	0x0020		/* large model data */
#define XE_OVER		0x0010		/* text overlay */
#define XE_FS		0x0008		/* fixed stack */
#define XE_PURE		0x0004		/* pure text */
#define XE_SEP		0x0002		/* separate I & D */
#define XE_EXEC		0x0001		/* executable */


/*
 *	Definitions for xe_mdttype (char).
 */

#define	XE_MDTNONE	0	/* no machine dependent table */
#define	XE_MDT286	1	/* iAPX286 LDT */


/*
 *	Definitions for xe_ostype (char).
 */

#define	XE_OSNONE	0
#define	XE_OSXENIX	1	/* Xenix */
#define	XE_OSRMX	2	/* iRMX */
#define	XE_OSCCPM	3	/* Concurrent CP/M */


/*
 *	Definitions for xe_osvers (char).
 */

#define	XE_OSXV2	0	/* Xenix V3.x */
#define	XE_OSXV3	1	/* Xenix V3.x */
#define	XE_OSXV5	2	/* Xenix V5.x */


/*
 *	Definitions for xs_type (short).
 *	  Values from 64 to 127 are reserved.
 */

#define	XS_TNULL	0	/* unused segment */
#define	XS_TTEXT	1	/* text segment */
#define	XS_TDATA	2	/* data segment */
#define	XS_TSYMS	3	/* symbol table segment */
#define	XS_TREL		4	/* relocation segment */
#define	XS_TSESTR	5	/* segment table's string table segment */
#define	XS_TGRPS	6	/* group definitions segment */

#define	XS_TIDATA	64	/* iterated data */
#define	XS_TTSS		65	/* tss */
#define	XS_TLFIX	66	/* lodfix */
#define	XS_TDNAME	67	/* descriptor names */
#define	XS_TDTEXT	68	/* debug text segment */
#define	XS_TIDBG	XS_TDTEXT
#define	XS_TDFIX	69	/* debug relocation */
#define	XS_TOVTAB	70	/* overlay table */
#define	XS_T71		71
#define	XS_TSYSTR	72	/* symbol string table */


/*
 *	Definitions for xs_attr (short).
 *	The top bit is set if the file segment represents a memory image.
 *	The low 15 bits' definitions depend on the type of file segment.
 */

#define XS_AMEM		0x8000	/* segment represents a memory image */
#define XS_AMASK	0x7fff	/* type specific field mask */

    /* For XS_TTEXT and XS_TDATA segments, bit definitions. */
#define XS_AITER	0x0001	/* contains iteration records */
#define XS_AHUGE	0x0002	/* contains huge element */
#define XS_ABSS		0x0004	/* contains implicit bss */
#define XS_APURE	0x0008	/* read-only, may be shared */
#define XS_AEDOWN	0x0010	/* segment expands downward (stack) */
#define XS_APRIV	0x0020	/* segment may not be combined */
#define	XS_A32BIT	0x0040	/* segment is 32 bits */

    /* For XS_TSYMS segments, enumerated symbol table types. */
#define XS_S5BELL	0	/* Bell 5.2 format */
#define XS_SXSEG	1	/* x.out segmented format */
#define	XS_SISLAND	2	/* island debugger support */

    /* For XS_TREL segments, enumerated relocation table types. */
#define XS_RXSEG	1	/* x.out segmented format */
#define XS_R86SEG	2	/* 8086 x.out segmented relocation */


/*
 *	File position macros, valid only if !XE_SEG.
 */

#define XEXTPOS(xp)	((long) sizeof(struct xexec))
#define XTEXTPOS(xp)	(XEXTPOS(xp) + (long) (xp)->x_ext)
#define XDATAPOS(xp)	(XTEXTPOS(xp) + (xp)->x_text)
#define XSYMPOS(xp)	(XDATAPOS(xp) + (xp)->x_data)
#define XRELPOS(xp)	(XSYMPOS(xp) + (xp)->x_syms)
#define XENDPOS(xp)	(XRELPOS(xp) + (xp)->x_reloc)

#define XRTEXTPOS(xp, ep)	(XRELPOS(xp))
#define XRDATAPOS(xp, ep)	(XRELPOS(xp) + (ep)->xe_trsize)


/*
 *	byte/word swapping macros:
 */

#define SBSWAP(x) ((((x) >> 8) & 0x00ff) | \
			(((x) << 8) & 0xff00))

#define LBSWAP(x)  ((((long) (x) >> 8) & 0x00ff00ffL) | \
			(((long) (x) << 8) & 0xff00ff00L))

#define LWSWAP(x)   ((((long) (x) >> 16) & 0x0000ffffL) | \
			   (((long) (x) << 16) & 0xffff0000L))

#ifndef _STRUCTOFF_	/* Also defined in emap.h */
#define _STRUCTOFF_
#define	STRUCTOFF(structure, field)	(int) &(((struct structure *) 0)->field)
#endif	/* _STRUCTOFF_ */


#define H_NONE	0		/* not an object file */
#define H_AOUT	1		/* a.out */
#define H_BOUT	2		/* b.out */
#define H_ROUT	3		/* 8086 rel */
#define H_XROUT	4		/* 8086 rel with x.out header */
#define H_ZAOUT	5		/* z8000 a.out */
#define H_XOUT	6		/* x.out */
#define H_XSEG	7		/* segmented x.out */

#define S_XNONE	0		/* not an object file */
#define S_ASYM	1		/* a.out */
#define S_BSYM	2		/* b.out */
#define S_RSYM	3		/* 8086 rel */
#define S_XSYM	4		/* x.out symbols */
#define S_XSEG	5		/* x.out segmented symbols */
#define S_86ABS	6		/* 8086 abs symbols */
#define S_IDBG	7		/* debug symbols */
#define S_5BELL	8		/* Bell 5.2 symbols */
#define S_ISLAND 9		/* island debugger support */




/*
 *	All of the following are provided for compatibility only.
 */

struct aexec {			    /* a.out header */
	unsigned short	xa_magic;       /* magic number */
	unsigned short	xa_text;        /* size of text segment */
	unsigned short	xa_data;        /* size of initialized data */
	unsigned short	xa_bss;         /* size of unitialized data */
	unsigned short	xa_syms;        /* size of symbol table */
	unsigned short	xa_entry;       /* entry point */
	unsigned short	xa_unused;      /* not used */
	unsigned short	xa_flag;        /* relocation info stripped */
};


struct nlist {			    /* nlist structure for nlist(3). */
	char		n_name[8];	/* symbol name */
	int		n_type;		/* type flag */
	unsigned	n_value;	/* value */
};


/*
 *	Definitions for aexec.xa_magic, OCTAL, obsolete (short).
 */

#define FMAGIC		0407	/* normal */
#define NMAGIC		0410	/* pure, shared text */
#define IMAGIC		0411	/* separate I & D */
#define OMAGIC		0405	/* text overlays */
#define ZMAGIC		0413	/* demand load format */

#define	A_MAGIC1	FMAGIC
#define	A_MAGIC2	NMAGIC
#define	A_MAGIC3	IMAGIC
#define	A_MAGIC4	OMAGIC

#define Z_MAGIC1	0164007	/* normal 	    0xe807 */
#define Z_MAGIC2	0164010	/* pure only text   0xe808 */
#define Z_MAGIC3	0164011	/* separate I & D   0xe809 */
#define Z_MAGIC4	0164005	/* overlay	    0xe805 */


#define ATEXTPOS(ap)	((long) sizeof(struct aexec))
#define ADATAPOS(ap)	(ATEXTPOS(ap) + (long) (ap)->xa_text)
#define ARTEXTPOS(ap)	(ADATAPOS(ap) + (long) (ap)->xa_data)
#define ARDATAPOS(ap)	(ARTEXTPOS(ap) + ((long) \
			    ((ap)->xa_flag? 0 : (ap)->xa_text)))
#define ASYMPOS(ap)	(ATEXTPOS(ap) + \
			    (((ap)->xa_flag? 1L : 2L) * \
			((long) (ap)->xa_text + (long) (ap)->xa_data)))
#define AENDPOS(ap)	(ASYMPOS(ap) + (long) (ap)->xa_syms)




struct bexec {		    /* b.out header */
	long	xb_magic;	/* magic number */
	long	xb_text;	/* text segment size */
	long	xb_data;	/* data segment size */
	long	xb_bss;		/* bss size */
	long	xb_syms;	/* symbol table size */
	long	xb_trsize;	/* text relocation table size */
	long	xb_drsize;	/* data relocation table size */
	long	xb_entry;	/* entry point */
};


#define BTEXTPOS(bp)	((long) sizeof(struct bexec))
#define BDATAPOS(bp) 	(BTEXTPOS(bp) + (bp)->xb_text)
#define BSYMPOS(bp)	(BDATAPOS(bp) + (bp)->xb_data)
#define BRTEXTPOS(bp)	(BSYMPOS(bp) + (bp)->xb_syms)
#define BRDATAPOS(bp)	(BRTEXTPOS(bp) + (bp)->xb_trsize)
#define BENDPOS(bp)	(BRDATAPOS(bp) + (bp)->xb_drsize)

#endif	/* _SYS_X_OUT_H */
   07070100005a4e000081240000000200000002000000012719347c00000bc9000000230000000c00000000000000000000001900000000usr/include/sys/xdebug.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _SYS_XDEBUG_H
#define _SYS_XDEBUG_H

#ident	"@(#)/usr/include/sys/xdebug.h.sl 1.1 4.0 10/15/90 64641 AT&T-SF"

#ifdef i386
/*
 * xdebug.h - kernel debugging macros
 */

/*
 * Reasons for Entering Debugger
 */
#define DR_USER		0	/* User request via sysi86 or key sequence */
#define DR_BPT1		1	/* Int 1 breakpoint trap */
#define DR_STEP		2	/* (Int 1) single-step trap */
#define DR_BPT3		3	/* Int 3 (breakpoint) trap */
#define DR_PANIC	4	/* Panic occurred */
#define DR_OTHER	5	/* Miscellaneous */
#define DR_INIT		6	/* At init time; apply debugger_init string */

#define NO_FRAME	((int *)0)

#ifndef NODEBUGGER

extern void (*cdebugger)(), nullsys();
#define debugentry(r0ptr)	((*cdebugger)(DR_OTHER, r0ptr))
#define calldebug()		debugentry(NO_FRAME)

#else

#define debugentry(r0ptr)
#define calldebug()

#endif

#ifdef MSDEBUGGER
# ifndef MSDEBUG
#  define MSDEBUG
# endif
# define debugger(class) if ( debug(class, DL_HALT) ) calldebug();
#else
# define debugger(class)
#endif

#ifdef MSDEBUG
# define debug(class, level) (bugbits[class] & level)
# define dentry(class, name) if (debug(class,DL_CALL)) printf(entryfmt,name);
# define dexit(class, name) if (debug(class,DL_CALL)) printf(exitfmt, name);
  extern char entryfmt[];
  extern char exitfmt[];
#else
# define debug(class, level)	0
# define dentry(class, name) 
# define dexit(class, name)
#endif

/*
 * Debugging classes
 */
#define DB_EXEC		0	/* Exec system call */
#define DB_FP		1	/* Floating Point */
#define DB_MAIN		2	/* System initialization */
#define DB_MALLOC	3	/* Memory allocation */
#define DB_MMU		4	/* memory management */
#define DB_PHYSIO	5	/* raw I/O */
#define DB_SIG		6	/* Signals */
#define DB_SLP		7	/* Process switching */
#define DB_TEXT		8	/* Text table management */
#define DB_TRAP		9	/* Traps and faults */
#define DB_PFAULT	10
#define DB_PGOUT	11
#define DB_SCALL	12
#define DB_PHASH	13	/* filesystem page cache */
#define DB_FORK		14	/* copy on write fork */
#define DB_SWAP		15	/* swapping */
#define DB_IPC		16	/* ipc msgs, sems, shm */
#define DB_CONSOLE	17	/* console */
#define	DB_DISK		18	/* disk driver */
#define DB_SYNC		19	/* page synchronization */
#define DB_SWTCH	20	/* context switching */
#define	DB_DMA		21	/* dma */
#define NDBC		22	/* number of debugging classes */

/* 
 * Debugging levels
 */
#define DL_TERSE	1	/* terse output */
#define DL_VERB		2	/* verbose output */
#define DL_HALT		4	/* call debug() at strategic points */
#define DL_CALL		8	/* function entry/exit trace */

/*
 * Manifest constants for debugger
 */
#define NAR	19		/* can't match anything in reg.h */

extern char bugbits[];

#else

#define	calldebug()	debug(0)
#define dentry(class, name) 
#define dexit(class, name)

#endif

#endif	/* _SYS_XDEBUG_H */
   07070100005a4f000081240000000200000002000000012719347c0000093e000000230000000c00000000000000000000001700000000usr/include/sys/xque.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/sys/xque.h.sl 1.1 4.0 10/15/90 30386 AT&T-SF"

#ifndef _SYS_XQUE_H
#define _SYS_XQUE_H

/*
 * Keyboard/mouse event queue entries
 */

typedef struct xqEvent {
	unchar	xq_type;	/* event type (see below) */
	unchar	xq_code;	/* when xq_type is XQ_KEY, => scan code;
				   when xq_type is XQ_MOTION or XQ_BUTTON, =>
					bit 0 clear if right button pushed;
					bit 1 clear if middle button pushed;
					bit 2 clear if left button pushed; */
	char	xq_x;		/* delta x movement (mouse motion only) */
	char	xq_y;		/* delta y movement (mouse motion only) */
	time_t	xq_time; 	/* event timestamp in "milliseconds" */
} xqEvent;

/*	xq_type values		*/

#define XQ_BUTTON	0	/* button state change only */
#define XQ_MOTION	1	/* mouse movement (and maybe button change) */
#define XQ_KEY		2	/* key pressed or released */

/*
 * The event queue
 */

typedef struct xqEventQueue {
	char	xq_sigenable;	/* allow signal when queue becomes non-empty
				   0 => don't send signals
				   non-zero => send a signal if queue is empty
				      and a new event is added */
	int	xq_head;	/* index into queue of next event to be dequeued */
	int	xq_tail;	/* index into queue of next event slot to be filled */
	time_t	xq_curtime;	/* time in milliseconds since 1/1/70 GMT */
	int	xq_size;	/* number of elements in xq_events array */
	xqEvent	xq_events[1];	/* configurable-size array of events */
} xqEventQueue;

#ifdef _KERNEL

/*
 * The driver's private data structure to keep track of xqEventQueue
 */

typedef struct xqInfo {
	xqEventQueue	*xq_queue;	/* pointer to the xqEventQueue structure */
	int	xq_ptail;	/* private copy of xq_tail */
	int	xq_psize;	/* private copy of xq_size */
	int	xq_signo;	/* signal number to send for xq_sigenable */
	proc_t	*xq_proc;	/* pointer to x server process (for signalling) */
	int	xq_pid;		/* process id of server process */
	struct xqInfo	*xq_next,	/* next xqInfo structure in list */
			*xq_prev;	/* previous xqInfo structure in list */
	addr_t	xq_uaddr;
	unsigned	xq_npages;
} xqInfo;

#endif	/* _KERNEL */

caddr_t xq_init();

#endif	/* _SYS_XQUE_H */
  07070100005a50000081240000000200000002000000012719347c00001396000000230000000c00000000000000000000001500000000usr/include/sys/xt.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sys/xt.h.sl 1.1 4.0 10/15/90 60060 AT&T-SF"

/*
**	Multiplexed channels driver header
*/

#define	XTRACE		1		/* 1 to include tracing */
#define	XTSTATS		1		/* 1 to enable statistics */
#define	XTDATA		1		/* 1 to enable Link table extraction */

#define	MAXLINKS	32
#define	CHAN(dev)	(dev & ((1<<CHANSIZ) - 1))
#define	LINK(dev)	((dev>>CHANSIZ)&(0xff>>CHANSIZ))

#if	(MAXPCHAN*MAXLINKS) > 256
	ERROR -- product cannot be greater than minor(dev)
#endif

#if	XTRACE == 1
#define	PKTPTSZ		8			/* Packet part to be captured for trace */
#define	PKTHIST		40			/* Size of trace history */

struct Tpkt
{
	Pbyte		pktpart[PKTPTSZ-1];	/* Record of a packet captured */
	Pbyte		flag;			/* Direction */
	time_t		time;			/* Log time in ticks */
};

#define	XMITLOG		0			/* Transmitted packet */
#define	RECVLOG		1			/* Received packet */

struct Tbuf
{
	struct Tpkt	log[PKTHIST];		/* A history of transactions */
	short		flags;			/* Flags */
	char		index;			/* Next slot */
	char		used;			/* Number of slots used */
};

#define	TRACEON		1			/* Trace enabled */
#define	TRACELOCK	2			/* Trace locked */

static void	logpkt();
#define		Logpkt(A,B,C)	if (((B)->l.trace.flags&(TRACEON|TRACELOCK))==TRACEON)logpkt(A,B,C)
#define		LOCKTRACE(A)	(A)->l.trace.flags|=TRACELOCK
#else
#define		Logpkt(A,B,C)
#define		LOCKTRACE(A)
#endif

#if	XTSTATS == 1
enum stats_t
{
	 xpkts, rpkts, crcerr, badack, badnak, outseq
	,nakretrys, rdup, rnak, xnak, rack, xack
	,badhdr, badsize, lostack, badcntl, badcdata
	,nocfree, badcount, badchan, badctype, norbuf
	,rtimo, xtimo
	,wiow, woas
	,nstats
};

#define	S_XPKTS		(int)xpkts
#define	S_RPKTS		(int)rpkts
#define	S_CRCERR	(int)crcerr
#define	S_BADACK	(int)badack
#define	S_BADNAK	(int)badnak
#define	S_OUTSEQ	(int)outseq
#define	S_NAKRETRYS	(int)nakretrys
#define	S_RDUP		(int)rdup
#define	S_RNAK		(int)rnak
#define	S_XNAK		(int)xnak
#define	S_RACK		(int)rack
#define	S_XACK		(int)xack
#define	S_BADHDR	(int)badhdr
#define	S_BADSIZE	(int)badsize
#define	S_LOSTACK	(int)lostack
#define	S_BADCNTL	(int)badcntl
#define	S_BADCDATA	(int)badcdata
#define	S_NOCFREE	(int)nocfree
#define	S_BADCOUNT	(int)badcount
#define	S_BADCHAN	(int)badchan
#define	S_BADCTYPE	(int)badctype
#define	S_NORBUF	(int)norbuf
#define	S_RTIMO		(int)rtimo
#define	S_XTIMO		(int)xtimo
#define	S_WIOW		(int)wiow
#define	S_WOAS		(int)woas
#define	S_NSTATS	(int)nstats

typedef long		Stats_t;

#define	STATS(A,B)	(A)->l.stats[B]++
#else
#define	STATS(A,B)
#endif

struct Channel
{
	struct Pchannel	chan;		/* Protocol state information for this channel */
	struct tty	tty;		/* Virtual tty for this channel */
	struct jwinsize	winsize;	/* Layer parameters for JWINSIZE ioctl */
#ifdef VPIX
	v86_t		*v86p;		/* Pointer to v86 proc in DOS mode */
#endif
};

typedef struct Channel *Ch_p;

/*
**	JAGENT ioctl structure
*/
struct hagent
{
	struct bagent desc;	/* WARNING!!this better be 12 bytes long!!!
					defined in jioctl.h */
	struct cblock *retcb;		/* returning cblock from rcvpkt */
	short flag;			/* flag to synchronise ioctl's */
};

/* flags for hagent struct */
#define	AGASLP	01
#define	AGBUSY	02

struct Linkinfo
{
	struct tty *	line;		/* Real tty for this link */
	char *		rdatap;		/* Pointer into rpkt */
	struct Pktstate	rpkt;		/* Packet being received for this link */
	short		lihiwat;	/* High water mark for real line */
	short		xtimo;		/* Transmission timeout */
	char		rtimo;		/* Receive timeout */
	char		old;		/* Old line discipline for line */
	char		nchans;		/* Number of channels allowed */
	char		lchan;		/* Last channel started */
	char		open;		/* Channel open bits */
	char		xopen;		/* Exclusive open bits */
	struct hagent	agent;		/* ioctl agent structure */
	short		pid;		/* real channel control process */
	short		hex;		/* 1 if 6-bit path, 0 if 8-bit  */
#if	XTRACE == 1
	struct Tbuf	trace;		/* Tracks */
#endif
#if	XTSTATS == 1
	Stats_t		stats[S_NSTATS];/* Statistics */
#endif
};

struct Link
{
	struct Linkinfo	l;		/* Link info */
	struct Channel	chans[1];	/* Array of channels for this link */
};

typedef	struct Link *	Link_p;

/*
**	Ioctl args
*/

#define	XTIOCTYPE	('b'<<8)
#define	XTIOCLINK	(XTIOCTYPE|1)
#define	XTIOCSTATS	(XTIOCTYPE|2)
#define	XTIOCTRACE	(XTIOCTYPE|3)
#define	XTIOCNOTRACE	(XTIOCTYPE|4)
#define	XTIOCDATA	(XTIOCTYPE|5)
#define	HXTIOCLINK	(XTIOCTYPE|6)

/** Link set up request **/

struct xtioclm
{
	char		fd;		/* File descriptor for 'real' 'tty' line */
	char		nchans;		/* Maximum channels that will be used */
};

/** Data descriptor **/

struct xtiocdd
{
	int		size;		/* Sizeof buffer */
	char *		addr;		/* Address of buffer */
};

#define	PCHANMATCH(tp)	((Pch_p)(tp)-1)
#define	LINKMATCH(p)	linkTable[(p)->link]
#define	t_link		t_dstat		/* Use dstat in real tty for linknumber */
  07070100005a51000081240000000200000002000000012719347c00001329000000230000000c00000000000000000000001a00000000usr/include/sys/xtproto.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


#ident	"@(#)/usr/include/sys/xtproto.h.sl 1.1 4.0 10/15/90 15638 AT&T-SF"

/*
**	Bx -- Blit packet protocol definition
*/

typedef	unsigned char	Pbyte;			/* The unit of communication */

#define	NPCBUFS		2			/* Double buffered protocol */
#define	MAXPCHAN	8			/* Maximum channel number */

/*	Packet Header:
 *
 *      High order bits                                      Low order bits
 *	____________________________________________________________________
 *	|       |       |        |       ||                                |
 *	| ptyp  | cntl  | chan   | seq   || dsize                          |
 *	|       |       |        |       ||                                |
 *	--------------------------------------------------------------------
 *	 15      14      13    11 10    8  7                              0
 *
 *	ptyp  - always 1.
 *	cntl  - TRUE if control packet.
 *	chan  - channel number.
 *	seq   - sequence number.
 *	dsize - size of the data part.
 *
 *	Note:   The following macros are used to set the bits in the packet
 *	        header for portability reasons. The bit fields that can be
 *	        defined in C are preferable for simplicity reasons, but are
 *	        highly machine dependent.
 */

#define GET_BITS(byte,pos,len,mask)     ((byte & mask) >> pos)
#define SET_BITS(byte,pos,len,mask,val) (byte = (byte &(~mask))|((val<<pos)&mask))

#define PTYPPOS             7
#define PTYPSIZ             1
#define PTYPMASK            0x80
#define GET_PTYP(pkt)       GET_BITS(pkt.header[0],PTYPPOS,PTYPSIZ,PTYPMASK)
#define SET_PTYP(pkt,val)   SET_BITS(pkt.header[0],PTYPPOS,PTYPSIZ,PTYPMASK,val)

#define CNTLPOS             6
#define CNTLSIZ             1
#define CNTLMASK            0x40
#define GET_CNTL(pkt)       GET_BITS(pkt.header[0],CNTLPOS,CNTLSIZ,CNTLMASK)
#define SET_CNTL(pkt,val)   SET_BITS(pkt.header[0],CNTLPOS,CNTLSIZ,CNTLMASK,val)

#define CHANPOS             3
#define CHANSIZ             3
#define CHANMASK            0x38
#define GET_CHAN(pkt)       GET_BITS(pkt.header[0],CHANPOS,CHANSIZ,CHANMASK)
#define SET_CHAN(pkt,val)   SET_BITS(pkt.header[0],CHANPOS,CHANSIZ,CHANMASK,val)

#define SEQPOS              0
#define SEQSIZ              3
#define	SEQMOD              8
#define SEQMASK             0x07
#define GET_SEQ(pkt)        GET_BITS(pkt.header[0],SEQPOS,SEQSIZ,SEQMASK)
#define SET_SEQ(pkt,val)    SET_BITS(pkt.header[0],SEQPOS,SEQSIZ,SEQMASK,val)

#define HEADER_DSIZE        header[1]

/*
**	Packet definition for maximum sized packet
*/
#define	PKTHDRSIZE	(2 * sizeof(Pbyte))	/* packet header part size */
#define	MAXPKTDSIZE	(32 * sizeof(Pbyte))	/* Maximum data part size */
#define	EDSIZE		(2 * sizeof(Pbyte))	/* Error detection part size */

struct Packet
{
	Pbyte	header[PKTHDRSIZE];	/* Packet Header */
	Pbyte	data[MAXPKTDSIZE];	/* Data part */
	Pbyte	edb[EDSIZE];		/* Error detection part */
};

typedef struct Packet *	Pkt_p;

/*
**	Control codes
*/

#define	PCDATA		(Pbyte)002		/* Data only control packet       */
#define	ACK		(Pbyte)006		/* Last packet ok and in sequence */
#define	NAK		(Pbyte)025		/* Last packet out of sequence    */

/*
**	Definition of a structure to hold status information
**	for a conversation with a channel.
*/

struct Pktstate
{
	struct Packet	pkt;			/* The packet */
	short		timo;			/* Timeout count */
	unsigned char	state;			/* Protocol state */
	unsigned char	size;			/* Packet size */
};

typedef struct Pktstate *Pks_p;

struct Pchannel
{
	struct Pktstate	pkts[NPCBUFS];		/* The packets */
	Pks_p		nextpkt;		/* Next packet to be acknowledged */
	Pbyte		cdata[SEQMOD];		/* Remember transmitted control data */
	Pbyte		rseq	:SEQSIZ;	/* Next receive sequence number */
	Pbyte		xseq	:SEQSIZ;	/* Next transmit sequence number */
	char		outen;			/* Output packets enabled */
	char		flags;			/* Control flags */
#if XTDRIVER == 1
	char		channo;			/* This channel's number */
	char		link;			/* This channel's link */
#endif
};

#define	XACK		1			/* Send ACK */
#define	XNAK		2			/* Send NAK */
#define	XCDATA		4			/* Send control data in ACK packet */

typedef struct Pchannel *Pch_p;

/**	Transmit packet states	**/

enum {	px_null, px_ready, px_wait, px_ok	};

#define	PX_NULL		(int)px_null		/* Empty packet */
#define	PX_READY	(int)px_ready		/* Full packet awaiting transmission */
#define	PX_WAIT		(int)px_wait		/* Packet awaiting acknowledgement */
#define	PX_OK		(int)px_ok		/* Packet has been acknowledged */

/**	Receive packet states	**/

enum { pr_null, pr_size, pr_data };

#define	PR_NULL		(int)pr_null		/* New packet expected */
#define	PR_SIZE		(int)pr_size		/* Size byte next */
#define	PR_DATA		(int)pr_data		/* Receiving data */
   070701000051d2000081240000000200000002000000012719347c000001ac000000230000000c00000000000000000000001500000000usr/include/tiuser.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/tiuser.h.sl 1.1 4.0 10/15/90 27906 AT&T-SF"

/*
 * TLI user interface definitions.
 */

#ifndef  _SYS_TIUSER_H
#include <sys/tiuser.h>
#endif

070701000051d0000081240000000200000002000000012719347c00000b77000000230000000c00000000000000000000001400000000usr/include/table.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/table.h.sl 1.1 4.0 10/15/90 15991 AT&T-SF"
/*
	This file contains all structure definitions for the table
	management library.
*/

/*
	#DEFINES
*/
/* Maximum values of various things */
#define TL_MAXTABLES 20
#define	TL_MAXFIELDS 32
#define	TL_MAXLINESZ 512
#define	TLCOMMENT	(unsigned char *)"<COMMENT>"
#define TLTRAILING	(unsigned char *)"<TRAILING>"

/* Search Operations */
#define	TLEQ	-1
#define	TLNE	-2
#define	TLLT	-3
#define TLGT	-4
#define	TLLE	-5
#define	TLGE	-6
#define TLMATCH	-7
#define	TLNMATCH	-8
#define	TLNUMEQ	-9
#define	TLNUMNE	-10
#define	TLNUMLT	-11
#define TLNUMGT	-12
#define	TLNUMLE	-13
#define	TLNUMGE	-14

/* Search how_to_match argument values */
#define	TL_AND	1
#define	TL_NAND	2
#define	TL_OR	3
#define	TL_NOR	4

/* NOTE: Entryno must have at least TLBITS + 2 number of bits */
typedef	int entryno_t;

#define	TLBITS		14
#define	TLBEGIN		0
#define	TLEND		(1<<(TLBITS + 2))	/* This is NOT portable */

/* 
	RETURN CODES
*/
#define	TLSUBSTITUTION -11 /* Text to be used in a field contains one or more
	field separatiors, end-of-entry characters, or comment characters */
#define	TLBADFIELD	-10	/* Non-existent field */
#define	TLNOMEMORY	-9	/* A malloc() failed */
#define	TLBADENTRY	-8	/* Entry does not exist */
#define	TLBADFORMAT	-7	/* Format in table description has bad syntax */
#define	TLBADID	-6	/* Invalid tid given to a library routine */
#define	TLTOOMANY	-5	/* Attempting to open too many tables */
#define TLDESCRIPTION	-4	/* Semantic ambiguity in a table description */
#define TLTOOLONG	-3	/* An Entry in the table is too long */
#define	TLARGS	-2
#define	TLFAILED	-1
#define	TLOK	0
#define	TLBADFS	1	/* Field Separator in TLopen() call differs from
					that in the table */
#define	TLDIFFFORMAT	2	/* Format in TLopen() call or entry argument
							differs from that in the table */

/*
	Typedefs
*/

/*
	This structure describes what a table is supposed to look like.
*/
typedef struct TLdesc {
	unsigned char td_fs;	/* field separator - default ":" */
	unsigned char td_eoe;	/* End of entry - default "\n" */
	unsigned char td_comment;	/* comment character - default "#" */
	unsigned char *td_format;	/* entry format */
} TLdesc_t;

/* This hides the implementation of an ENTRY from applications */
typedef	long ENTRY;

/*
	This structure describes search operations.
*/
typedef	struct TLsearch	{
	unsigned char *ts_fieldname;
	unsigned char *ts_pattern;
	int	(*ts_operation)();
} TLsearch_t;

/* Declarations */
int TLopen(), TLsync(), TLclose(), TLread(), TLwrite(), TLdelete();
int TLappend(), TLassign(), TLsubst(), TLfreeentry(), TLsearch1();
ENTRY TLgetentry();
unsigned char *TLgetfield();

 070701000051d3000081240000000200000002000000012719347c000009a2000000230000000c00000000000000000000001700000000usr/include/userdefs.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)/usr/include/userdefs.h.sl 1.1 4.0 10/15/90 12421 AT&T-SF"

/* User/group default values */
#define	DEFGID		99	/* max reserved group id */
#define	DEFRID		99
#define	DEFGROUP	1
#define	DEFGNAME	"other"
#define	DEFPARENT	"/home"
#define	DEFSKL		"/etc/skel"
#define	DEFSHL		"/sbin/sh"
#define	DEFINACT	0
#define	DEFEXPIRE	""

/* Defaults file keywords */
#define	RIDSTR		"defrid="
#define	GIDSTR		"defgroup="
#define	GNAMSTR		"defgname="
#define	PARSTR		"defparent="
#define	SKLSTR		"defskel="
#define	SHELLSTR	"defshell="
#define	INACTSTR	"definact="
#define	EXPIRESTR	"defexpire="
#define	FHEADER		"#	Default values for useradd.  Changed "

/* Defaults file */
#define	DEFFILE		"/usr/sadm/defadduser"
#define	GROUP	"/etc/group"

/* various limits */
#define	MAXGLEN		9	/* max length of group name */
#define	MAXDLEN		80	/* max length of a date string */

/* defaults structure */
struct userdefs {
	int defrid;		/* highest reserved uid */
	int defgroup;		/* default group id */
	char *defgname;		/* default group name */
	char *defparent;	/* default base directory for new logins */
	char *defskel;		/* default skel directory */
	char *defshell;		/* default shell */
	int definact;		/* default inactive */
	char *defexpire;		/* default expire date */
};

/* exit() values for user/group commands */

/* Everything succeeded */
#define	EX_SUCCESS	0

/* No permission */
#define	EX_NO_PERM	1

/* Command syntax error */
#define	EX_SYNTAX	2

/* Invalid argument given */
#define	EX_BADARG	3

/* A gid or uid already exists */
#define	EX_ID_EXISTS	4

/* PASSWD and SHADOW are inconsistent with each other */
#define	EX_INCONSISTENT	5

/* A group or user name  doesn't exist */
#define	EX_NAME_NOT_EXIST	6

/* GROUP, PASSWD, or SHADOW file missing */
#define	EX_MISSING	7

/* GROUP, PASSWD, or SHAWOW file is busy */
#define	EX_BUSY	8

/* A group or user name already exists */
#define	EX_NAME_EXISTS	9

/* Unable to update GROUP, PASSWD, or SHADOW file */
#define	EX_UPDATE	10

/* Not enough space */
#define	EX_NOSPACE	11

/* Unable to create/remove/move home directory */
#define	EX_HOMEDIR	12

/* new login already in use */
#define	EX_NL_USED	13

/* Unexpected failure */
#define	EX_FAILURE	14
  070701000028d7000041ed0000000200000002000000022719347c00000000000000230000000c00000000000000000000000f00000000usr/include/vm    070701000028d1000081240000000200000002000000012719347c00000cbf000000230000000c00000000000000000000001600000000usr/include/vm/anon.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_ANON_H
#define _VM_ANON_H

#ident	"@(#)/usr/include/vm/anon.h.sl 1.1 4.0 10/15/90 61412 AT&T-SF"

/*
 * VM - Anonymous pages.
 */

/*
 * Each page which is anonymous, either in memory or in swap,
 * has an anon structure.  The structure's primary purpose is
 * to hold a reference count so that we can detect when the last
 * copy of a multiply-referenced copy-on-write page goes away.
 * When on the free list, un.next gives the next anon structure
 * in the list.  Otherwise, un.page is a ``hint'' which probably
 * points to the current page.  This must be explicitly checked
 * since the page can be moved underneath us.  This is simply
 * an optimization to avoid having to look up each page when
 * doing things like fork.
 */
struct anon {
	int	an_refcnt;
	union {
		struct	page *an_page;	/* ``hint'' to the real page */
		struct	anon *an_next;	/* free list pointer */
	} un;
	struct anon *an_bap;		/* pointer to real anon */
	short	an_flag;		/* see below */
	short	an_use;			/* for debugging code */
};

/* an_flag values */
#define ALOCKED	0x1
#define AWANT	0x2

#ifdef DEBUG
/* an_use values */
#define AN_NONE		0
#define AN_DATA		1
#define AN_UPAGE	2
#endif

struct anoninfo {
	u_int	ani_max;	/* maximum anon pages available */
	u_int	ani_free;	/* number of anon pages currently free */
	u_int	ani_resv;	/* number of anon pages reserved */
};

#ifdef _KERNEL
extern	struct anoninfo anoninfo;

struct	anon *anon_alloc();
void	anon_dup(/* old, new, size */);
void	anon_free(/* app, size */);
int	anon_getpage(/* app, protp, pl, sz, seg, addr, rw, cred */);
struct	page *anon_private(/* app, seg, addr, ppsteal */);
struct	page *anon_zero(/* seg, addr, app */);
struct	page *anon_zero_aligned(/* seg, addr, app, align_mask, align_val */);
void	anon_unloadmap(/* ap, ref, mod */);
int	anon_resv(/* size */);
void	anon_unresv(/* size */);

#define ALOCK(ap) { \
	while ((ap)->an_flag & ALOCKED) { \
		(ap)->an_flag |= AWANT; \
		(void) sleep((caddr_t)(ap), PINOD); \
	} \
	(ap)->an_flag |= ALOCKED; \
}

#define AUNLOCK(ap) { \
	ASSERT((ap)->an_flag & ALOCKED); \
	(ap)->an_flag &= ~ALOCKED; \
	if ((ap)->an_flag & AWANT) { \
		(ap)->an_flag &= ~AWANT; \
		wakeprocs((caddr_t)(ap), PRMPT); \
	} \
}

/* flags to anon_private */
#define STEAL_PAGE 0x1
#define LOCK_PAGE 0x2

#endif /* _KERNEL */

#endif	/* _VM_ANON_H */
 070701000028d3000081240000000200000002000000012719347c00000b6e000000230000000c00000000000000000000001400000000usr/include/vm/as.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_AS_H
#define _VM_AS_H

#ident	"@(#)/usr/include/vm/as.h.sl 1.1 4.0 10/15/90 23091 AT&T-SF"

#include "vm/faultcode.h"
#include "vm/vm_hat.h"

/*
 * VM - Address spaces.
 */

/*
 * Each address space consists of a list of sorted segments
 * and machine dependent address translation information.
 *
 * All the hard work is in the segment drivers and the
 * hardware address translation code.
 */
struct as {
	u_int	a_lock: 1;
	u_int	a_want: 1;
	u_int	a_paglck: 1;
	u_int	: 13;
	u_short	a_keepcnt;	/* number of `keeps' */
	struct	seg *a_segs;	/* segments in this address space */
	struct	seg *a_seglast;	/* last segment hit on the address space */
	size_t	a_size;		/* size of address space */
	size_t	a_rss;		/* memory claim for this address space */
	struct	hat a_hat;	/* hardware address translation */
};

#ifdef _KERNEL

/*
 * Flags for as_gap.
 */
#define AH_DIR		0x1	/* direction flag mask */
#define AH_LO		0x0	/* find lowest hole */
#define AH_HI		0x1	/* find highest hole */
#define AH_CONTAIN	0x2	/* hole must contain `addr' */

#ifdef __STDC__
extern size_t rm_assize(struct as *);
extern int as_lock(struct as *, int, u_int);
#else
extern size_t rm_assize();
extern int as_lock();
#endif

struct	seg *as_segat(/* as, addr */);
struct	as *as_alloc();
void	as_free(/* as */);
struct	as *as_dup(/* as */);
int	as_addseg(/* as, seg */);
faultcode_t as_fault(/* as, addr, size, type, rw */);
faultcode_t as_faulta(/* as, addr, size */);
int	 as_setprot(/* as, addr, size, prot */);
int	as_checkprot(/* as, addr, size, prot */);
int	as_unmap(/* as, addr, size */);
int	as_map(/* as, addr, size, crfp, crargsp */);
int	as_gap(/* as, minlen, basep, lenp, flags, addr */);
int	as_memory(/* as, addrp, sizep */);
u_int	as_swapout(/* as */);
int	as_incore(/* as, addr, size, vecp, sizep */);
int	as_ctl(/* as, addr, size, func, attr, arg, bitmap, pos */);
u_int	as_getprot(/* as, addr, naddrp */);

struct anon_map *as_shmlookup(/* as, addr */);
#endif /* _KERNEL */

#endif	/* _VM_AS_H */
  070701000028d4000081240000000200000002000000012719347c000006c4000000230000000c00000000000000000000001a00000000usr/include/vm/bootconf.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_BOOTCONF_H
#define _VM_BOOTCONF_H

#ident	"@(#)/usr/include/vm/bootconf.h.sl 1.1 4.0 10/15/90 34838 AT&T-SF"

/*
 * Boot time configuration information objects
 */

#define	MAXFSNAME	16
#define	MAXOBJNAME	128
/*
 * Boot configuration information
 */
struct bootobj {
	char	bo_fstype[MAXFSNAME];	/* filesystem type name (e.g. nfs) */
	char	bo_name[MAXOBJNAME];	/* name of object */
	int	bo_flags;		/* flags, see below */
	int	bo_offset;		/* number of blocks */
	int	bo_size;		/* number of blocks */
	struct vnode *bo_vp;		/* vnode of object */
};

/*
 * flags
 */
#define	BO_VALID	0x01		/* all information in object is valid */
#define	BO_BUSY		0x02		/* object is busy */

extern struct bootobj rootfs;
extern struct bootobj dumpfile;
extern struct bootobj swapfile;

#endif	/* _VM_BOOTCONF_H */
070701000028d5000081240000000200000002000000012719347c0000041f000000230000000c00000000000000000000001500000000usr/include/vm/cpu.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_CPU_H
#define _VM_CPU_H

#ident	"@(#)/usr/include/vm/cpu.h.sl 1.1 4.0 10/15/90 44659 AT&T-SF"

#endif	/* _VM_CPU_H */
 070701000028d6000081240000000200000002000000012719347c00000433000000230000000c00000000000000000000001a00000000usr/include/vm/debugger.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_DEBUGGER_H
#define _VM_DEBUGGER_H

#ident	"@(#)/usr/include/vm/debugger.h.sl 1.1 4.0 10/15/90 62247 AT&T-SF"

#endif	/* _VM_DEBUGGER_H */
 070701000028d8000081240000000200000002000000012719347c00000795000000230000000c00000000000000000000001b00000000usr/include/vm/faultcode.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_FAULTCODE_H
#define _VM_FAULTCODE_H

#ident	"@(#)/usr/include/vm/faultcode.h.sl 1.1 4.0 10/15/90 34650 AT&T-SF"

/*
 * This file describes the "code" that is delivered during
 * SIGBUS and SIGSEGV exceptions.  It also describes the data
 * type returned by vm routines which handle faults.
 *
 * If FC_CODE(fc) == FC_OBJERR, then FC_ERRNO(fc) contains the errno value
 * returned by the underlying object mapped at the fault address.
 */
#define	FC_HWERR	0x1	/* misc hardware error (e.g. bus timeout) */
#define	FC_ALIGN	0x2	/* hardware alignment error */
#define	FC_NOMAP	0x3	/* no mapping at the fault address */
#define	FC_PROT		0x4	/* access exceeded current protections */
#define	FC_OBJERR	0x5	/* underlying object returned errno value */

#define	FC_MAKE_ERR(e)	(((e) << 8) | FC_OBJERR)

#define	FC_CODE(fc)	((fc) & 0xff)
#define	FC_ERRNO(fc)	((unsigned)(fc) >> 8)

#ifndef LOCORE
typedef	int	faultcode_t;	/* type returned by vm fault routines */
#endif /* LOCORE */

#endif	/* _VM_FAULTCODE_H */
   070701000028d9000081240000000200000002000000012719347c00001135000000230000000c00000000000000000000001500000000usr/include/vm/hat.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_HAT_H
#define _VM_HAT_H

#ident	"@(#)/usr/include/vm/hat.h.sl 1.1 4.0 10/15/90 60787 AT&T-SF"

/*
 * VM - Hardware Address Translation management.
 *
 * This file describes the machine independent interfaces to
 * the hardware address translation management routines.  Other
 * machine specific interfaces and structures are defined
 * in <vm/vm_hat.h>.  The hat layer manages the address
 * translation hardware as a cache driven by calls from the
 * higher levels of the VM system.
 */

#include "vm/vm_hat.h"

#ifdef _KERNEL
/*
 * One time hat initialization
 */
void	hat_init();

/*
 * Operations on hat resources for an address space:
 *	- initialize any needed hat structures for the address space
 *	- free all hat resources now owned by this address space
 *	- initialize any needed hat structures when the process is
 *	  swapped in.
 *	- free all hat resources that are not needed while the process
 *	  is swapped out.
 *	- dup any hat resources that can be created when duplicating
 *	  another process' address space.
 *
 * N.B. - The hat structure is guaranteed to be zeroed when created.
 * The hat layer can choose to define hat_alloc as a macro to avoid
 * a subroutine call if this is sufficient initialization.
 */
void	hat_alloc(/* as */);
void	hat_free(/* as */);
void	hat_swapin(/* as */);
void	hat_swapout(/* as */);
int	hat_dup(/* as */);

/* Operation to allocate/reserve mapping structures
 *	- allocate/reserve mapping structures for a segment.
 */
u_int	hat_map(/* seg, vp, vp_base, prot, flags */);

/*
 * Operations on a named address with in a segment:
 *	- load/lock the given page struct
 *	- load/lock the given page frame number
 *	- unlock the given address
 *
 * (Perhaps we need an interface to load several pages at once?)
 */
void	hat_memload(/* seg, addr, pp, prot, flags */);
void	hat_devload(/* seg, addr, pf, prot, flags */);
void	hat_unlock(/* seg, addr */);

/*
 * Operations over an address range:
 *	- change protections
 *	- change mapping to refer to a new segment
 *	- unload mapping
 */
void	hat_chgprot(/* seg, addr, len, prot */);
void	hat_newseg(/* seg, addr, len, nseg */);
void	hat_unload(/* seg, addr, len, flags */);

/*
 * Operations that work on all active translation for a given page:
 *	- unload all translations to page
 *	- get hw stats from hardware into page struct and reset hw stats
 */
void	hat_pageunload(/* pp */);
void	hat_pagesync(/* pp */);

/*
 * Operations that return physical page numbers (ie - used by mapin):
 *	- return the pfn for kernel virtual address
 *	- return the pfn for arbitrary virtual address
 *
 * XXX - The second  one is not yet implemented - not yet needed.
 * u_int hat_getpfnum(as, addr);
 */
u_int	hat_getkpfnum(/* addr */);

/*
 * Flags to pass to hat routines.
 *
 * Certain flags only apply to some interfaces:
 *
 * 	HAT_NOFLAGS   No flags specified.
 * 	HAT_LOCK      Lock down mapping resources; hat_map(), hat_memload(),
 * 	              and hat_devload().
 * 	HAT_UNLOCK    Unlock mapping resources; hat_memload(), hat_devload(),
 * 	              and hat_unload().
 * 	HAT_FREEPP    Free pp if unloading last mapping; hat_unload().
 * 	HAT_RELEPP    PAGE_RELE() pp after mapping is unloaded; hat_unload().
 * 	HAT_PRELOAD   Pre-load pages for new segment; hat_map().
 */
#define	HAT_NOFLAGS	0x0
#define	HAT_LOCK	0x1
#define	HAT_UNLOCK	0x2
#define	HAT_FREEPP	0x4
#define	HAT_RELEPP	0x8
#define	HAT_PRELOAD	0x10

#endif /* _KERNEL */

#endif	/* _VM_HAT_H */
   070701000028da000081240000000200000002000000012719347c00000466000000230000000c00000000000000000000001800000000usr/include/vm/kernel.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_KERNEL_H
#define _VM_KERNEL_H

#ident	"@(#)/usr/include/vm/kernel.h.sl 1.1 4.0 10/15/90 3278 AT&T-SF"

long	avenrun[3];			/* FSCALED average run queue lengths */

#endif	/* _VM_KERNEL_H */
  070701000028db000081240000000200000002000000012719347c000008ea000000230000000c00000000000000000000001400000000usr/include/vm/mp.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_MP_H
#define _VM_MP_H

#ident	"@(#)/usr/include/vm/mp.h.sl 1.1 4.0 10/15/90 21115 AT&T-SF"

/*
 * VM - multiprocessor/ing support.
 *
 * Currently the mon_enter() / mon_exit() pair implements a
 * simple monitor for objects protected by the appropriate lock.
 * The cv_wait() / cv_broadcast pait implements a simple
 * condition variable which can be used for `sleeping'
 * and `waking' inside a monitor if some resource
 * is needed which is not available.
 */

typedef struct mon_t {
	unchar	dummy;
} mon_t;

#if defined(DEBUG) || defined(lint)
void	mon_enter(/* lk */);
void	mon_exit(/* lk */);
void	cv_wait(/* lk, cond */);
void	cv_broadcast(/* lk, cond */);

#else

/*
 * mon_enter is used as a type of multiprocess semaphore
 * used to implement a monitor where the lock represents
 * the ability to operate on the associated object.
 * For now, the lock/object association is done
 * by convention only.
 * For single processor systems that are debugged, no lock is needed.
 * For multiprocessor systems that are debugged, a simple lock suffices.
 * Only the single processor macros are included.
 */

#define mon_enter(lk)
#define mon_exit(lk)
#define cv_wait(lk, cond) ((void) sleep(cond, PSWP+1))
#define cv_broadcast(lk, cond) (wakeprocs(cond, PRMPT))

#endif	/* DEBUG */

#define	lock_init(lk)	(lk)->dummy = 0

#endif	/* _VM_MP_H */
  070701000028dc000081240000000200000002000000012719347c000022b5000000230000000c00000000000000000000001600000000usr/include/vm/page.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_PAGE_H
#define _VM_PAGE_H

#ident	"@(#)/usr/include/vm/page.h.sl 1.1 4.0 10/15/90 63765 AT&T-SF"

#include "vm/vm_hat.h"

/*
 * VM - Ram pages.
 *
 * Each physical page has a page structure, which is used to maintain
 * these pages as a cache.  A page can be found via a hashed lookup
 * based on the [vp, offset].  If a page has an [vp, offset] identity,
 * then it is entered on a doubly linked circular list off the
 * vnode using the vpnext/vpprev pointers.   If the p_free bit
 * is on, then the page is also on a doubly linked circular free
 * list using next/prev pointers.  If the p_intrans bit is on,
 * then the page is currently being read in or written back.
 * In this case, the next/prev pointers are used to link the
 * pages together for a consecutive IO request.  If the page
 * is in transit and the the page is coming in (pagein), then you
 * must wait for the IO to complete before you can attach to the page.
 * 
 */
typedef struct page {
	u_int	p_lock: 1,		/* locked for name manipulation */
		p_want: 1,		/* page wanted */
		p_free: 1,		/* on free list */
		p_intrans: 1,		/* data for [vp, offset] intransit */
		p_gone: 1,		/* page has been released */
		p_mod: 1,		/* software copy of modified bit */
		p_ref: 1,		/* software copy of reference bit */
		p_pagein: 1,		/* being paged in, data not valid */
		p_nc: 1,		/* do not cache page */
		p_age: 1;		/* on page_freelist */
	u_int	p_nio : 6;		/* # of outstanding io reqs needed */
	u_short	p_keepcnt;		/* number of page `keeps' */
	struct	vnode *p_vnode;		/* logical vnode this page is from */
	u_int	p_offset;		/* offset into vnode for this page */
	struct page *p_hash;		/* hash by [vnode, offset] */
	struct page *p_next;		/* next page in free/intrans lists */
	struct page *p_prev;		/* prev page in free/intrans lists */
	struct page *p_vpnext;		/* next page in vnode list */
	struct page *p_vpprev;		/* prev page in vnode list */
	struct phat p_hat;		/* hat specific translation info */
	u_short	p_lckcnt;		/* number of locks on page data */
	u_short	p_cowcnt;		/* number of copy on write lock */
	daddr_t	p_dblist[PAGESIZE/NBPSCTR]; /* disk storage for the page */
#ifdef DEBUG
	struct proc *p_uown;		/* process owning it as u-page */
#endif
} page_t;

#define p_mapping	p_hat.ph_use.mappings

/*
 * Maximum of noncontiguous Memory Segments.
 * XXX - We must change this to be a tuneable. page_init() must handle this.
 */
#define	MAX_MEM_SEG	10

struct pageac {			/* page pool accounting structure */
	struct pageac *panext;	/* pointer to next contiguous
				 * chunk in the ram pool.
				 * It must be the first entry in
				 * this structure for page_init() to work.
				 */
	uint	num;		/* number of logical pages in chunk */
	uint	firstpfn;	/* page frame number of first page in chunk. */
	uint	endpfn;		/* firstpfn + num*(PAGESIZE/MMU_PAGESIZE) */
				/* NOTE:This page frame number DOES NOT exits */
	struct	page *firstpp;	/* pointer to first page structure */
	struct	page *endpp;	/* firstpp + num */
} ;

/* global mapping table for noncontiguous user free memory chunks.
*/
extern struct pageac pageac_table[];

/* 1st page structure address for 1st free user page in the system.
*/
extern page_t *pages;

/* Last page structure address for (Last free user page in system - 1). 
/* Logically this structure does not exists.
*/
extern page_t *epages;



#ifdef _KERNEL
#define PAGE_HOLD(pp)	(pp)->p_keepcnt++
#define PAGE_RELE(pp)	page_rele(pp)

/*
 * page_get() request flags.
 */
#ifndef P_NOSLEEP
#define	P_NOSLEEP	0x0000
#define	P_CANWAIT	0x0001
#define	P_PHYSCONTIG	0x0002
#define	P_DMA		0x0004
#endif
/*
 * P_RESOURCELIMIT is
 * used by rm_pageget to tell page_get to use resource limit
 * it is needed for P_PHYSCONTIG processing
 */
#define P_RESOURCELIMIT 0x0008

#define	PAGE_HASHSZ	page_hashsz

extern	int page_hashsz;
extern	page_t **page_hash;

struct pageac *pageahead;
uint pagepoolsize;

#ifdef sun386
extern	page_t *epages2;		/* end of absolutely all pages */
extern	u_int	pages_base2;		/* page # for compaq expanded mem */
#endif

/*
 * Variables controlling locking of physical memory.
 */
extern	u_int	pages_pp_locked;	/* physical pages actually locked */
extern	u_int	pages_pp_claimed;	/* physical pages reserved */
extern	u_int	pages_pp_kernel;	/* physical page locks by kernel */
extern	u_int	pages_pp_maximum;	/* tuning: lock + claim <= max */

/*
 * Page frame operations.
 */

void	page_init(/* pap */);
void	page_reclaim(/* pp */);
page_t *page_exists(/* vp, off */);
page_t *page_find(/* vp, off */);
page_t *page_lookup(/* vp, off */);
int	page_enter(/* pp, vp, off */);
void	page_abort(/* pp */);
void	page_free(/* pp */);
page_t *page_get(/* bytes, flags */);
page_t *page_get_aligned(/* bytes, align_mask, align_val, flags */);
int	page_pp_lock(/* pp, claim, kernel */);
void	page_pp_unlock(/* pp, claim, kernel */);
void	page_pp_useclaim(/* opp, npp */);
int	page_addclaim(/* claim */);
void	page_subclaim(/* claim */);
void	page_hashin(/* pp, vp, offset, lock */);
void	page_hashout(/* pp */);
void	page_sub(/* ppp, pp */);
void	page_sortadd(/* ppp, pp */);
void	page_wait(/* pp */);
page_t *page_numtookpp(/* pfnum */);

#if defined(DEBUG) || defined(sun386) || defined(i386)

	/*
	 *	Since we now handle non-contiguous physical memory segments
	 *	on the 80386 we need these routines.
	 */

u_int	page_pptonum(/* pp */);
page_t *page_numtopp(/* pfnum */);

extern	u_int	pages_base;	/* on 80386 this is pfn for pages */
extern	uint	pages_end;	/* on 80386 this is pfn for epages */
				/* But this base and end may not be contiguous */

#else

	/*
	 *	Generalized simple case, e.g. on 3b2. Here we assume that
	 *	we have a single physically contiguous memory segment.
	 */

extern	u_int	pages_base;		/* page # for pages[0] */
extern	uint	pages_end;

#define page_pptonum(pp) \
	(((uint)((pp) - pages) * \
		(PAGESIZE/MMU_PAGESIZE)) + pages_base)

#define page_numtopp(pfn) \
	((pfn) < pages_base || (pfn) >= pages_end) ? \
		((struct page *) NULL) : \
		((struct page *) (&pages[(uint) ((pfn) - pages_base) / \
			(PAGESIZE/MMU_PAGESIZE)]))

#endif

#include "vm/mp.h"

#ifdef DEBUG

void	page_rele(/* pp */);
void	page_lock(/* pp */);
void	page_unlock(/* pp */);

#else

extern	mon_t	page_mplock;		/* lock for manipulating page links */

#define page_rele(pp) { \
	mon_enter(&page_mplock); \
	\
	if (--((struct page *)(pp))->p_keepcnt == 0) { \
		while (((struct page *)(pp))->p_want) { \
			cv_broadcast(&page_mplock, (char *)(pp)); \
			((struct page *)(pp))->p_want = 0; \
		} \
	} \
	\
	mon_exit(&page_mplock); \
	\
	if (((struct page *)(pp))->p_keepcnt == 0 \
		&& (((struct page *)(pp))->p_gone \
		|| ((struct page *)(pp))->p_vnode == NULL)) \
		page_abort(pp); \
}
#define page_lock(pp) { \
	mon_enter(&page_mplock); \
	while (pp->p_lock) \
		page_cv_wait(pp); \
	pp->p_lock = 1; \
	mon_exit(&page_mplock); \
}
#define page_unlock(pp) { \
	mon_enter(&page_mplock); \
	((struct page *)(pp))->p_lock = 0; \
	while (((struct page *)(pp))->p_want) { \
		((struct page *)(pp))->p_want = 0; \
		cv_broadcast(&page_mplock, (char *)(pp)); \
	} \
	mon_exit(&page_mplock); \
}

#endif

#endif /* _KERNEL */

/*
 * Page hash table is a power-of-two in size, externally chained
 * through the hash field.  PAGE_HASHAVELEN is the average length
 * desired for this chain, from which the size of the page_hash
 * table is derived at boot time and stored in the kernel variable
 * page_hashsz.  In the hash function it is given by PAGE_HASHSZ.
 * PAGE_HASHVPSHIFT is defined so that 1 << PAGE_HASHVPSHIFT is
 * the approximate size of a vnode struct.
 */
#define	PAGE_HASHAVELEN		4
#define	PAGE_HASHVPSHIFT	6
#define	PAGE_HASHFUNC(vp, off) \
	((((off) >> PAGESHIFT) + ((int)(vp) >> PAGE_HASHVPSHIFT)) & \
		(PAGE_HASHSZ - 1))

#if defined(__STDC__)
extern void page_cv_wait(page_t *);
extern void ppcopy(page_t *, page_t *);
#else
extern void page_cv_wait();
extern void ppcopy();
#endif /* __STDC__ */

#endif	/* _VM_PAGE_H */
   070701000028dd000081240000000200000002000000012719347c0000041f000000230000000c00000000000000000000001500000000usr/include/vm/pte.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_PTE_H
#define _VM_PTE_H

#ident	"@(#)/usr/include/vm/pte.h.sl 1.1 4.0 10/15/90 33436 AT&T-SF"

#endif	/* _VM_PTE_H */
 070701000028de000081240000000200000002000000012719347c0000093c000000230000000c00000000000000000000001500000000usr/include/vm/pvn.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_PVN_H
#define _VM_PVN_H

#ident	"@(#)/usr/include/vm/pvn.h.sl 1.1 4.0 10/15/90 58875 AT&T-SF"

/*
 * VM - paged vnode.
 *
 * The VM system manages memory as a cache of paged vnodes.
 * This file desribes the interfaces to common subroutines
 * used to help implement the VM/file system routines.
 */

struct	page *pvn_kluster(/* vp, off, seg, addr, offp, lenp, vp_off,
	    vp_len, isra */);
void	pvn_fail(/* plist, flags */);
void	pvn_done(/* bp */);
struct	page *pvn_vplist_dirty(/* vp, off, flags */);
struct	page *pvn_range_dirty(/* vp, off, eoff, offlo, offhi, flags */);
void	pvn_vptrunc(/* vp, vplen, zbytes */);
void	pvn_unloadmap(/* vp, offset, ref, mod */);
int	pvn_getpages(/* getapage, vp, off, len, protp, pl, plsz, seg, addr,
	    rw, cred */);

/*
 * When requesting pages from the getpage routines, pvn_getpages will
 * allocate space to return PVN_GETPAGE_NUM pages which map PVN_GETPAGE_SZ
 * worth of bytes.  These numbers are chosen to be the minimum of the max's
 * given in terms of bytes and pages.
 */
#define	PVN_MAX_GETPAGE_SZ	0x10000		/* getpage size limit */
#define	PVN_MAX_GETPAGE_NUM	0x8		/* getpage page limit */

#if PVN_MAX_GETPAGE_SZ > PVN_MAX_GETPAGE_NUM * PAGESIZE

#define	PVN_GETPAGE_SZ	ptob(PVN_MAX_GETPAGE_NUM)
#define	PVN_GETPAGE_NUM	PVN_MAX_GETPAGE_NUM

#else

#define	PVN_GETPAGE_SZ	PVN_MAX_GETPAGE_SZ
#define	PVN_GETPAGE_NUM	btop(PVN_MAX_GETPAGE_SZ)

#endif

#endif	/* _VM_PVN_H */
070701000028df000081240000000200000002000000012719347c0000042b000000230000000c00000000000000000000001800000000usr/include/vm/reboot.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_REBOOT_H
#define _VM_REBOOT_H

#ident	"@(#)/usr/include/vm/reboot.h.sl 1.1 4.0 10/15/90 14072 AT&T-SF"

#endif	/* _VM_REBOOT_H */
 070701000028e0000081240000000200000002000000012719347c000007fe000000230000000c00000000000000000000001400000000usr/include/vm/rm.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_RM_H
#define _VM_RM_H

#ident	"@(#)/usr/include/vm/rm.h.sl 1.1 4.0 10/15/90 54186 AT&T-SF"

/*
 * VM - Resource Management.
 */

/* These 2 macros were defined in SVR4 Version 2.0.  They are added back
	here for compatibility but are not used by anyone in Version 2.1 */
#define rm_allocpage(seg, addr, len, flags) \
	(struct page *) (rm_pageget((u_int) (len), (u_int) (flags)))

#define rm_allocpage_aligned(seg, addr, len, mask, val, flags) \
	(struct page *) (rm_pageget_aligned(len, (u_int) (mask), \
			(u_int) (val), (u_int) (flags)))

struct	page *rm_pageget(/* len, flags */);
struct	page *rm_pageget_aligned(/* len, align_mask, align_val, flags */);


void	rm_outofanon();
void	rm_outofhat();
size_t	rm_asrss(/* as */);
size_t	rm_assize(/* as */);

/*
 * rm_pageget() request flags.
 */
#ifndef P_NOSLEEP
#define	P_NOSLEEP	0x0000
#define	P_CANWAIT	0x0001
#define	P_PHYSCONTIG	0x0002
#define	P_DMA		0x0004
#endif
/*
 * P_RESOURCELIMIT is
 * used by rm_pageget to tell page_get to use resource limit
 * it is needed for P_PHYSCONTIG processing
 */
#define P_RESOURCELIMIT	0x0008

#endif	/* _VM_RM_H */
  070701000028e1000081240000000200000002000000012719347c0000131d000000230000000c00000000000000000000001500000000usr/include/vm/seg.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_H
#define _VM_SEG_H

#ident	"@(#)/usr/include/vm/seg.h.sl 1.1 4.0 10/15/90 32833 AT&T-SF"

#include "vm/faultcode.h"
#include "vm/mp.h"

/*
 * VM - Segments.
 */

/*
 * An address space contains a set of segments, managed by drivers.
 * Drivers support mapped devices, sharing, copy-on-write, etc.
 *
 * The seg structure contains a lock to prevent races, the base virtual
 * address and size of the segment, a back pointer to the containing
 * address space, pointers to maintain a circularly doubly linked list
 * of segments in the same address space, and procedure and data hooks
 * for the driver.  The seg list on the address space is sorted by
 * ascending base addresses and overlapping segments are not allowed.
 *
 * After a segment is created, faults may occur on pages of the segment.
 * When a fault occurs, the fault handling code must get the desired
 * object and set up the hardware translation to the object.  For some
 * objects, the fault handling code also implements copy-on-write.
 *
 * When the hat wants to unload a translation, it can call the unload
 * routine which is responsible for processing reference and modify bits.
 */

/*
 * Fault information passed to the seg fault handling routine.
 * The F_SOFTLOCK and F_SOFTUNLOCK are used by software
 * to lock and unlock pages for physical I/O.
 */
enum fault_type {
	F_INVAL,		/* invalid page */
	F_PROT,			/* protection fault */
	F_SOFTLOCK,		/* software requested locking */
	F_SOFTUNLOCK		/* software requested unlocking */
};

/*
 * seg_rw gives the access type for a fault operation
 */
enum seg_rw {
	S_OTHER,		/* unknown or not touched */
	S_READ,			/* read access attempted */
	S_WRITE,		/* write access attempted */
	S_EXEC 			/* execution access attempted */
};

struct seg {
	mon_t	s_lock;
	addr_t	s_base;			/* base virtual address */
	u_int	s_size;			/* size in bytes */
	struct	as *s_as;		/* containing address space */
	struct	seg *s_next;		/* next seg in this address space */
	struct	seg *s_prev;		/* prev seg in this address space */
	struct	seg_ops {
#if defined(__STDC__)
		int (*dup)(struct seg *, struct seg *);
		int (*unmap)(struct seg *, addr_t, u_int);
		void (*free)(struct seg *);
		faultcode_t (*fault)(struct seg *, addr_t, u_int, 
			enum fault_type, enum seg_rw);
		faultcode_t (*faulta)(struct seg *, addr_t);
		void (*unload)(struct seg *, addr_t, u_int, u_int);
		int (*setprot)(struct seg *, addr_t, u_int, u_int);
		int (*checkprot)(struct seg *, addr_t, u_int, u_int);
		int (*kluster)(struct seg *, addr_t, int);
		u_int (*swapout)(struct seg *);
		int (*sync)(struct seg *, addr_t, u_int, int, u_int);
		int (*incore)(struct seg *, addr_t, u_int, char *);
		int (*lockop)(struct seg *, addr_t, u_int, int, int, 
			ulong *, u_int);
		int (*getprot)(struct seg *, addr_t, u_int, u_int *);
		off_t (*getoffset)(struct seg *, addr_t);
		int (*gettype)(struct seg *, addr_t);
		int (*getvp)(struct seg *, addr_t, struct vnode **);		
#else
		int	(*dup)();
		int	(*unmap)();
		void	(*free)();
		faultcode_t	(*fault)();
		faultcode_t	(*faulta)();
		void	(*unload)();
		int	(*setprot)();
		int	(*checkprot)();
		int	(*kluster)();
		u_int	(*swapout)();
		int	(*sync)();
		int	(*incore)();
		int	(*lockop)();
		int	(*getprot)();
		off_t	(*getoffset)();
		int	(*gettype)();
		int	(*getvp)();		
#endif
	} *s_ops;
	_VOID *s_data;			/* private data for instance */
};

#ifdef _KERNEL
/*
 * Generic segment operations
 */
struct	seg *seg_alloc(/* as, base, size */);
int	seg_attach(/* as, base, size, seg */);
void	seg_free(/* seg */);

#ifdef DEBUG

u_int	seg_page(/* seg, addr */);
u_int	seg_pages(/* seg */);

#else

#define seg_page(seg, addr) \
 	((u_int)(((addr) - (seg)->s_base) >> PAGESHIFT))

#define seg_pages(seg) \
	((u_int)(((seg)->s_size + PAGEOFFSET) >> PAGESHIFT))

#endif

#if defined(__STDC__)
extern void seg_unmap(struct seg *);
#else
extern void seg_unmap();
#endif	/* __STDC__ */

#endif /* _KERNEL */

#endif	/* _VM_SEG_H */
   070701000028e2000081240000000200000002000000012719347c000007e5000000230000000c00000000000000000000001900000000usr/include/vm/seg_dev.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_DEV_H
#define _VM_SEG_DEV_H

#ident	"@(#)/usr/include/vm/seg_dev.h.sl 1.1 4.0 10/15/90 19408 AT&T-SF"

/*
 * Structure who's pointer is passed to the segvn_create routine
 */
struct segdev_crargs {
	int	(*mapfunc)();	/* map function to call */
	u_int	offset;		/* starting offset */
	dev_t	dev;		/* device number */
	u_char	prot;		/* protection */
	u_char	maxprot;	/* maximum protection */
};

/*
 * (Semi) private data maintained by the seg_dev driver per segment mapping
 */
struct	segdev_data {
	int	(*mapfunc)();	/* really returns struct pte, not int */
	u_int	offset;		/* device offset for start of mapping */
	struct	vnode *vp;	/* Vnode associated with device */
	u_char	pageprot;	/* true if per page protections present */
	u_char	prot;		/* current segment prot if pageprot == 0 */
	u_char	maxprot;	/* maximum segment protections */
	struct	vpage *vpage;	/* per-page information, if needed */
};

#ifdef _KERNEL

#if defined(__STDC__)
extern int segdev_create(struct seg *, void *);
#else
extern int segdev_create();
#endif

#endif /* _KERNEL */

#endif	/* _VM_SEG_DEV_H */
   070701000028e4000081240000000200000002000000012719347c00000919000000230000000c00000000000000000000001a00000000usr/include/vm/seg_kmem.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_KMEM_H
#define _VM_SEG_KMEM_H

#ident	"@(#)/usr/include/vm/seg_kmem.h.sl 1.1 4.0 10/15/90 27685 AT&T-SF"

/*
 * VM - Kernel Segment Driver
 */

/*
 * These variables should be put in a place which
 * is guaranteed not to get paged out of memory.
 */
extern struct as kas;			/* kernel's address space */
extern struct seg kpseg;		/* kernel's "ptov" segment */
extern struct seg kvseg;		/* kernel's "sptalloc" segment */
extern struct seg ktextseg;		/* kernel's "most everything else" segment */
extern struct seg kpioseg;		/* kernel's "pioseg" segment */

#if defined(__STDC__)

extern int sptalloc(int, int, caddr_t, int);
extern void sptfree(caddr_t, int, int);

/*
 * For segkmem_create, the argsp is actually a pointer to the
 * optional array of pte's used to map the given segment.
 */
extern int segkmem_create(struct seg *, void *);

extern caddr_t kseg(int);
extern void unkseg(caddr_t);

#else

extern int sptalloc();
extern void sptfree();
extern int segkmem_create();
extern caddr_t kseg();
extern void unkseg();

#endif /* __STDC__ */

/*
 * Flags to pass to segkmem_mapin().
 */
#define PTELD_LOCK	0x01
#define PTELD_INTREP	0x02
#define PTELD_NOSYNC	0x04

typedef struct kseg_list {
caddr_t	kseg_vaddr;			/* virtual address of kseg */
int kseg_size;				/* size of kseg request in clicks */
struct kseg_list *kseg_next;			/* link */
} kseg_list_t;
#endif	/* _VM_SEG_KMEM_H */
   070701000028e5000081240000000200000002000000012719347c00000e9a000000230000000c00000000000000000000001900000000usr/include/vm/seg_map.h  /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_MAP_H
#define _VM_SEG_MAP_H

#ident	"@(#)/usr/include/vm/seg_map.h.sl 1.1 4.0 10/15/90 37259 AT&T-SF"

struct segmap_crargs {
	u_int	prot;
};

/*
 * Each smap struct represents a MAXBSIZE sized mapping to the
 * <sm_vp, sm_off> given in the structure.  The location of the
 * the structure in the array gives the virtual address of the
 * mapping.
 */
struct	smap {
	struct	vnode *sm_vp;		/* vnode pointer (if mapped) */
	u_int	sm_off;			/* file offset for mapping */
	/*
	 * These next 4 entries can be coded as
	 * u_shorts if we are tight on memory.
	 */
	u_int	sm_refcnt;		/* reference count for uses */
	struct	smap *sm_hash;		/* hash pointer */
	struct	smap *sm_next;		/* next pointer */
	struct	smap *sm_prev;		/* previous pointer */
};

/*
 * (Semi) private data maintained by the segmap driver per SEGMENT mapping
 */
struct	segmap_data {
	struct	smap *smd_sm;		/* array of smap structures */
	struct	smap *smd_free;		/* free list head pointer */
	u_char	smd_prot;		/* protections for all smap's */
	u_char	smd_want;		/* smap want flag */
	u_int	smd_hashsz;		/* power-of-two hash table size */
	struct	smap **smd_hash;	/* pointer to hash table */
};

/*
 * These are flags used on release.  Some of these might get handled
 * by segment operations needed for msync (when we figure them out).
 * SM_ASYNC modifies SM_WRITE.  SM_DONTNEED modifies SM_FREE.  SM_FREE
 * and SM_INVAL are mutually exclusive.
 */
#define	SM_WRITE	0x01		/* write back the pages upon release */
#define	SM_ASYNC	0x02		/* do the write asynchronously */
#define	SM_FREE		0x04		/* put pages back on free list */
#define	SM_INVAL	0x08		/* invalidate page (no caching) */
#define	SM_DONTNEED	0x10		/* less likely to be needed soon */

#define MAXBSHIFT	13		/* log2(MAXBSIZE) */

#define MAXBOFFSET	(MAXBSIZE - 1)
#define MAXBMASK	(~MAXBOFFSET)

/*
 * SMAP_HASHAVELEN is the average length desired for this chain, from
 * which the size of the smd_hash table is derived at segment create time.
 * SMAP_HASHVPSHIFT is defined so that 1 << SMAP_HASHVPSHIFT is the
 * approximate size of a vnode struct.
 */
#define	SMAP_HASHAVELEN		4
#define	SMAP_HASHVPSHIFT	6

#define	SMAP_HASHFUNC(smd, vp, off) \
	((((off) >> MAXBSHIFT) + ((int)(vp) >> SMAP_HASHVPSHIFT)) & \
		((smd)->smd_hashsz - 1))

#ifdef _KERNEL

/* the kernel generic mapping segment */
extern struct seg *segkmap;

#if defined(__STDC__)

extern int segmap_create(struct seg *, void *);
extern void segmap_pagecreate(struct seg *, addr_t, u_int, int);
extern addr_t segmap_getmap(struct seg *, struct vnode *, u_int);
extern int segmap_release(struct seg *, addr_t, u_int);

#else

extern int segmap_create();
extern void segmap_pagecreate();
extern addr_t segmap_getmap();
extern int segmap_release();

#endif
#endif /* _KERNEL */

#endif	/* _VM_SEG_MAP_H */
  070701000028e6000081240000000200000002000000012719347c00000789000000230000000c00000000000000000000001a00000000usr/include/vm/seg_objs.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_OBJS_H
#define _VM_SEG_OBJS_H

#ident	"@(#)/usr/include/vm/seg_objs.h.sl 1.1 4.0 10/15/90 14918 AT&T-SF"

/*
 * Structure who's pointer is passed to the segvn_create routine
 */
struct segobjs_crargs {
	int	(*mapfunc)();	/* map function to call */
	u_int	offset;		/* starting offset */
	caddr_t	arg;
	u_char	prot;		/* protection */
	u_char	maxprot;	/* maximum protection */
};

/*
 * (Semi) private data maintained by the seg_objs driver per segment mapping
 */
struct	segobjs_data {
	int	(*mapfunc)();	/* really returns struct pte, not int */
	u_int	offset;		/* device offset for start of mapping */
	caddr_t	arg;		/* 1st argument to (*mapfunc)() */
	u_char	pageprot;	/* true if per page protections present */
	u_char	prot;		/* current segment prot if pageprot == 0 */
	u_char	maxprot;	/* maximum segment protections */
	struct	vpage *vpage;	/* per-page information, if needed */
};

#ifdef _KERNEL
int	segobjs_create(/* seg, void */);
#endif /* _KERNEL */

#endif	/* _VM_SEG_OBJS_H */
   070701000028e7000081240000000200000002000000012719347c000011b4000000230000000c00000000000000000000001700000000usr/include/vm/seg_u.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_U_H
#define _VM_SEG_U_H

#ident	"@(#)/usr/include/vm/seg_u.h.sl 1.1 4.0 10/15/90 14605 AT&T-SF"

/*
 * VM - U-area segment management
 *
 * This file contains definitions related to the u-area segment type.
 *
 * In its most general form, this segment type provides an interface
 * for managing stacks that are protected by red zones, with the size
 * of each stack independently specifiable.  The current implementation
 * is restricted in the following way.
 * 1)	It assumes that all stacks are the same size.  In particular,
 *	it assumes that the stacks it manages are actually traditional
 *	u-areas, each containing a stack at one end.
 *
 * The segment driver manages a contiguous chunk of virtual space,
 * carving it up into individual stack instances as required, and
 * associating physical storage, MMU mappings, and swap space with
 * each individual stack instance.
 *
 * As a matter of nomenclature, the individual allocation units are
 * referred to as "slots".
 */

/*
 * The number of pages covered by a single seg_u slot.
 *
 * This value is the number of (software) pages in the u-area
 * (including the stack in the u-area) plus an additional page
 * for a stack red zone.  If the seg_u implementation is ever
 * generalized to allow variable-size stack allocation, this
 * define will have to change.
 */

/*
 * On the 386, ublocks are variable length.  Each process can have a maximum of
 * SEGU_PAGES (MAXUSIZE) pages allocated for it.  Since MAXUSIZE is fairly
 * large, this uses up a lot of kernel virtual address space, but as long as
 * no physical memory is wasted this is alright.
 *
 * NOTE: The 386 implementation does not need an extra page for redzone.
 */
#define	SEGU_PAGES	MAXUSIZE

#define	segu_stom(v)	(v)
#define	segu_mtos(v)	(v)


/*
 * Private information per overall segu segment (as opposed
 * to per slot within segment)
 *
 * XXX:	We may wish to modify the free list to handle it as a queue
 *	instead of a stack; this possibly could reduce the frequency
 *	of cache flushes.  If so, we would need a list tail pointer
 *	as well as a list head pointer.
 */
struct segu_segdata {
	/*
	 * info needed:
	 *	- slot vacancy info
	 *	- a way of getting to state info for each slot
	 */
	struct	segu_data *usd_slots;	/* array of segu_data structs,
					   one per slot */
	struct	segu_data *usd_free;	/* slot free list head */
};

/*
 * Private per-slot information.
 */
struct segu_data {
	struct	segu_data *su_next;		/* free list link */
	struct	anon *su_swaddr[SEGU_PAGES];	/* disk address of u area when
						   swapped */
	u_int	su_flags;			/* state info: see below */
	struct proc *su_proc;			/* owner fo the slot */
};

/*
 * Flag bits
 *
 * When the SEGU_LOCKED bit is set, all the resources associated with the
 * corresponding slot are locked in place, so that referencing addresses
 * in the slot's range will not cause a fault.  Clients using this driver
 * to manage a u-area lock down the slot when the corresponding process
 * becomes runnable and unlock it when the process is swapped out.
 */
#define	SEGU_ALLOCATED	0x01		/* slot is in use */
#define	SEGU_LOCKED	0x02		/* slot's resources locked */


#ifdef	_KERNEL
extern struct seg	*segu;

/*
 * Public routine declarations not part of the segment ops vector go here.
 */
#if defined(__STDC__)
extern int segu_create(struct seg *, void *);
extern addr_t segu_get(struct proc *, int);
extern void segu_release(struct proc *);
#else
extern int	segu_create();
extern addr_t	segu_get();
extern void	segu_release();
#endif /* __STDC__ */

#endif	/* _KERNEL */

#endif	/* _VM_SEG_U_H */
070701000028e8000081240000000200000002000000012719347c00000e3a000000230000000c00000000000000000000001800000000usr/include/vm/seg_vn.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_VN_H
#define _VM_SEG_VN_H

#ident	"@(#)/usr/include/vm/seg_vn.h.sl 1.1 4.0 10/15/90 25438 AT&T-SF"

#include "vm/mp.h"

/*
 * A pointer to this structure is passed to segvn_create().
 */
struct segvn_crargs {
	struct	vnode *vp;	/* vnode mapped from */
	u_int	offset;		/* starting offset of vnode for mapping */
	struct	cred *cred;	/* credentials */
	u_char	type;		/* type of sharing done */
	u_char	prot;		/* protections */
	u_char	maxprot;	/* maximum protections */
	struct	anon_map *amp;	/* anon mapping to map to */
};

/*
 * The anon_map structure is used by the seg_vn driver to manage
 * unnamed (anonymous) memory.   When anonymous memory is shared,
 * then the different segvn_data structures will point to the
 * same anon_map structure.  Also, if a segment is unmapped
 * in the middle where an anon_map structure exists, the
 * newly created segment will also share the anon_map structure,
 * although the two segments will use different ranges of the
 * anon array.  When mappings are private (or shared with
 * a reference count of 1), an unmap operation will free up
 * a range of anon slots in the array given by the anon_map
 * structure.  Because of fragmentation due to this unmapping,
 * we have to store the size of the anon array in the anon_map
 * structure so that we can free everything when the referernce
 * count goes to zero.
 */
struct anon_map {
	u_int	refcnt;		/* reference count on this structure */
	u_int	size;		/* size in bytes mapped by the anon array */
	struct	anon **anon;	/* pointer to an array of anon * pointers */
	u_int	swresv;		/* swap space reserved for this anon_map */
};

/*
 * (Semi) private data maintained by the seg_vn driver per segment mapping.
 */
struct	segvn_data {
	mon_t	lock;
	u_char	pageprot;	/* true if per page protections present */
	u_char	prot;		/* current segment prot if pageprot == 0 */
	u_char	maxprot;	/* maximum segment protections */
	u_char	type;		/* type of sharing done */
	struct	vnode *vp;	/* vnode that segment mapping is to */
	u_int	offset;		/* starting offset of vnode for mapping */
	u_int	anon_index;	/* starting index into anon_map anon array */
	struct	anon_map *amp;	/* pointer to anon share structure, if needed */
	struct	vpage *vpage;	/* per-page information, if needed */
	struct	cred *cred;	/* mapping credentials */
	u_int	swresv;		/* swap space reserved for this segment */
};

#ifdef _KERNEL

#if defined(__STDC__)
extern int segvn_create(struct seg *, void *);
#else
extern int segvn_create();
#endif

extern	struct seg_ops segvn_ops;

/*
 * Provided as shorthand for creating user zfod segments.
 */
extern	caddr_t zfod_argsp;
extern	caddr_t kzfod_argsp;
#endif /* _KERNEL */

#endif	/* _VM_SEG_VN_H */
  070701000028e9000081240000000200000002000000012719347c00000ff6000000230000000c00000000000000000000001a00000000usr/include/vm/seg_vpix.h /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_SEG_VPIX_H
#define _VM_SEG_VPIX_H

#ident	"@(#)/usr/include/vm/seg_vpix.h.sl 1.1 4.0 10/15/90 8369 AT&T-SF"

#include "vm/seg.h"
#include "vm/anon.h"
#include "vm/mp.h"

/*
 * Structure whose pointer is passed to the segvpix_create routine
 */
struct segvpix_crargs {
	u_int		n_hole;		/* # of "holes" - these are regions
					   in the segment which will never
					   have real memory associated with
					   them. */
	struct vpix_hole {
		caddr_t		base;	/* start addr of hole */
		u_int		size;	/* size (in bytes) of hole */
	} hole[4];
};

/*
 * Note: we don't need a shareable anon_map, because 1) seg_vpix segments
 * are always private, and 2) we don't allow seg_vpix segments to be
 * partially unmapped.  We don't need protection information since seg_vpix
 * pages are always read/write.
 */

/*
 * A seg_vpix segment supports the notion of "equivalenced" pages.  This
 * refers to multiple virtual pages in the same segment mapping to the
 * same physical (or anonymous) page.  We represent the equivalences by
 * keeping a circular linked list for each equivalence set.  One of the
 * pages in the equivalence set is (arbitrarily) considered the "primary";
 * This is kept,
 * along with some other per-page information, in a vpix_page structure.
 */

typedef struct vpix_page vpix_page_t;
struct vpix_page {	/* one for every virtual page */
	u_short		eq_map;		/* "real" page this is mapped to */
	u_short		eq_link;	/* link to next equivalenced vpage */
	u_short		rp_eq_list;	/* 1st vpage mapped to this rpage */
	u_short		rp_phys : 1;	/* this rpage is physmapped */
	u_short		rp_lock : 1;	/* we locked the physical page */
	u_short		rp_errata10 : 1;/* some vpage in 0x1000 - 0xF000 range,
					   and thus subject to B1 Errata 10 */
	u_short		rp_hole : 1;	/* this rpage has no real memory */
	union {				/* actual page assignment for rpage */
		struct anon *rpu_anon;		/* anonymous backing */
		u_int	     rpu_pfn;		/* physical map pfn */
	} rp_un;
};

#define rp_anon	rp_un.rpu_anon
#define rp_pfn	rp_un.rpu_pfn

#define NULLEQ	((u_short)-1)

/*
 * (Semi) private data maintained by the seg_vn driver per segment mapping
 */
struct	segvpix_data {
	mon_t	lock;
	short	s_vpix;		/* hook to the v86tab structure */
	vpix_page_t *vpage;	/* per-page information */
	struct cred *cred;	/* mapping credentials */
	u_int	swresv;		/* swap space reserved for this segment */
};

#ifdef _KERNEL

#if defined(__STDC__)
extern int segvpix_create(struct seg *, void *);
extern int segvpix_physmap(struct seg *, u_int, u_int, u_int);
extern int segvpix_unphys(struct seg *, u_int, u_int);
extern int segvpix_page_equiv(struct seg *, u_int, u_int);
extern int segvpix_range_equiv(struct seg *, u_int, u_int, u_int);
extern int segvpix_modscan(struct seg *, u_int, u_int);
#else
extern int segvpix_create();
extern int segvpix_physmap();
extern int segvpix_unphys();
extern int segvpix_page_equiv();
extern int segvpix_range_equiv();
extern int segvpix_modscan();
#endif

extern	struct seg_ops segvpix_ops;

/*
 * Provided as shorthand for creating a vanilla vpix segment.
 */
extern caddr_t vpix_argsp;

#endif /* _KERNEL */

#endif	/* _VM_SEG_VPIX_H */
  070701000028ea000081240000000200000002000000012719347c00002cd7000000230000000c00000000000000000000001700000000usr/include/vm/trace.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_TRACE_H
#define _VM_TRACE_H

#ident	"@(#)/usr/include/vm/trace.h.sl 1.1 4.0 10/15/90 51870 AT&T-SF"

/*
 * Trace point definitions.  Beware of conflicts with the
 * window system keyboard translation macros (TR_ASCII et al).
 *
 * The set of active trace points is recorded in the variable
 * tracedevents.  Because we declare this variable as an fd_set,
 * the maximum allowable trace point index is bounded by FD_SETSIZE.
 *
 * For the most part, these trace points are quite specific to SunOS 4.0.
 *
 * The trace point definitions follow stringent conventions for the benefit
 * of postprocessors wishing to manipulate trace information.  The names
 * all start with TR_, and each definition is followed on the next line by
 * a comment whose content is a printf-like formatting string.  Successive
 * format items are fed by successive tr_datum* values from the current
 * trace item.  The only unusual format is %C, which is followed by an angle
 * bracketed, comma separated list of (unquoted) strings, the i-th of which
 * is to be printed when the associated value is i (0-origin).
 *
 * Note that the current trace points confine themselves to the C, d, and
 * x formats so that postprocessors can confine themselves to supporting
 * only these formats.  This situation may change when additional trace
 * points are defined.
 */

/*
 * User-level trace annotation.
 */
#define TR_STAMP		0	/* user: vtrace(VTR_STAMP, value); */
/* "value %d pid %d" */

/*
 * Paging trace points.  The TR_PG_* trace points all start by recording
 * pp, vp, and off values.
 */
#define TR_PG_POCLEAN		1	/* about to clean a page in pageout */
/* "pp %x vp %x off %d hand %d freemem %d" */
#define TR_PG_POFREE		2	/* add page to free list in pageout */
/* "pp %x vp %x off %d hand %d freemem %d" */
#define TR_PG_RECLAIM		3	/* page obtained in page_reclaim */
/* "pp %x vp %x off %d ap %x age %d freemem %d" */
#define TR_PG_ENTER		4 /* page_enter: page assoc. with <vp,off> */
/* "pp %x vp %x off %d retval %d" */
#define TR_PG_ABORT		5 /* page_abort: page disassoc. w/ <vp,off> */
/* "pp %x vp %x off %d code %C<aborted,kept,intrans>" */
#define TR_PG_FREE		6	/* call to page_free */
/* "pp %x vp %x off %d dontneed %d freemem %d code %C<gone,free,cachetl,cachehd>" */
#define TR_PG_ALLOC		7	/* single page allocated in page_get */
/* "pp %x vp %x off %d age %d fromcache %d" */
#define TR_PG_SEGMAP_FLT	8	/* segmap_fault sets p_ref = 1 */
/* "pp %x vp %x off %d softlock %d" */
#define TR_PG_SEGVN_FLT		9	/* segvn_fault sets p_ref = 1 */
/* "pp %x vp %x off %d softlock %d" */
#define TR_PG_PVN_DONE		10	/* pvn_done sets p_gone = 1 */
/* "pp %x vp %x off %d" */
#define TR_PG_PVN_GETDIRTY	11	/* pvn_getdirty sets p_ref = 0 */
/* "pp %x vp %x off %d" */
#define TR_PG_HAT_NEWSEG	12	/* hat_newseg OR's p_ref */
/* "pp %x vp %x off %d referenced %d" */
#define TR_PG_HAT_GETPME	13	/* hat_getpme OR's p_ref */
/* "pp %x vp %x off %d referenced %d" */
#define TR_PG_POREF		14	/* clock hand finds p_ref == 1 */
/* "pp %x vp %x off %d hand %d" */

#define TR_PAGE_GET_SLEEP	19	/* sleep during page alloc request */
/* "bytes %x canwait %d freemem %d after? %d" */
#define TR_PAGE_GET		20	/* page allocation request */
/* "bytes %x canwait %d freemem %d code %C<allocated,toobig,nomem>" */

/*
 * Page abort codes
 */
#define TRC_ABORT_ABORTED	0
#define TRC_ABORT_KEPT		1
#define TRC_ABORT_INTRANS	2

/*
 * Page free codes
 */
#define TRC_FREE_GONE		0
#define TRC_FREE_FREE		1
#define TRC_FREE_CACHETL	2
#define TRC_FREE_CACHEHD	3

/*
 * Page get codes
 */
#define TRC_GET_ALLOCATED	0
#define TRC_GET_TOOBIG		1
#define TRC_GET_NOMEM		2
/*
 * File system buffer tracing points; all trace <dev, bn>
 */
#define TR_BREADHIT		21	/* buffer read found in cache */
/* "" */
#define TR_BREADMISS		22	/* buffer read not in cache */
/* "" */
#define TR_BWRITE		23	/* buffer written */
/* "" */
#define TR_BRELSE		24	/* brelse */
/* "" */

/*
 *  Calibration trace record
 */
#define TR_CALIBRATE		30	/* calibration point in hardclock */
/* "seqnum %d sec %d usec %d" */

/*
 * Paging daemon trace points
 */
#define TR_PAGEOUT		31	/* pageout daemon statistics */
/* "after? %d nscan %d desscan %d freemem %d lotsfree %d" */
#define TR_PAGEOUT_CALL		32	/* pageout daemon call */
/* "callpoint %C<getnpage,getfrlw,schedcpu,schedpag,swdone>" */
#define TR_PAGEOUT_MAXPGIO	33	/* pushes > maxpgio in checkpage */
/* "freemem %d nscan %d" */
#define TR_PAGEOUT_WRAP		34	/* front clock hand wrap around */
/* "freemem %d hand %d" */
/*
 * Pageout daemon call location codes
 */
#define TRC_POCALL_GETNPAGE	0
#define TRC_POCALL_GETFRLW	1
#define TRC_POCALL_SCHEDCPU	2
#define TRC_POCALL_SCHEDPAG	3
#define TRC_POCALL_SWDONE	4

/*
 * Mapping of objects to vnode and <vnode, offset> values
 */
#define TR_MP_SWAP		40	/* allocate a page of swap */
/* "vp %x off %d ap %x" */
#define TR_MP_LNODE		41	/* allocate an lnode */
/* "vp %x lvp %x" */
#define TR_MP_SNODE		42	/* allocate an snode */
/* "vp %x dev %x makespecvp %d" */
#define TR_MP_INODE		43	/* allocate an inode */
/* "vp %x dev %x inode %x" */
#define TR_MP_RNODE		44	/* allocate an rnode */
/* "vp %x fsid %x %x len %x fid %x %x" */
#define TR_MP_TRUNC0		45	/* truncate file to zero length */
/* "vp %x" */
#define TR_MP_TRUNC		46	/* truncate file */
/* "vp %x newlen %d oldlen %d" */

/*
 * Segment trace points
 */
#define TR_SEG_GETMAP		50	/* get a segmap */
/* "seg %x addr %d type %C<kseg,segkmap,anon,file,unk> vp %x off %d" */
#define TR_SEG_RELMAP		51	/* release a segmap */
/* "seg %x addr %d type %C<kseg,segkmap,anon,file,unk> refcnt %d" */
#define TR_SEG_ALLOCPAGE	52	/* call to rm_allocpage */
/* "seg %x addr %d type %C<kseg,segkmap,anon,file,unk> vp %x off %d pp %x" */
#define TR_SEG_GETPAGE		53	/* call to VOP_GETPAGE */
/* "seg %x addr %d type %C<kseg,segkmap,anon,file,unk>" */
#define TR_SEG_KLUSTER		54	/* call to pvn_kluster */
/* "seg %x addr %d readahead %d" */

/*
 * Segment type codes
 */
#define TRC_SEG_KSEG		0
#define TRC_SEG_SEGKMAP		1
#define TRC_SEG_ANON		2
#define TRC_SEG_FILE		3
#define TRC_SEG_UNK		4

/*
 * Process trace points
 */
#define TR_PR_WAKEUP		60	/* before call to wakeup */
/* "ptime %d cpu %d stime %d runout %d" */

/*
 * Swapper trace points
 */
#define TR_SWAP_LOOP		70	/* at loop: in sched */
/* "mapwant %d avenrun %d avefree %d avefree30 %d pginrate %d pgoutrate %d" */
#define TR_SWAP_OUT		71	/* call to swapout */
/* "proc %x hardwap? %d freed %d" */
#define TR_SWAP_SLEEP		72	/* sched calls sleep() */
/* "chan %x runin %d runout %d wantin %d" */
#define TR_SWAP_IN_CHECK	73	/* decision point on calling swapin */
/* "proc %x freemem %d deficit %d needs %d outpri %d maxslp %d" */
#define TR_SWAP_OUT_CHECK	74	/* decision point on calling swapout */
/* "proc %x sleeper %d desperate %d deservin %d inpri %d maxslp %d" */
#define TR_SWAP_IN		75	/* call to swapin */
/* "proc %x taken %d" */
#define TR_SWAP_OUT_CHECK0	76	/* decision point on calling swapout */
/* "proc %x freemem %d rssize %d slptime %d maxslp %d swappable %x" */

/*
 * ufs trace points
 */
#define TR_UFS_RWIP		80	/* call to rwip */
/* "inode %x uio %x rw %x ioflag %d offset %d location %C<enter,getmap,bmapalloc,uiomove,release,iupdat,return>" */

/*
 * rwip location type codes
 */
#define TRC_RWIP_ENTER		0
#define TRC_RWIP_GETMAP		1
#define TRC_RWIP_BMAPALLOC	2
#define TRC_RWIP_UIOMOVE	3
#define TRC_RWIP_RELEASE	4
#define TRC_RWIP_IUPDAT		5
#define TRC_RWIP_RETURN		6

/*
 * Memory allocator trace points; all trace the amount of memory involved.
 */

/*
 * System call trace points.
 */

/*
 * Parameters needed for trace post-processing.  Be careful to keep this
 * up-to-date.  MAXTRACEID is the highest number used for a trace id.
 * MAXTRACECODE is the highest number used to represent a code, for example
 * the codes for TR_PG_FREE are gone, free, cachetl, and cachehd.  These are
 * represented as 0, 1, 2, and 3, respectively.  If 3 were the highest code
 * used for any trace point, that would be the value of MAXTRACECODE.

 */
#define MAXTRACEID	TR_UFS_RWIP
#define MAXTRACECODE	TRC_RWIP_RETURN

/*
 * Generic format for data saved with trace calls.
 *
 * The format of tr_time varies depending on whether or not there's
 * a high resolution timer available.  If so, it's the timer's value;
 * if not, it's the low 16 bits of hrestime.tv_sec concatenated to the
 * high 16 bits of hrestime.tv_usec.  Tr_pid records the process active
 * at the time of the trace call; it's not meaningful if called from
 * interrupt level.
 */
struct trace_rec {
	u_long	tr_time;
	short	tr_tag;
	u_short	tr_pid;
	u_long	tr_datum0;
	u_long	tr_datum1;
	u_long	tr_datum2;
	u_long	tr_datum3;
	u_long	tr_datum4;
	u_long	tr_datum5;
};



/*
 * Requests for the vtrace() system call.
 */
#define VTR_DISABLE	0		/* trace specified events */
#define VTR_ENABLE	1		/* don't trace specified events */
#define VTR_VALUE	2		/* return currently-traced events */
#define VTR_STAMP	3		/* cause TR_STAMP event */
#define VTR_RESET	4		/* reset eventstraced to zero */

#ifdef	_KERNEL
#ifdef	TRACE

extern fd_set	tracedevents;
extern u_int	tracebufents;
extern u_int	eventstraced;
extern struct	trace_rec *tracebuffer;
extern void	inittrace();
extern void	resettracebuf();
extern void	traceit();

#define pack(a, b)	((a)<<16)|(b)

/*
 * Lint doesn't believe that there are valid reasons for comparing
 * constants to each other...
 */
#ifdef	lint
#define trace(ev, d0, d1, d2, d3, d4, d5) \
	if (FD_ISSET((ev), &tracedevents)) \
		traceit((ev), (u_long)(d0), (u_long)(d1), (u_long)(d2), \
			(u_long)(d3), (u_long)(d4), (u_long)(d5))
#else	/* lint */
#define trace(ev, d0, d1, d2, d3, d4, d5) \
	if ((u_int)(ev) < FD_SETSIZE && FD_ISSET((ev), &tracedevents)) \
		traceit((ev), (u_long)(d0), (u_long)(d1), (u_long)(d2), \
			(u_long)(d3), (u_long)(d4), (u_long)(d5))
#endif	/* lint */

#define trace6(ev, d0, d1, d2, d3, d4, d5) \
	trace(ev, d0, d1, d2, d3, d4, d5)
#define trace5(ev, d0, d1, d2, d3, d4)	trace(ev, d0, d1, d2, d3, d4, 0)
#define trace4(ev, d0, d1, d2, d3)	trace(ev, d0, d1, d2, d3, 0, 0)
#define trace3(ev, d0, d1, d2)		trace(ev, d0, d1, d2, 0, 0, 0)
#define trace2(ev, d0, d1)		trace(ev, d0, d1, 0, 0, 0, 0)
#define trace1(ev, d0)			trace(ev, d0, 0, 0, 0, 0, 0)

#else	/* TRACE */

#define pack(a, b)

#define trace	trace6
#define trace6(ev, d0, d1, d2, d3, d4, d5)
#define trace5(ev, d0, d1, d2, d3, d4)
#define trace4(ev, d0, d1, d2, d3)
#define trace3(ev, d0, d1, d2)
#define trace2(ev, d0, d1)
#define trace1(ev, d0)

#endif	/* TRACE */
#endif	/* _KERNEL */

#endif	/* _VM_TRACE_H */
 070701000028eb000081240000000200000002000000012719347c00001a68000000230000000c00000000000000000000001800000000usr/include/vm/vm_hat.h   /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ifndef _VM_VM_HAT_H
#define _VM_VM_HAT_H

#ident	"@(#)/usr/include/vm/vm_hat.h.sl 1.1 4.0 10/15/90 42370 AT&T-SF"

#include "sys/immu.h"

/*
 * VM - Hardware Address Translation management.
 *
 * This file describes the contents of the machine specific
 * hat data structures and the machine specific hat procedures.
 * The machine independent interface is described in <vm/hat.h>.
 */

/* The 386 HAT design is based on dividing a page table into
 * chunks that are a power of 2 long.
 * These chunks allow the mapping pointer overhead to be
 * reduced for the typical small process.
 * The number of chunks times the number of entries equals 1024.
 * The initial design uses 32 chunks of 32 entries.
 * If translation caching (stealable translation accounting)
 * is implemented, this may change to 16 chunks of 64 entries.
 * This allows four accounting words to be available per chunk
 * (instead of 1 word) in the accounting chunk (chunk 0) of
 * a mapping chunk page.
 * The extra words would be used for a time stamp and pointers
 * for a doubly linked list.
 * To acommodate this possible change, the following defines exist.
 */
#define HAT_MCPP	32	/* number of mapping chunks per page */
#define HAT_EPMC	32	/* number of entries per mapping chunk */
typedef union hatmap {
	uint hat_mapv;
	union hatmap *hat_mnext;
} hatmap_t;

typedef struct hatmc {
	hatmap_t hat_map[HAT_EPMC];
} hatmc_t;

/* 
 * The hatmcp_t:
 */
typedef struct {
	hatmc_t *hat_mcp;
} hatmcp_t;

#define HATMAP_ADDR	0xFFFFFF80

/* The hatpt structure is the machine dependent page table accounting
 * structure internal to the 386 HAT layer.
 * It links an address space to a currently resident page table
 * and the currently resident mapping pointer chunks for that
 * page table.
 * It contains an active PTE count and all locking information.
 * It also contains hatpt pointers for a doubly linked, circular
 * linked list of active page tables for an address space.
 */
typedef struct hatpt {
	struct	hatpt *hatpt_forw;	/* forward page table list ptr */
	struct	hatpt *hatpt_back;	/* backward page table list ptr */
	struct	hatpt *hatpt_next;	/* forward activept list ptr */
	struct	hatpt *hatpt_prev;	/* backward activept list ptr */
	pte_t	hatpt_pde;		/* PDE for page table */
	pte_t	*hatpt_pdtep;		/* PDT entry pointer */
	struct	as *hatpt_as;		/* pointer back to containing as */
	cnt_t	hatpt_aec;		/* active entry count */
	cnt_t	hatpt_locks;		/* count of locked PTEs */
	hatmcp_t hatpt_mcp[HAT_MCPP];	/* mapping chunk pointer array */
} hatpt_t;

/*
 * The hat structure is the machine dependent hardware address translation
 * structure kept in the address space structure to show the translation.
 */
typedef struct hat {
	struct	hatpt *hat_pts;		/* current page table list */
	struct	hatpt *hat_ptlast;	/* last page table to fault */
} hat_t;

typedef struct hatpgtc {
	pte_t	hat_pte[HAT_EPMC];
} hatpgtc_t;

/* The mapping chunk page declarations:
 */

typedef union {
	struct {
		uint hat_mcaec	:  6,	/* active PTE count for chunk */
				:  1,	/* spare bit */
		     hat_ptcndx	: 25;	/* high order bits of pointer
					 * to page table chunk.  Zeroed
					 * low order bits completes
					 * the pointer.
					 */
	} ptp;
	uint hat_ptpv;
	hatpgtc_t *hat_pgtcp;
} hatptcp_t;

#define HATPTC_ADDR	0xFFFFFF80


typedef union hatmpga {
	uint	hat_mpgabits;		/* mapping chunk page allocation bits.
					 * This may get changed if translation
					 * cache needs it.
					 */
	hatptcp_t hatptcp[HAT_MCPP];	/* pointers to the page table chunks
					 * for the 31 (1-31) mapping chunks
					 * in the page.
					 * Slot 0 corresponds to the hatmpga
					 * data, so it is available for other use.
					 */
} hatmpga_t;

#define HATMCFULL	0xFFFFFFFF

typedef union hatmcpg {
	hatmpga_t hat_mcpga;
	hatmc_t hat_mc[HAT_MCPP];
} hatmcpg_t;


typedef struct hatpgt {
	hatpgtc_t hat_pgtc[HAT_MCPP];
} hatpgt_t;

struct phat {
	union {
		caddr_t mappings;
		hatpt_t *ptap;
		hatmcpg_t *mcpgp;
	} ph_use;
};

/*
 * Flags to pass to hat_ptalloc().
 *
 * NOTE: HAT_NOSLEEP and HAT_CANWAIT must match up with
 *       P_NOSLEEP and P_CANWAIT (respectively) in vm_page.h
 */
#define	HAT_NOSLEEP	0	/* return immediately if no memory */
#define HAT_CANWAIT	1	/* wait if no memory currently available */
#define HAT_NOSTEAL	2	/* don't steal a PT from another process */	

/*
 * Flags to pass to hat_ptsteal().
 */
#define HAT_PTUSED	0	/* stolen PT will be reused immediately */
				/* called from hat_ptalloc() */
#define HAT_PTFREE	1	/* stolen PT will be freed, */
				/* called from hat_mcalloc() */


#define HATMCNOSHFT	17	/* PNUMSHFT + LOG2(HAT_EPMC) */
#define HATMCNOMASK	(HAT_MCPP-1)
#define HATMCNDXSHFT	PNUMSHFT
#define HATMCNDXMASK	(HAT_EPMC-1)
#define MAPMCNOSHFT	7	
#define MAPMCNDXSHFT	2
#define HATMCNO(v)	(((uint)(v) >>HATMCNOSHFT) & HATMCNOMASK)
#define HATMCNDX(v)	(((uint)(v) >>HATMCNDXSHFT) & HATMCNDXMASK)
#define HATMAPMCNO(map)	(((uint)(map) >>MAPMCNOSHFT) & HATMCNOMASK)
#define HATMAPMCNDX(map)(((uint)(map) >>MAPMCNDXSHFT) & HATMCNDXMASK)
#define HATMCSIZE	(1 << HATMCNOSHFT)
#define HATVMC_ADDR	0xFFFE0000

#ifdef _KERNEL

extern void restorepd();

#endif /* _KERNEL */

/* some HAT-specific macros: */

/* obtain the virtual address that maps the page frame number in a pte */
#define ptetokv(pte)	(xphystokv((pte) & PG_ADDR))

/* from a mapping chunk pointer to the address of mapping chunk */
#define mcptomapp(mcp)	((hatmap_t *)((mcp)->hat_mcp))

/* from a mapping pointer to the page table chunk pointer */
#define mapptoptcp(mapp) ((hatptcp_t *)((uint)(mapp) & PG_ADDR) \
				+ HATMAPMCNO(mapp))

/* from a mapping pointer to the page table entry pointer */
#define mapptoptep(mapp) ((pte_t *)(((hatptcp_t *)((uint)(mapp) & PG_ADDR) \
			  + HATMAPMCNO(mapp))->hat_ptpv & HATPTC_ADDR) \
			  + HATMAPMCNDX(mapp))

/* obtain page table chunk point from ptcp */
#define ptcptoptep(ptcp) (pte_t *)(ptcp->hat_ptpv & HATPTC_ADDR) 

#define	APPEND_PT(PT, LIST)	{					\
				(LIST).hatpt_prev->hatpt_next = PT;	\
				(PT)->hatpt_prev = (LIST).hatpt_prev;	\
				(PT)->hatpt_next = &LIST;			\
				(LIST).hatpt_prev = PT;			\
			}

#define	PREPEND_PT(PT, LIST)	{					\
				(LIST).hatpt_next->hatpt_prev = PT;	\
				(PT)->hatpt_next = (LIST).hatpt_next;	\
				(PT)->hatpt_prev = &LIST;			\
				(LIST).hatpt_next = PT;			\
			}

#define	REMOVE_PT(PT)	{						\
			(PT)->hatpt_prev->hatpt_next = (PT)->hatpt_next;	\
			(PT)->hatpt_next->hatpt_prev = (PT)->hatpt_prev;	\
			}

#endif	/* _VM_VM_HAT_H */

070701000028ec000081240000000200000002000000012719347c00000427000000230000000c00000000000000000000001700000000usr/include/vm/vmlog.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_VMLOG_H
#define _VM_VMLOG_H

#ident	"@(#)/usr/include/vm/vmlog.h.sl 1.1 4.0 10/15/90 29356 AT&T-SF"

#endif	/* _VM_VMLOG_H */
 070701000028ed000081240000000200000002000000012719347c00000622000000230000000c00000000000000000000001700000000usr/include/vm/vpage.h    /*	Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990 AT&T	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 		PROPRIETARY NOTICE (Combined)
 * 
 * This source code is unpublished proprietary information
 * constituting, or derived under license from AT&T's UNIX(r) System V.
 * In addition, portions of such source code were derived from Berkeley
 * 4.3 BSD under license from the Regents of the University of
 * California.
 * 
 * 
 * 
 * 		Copyright Notice 
 * 
 * Notice of copyright on this source code product does not indicate 
 * publication.
 * 
 * 	(c) 1986,1987,1988,1989  Sun Microsystems, Inc
 * 	(c) 1983,1984,1985,1986,1987,1988,1989  AT&T.
 * 	          All rights reserved.
 *  
 */

#ifndef _VM_VPAGE_H
#define _VM_VPAGE_H

#ident	"@(#)/usr/include/vm/vpage.h.sl 1.1 4.0 10/15/90 58447 AT&T-SF"

/*
 * VM - Information per virtual page.
 */
struct vpage {
	u_int	vp_prot: 4;		/* see <sys/mman.h> prot flags */
	u_int	vp_advise: 3;		/* see <sys/mman.h> madvise flags */
	u_int	vp_lock: 1;		/* someone has this vpage locked  */
	u_int	vp_want: 1;		/* someone wants this vpage */
	u_int	vp_ref: 1;		/* reference bit */
	u_int	vp_mod: 1;		/* (maybe) modify bit, from hat */
	u_int	vp_pplock: 1;		/* physical page locked by me */
	u_int	: 4;
};

int	vpage_lock(/* l, vp */);
void	vpage_unlock(/* l, vp */);

#endif	/* _VM_VPAGE_H */
  07070100001999000041fd0000000200000002000000022719347c00000000000000230000000c00000000000000000000000900000000usr/lbin  07070100001baa0000816d0000000200000002000000012719347c00003199000000230000000c00000000000000000000001400000000usr/lbin/Install.sh   #!/sbin/sh
#	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
#	  All Rights Reserved

#	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T
#	The copyright notice above does not evidence any
#	actual or intended publication of such source code.

#	Copyright (c) 1987, 1988 Microsoft Corporation
#	  All Rights Reserved

#	This Module contains Proprietary Information of Microsoft
#	Corporation and should be treated as Confidential.

#ident	"@(#)/usr/lbin/Install.sh.sl 1.1 4.0 10/01/90 39786 AT&T-SF"
#
# ----------------------------------------------------------------------
# PURPOSE:  Install application software in PLUS format.
# ----------------------------------------------------------------------
INDIR=/usr/lib/installed
CONTENTS=${INDIR}/CONTENTS
PLUSDIR=/tmp/installed
TMPDIR=/usr/tmp/install$$
CPLOG=/tmp/cplog$$
PATH=/sbin:/usr/sbin:/etc:/usr/bin
export PATH

trap "trap '' 1 2 3 9 15; cd /; rm -rf ${TMPDIR} ${CPLOG} > /dev/null 2>&1; echo You have canceled the installation.; sync; exit 1" 1 2 3 9 15

SPACE=/etc/conf/bin/idspace

FDMESS="Please insert the floppy disk.\n\nIf the program installation \
requires more than one floppy disk, be sure to insert the disks in the \
proper order, starting with disk number 1.\nAfter the first floppy disk, \
instructions will be provided for inserting the remaining floppy disks."
ERROR2="An error was encountered while reading in the floppy disk(s).\
Please be sure to insert them in the proper order, that the drive door is closed,\
and wait for the notification before removing them."
ERROR3="If this problem reoccurs at the same floppy disk, the floppy disk may \
be bad. Please re-insert the first floppy disk of this package and try again."

# Check if root is performing the operation
id | grep "(root)" > /dev/null
if [ "$?" = "0" ]
then
	id | grep "euid=" > /dev/null
	if [ "$?" = "0" ] #Did get root above; no euid string
	then
		id | grep "euid=0(root)" > /dev/null
		if [ "$?" = 0 ]
		then
			UID=0
		else
			UID=1
		fi
	else
		UID=0
	fi
else
	UID=1
fi
if [ "$UID" != 0 ]
then echo "You must be root or super-user to install software."
     exit 1
fi

if [ -z "$TERM" ]
then TERM=AT386-M
fi
CLEAR=`tput clear 2>/dev/null`

if [ $# -eq 2 ]
then DRIVE=$1
else DRIVE=/dev/rdsk/f0
fi
FD=$2
cd /
rm -rf ${TMPDIR}
mkdir ${TMPDIR}
cd ${TMPDIR}

if [ ! -f ${CONTENTS} ]
then	rm -rf ${CONTENTS}
	>> ${CONTENTS}
fi

DEVICE=q
while [ 1 ]
do
	rm -rf Size
	echo "$CLEAR"
	echo "\n\nSearching for the Size file\n"

	xtract icBu Size ${DRIVE} 1>${CPLOG} 2>&1
	err=$?
	sync
	if [ "`grep \"error - Size not found\" ${CPLOG}`" ]
	then DEVICE=q
	elif [ "$err" != "0" ]
	then continue
	fi
	if [ -r Size -a -s Size ]
	then 
		DEVICE=w
		if grep "USR=" Size 2>&1 > /dev/null ||
		   grep "ROOT=" Size 2>&1 > /dev/null
		then
			APPTYPE="386"
		else
			APPTYPE="PLUS"
			# DENSITY is used to flag whether the application
			# should by cpio'd or cpiopc'd.  All plus applications
			# should be cpiopc'd regardless if they are 1.2 or 360.
			DENSITY=360
		fi
	fi
	while [ 1 ]
	do
	if [ $DEVICE = q ]
	then
	    while [ 1 ]
	    do
		flp=0
		while [ $flp -lt 1 ]
		do
			echo "Please enter the number of floppies in the package followed by ENTER: \c"
			read num
			if [ -z "$num" ]
			then
				echo "The number of floppies field must be filled in."
			else
				expr ${num} \* 20 > /dev/null 2>/dev/null
				if  [ $? != 0 ]
					then echo "The number of floppies, is not a valid number."
				elif  [ 1 -gt "$num" ]
				then
					echo "The number of floppies must be at least 1."
				else
					flp=`expr $num`
				fi
			fi
		done
		media=0
		while [ $media -lt 1 ]
		do
			echo "\rPlease enter:\n\
			1 (for 360 KB)\n\
			2 (for 1.2 MB)\n\
			3 (for 720 KB)\n\
			4 (for 1.44 MB)\n\c"
				
			read num
			if [ -z "$num" ]
			then
				echo "The disk density must be filled in."
			else
				expr ${num} \* 20 > /dev/null 2>/dev/null
				if  [ $? != 0 ]
					then echo "The density number is not a valid number."
				elif  [ 1 -eq "$num" ]
				then
					media=`expr $num`
					DENSITY=360
					DEVICE=y
					BLOCKS=702
				elif  [ 2 -eq "$num" ]
				then
					media=`expr $num`
					DEVICE=z
					BLOCKS=2370
				elif [ 3 -eq "$num" ]
				then
					media=`expr $num`
					DEVICE=a
					BLOCKS=1440
				elif [ 4 -eq "$num" ]
				then
					media=`expr $num`
					DEVICE=b
					BLOCKS=2880
				else
					echo "The density number must be 1, 2, 3, or 4."
				fi
			fi
		done
		break
	   done
	   USR=`expr ${flp} \* ${BLOCKS} `
	   ROOT=50
	fi
	if [ $DEVICE = w ]
	then
		linecnt=`expr \`cat Size | wc -l\``
		if [ \( $linecnt -ne 1 \) -a \( $linecnt -ge 3 \) ]
		then
			echo "Invalid Size file found.  Cannot determine disk requirements."
			DEVICE=q
			continue
		fi
		ROOT=10
		USR=10
		if [ "`grep ROOT= Size`" ]
		then ROOT=50
		     USR=50
		fi
		if [ "`grep USR= Size`" ]
		then USR=50
		fi
		if [ \( \( $ROOT = 50 \) -a \( $USR != 50 \) \) -o \( \( $ROOT != 50 \) -a \( $USR = 50 \) \) ]
		then
			echo "Invalid Size file found.  Cannot determine disk requirements."
			DEVICE=q
			continue
		fi
		if [ "`grep USR= Size`" ]
		then
			ROOT=`cat Size | grep ROOT | cut -d= -f2`
			USR=`cat Size | grep USR | cut -d= -f2`
		elif [ "`grep ROOT= Size`" ]
		then
			ROOT=`cat Size | grep ROOT | cut -d= -f2`
		else
			USR=`cat Size`
			ROOT=50
		fi
	fi
	break
	done
	FILE_S="user (/usr) filesystem"
	$SPACE -u $USR > /dev/null 2>&1
	ERR=$?
	if [ $ERR = 3 ]
	then
		FILE_S="hard disk"
		ROOT=`expr $ROOT + $USR`
	fi
	if [ $ERR = 2 ]
	then USR="user (/usr) "
	else USR=
	fi
	$SPACE -r $ROOT > /dev/null 2>&1
	if [ $? = 2 ]
	then ROOT="root (/) "
	else ROOT=""
	fi
	if [ \( $ERR = 2 \) -o \( "$ROOT" = "root (/) " \) ]
	then
		if [ \( $ERR = 2 \) -a \( "$ROOT" = "root (/) " \) ]
		then S=s
		     CONJ=" and "
		else S=
		     CONJ=
		fi
		if [ -z "$USR" ]
		then PART="${ROOT}filesystem "
		else PART="${ROOT}${CONJ}${USR}filesystem${S} "
		fi
		message "There is not enough room on the hard disk to \
install the package.  Please remove some files from the ${PART}and try again."
		echo "The Installation is canceled."
		break
	fi

	if [ $DEVICE != w ]
	then
		message -c "$FDMESS"
		if [ $? != "0" ]
		then
			echo "The Installation is canceled."
			break
		fi
	fi
	rm -rf *
##
	if [ "${APPTYPE}" = "PLUS" ]
	then
		cd /
		rm -rf ${TMPDIR}
		TMPDIR=${PLUSDIR}
		mkdir ${TMPDIR}
		cd ${TMPDIR}
	fi
	echo "$CLEAR"
	echo "                        Install in progress\n\n\n\n\n\n"
	if [ "$DENSITY" = "360" ] && expr "$FD" : '^[0-5]$' > /dev/null
	then
		/usr/sbin/.cpiopc -iBcduw$FD 2>${CPLOG}
		err=$?
	else
		cpio -iBcdu -I${DRIVE} -M"You may remove this floppy disk.
To QUIT - strike <q> followed by <ENTER>
To continue - insert floppy disk number %d and strike the <ENTER> key." 2>${CPLOG}
		err=$?
	fi
	if [ "`grep \"file header information\" ${CPLOG}`" ]
	then
		message -c "The floppy disk you inserted is either not the correct floppy disk, \
or you inserted it in the wrong order.  ${ERROR3}"
		if [ $? != "0" ]
		then
			echo "The Installation is canceled."
			break
		fi
	elif [ "`grep \"annot create\" ${CPLOG}`" ]
	then
		message "Your ${FILE_S} is out of space.  Please remove some files and try again."
		echo "Installation aborted."
		break
	elif [ "$err" = "4" ]
	then
		message -c "You have canceled the Installation.  If you wish \
to try it again press ENTER, otherwise press ESC."
		if [ $? != "0" ]
		then
			echo "The Installation is canceled."
			break
		fi
	elif [ "$err" != "0" ] 
	then
		message -c "${ERROR2}  ${ERROR3}"
		err1=$?
		if [ $err1 != "0" ]
		then
			echo "The Installation is canceled."
			break
		fi
# No need to check for ./Size since we're here
	elif [ ! -f ./Install -o ! -f ./Remove -o ! -f ./Name ]
	then
		message -c "The software package is missing the necessary installation programs.  \
Please check to make sure you have the right floppy disk(s)."
		if [ "$?" != "0" ]
		then	
			echo "The Installation is canceled."
			break
		fi
	else
		trap '' 1 2 3 9 15
		chmod +x ./Install
		NAME=`cat -s Name`

# Check for special case of Simultask on top of MERGE 386 or vice versa
		STASK="Simul-Task 386"
		MG386="Merge 386"
		grep "$STASK" Name > /dev/null 2>&1; stask_new=$?
		grep "$MG386" Name > /dev/null 2>&1; mg386_new=$?
		grep "$STASK" /usr/options/* > /dev/null 2>&1; stask_in=$?
		grep "$MG386" /usr/options/* > /dev/null 2>&1; mg386_in=$?
		if [ "$stask_new" = 0 -a "$mg386_in" = 0 ]
		then
			message -d "You cannot install $STASK on a system \
that has $MG386 installed. You must remove $MG386 before continuing."
			break
		fi
		if [ "$stask_in" = 0 -a "$mg386_new" = 0 ]
		then
			message -d "You cannot install $MG386 on a system \
that has $STASK installed. You must remove $STASK before continuing."
			break
		fi

# Check out if previously installed
		SNAME=`echo "$NAME" | sed -e 's/[ &()$#\-?\\!*;|<>]/./g' -e 's/\[/./g' -e 's/\]/./g'`

		#  Warn the user if there is a xenix package already installed
		#  with the same name.  
		#  Use a bogus directory to check if /etc/perms is an empty 
		#  directory.  Used to be guaranteed not empty in XENIX.
		#  Avoids expansion of '*'.
		tmp=/tmp/CUSLIST
		perm_files=`cd /etc/perms; echo *`
		if [ "/att/msoft/isc/*" != "/att/msoft/isc/$perm_files" ]
		then
			for perm in $perm_files
			do
				#  Call fixperm to list the installed packages 
				#  for this set
				fixperm -iv $ignorepkgs /etc/perms/$perm |
				sed "s/^\(.*\)	.*$/s:^#!\1[ 	][ 	]*:	&	:p/" > $tmp.fl
				#  Get the package name in field 4 
				sed -n -f $tmp.fl /etc/perms/$perm   | 
						sed "s/^	//"  | 
						cut -f4 >> $tmp.sid
			done

			KEY=`grep "$SNAME\$" $tmp.sid`
			rm -f $tmp.sid $tmp.fl
			if [ -n "$KEY" ]
			then 
				message -c "A XENIX package with the same name, $NAME, \
	has already been installed.  This package may overwrite the XENIX package."
			     if [ "$?" != "0" ]
			     then echo "The Installation is canceled"
				 break
			     fi
			fi
		fi

		KEY=`grep " $SNAME\$" $CONTENTS`
		if [ -n "$KEY" ]
		then message -c "The $NAME has already been installed.  \
The new installation will now replace the original $NAME files."
		     if [ "$?" != "0" ]
		     then echo "The Installation is canceled"
			 break
		     fi
		     cd /usr/options
		     for i in *
		     do
			grep "^${SNAME}$" $i > /dev/null 2>&1
			if [ $? = 0 ]
			then
				KEY2=$i
				break
			fi
		     done
		     cd ${TMPDIR}
		     eval KEY=`grep " $SNAME\$" $CONTENTS | cut -f1 -d' ' `
		     if [ "$KEY" ]
		     then
			   mv ${INDIR}/Remove/"${KEY2}" /tmp/"${KEY}".R
			   mv ${INDIR}/Files/"${KEY2}" /tmp/"${KEY}".F > /dev/null 2>&1
			   mv /usr/options/"${KEY2}" /tmp/"${KEY}".O
			   grep " $SNAME\$" $CONTENTS > /tmp/"${KEY}"
		           grep -v " $SNAME\$" $CONTENTS > /tmp/$$
		           mv /tmp/$$ $CONTENTS
		     fi
		else KEY2=`echo "$NAME" | sed -e 's/ //g' -e 's/\///g' -e 's/\&//g' | tr "[A-Z]" "[a-z]" | cut -c1-6`
		     if [ -f /usr/options/"${KEY2}".name ]
		     then
			num=`expr 1`
			while [ -f /usr/options/"${KEY2}"${num}.name ]
			do
				num=`expr $num + 1`
			done
			KEY2="${KEY2}"${num}.name
		     else
			KEY2="${KEY2}".name
		     fi
		fi
		echo "$CLEAR "
		./Install
		# It is the 'Install' script's job to print an error message
		# if the installation indicates the return of non-zero:
		if [ "$?" != "0" ]
		then
			if [ -n "$KEY" ]
			then
				mv /tmp/"${KEY}".R ${INDIR}/Remove/"${KEY2}" > /dev/null 2>&1
				mv /tmp/"${KEY}".F ${INDIR}/Files/"${KEY2}" > /dev/null 2>&1
				mv /tmp/"${KEY}".O /usr/options/"${KEY2}" > /dev/null 2>&1
				cat /tmp/"${KEY}" >> $CONTENTS
				rm -f /tmp/"${KEY}" > /dev/null 2>&1
			fi
			break
		else
			rm -f /tmp/"${KEY}".[RFO] /tmp/"${KEY}" > /dev/null 2>&1
			if [ ! -d $INDIR ]
			then mkdir $INDIR; chmod 755 $INDIR
			fi
			if [ ! -d ${INDIR}/Files ]
			then mkdir ${INDIR}/Files; chmod 755 ${INDIR}/Files
			fi
			if [ ! -d ${INDIR}/Remove ]
			then mkdir ${INDIR}/Remove; chmod 755 ${INDIR}/Remove
			fi
			echo "$KEY2 1 $NAME" >> $CONTENTS
			mv ./Remove ${INDIR}/Remove/"${KEY2}"
			mv ./Name /usr/options/"${KEY2}"
			if [ -f Files ]
			then
				mv Files ${INDIR}/Files/"${KEY2}"
			fi
			chown bin ${INDIR}/Remove/"${KEY2}" /usr/options/"${KEY2}" ${INDIR}/Files/"${KEY2}" > /dev/null 2>&1
			chgrp bin ${INDIR}/Remove/"${KEY2}" /usr/options/"${KEY2}" ${INDIR}/Files/"${KEY2}" > /dev/null 2>&1
			chmod 644 ${INDIR}/Remove/"${KEY2}" /usr/options/"${KEY2}" ${INDIR}/Files/"${KEY2}" > /dev/null 2>&1
			sync; sync
			if [ -f /etc/.new_unix ]
			then
				sync; sync
				cd /
				rm -rf ${TMPDIR} ${CPLOG}
				exec /etc/conf/bin/idreboot
			else
				message -d "The installation of the \
$NAME is now complete."
			fi
			break
		fi
	fi
	DEVICE=q
done
cd /
rm -rf ${TMPDIR} ${CPLOG}
   07070100001bad0000816d0000000200000002000000012719347c000036e5000000230000000c00000000000000000000001600000000usr/lbin/Install.tape #!/sbin/sh
#	Copyright (c) 1984, 1986, 1987, 1988 AT&T
#	  All Rights Reserved

#	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T
#	The copyright notice above does not evidence any
#	actual or intended publication of such source code.

#ident	"@(#)/usr/lbin/Install.tap.sl 1.1 4.0 10/01/90 39233 AT&T-SF"

# ----------------------------------------------------------------------
# PURPOSE: Install application software from tape (V/386 3.2 version 2.2
# ----------------------------------------------------------------------

INDIR=/usr/lib/installed
CONTENTS=${INDIR}/CONTENTS
TMPDIR=/usr/tmp/install$$
CPLOG=/tmp/cplog$$
SPACE=/etc/conf/bin/idspace
TMP_FILE=/tmp/T$$
PACK_FLNM=/tmp/pkglist
MAX_CHECK=8
PATH=/sbin:/usr/sbin:/etc:/usr/bin
export PATH

[ -z "$TERM" ] && TERM=vt100
CLEAR=`tput clear 2>/dev/null`

if [ $# -gt 0 ]
then SPECIAL=YES
fi
export SPECIAL
DEVICE=/dev/rmt/c0s0
DEVICEN=""
SCSI_DEV=/dev/scsi/qtape1
OATAPE=ctape1

TAPECNTL=/usr/lib/tape/tapecntl
if [ -c ${SCSI_DEV} ]
then DEVICE=${SCSI_DEV}
     DEVICEN="-y ${DEVICE}n"
     TAPECNTL=/usr/lib/scsi/scsitapecntl
     OATAPE=qtapeN
fi
if [ -c /dev/rmt/c0s0 -a -c ${SCSI_DEV} ]
then
/etc/machid -s
if [ $? = 1 ]
then DEVICE=${SCSI_DEV}
     DEVICEN="-y ${DEVICE}n"
     TAPECNTL=/usr/lib/scsi/scsitapecntl
     OATAPE=qtapeN
else DEVICE=/dev/rmt/c0s0
     DEVICEN=""
     TAPECNTL=/usr/lib/tape/tapecntl
     OATAPE=ctape1
fi
fi
export DEVICE TAPECNTL DEVICEN OATAPE
[ -f ${TAPECNTL} ] || {
	echo "The Program ${TAPECNTL} is missing"
	exit 1
}
TENSION="${TAPECNTL} -t ${DEVICEN}"
REWIND="${TAPECNTL} -w ${DEVICEN}"
MOVE="${TAPECNTL} -p"

# Function for old 3.2.1 style tapes
old_tape()
{
	loop=$2
	while [ ${loop} -le ${MAX_CHECK} ]
	do
	${REWIND} > /dev/null 2>&1
	sleep 1
	${MOVE} ${loop} ${DEVICEN} > /dev/null 2>&1
	sleep 1
	dd if=$1 of=${PACK_FLNM} bs=5120 count=1 > /dev/null 2>&1
	if [ "$?" != "0" ]
	then return 1
	fi
	grep ${PACK_FLNM} ${PACK_FLNM} > /dev/null 2>&1
	if [ $? = "0" ]
	then break
	fi
	loop=`expr ${loop} + 1`
	done

	if [ ${loop} -gt ${MAX_CHECK} ]
	then return 1
	else echo ${loop} > /tmp/pkg.idx
	     return 0
	fi
}

trap "trap '' 1 2 3 9 15; cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG}; echo You have canceled the installation.; (< ${DEVICE}) > /dev/null 2>&1; sync; exit 1" 1 2 3 9 15

#
# variables
#

PKG_BASE=1
PKG_CNT=0
PKG_LIST=""
ERROR=0
INSTALLED_LIST=""

echo "0" > /tmp/pkg.idx
if [ -z "$SPECIAL" ]
then
while [ 1 ]
do
while [ 1 ]
do
message -c "Please insert the cartridge tape into the tape drive."
if [ "$?" != 0 ]
then echo "\nInstallation has been canceled."
	exit 1
fi
( < ${DEVICE} ) > /dev/null 2>&1
if [ $? = 0 ]
then break
fi
sleep 2
echo "\n"
done
echo "\n"
rm -f ${PACK_FLNM}
sleep 3
dd if=${DEVICE} of=$PACK_FLNM bs=5120 count=1 > /dev/null 2>&1
if [ "$?" = "0" ]
then
grep $PACK_FLNM $PACK_FLNM > /dev/null 2>&1
if [ "$?" = "0" ]
then break
fi
sync;sync
seq=`dd if=${DEVICE} bs=5120 count=1 2>/dev/null`
if [ "20" = `expr "$seq" : "# PaCkAgE DaTaStReAm"` ]
then 
	message -d "This package is an OA&M style package.  \
To install this package type in:\n\n\t\tpkgadd -d ${OATAPE}\n"
	exit 1
fi
old_tape ${DEVICE}n 0
if [ "$?" = "0" ]
then ${REWIND} > /dev/null 2>&1
     break
fi
fi
message -c "This tape is not in the correct format.\nNo installable packages \
could be found.\n\nPlease check that the correct tape has been inserted into the drive."
if [ "$?" != "0" ]
then echo "Installation has been canceled."
	(< ${DEVICE}) > /dev/null 2>&1
	cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG}; sync
	exit 1
fi
done

message -c "It is recommended that you re-tension the tape before attempting \
the installation, to ensure that the tape is read without any errors.\n\n\
If you strike ENTER the tape will be re-tensioned."
if [ "$?" != "1" ]
then
	echo "Re-tensioning the tape media.\n\nThis will take approximately 3 minutes."
	sleep 3
	$TENSION
	if [ $? != 0 ]
	then echo "Re-tensioning failed.  Please try again."
		cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG}; sync
		(< ${DEVICE}) > /dev/null 2>&1
		exit 1
	fi
	sleep 2
fi

rm -f ${PACK_FLNM}
sleep 2
${MOVE} `cat /tmp/pkg.idx` ${DEVICEN}
sleep 1
cpio -iBcu -I${DEVICE}n 2>/dev/null
if [ $? != 0 ]
then echo "Can't read the cartridge tape.  Please try again."
	cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG}; sync
	(< ${DEVICE}) > /dev/null 2>&1
	exit 1
fi
fi

OLDTAPE=0
PKG_BASE=`expr \`cat /tmp/pkg.idx\` + 1`
PKG_CNT=`expr \`cat $PACK_FLNM | wc -l\``
grep "^PKG[0-9]" ${PACK_FLNM} > /dev/null 2>&1
if [ "$?" = "0" ]
then OLDTAPE=1
else OLDTAPE=0
fi
if [ \( $PKG_CNT -lt 2 \) -a \( ${OLDTAPE} = "0" \) ]
then echo "This tape is not in the correct format.  Installation has been canceled."
	(< ${DEVICE}) > /dev/null 2>&1
	cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG}; sync
     exit 1
fi

rm -rf ${TMPDIR} ${TMP_FILE}
mkdir ${TMPDIR}
cd ${TMPDIR}

if [ ${OLDTAPE} = "1" ]
then cat $PACK_FLNM > ${TMP_FILE}
else cat $PACK_FLNM | sed -n "2,\$p" | grep -v "	Hidden$" > ${TMP_FILE}
fi
if [ ! -s ${TMP_FILE} ]
then
	message -d "This tape has no 'installpkg format' packages on it.\n\
If this tape has OA&M style packages on it, please run:\n\
\t\tpkgadd -d ${OATAPE}"
	(< ${DEVICE}) > /dev/null 2>&1
	cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG}; sync
	exit 1
fi

echo $CLEAR
if [ -n "$SPECIAL" ]
then STR="Foundation Set Add-on\npackages that you wish to install."
else STR="packages that you\nwish to install from this tape."
fi
echo "You will now be prompted to select the ${STR}\n\n\
You may select one or more packages from the menu by\n\
entering the number listed alongside the package name.\n"
echo "Enter each package number one at a time, pressing ENTER\n\
after each selection.  The package numbers may be entered\n\
in any order.\n"
echo "To install all the packages, type the number indicated\n\
at the end of the package list.\n\n\
When you have made all the selections required, Strike ESC.\n"
echo "To skip this step or cancel any selections made, type\n\
the number as indicated in the package list.\n\n"
echo "Strike ENTER when ready".
read x

while [ 1 ]
do
while [ 1 ]
do
echo $CLEAR
if [ ${OLDTAPE} = "0" ]
then echo "Tape Name: `sed -n 1p $PACK_FLNM`"
fi
echo "\nPackages available for installation:\n"
count=1
if [ ${OLDTAPE} = 1 ]
then
while [ 1 ]
do
	echo "$count.\c"
	grep "${count}=" ${TMP_FILE} | cut -f2- -d= | sed -e "s/^/	/g"
	count=`expr $count + 1`
	grep "${count}=" ${TMP_FILE} > /dev/null 2>&1
	if [ "$?" != "0" ]
	then break;
	fi
done
else
while [ 1 ]
do
	echo "$count.\c"
	grep "	$count$" ${TMP_FILE} | cut -f1 -d"	" | sed -e "s/^/	/g"
	count=`expr $count + 1`
	grep "	$count$" ${TMP_FILE} > /dev/null 2>&1
	if [ "$?" != "0" ]
	then break;
	fi
done
fi
echo "\n${count}.\tInstall ALL packages shown above"
count=`expr $count + 1`
echo "${count}.\tExit, do not install any packages\c"
message -d "Please enter the next package number(s) to install, followed by \
ENTER.\n\nPress ESC when all selections have been made."

/usr/lbin/get_sel $count 2> /tmp/Ap$$
if [ "$?" != "0" ]
then message -c "You have canceled the package selection menu.\n\n\
Stike ENTER if you wish to re-display the menu and re-select."
if [ "$?" != "0" ]
then echo "Installation has been canceled."
	(< ${DEVICE}) > /dev/null 2>&1
	cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG} /tmp/Ap$$; sync
	   exit 1;
else continue;
fi
fi
if [ ! -s /tmp/Ap$$ ]
then echo "Installation has been canceled."
	(< ${DEVICE}) > /dev/null 2>&1
	cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG} /tmp/Ap$$; sync
	   exit 1;
fi
if [ "$?" = "0" ]
then break;
fi
done

echo "$CLEAR"

sort -u -o /tmp/Ap$$ /tmp/Ap$$
echo "\nYou have made the following selections:\n"
if [ ${OLDTAPE} = "1" ]
then
cat /tmp/Ap$$ | while read k
do
	echo "$k.\c"
	grep "$k=" ${PACK_FLNM} | cut -f2- -d= | sed -e "s/^/	/g"
done
else
cat /tmp/Ap$$ | while read k
do
	echo "$k.\c"
	grep "	$k$" ${PACK_FLNM} | cut -f1 -d"	" | sed -e "s/^/	/g"
done
fi
message -c "\nStrike ENTER to confirm and continue with the installation or \
ESC to re-display the menu and re-select."
if [ "$?" = "0" ]
then
	break
fi
done

if [ ! -f ${CONTENTS} ]
then	rm -rf ${CONTENTS}
	>> ${CONTENTS}
fi

message -t "REMINDER!" "Depending on the packages you are installing, you may be \
required to provide some input to the installation utility to configure the \
software for your system."

trap '' 1 2 3 9 15
echo "$CLEAR"
echo "            Installation in progress -- Do not remove the cartridge tape"
if [ -z "$SPECIAL" ]
then CURR_POS=$PKG_BASE
else CURR_POS=2
fi
export CURR_POS
k=0;
if [ ${OLDTAPE} = "1" ]
then cat ${PACK_FLNM} | cut -f1 -d= | cut -f2- -dG > ${TMP_FILE}
else cat ${PACK_FLNM} | sed -n "2,\$p" | cut -f2 -d'	' > ${TMP_FILE}
fi
cat ${TMP_FILE} | while read pkg_id
do
	k=`expr $k + 1`
	grep "${pkg_id}" /tmp/Ap$$ > /dev/null 2>&1
	if [ "$?" != "0" ]
	then continue
	fi
	POS=`expr $PKG_BASE + $k - $CURR_POS - 1` 
	CURR_POS=`expr $CURR_POS + $POS + 1` 

if [ "$NAME" != "" ]
then
echo "\nSearching for the Next Package to Install -- Do not remove the cartridge tape"
fi

	eval $MOVE $POS ${DEVICEN} >/dev/null 2>&1	
	sleep 3
	cpio -iBcdu -I${DEVICE}n 2>${CPLOG}
	if [ $? != "0" ]
	then
		echo "An error was encountered while reading in the tape."
		ERROR=1
		break
	fi
	if [ ! -f ./Size ]
	then
		echo "The software package is missing the Size file"
		ERROR=1
		break
	fi
	# check the disk requirement
	linecnt=`expr \`cat Size | wc -l\``
	if [ \( $linecnt -ne 1 \) -a \( $linecnt -ge 3 \) ]
	then
		echo "Invalid Size file found.  Cannot determine disk requirements."
		ERROR=1
		break
	fi
	ROOT=10
	USR=10
	if [ "`grep ROOT= Size`" ]
	then ROOT=50
	     USR=50
	fi
	if [ "`grep USR= Size`" ]
	then USR=50
	fi
	if [ \( \( $ROOT = 50 \) -a \( $USR != 50 \) \) -o \( \( $ROOT != 50 \) -a \( $USR = 50 \) \) ]
	then
		echo "Invalid Size file found.  Cannot determine disk requirements."
		ERROR=1
		break
	fi
	if [ "`grep USR= Size`" ]
	then
		ROOT=`cat Size | grep ROOT | cut -d= -f2`
		USR=`cat Size | grep USR | cut -d= -f2`
	elif [ "`grep ROOT= Size`" ]
	then
		ROOT=`cat Size | grep ROOT | cut -d= -f2`
	else
		USR=`cat Size`
		ROOT=50
	fi
	$SPACE -u $USR > /dev/null 2>&1
	ERR=$?
	[ $ERR = 3 ] && ROOT=`expr $ROOT + $USR`
	$SPACE -r $ROOT > /dev/null 2>&1
	[ $? = 2 ] && ROOT="root (/)"
	if [ \( $ERR = 2 \) -o \( "$ROOT" = "root (/)" \) ]
	then
		echo "There is not enough room on the hard disk to \
install the package."
		ERROR=1
		break
	fi

	if [ ! -f ./Install -o ! -f ./Remove -o ! -f ./Name ]
	then
		echo "The software package is missing the necessary installation programs."
		ERROR=1
		break
	else
		trap '' 1 2 3 9 15
		chmod +x ./Install
		NAME=`cat -s Name`
		# Check out if previously installed
		SNAME=`echo $NAME | sed -e 's/[ &()$#-?\\!*;|<>]/./g' -e 's/\[/./g' -e 's/\]/./g'`
		KEY=`grep " $SNAME\$" $CONTENTS`
		if [ -n "$KEY" ]
		then
		     message -d "The $NAME package has already been installed.  \
The new installation will now replace the original $NAME files."
		     cd /usr/options
		     for i in *
		     do
			grep "^${SNAME}$" $i > /dev/null 2>&1
			if [ $? = 0 ]
			then
				KEY2=$i
				break
			fi
		     done
		     cd ${TMPDIR}
		     eval KEY=`grep " $SNAME\$" $CONTENTS | cut -f1 -d' ' `
		     if [ "$KEY" ]
		     then
			   mv ${INDIR}/Remove/${KEY2} /tmp/${KEY}.R
			   mv ${INDIR}/Files/${KEY2} /tmp/${KEY}.F
			   mv /usr/options/${KEY2} /tmp/${KEY}.O
			   grep " $SNAME\$" $CONTENTS > /tmp/${KEY}
		           grep -v " $SNAME\$" $CONTENTS > /tmp/$$
		           mv /tmp/$$ $CONTENTS
		     fi
		else KEY2=`echo $NAME | sed -e 's/ //g' | tr "[A-Z]" "[a-z]" | cut -c1-6`
		     if [ -f /usr/options/${KEY2}.name ]
		     then
			num=`expr 1`
			while [ -f /usr/options/${KEY2}${num}.name ]
			do
				num=`expr $num + 1`
			done
			KEY2=${KEY2}${num}.name
		     else
			KEY2=${KEY2}.name
		     fi
		fi
		./Install < /dev/tty
		# It is the 'Install' script's job to print an error message
		# if the installation indicates the return of non-zero:
		if [ "$?" != "0" ]
		then
			if [ -n "$KEY" ]
			then
				mv /tmp/${KEY}.R ${INDIR}/Remove/${KEY2} > /dev/null 2>&1
				mv /tmp/${KEY}.F ${INDIR}/Files/${KEY2} > /dev/null 2>&1
				mv /tmp/${KEY}.O /usr/options/${KEY2} > /dev/null 2>&1
				cat /tmp/${KEY} >> $CONTENTS
				rm -f /tmp/${KEY} > /dev/null 2>&1
			fi
			message -c "The installation of $NAME failed.\n\n\
Strike ENTER if you wish to continue installation with the other packages you have \
chosen or Strike ESC to skip the rest of the packages.  If you Strike ESC any \
packages previously installed will remain installed." < /dev/tty
			if [ "$?" = "0" ]
			then continue
			fi
			break
		else
			if [ -n "$KEY" -a -s /tmp/${KEY}.un ]
			then
				rm -f /tmp/${KEY}.[RFO] /tmp/${KEY}
			fi
			if [ ! -d $INDIR ]
			then mkdir $INDIR; chmod 755 $INDIR
			fi
			if [ ! -d ${INDIR}/Files ]
			then mkdir ${INDIR}/Files; chmod 755 ${INDIR}/Files
			fi
			if [ ! -d ${INDIR}/Remove ]
			then mkdir ${INDIR}/Remove; chmod 755 ${INDIR}/Remove
			fi
			echo $KEY2 1 $NAME >> $CONTENTS
			INSTALLED_LIST="$INSTALLED_LIST $NAME"
			mv ./Remove ${INDIR}/Remove/${KEY2}
			mv ./Name /usr/options/${KEY2}
			if [ -f Files ]
			then
				mv Files ${INDIR}/Files/${KEY2}
			fi
			rm -rf ${TMPDIR} ${CPLOG}
			sync; sync
			message -d "The installation of the $NAME package is now complete."
		fi
	fi
done
rm -f /tmp/Ap$$
cd /; rm -rf /tmp/pkg.idx ${TMP_FILE} ${PACK_FLNM} ${TMPDIR} ${CPLOG}; sync

if [ -z "$SPECIAL" ]
then eval $REWIND
fi

if [ $ERROR -eq 1 ]
then

	echo "The Installation process is aborted."
	if [ ! -z "$INSTALLED_LIST" ] 
	then
		echo "The following packages have already been installed:\n"
		for i in $INSTALLED_LIST
		do
			echo "           \"`eval echo \\$PKG$i`\""
		done
		echo "\n\n"
		echo "Use 'removepkg' if you need to remove any of the installed packages"
	fi
	exit 1
fi
if [ -f /etc/.new_unix ]
then
sync; sync; cd /
exec /etc/conf/bin/idreboot
fi
   07070100001c780000816d0000000200000002000000012719347c00001ab8000000230000000c00000000000000000000001000000000usr/lbin/fsinfo   ELF              x4          4    (  	    t   t    Ö  Ö           L  L§    .  Ô        Â   j j ìR¸    Àth    è
  Ä¸    Àtèù  hàèï  ET¨RURPè¯ÿÿÿèË  èm   ÄPèì  j ¸        ôÃÿt$ÿt$jèt  ÄÃÿt$ÿt$jèı  ÄÃÿt$ÿt$jèÁ  ÄÃÿt$ÿt$ÿt$jè  ÄÃUìWVSL}3öj/ÿ7è¾  Ä£|¨Àtÿ|¨é   £|¨ëxh¨ÿ7ÿÓÄÀufÿ¨ë\h¨ÿ7ÿÓÄÀufÿ¨ë@h¨ÿ7ÿÓÄÀufÿ¨ë$h¨ÿ7ÿÓÄÀufÿ¨ëè§  ? t8-xÿÿÿf¡¨fÀu!f¡¨fÀuf¡¨fÀuf¡¨fÀt? uè^  ëÿ7Çè   YÀ}F? uëVèm  Y[^_ÉÃUìì  WVS]j Sè¦  Äøÿ}<©: ¸X¨ë¡H9}èëê¸h¨ëãPSè@  Ä[^_ÉÃj h   Wè,  ÄÀ|h   üıÿÿPWèN  Ä=   t¸   ë3ÀEü}ü u	}ô ~ıth¨Sèá  Ä[^_ÉÃEø=   t=   t=   ¤   ¾   ë¾   ë¾   Wè-  Yf=¨ t şÿÿ+E¬¯Æ¹   ÷ùPè   Yf=¨ t·üıÿÿ-   ¯ÆÁèPè]   Yf=¨ tE¬¯Æ¹   ÷ùPè>   Yf=¨ t+E Eğ=8&|t¸ÿÿÿÿ[^_ÉÃh,¨Sè  Ä[^_ÉÃ3À[^_ÉÃUìì@WV}u NÆ NÆ
NÇ¹
   3Ò÷ñD¨Ç3Ò÷ñøÿuàVÿu´èÅ  YPÿu´jèú  ÄY^_ÉÃÿt$è§  YPÿt$jèÛ  ÄÃ©: 	¸X¨Ã¡H9}èÃ¸h¨ÃhP§èZ  YPhP§jè  Äÿ5|¨è>  YPÿ5|¨jèp  ÄhX§è"  YPhX§jèU  ÄjèÒ  YÃUìÿ5|¨èú  YPÿ5|¨jè,  Ähy§èŞ  YPhy§jè  ÄÿuèÅ  YPÿujèú  Ähy§è¬  YPhy§jèß  Äÿuè  YPÿujèÈ  Äh|§èz  YPh|§jè­  Ä¸ÿÿÿÿÉÃ§9%|	¸ÿÿÿÿÃÿT$¨3ÀÃV5§ëÿ¨ÿ}ó^Ã¸}        Æ  3ÀÃ¸        ±  Ã¸|          3ÀÃ¸          Ã¸        s
<[tîéq  ÃVt$T$;Öts
;Ául-÷Ñá#ÁuWFJ;ÁuQ-÷Ñá#Áu<FJ;Áu6-÷Ñá#Áu!FJ;ÁuÆÂ-÷Ñá#Át^3ÀÃ:Áu"Àtô:åu"ätìÁèÁé:Áu"ÀtŞ:å^À   Ã×|$3À¹ÿÿÿÿò®AÁ÷ĞúÃ×|$3À¹ÿÿÿÿò®O÷ÑD$ıò®üuGúÃ3ÀúÃ¸        s
<[tîéd   Ã¸~        P   3ÀÃ¸{        ;   3ÀÃ¸        &   3ÀÃé   UìPÇEü    Ù}üMü?  ÙmüÉÃ£©¸ÿÿÿÿÃèûıÿÿT$¸        ÙÿÿÿÃÂ       LT`|¤°Ìàô,@T`x¤´ÄÔèü$4D\l ¸Ìèü4DTp¬¼àü 8Pd| ¸ĞÜèü 8Xp¬¼Øèô  ,@T|¸Ğø @¨´Ğ$0<P` ´Ôø(4@LXdp| ¬¸ÄĞÜè Ll´Ôäü(Lh¬Ğìø(<T`¨ÀÔäø4   Error 0 Not owner   No such file or directory   No such process Interrupted system call I/O error   No such device or address   Arg list too long   Exec format error   Bad file number No child processes  No more processes   Not enough space    Permission denied   Bad address Block device required   Device busy File exists Cross-device link   No such device  Not a directory Is a directory  Invalid argument    File table overflow Too many open files Not a typewriter    Text file busy  File too large  No space left on device Illegal seek    Read-only file system   Too many links  Broken pipe Argument out of domain  Result too large    No message of desired type  Identifier removed  Channel number out of range Level 2 not synchronized    Level 3 halted  Level 3 reset   Link number out of range    Protocol driver not attached    No CSI structure available  Level 2 halted  Deadlock situation detected/avoided No record locks available   Error 47    Error 48    Error 49    Bad exchange descriptor Bad request descriptor  Message tables full Anode table overflow    Bad request code    Invalid slot    File locking deadlock   Bad font file format    Error 58    Error 59    Not a stream device No data available   Timer expired   Out of stream resources Machine is not on the network   Package not installed   Object is remote    Link has been severed   Advertise error Srmount error   Communication error on send Protocol error  Error 72    Error 73    Multihop attempted  Error 75    Error 76    Not a data message  File name too long  Value too large for defined data type   Name not unique on network  File descriptor in bad state    Remote address changed  Can not access a needed shared library  Accessing a corrupted shared library    .lib section in a.out corrupted Attempting to link in more shared libraries than system limit   Can not exec a shared library directly  Error 88    Operation not applicable    Number of symbolic links encountered during path name traversal exceeds MAXSYMLINKS Error 91    Error 92    Directory not empty Too many users  Socket operation on non-socket  Destination address required    Message too long    Protocol wrong type for socket  Option not supported by protocol    Error 100   Error 101   Error 102   Error 103   Error 104   Error 105   Error 106   Error 107   Error 108   Error 109   Error 110   Error 111   Error 112   Error 113   Error 114   Error 115   Error 116   Error 117   Error 118   Error 119   Protocol not supported  Socket type not supported   Operation not supported on transport endpoint   Protocol family not supported   Address family not supported by protocol family Address already in use  Cannot assign requested address Network is down Network is unreachable  Network dropped connection because of reset Software caused connection abort    Connection reset by peer    No buffer space available   Transport endpoint is already connected Transport endpoint is not connected Structure needs cleaning    Error 136   Not a name file Not available   Is a name file  Remote I/O error    Reserved for future use Error 142   Cannot send after socket shutdown   Too many references: cannot splice  Connection timed out    Connection refused  Host is down    No route to host    Operation already in progress   Operation now in progress   Stale NFS file handle       Usage:	  [ -f -i -s -l ] filesystem ...
 :  
                                                                                                                                           -f  -i  -s  -l  Not a filesystem    Unknown filesystem type 0123456789abcdef    No error (?)    Unknown error (!)    .init .text .fini .rodata .rodata1 .data .data1 .bss .shstrtab .comment  @(#)/usr/lbin/fsinfo.sl 1.1 4.0 10/01/90 27975 AT&T-SF                                                     tt                              xx   h                          àà                             ää  h                          LL
  ş                 $         L§L  ¼                  *         ¨  r                  1         |¨|  ¤                  6              |  I                  @              Å  8                  07070100000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000b00000000TRAILER!!!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö